[{"title":"J2SE面向对象","date":"2019-07-07T10:50:47.000Z","path":"2019/07/07/J2SE面向对象.html","text":"二、Java面向对象 类与对象 构造方法和方法重载 this关键字 方法的传递和递归 封装 static关键字 单例设计模式 继承（extends） 方法的重写（Override） 访问控制 包（Package） final关键字 对象的创建过程 多态 抽象类 接口 内部类 回调模式 抽象方法的笔试考点 枚举类（enum） 内存机制问题 1. 类与对象1.1 类的定义1class 类名 &#123;类体&#125; 类名由多个单词组成时，要求每个单词首字母大写 1.2 成员变量的定义1class 类名 &#123; 数据类型 成员变量名=初始值; ... &#125; 成员变量名由多个单词组成时，要求第二个起每个单词首字母大写 1.3 对象的创建1new 类名(); 当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。 1.4 引用12类名 引用变量名;Person p = new Person(); //声明person类型的引用p指向Person类型对象 1234567891011121314引用变量名.成员变量名;p.name = 'zhangsan';``` &gt;- 在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。&gt;- 使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。- 除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。#### 1.5 成员方法``` javaclass 类名 &#123; 返回值类型 成员方法名(形参列表)&#123;方法体;&#125;&#125; 返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void 形参列表：数据类型 形参1, 数据类型 形参2, … 2. 构造方法和方法重载2.1 构造方法1class 类名 &#123; 构造方法名(形参列表)&#123;构造方法体;&#125; &#125; 构造方法名与类名相同且没有返回值 当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。 2.2 默认构造方法 当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。 若类中出现自定义构造方法，则编译器不再提供构造方法。 2.3 方法重载（overload）在Java中，方法名相同，参数列表不同的方法构成重载关系。 体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同） 实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。 3. this关键字在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。 使用方式： 当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名 在构造方法的的第一行，可以调用本类中的其他构造方法。 4. 方法的传递和递归4.1 传参 基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。 引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。 引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。 4.2 递归的调用 递归是指方法体内部调用自身 必须有递归的规律和退出条件 使用递归必须使得问题简单化而不是复杂化 若递归影响到程序的执行性能时，则用递推取代之 5. 封装面向对象的三大特征：封装，继承，多态。 封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断 封装基本流程： 私有化成员变量(private) 提供公有的get、set方法，并在set方法体中进行合理性判断 在构方法中调用set方法进行合理值的判断 6. static关键字基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。 为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。 static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类) 特点 静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问 静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突 静态元素只加载一次，全部类对象及类本身共享 静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存 非静态成员和静态成员都可以访问静态成员 静态成员不可以访问非静态成员 静态元素中不可出现this或super关键字，静态元素属于类的 7. 单例设计模式基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。 12345678910/** * 编程实现Singleton类的封装 */public class Singleton&#123; private static Singleton sin = new Singleton();//2.提供本类的引用指向本类的对象 private Singleton()&#123;&#125; //1.私有化构造方法 public static Singleton getInstance()&#123;//3.提供公有的get方法将上述成员变量的数值返回出去 return sin; &#125;&#125; 实现流程： 私有化构造方法（private） 提供本类类型的引用指向本类类型对象（private static） 提供公有的get方法将上述对象return出去（public static） 实现方式：饿汉式和懒汉式，开发中推荐饿汉式。 8. 继承（extends） 继承就是子类复用父类的代码，关键字extends表示类和类的继承关系 使用继承可以提高代码复用性、扩展性、以及可维护性。 子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。 无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。 使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。 在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。 1234567891011class Cricle extends Shape&#123; int r; Cricle()&#123;&#125; //编译器会加入无参的调用 super()。 Cricle(int x, int y, int r)&#123; super(x, y); //通过super关键字调用父类的构造方法。 setR(r); &#125; public void setR(int r)&#123; this.r = r; &#125;&#125; 9. 方法的重写（Override）概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。原则： 要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。 要求访问权限不能变小，可以相同或变大 重写的方法不能抛出更大的异常 10. 访问控制 public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用， 通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰 访问控制符 访问权限 本类内部 本类中的包 子类 其他包 public 共有的 Y Y Y Y protected 保护的 Y Y Y N 不写 默认的 Y Y N N private 私有的 Y N N N 11. 包（Package）为了解决命名冲突问题，便于文件的管理 1234package 包名；package 包名1.包名2.包名3...包名n;/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */org.apache.commons.lang.StringUtil; 12. final关键字 final关键字修饰类体现该类不能被继承（防止滥用继承）。 final关键字修饰方法体现在该方法不能被重新，但可以被继承（防止不经意间造成的方法重写）。 final关键字修饰成员变量体现在改成员变量必须初始化且不能更改（防止不经意间造成的数据更改）。 扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用public static final共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。 13. 对象的创建过程 单个对象的创建过程 main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理； 若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理； 执行构造块中的代码可以对成员变量进行赋值； 执行构造方法体中的代码可以对成员变量进行再次赋值； 此时对象构造完毕，继续向下执行后续的代码； 子类对象的创建过程 main方法是程序的入口，先加载父类的的代码再加载子类的代码； 先执行父类静态代码块，再执行子类的静态代码块； 先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕； 先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。 14. 多态 语法：父类的引用指向子类的对象 123父类类型 引用变量名 = new 子类类型();Person pw = new Worker();pw.show();//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。 多态的效果： 父类的引用可以直接调用父类独有的方法。 父类的引用不可以直接调用子类独有的方法。 对于父类子类都有的非静态方法来说，编译阶段调用父类的，运行阶段调用子类重写后的。 对于父类子类都有的静态方法来说，只调用父类的。 多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。 多态的表现形式 多态的前提要有继承的关系 使用父类引用指向子类对象 Person p = new Teacher();//向上转型 该引用只能调用父类中定义的属性/方法 执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写 若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException 引用数据类型之间的转换 转换必须发生在父子类之间，否则编译报错。 自动类型转换：小到大，子类型向父类型的转换，eg:Person pw = new Worker();。 强制类型转换：大到小，父类型向子类型转换，eg:((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法。 为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。 123456/*语法格式：*/ 对象 instanceof 类型 //返回布尔值if(pw instanceof Teacher)&#123; Teacher t = (Teacher) pw;&#125;else&#123; System.out.println(\"转换会有异常\");&#125; 多态的使用场合： 1234567// 通过方法的参数传递形成多态。public static void draw(Shape s)&#123;&#125;TestShape.draw(new Rect(1,2,3,4));// 在方法体中直接使用多态的语法格式。TestAbstrat ta = new SubTestAbstract();ta.show(); 15. 抽象类 基本概念 用abstract关键字修饰的类称为抽象类。 抽象类不能实例化，抽象类的意义在于被继承。 抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。 抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。 12345public abstract class Shape&#123; //一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类 private int x; private int y; public abstract boolean contains(int x, int y);//用abstract修饰的方法，称之为抽象方法，没有方法体&#125; 注意： 抽象类中可以有成员变量，成员方法，以及构造方法。 抽象类中可以没有抽象方法，也可以有抽象方法。 具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。 子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。 抽象类对子类具有强制性和规范性，因此叫做模板设计模式。 推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。 多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。 16. 接口 基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过interface关键字定义。 1234interface Runner &#123; //-通过interface关键字定义接口 public static final int SEF_SPEED=100;//-接口中不能定义成员变量，只能定义常量 public void run();//-接口中只可以定义没有实现的方法（可以省略public abstract）&#125; 一个类可以通过implements关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。 12345678910class American implements Runner,... &#123; //与继承不同，可以实现多个接口 @Override public void run()&#123;//该类需要实现接口中定义的所有方法 System.out.println(\"run...\"); &#125; public static void main(String[] args) &#123; Runner ra = new American();//接口作为一种类型声明，并且声明的变量可以引用实现类的对象 ra.run();//通过该变量可以调用该接口定义的方法 &#125;&#125; 一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。 1interface Hunter extends Runner&#123;...&#125; 类与接口的关系 类和类使用extends继承，仅支持单继承。 接口和接口使用extends继承，支持多继承。 类使用implements实现接口，支持多实现。 抽象类与接口的关系（笔试题） 定义抽象类:abstract class，而定义接口:interface； 类继承抽象类:extends单继承，而类实现接口:implements多实现； 抽象类可以有构造方法，而接口不能有构造方法； 抽象类可以有成员变量，而接口只能有常量； 抽象类可以有成员方法，而接口只能有抽象方法； 抽象类中增加方法子类可以不用重写，而接口中增加方法子类必须重写； 从jdk1.8开始允许接口中有非抽象方法，但需要default关键字修饰。 17. 内部类 内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部 内部类定义在 类的内部 ，与类成员层次一致 内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次） 成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致 局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次 匿名内部类：成员匿名内部类，局部匿名内部类 静态内部类：成员静态内部类 17.1 *成员内部类 将一个类直接定义在类的里面，作为成员，与属性或方法层次一致 成员内部类可以与正常类一样 使用不同的修饰符来修饰 好处1.省略了一个.java文件 好处2.成员内部类中可以访问外部类的所有成员 包括私有的 若想要在内部类中通过对象.调用外部类成员 外部类.this.外部类成员; 内部类存在后 源代码进行编译 产生一个字节码 Demo$InnerDemo.class 17.2 局部内部类 将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次 局部内部类像是一个局部的变量一样，不能用public protected private及static 只能用abstract或final 局部内部类命名规则Demo$1InnerTestMethod Demo$2InnerTestMethod 局部内部类使用的变量只能是final修饰 17.3 *匿名内部类将类直接定义在类中 或者类成员中 成员匿名内部类 局部匿名内部类匿名内部类没有类的所有结构(名字 修饰符) 只有类体通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类匿名类内部没有构造方法，也不能用任何修饰符来修饰 当接口类型的引用作为方法的形参时，实参的传递方式有两种： 自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。 直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。 12345678910111213141516171819202122232425262728293031public interface A &#123; public abstract void show();&#125;//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递public class SubA implements A &#123; @Override public void show() &#123; System.out.println(\"这里自定义类实现接口并重写抽象方法！\"); &#125;&#125;//测试类public class ATest &#123; public static void test(A a) &#123; a.show(); &#125; public static void main(String[] args) &#123; //ATest.test(new A());//报错，A是接口，不能new对象 //-方式1：接口实现类的对象作为实参传递 ATest.test(new ASub());//接口类型引用指向实现类的对象，形成了多态。 //-方式2：匿名内部类 // 接口/父类类型 引用变量名 = new 接口/父类类型() &#123;方法的重写&#125;; A ta = new A() &#123; @Override public void show() &#123; System.out.println(\"这里是匿名内部类\"); &#125; &#125;; ATest.test(ta);//得到接口类型的引用，再作为实参传递 &#125;&#125; 匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。 语法格式：接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};。 1SuperType obj = new SuperType(...)&#123; ... &#125;; 17.4 静态内部类 成员静态内部类 不需要外部类对象，通过正常的方式直接创建内部类 静态元素不能访问非静态成员(自己类和外部类) 18. 回调模式回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法 123456789101112131415interface Action&#123; public void doSth();&#125;//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次public static void repeat(int n, Action ac)&#123; for(int i=0; i&lt;n; i++)&#123; ac.doSth();&#125;&#125;//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。public static void main(String[] args)&#123; repeat(5, new Action()&#123;//通过匿名内部类传递参数 public void doSth()&#123; System.out.println(\"Hello\") &#125; &#125;);&#125; 19. 抽象方法的笔试考点 abstract与哪些关键字不能共存： final关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。 static关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。 private关键字；因为private修饰的私有方法不能被继承，就不能重写，而abstract方法需要重写。 20. 枚举类（enum） 一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来 创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。 我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object Enum类型，有两个属性 name—–&gt;枚举对象的名字，name()获取name属性 ordinal—&gt;枚举对象在类中罗列的顺序 类似index 也从0开始 ordinal()获取序号 一些常用的方法 valueOf() 通过给定的name获取对应的枚举对象 values() 获取全部的枚举对象 —&gt; 返回一个数组 Day[] compareTo() 可以比较两个枚举对象 int toString() 由于这个方法没有final修饰 可以覆盖(重写) switch内部判断枚举的应用 我们也可以在enum中描述自己的一些属性或方法 必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束; 可以定义自己的属性 类创建的过程中 帮我们创建枚举类型的对象 需要给枚举类型提供对应样子的构造方法 构造方法只能private修饰 可以重载 1234567891011121314151617181920public enum Day&#123; //描述了七个当前类的对象 monday(\"星期一\",1),tuesday(\"星期二\",2),wednesday,thursday,friday,saturday,sunday; private String name; private int index; private Day()&#123;&#125; private Day(String name,int index)&#123; this.name=name; this.index=index; &#125; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name=name; &#125;&#125; 21. 内存机制问题 类创建在哪儿 对象创建在哪里 继承关系 静态成员 方法执行 栈内存—&gt;Person p = new Person();—-&gt;堆内存 方法区—类模板 栈内存—-变量空间,方法临时执行空间（从创建开始执行完毕,立即回收） 堆内存—-new申请对象空间（垃圾回收器GC,对象空间没有任何引用指向视为垃圾） 方法区—-常量 类模板 静态成员（有且只有一份,不回收） Runtime类(是单例模式)之中提供了几个管理内存的方法 maxMemory totalMemory freeMemory 栈内存溢出错误StackOverflowError 堆内存溢出错误OutOfMemoryError Object类中有一个finalize方法 如果重写也能看见对象回收的效果 GC系统提供的一个线程 回收算法 回到顶部😼","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"J2SE语法基础","date":"2019-07-07T09:33:54.000Z","path":"2019/07/07/J2SE语法基础.html","text":"一、Java语法基础 标识符（变量）命名规则 数据类型 运算符 循环 数组 1. 标识符（变量）命名规则 必须字母，数字，下划线以及美元$等组成，且首位非数字。 不能使用Java语言中的关键字，如class，static，void，int等。 区分大小写，长度无限制，但不能过长，尽量见名知意。 2. 数据类型2.1 分为两大类： 基本数据类型：byte，short，int，long，float，double，boolean，char 引用数据类型：数组，类，接口，枚举，标注 注：单个字节表示8位二进制位，最左边表示符号位（0：正，1：负）。 2.2 整数类型（byte，short，int，long） byte： 1个字节，范围-2^7~2^7-1，即-128~127。 short：2个字节，范围-2^15~2^15-1，即-32768~32767。 int: 4个字节，范围-2^31~2^31-1，即正负21亿之间。 long： 8个字节，范围-2^63~2^63-1，比int更大。如果要表示long直接量，需要L或l结尾。 2.3 浮点类型（float，double） float： 4个字节，单精度浮点数，取到小数点后7位有效数字。如果要表示float直接量，需要F或f结尾 double：8个字节，双精度浮点数，取到小数点后15位有效数字。 扩展：浮点运算有时会有误差，为了实现精确运算可使用java.math.BigDecimal类型加以描述。 2.4 布尔类型（boolean） boolean：1个字节（未明确规定），值只有true和false。 2.5 字符类型（char） char：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：’a’,’1’,’中’ 等。 开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号””引起来。 需记住的ASII码字符：’a’:97，’A’:65，’0’:48，空格:32，换行符:10 常用转义符：\\t:制表符，\\n:换行，\\&quot;，\\&#39;，\\\\，\\b，\\r 2.6 基本数据类型之间转换 自动类型转换：从小类型到大类型自动转换 12byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double char -----^ 强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出 12long big = 1024L\\*1024\\*1024;int i = (int)big; 3. 运算符 算术运算符： +，-，*，/，% 关系运算符： &gt;，&lt;，&gt;=，&lt;=，==，!= 自增减运算符： ++，-- 逻辑运算符： &amp;&amp;，||，！（短路特性：逻辑与&amp;&amp;运算，若第一个条件为假,跳过第二个条件；逻辑或||运算，若第一个条件为真，跳过第二个条件） 三目运算符： 条件 ? 表达式1 ： 表达式2 赋值运算符：=，+=，-=，*=，= 4. 循环 while循环和for循环完全可以互换。 while循环主要用于明确循环条件，但不明确循环次数的场合 for循环主要用于明确次数或范围的场合 while(true) 等价于 for(;;)，表示无限循环。 5. 数组5.1 一维数组 数组类型[] 数组名 = new 数据类型[长度] ：动态方式 12数组类型[] 数组名 = new 数据类型[长度] //动态方式int[] arr = new int[5]; 123数组类型[] 数组名 = &#123;初始值1, 初始值1, 初始值1, ...&#125; //静态方式int[] arr = &#123;10, 20, 30, 40&#125;;/*特殊方式：*/ int[] arr = new int[]&#123;10, 20, 30&#125;; 5.2 二维数组12数组类型[][] 数组名 = new 数据类型[行数][列数]int[][] arr = new int\\[5]\\[6]; 12数组类型[][] 数组名 = &#123;&#123;初始值1, 初始值1, 初始值1&#125;,&#123;值2,...&#125; ...&#125;int[] arr = &#123;&#123;10, 20, 30&#125;, &#123;01, 5, 3&#125;, &#123;8, 20, 6&#125;&#125;; 二维数组arr.length表示行数，arr[0].length表示此行的长度 回到顶部😼","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"Win10下配置Nginx+PHP-7+MySQL-5.6","date":"2019-02-22T03:39:12.000Z","path":"2019/02/22/Win10下配置Nginx-php7-mysql-5-6.html","text":"1. 软件下载 Windows操作系统。 Nginx，下载地址：http://nginx.org/en/download.html。 PHP，下载地址：http://php.net/downloads.php（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。 MySQL，下载地址：https://www.mysql.com/downloads/。（选择社区版Community-&gt;MySQL Community Server-&gt;MySQL Community Server 5.6，根据Windows系统选择对应zip包）。 2. 软件安装在C盘新建安装目录C:\\PHP。2.1 Nginx安装Nginx本身就是绿色软件，下载zip安装包解压到C:\\PHP，打开目录C:\\PHP\\nginx-1.15.8双击nginx.exe就可以运行，然后在浏览器打开http://127.0.0.1，出现欢迎界面表示NGINX正常工作。确认NGINX正常工作后在任务管理器中结束nginx.exe任务。2.2 PHP安装把PHP的zip安装包解压到C:\\PHP，解压后PHP安装目录为：C:\\PHP\\php-7.3.2。cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。将C:\\PHP\\php-7.3.2加入系统环境变量。2.3 准备网站根目录准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把C:\\PHP\\web作为我的网站根目录。在根目录C:\\PHP\\web下新建一个info.php文件，输入如下内容：123&lt;?php phpinfo();?&gt; 2.4 让nginx识别PHP 配置PHP (C:\\PHP\\php-7.3.2) 在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf: 在PHP根目录下修改配置文件C:\\PHP\\php-7.3.2\\php.ini-development并另存为php.ini,在其中修改或添加配置： 1cgi.fix_pathinfo=1 配置nginx conf(C:\\PHP\\nginx-1.15.8\\conf) 在Nginx根目录下找到conf目录，编辑器打开C:\\PHP\\nginx-1.15.8\\confnginx.conf: 123456789101112131415161718192021222324252627282930error_log logs/error.log; #打开error_loghttp &#123; # ... server &#123; # ... location / &#123; root C:\\PHP\\web; #配置根目录 index index.html index.htm index.php; &#125; # ... # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # 打开下面几行注释 location ~ \\.php$ &#123; root C:\\PHP\\web; #配置根目录 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; #重要: 把下面 /scripts 修改成 $document_root fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; # ... &#125;&#125; 2.5 运行与测试nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么nginx.conf中有这样一句fastcgi_pass 127.0.0.1:9000;。 在任务管理器中结束nginx.exe任务，然后到C:\\PHP\\nginx-1.15.8目录双击nginx.exe开启服务。 在命令行中，cd到php的home目录C:\\PHP\\php-7.3.2，然后执行如下命令： 1php-cgi.exe -b 127.0.0.1:9000 -c php.ini 打开浏览器，输入 http://127.0.0.1/info.php，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。 2.6 MySQL安装 把MySQL的zip安装包解压到C:\\PHP，解压后PHP安装目录为：C:\\PHP\\mysql-5.6.43-winx64。 将C:\\PHP\\mysql-5.6.43-winx64\\bin加入系统环境变量。 修改配置文件C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini并另存为my.ini,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）： 12basedir=C:\\PHP\\mysql-5.6.43-winx64 #mysql所在目录datadir=C:\\PHP\\mysql-5.6.43-winx64\\data #mysql所在目录\\data 以管理员身份运行cmd,到安装目录的bin下，输入mysqld -install： 12C:\\PHP\\mysql-5.6.43-winx64\\bin&gt; mysqld -installService successfully installed. 输入命令:mysql --version,正常会显示版本信息。 输入命令:net start mysql启动服务(停止命令：net stop mysql): 123C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;net start mysqlMySQL 服务正在启动 ..MySQL 服务已经启动成功。 服务启动成功之后，输入命令：mysql -u root -p（第一次登录没有密码，直接按回车过）: 1234567891011C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 1Server version: 5.6.43 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.mysql&gt; 如出现mysql&gt;,即登录成功。 输入命令exit,退出登录。 123mysql&gt; exitByeC:\\PHP\\mysql-5.6.43-winx64\\bin&gt; 3. 制作自动启动脚本控制台就一直开着，很不方便。这个时候可以使用 RunHiddenConsole.zip 来得管理服务的启动与关闭。 3.1 启动脚本在目录C:\\PHP下新建一个start.bat作为启动脚本文件： 12345678910111213141516171819202122:启动脚本@echo offset php_home=./php-7.3.2set nginx_home=./nginx-1.15.8REM Windows 下无效REM set PHP_FCGI_CHILDREN=5REM 每个进程处理的最大请求数，或设置为 Windows 环境变量set PHP_FCGI_MAX_REQUESTS=1000echo Starting PHP FastCGI...RunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.iniecho FastCGI 启动成功echo.echo Starting nginx...RunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%echo nginx 启动成功echo.:echo 15秒后自动退出:ping 0.0.0.0 -n 15 &gt; null:请按任意键继续. . .pause 3.2 停止脚本在目录C:\\PHP下新建一个stop.bat作为停止脚本文件： 123456789101112:停止脚本@echo offecho Stopping nginx... taskkill /F /IM nginx.exe &gt; nulecho nginx 已停止:换行echo.echo Stopping PHP FastCGI...taskkill /F /IM php-cgi.exe &gt; nulecho FastCGI 已停止:请按任意键继续. . .pause 3.3 重启脚本在目录C:\\PHP下新建一个restart.bat作为重启脚本文件： 12345678910111213141516171819202122232425262728293031323334:停止脚本@echo offecho Stopping nginx... taskkill /F /IM nginx.exe &gt; nulecho nginx 已停止:换行echo.echo Stopping PHP FastCGI...taskkill /F /IM php-cgi.exe &gt; nulecho FastCGI 已停止echo.:启动脚本@echo offset php_home=./php-7.3.2set nginx_home=./nginx-1.15.8REM Windows 下无效REM set PHP_FCGI_CHILDREN=5REM 每个进程处理的最大请求数，或设置为 Windows 环境变量set PHP_FCGI_MAX_REQUESTS=1000echo Starting PHP FastCGI...RunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.iniecho FastCGI 启动成功echo.echo Starting nginx...RunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%echo nginx 启动成功echo.:echo 15秒后自动退出:ping 0.0.0.0 -n 15 &gt; null:请按任意键继续. . .pause 4.最后我的根目录结构 123456789101112131415161718C:\\PHP&gt;dir 驱动器 C 中的卷是 系统 卷的序列号是 09C1-B27D C:\\PHP 的目录2019/02/22 15:46 &lt;DIR&gt; .2019/02/22 15:46 &lt;DIR&gt; ..2019/02/22 11:23 &lt;DIR&gt; mysql-5.6.43-winx642018/12/25 17:54 &lt;DIR&gt; nginx-1.15.82019/02/21 15:59 &lt;DIR&gt; php-7.3.22019/02/22 15:41 758 restart.bat2010/10/26 11:43 1,536 RunHiddenConsole.exe2019/02/22 15:41 549 start.bat2019/02/22 15:41 227 stop.bat2019/02/21 16:56 &lt;DIR&gt; web 4 个文件 3,070 字节 6 个目录 100,959,772,672 可用字节","tags":[]},{"title":"BlueLake博客主题的详细配置","date":"2016-12-29T03:25:33.000Z","path":"2016/12/29/BlueLake博客主题的详细配置.html","text":"开始之前BlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 1. 安装您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。 1.1 安装主题在根目录下打开终端窗口： git bash1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。 git bash12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。 根_config.yml_config.yml1theme: BlueLake 1.4 验证首先启动 Hexo 本地站点，并开启调试模式： git bash1$ hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 1.5 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。 git bash12cd themes/BlueLakegit pull 2. 配置2.1 配置网站头部显示文字打开根_config.yml，找到： 根_config.yml_config.yml1234title: subtitle: description: author: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。 2.2 设置语言该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下： 根_config.yml_config.yml1language: zh-CN 2.3 设置菜单打开主题_config.yml，找到： 主题_config.ymlthemes/BlueLake/_config.yml12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive # - page: about # directory: about/ # icon: fa-user - page: rss directory: atom.xml icon: fa-rss 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好： 主题_config.ymlthemes/BlueLake/_config.yml12345# About page about: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 2.3.1 添加about页此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面： git bash1$ hexo new page 'about' 打开主题_config.yml，补全关于我页面的详细信息： 主题_config.ymlthemes/BlueLake/_config.yml12345678# About page about: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件在根目录下打开命令行窗口： git bash123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置： 主题_config.ymlthemes/BlueLake/_config.yml1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.4 添加本地搜索默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件： git bash1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置： 根_config.yml_config.yml123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置： 主题_config.ymlthemes/BlueLake/_config.yml1local_search: true 2.5 修改站点图标站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为** favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。) 2.6 添加站点关键字请在hexo目录的根_config.yml中添加keywords字段，如： 根_config.yml_config.yml1234567# Sitetitle: Hexosubtitle: 副标题description: 网站简要描述,如：Charles·Zheng's blog.keywords: 网站关键字, key, key1, key2, key3author: Charleslanguage: zh-CN 2.7 首页添加文章置顶在根目录下打开命令行窗口安装： git bash12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。 123456---title: BlueLake博客主题的详细配置tags: [hexo,BlueLake]categories: hexo博客折腾top: true--- 2.8 更换主题背景和添加文章版权信息更换主题背景为深色 主题_config.ymlthemes/BlueLake/_config.yml 12# Theme tonedark: true #true/false 添加文章版权信息 主题_config.ymlthemes/BlueLake/_config.yml 12345# Theme tone#Copyrightcopyright: enable: true #true/false describe: 转载请注明出处(必须保留原文作者署名原文链接) #自定义描述替换默认描述 2.9 其他配置主题_config.yml的其他配置 show_category_count——是否显示分类下的文章数。 widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。主题_config.ymlthemes/BlueLake/_config.yml 12show_category_count: true widgets_on_small_screens: true 3.集成第三方服务3.1 添加评论目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。 注册并获得代码。 若使用多说评论，注册多说后获得short_name。 若使用Disqus评论，注册Disqus后获得short_name。 若使用来必力评论，注册来必力,获得data-uid。 若使用友言评论，注册友言,获得uid。 若使用网易云跟帖评论，注册网易云跟帖,获得productKey。 若使用畅言评论，注册畅言，获得appid，appkey。 配置主题_config.yml：主题_config.ymlthemes/BlueLake/_config.yml12345678910#Cmmentscomment: duoshuo: ## duoshuo_shortname disqus: ## disqus_shortname livere: ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey) 3.2 百度统计 登录百度统计，定位到站点的代码获取页面。 复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000) 配置主题_config.yml:主题_config.ymlthemes/BlueLake/_config.yml 1baidu_analytics: 8006843039519956000 注意： baidu_analytics不是你的百度id或者百度统计id如若使用谷歌统计，配置方法与百度统计类似。 3.3 卜算子阅读次数统计主题_config.ymlthemes/BlueLake/_config.yml1busuanzi: true 若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。 3.4 微博秀微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。 登录微博开放平台，选择微博秀。 为了与主题风格统一，作如下配置 基础设置：高400px；勾选宽度自适应；颜色选择白色； 样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8； 模块设置：去掉标题、边框、粉丝的勾选框，只留微博。 复制代码里src=&quot;&quot;里引号包裹的内容，替换到layout/_widget/weibo.jadeweibo.jadelayout/_widget/weibo.jade1234.widget .widget-title i(class='fa fa-weibo')= ' ' + __('新浪微博') iframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1\") 这只是为了和主题的风格统一，当然您也可以自由随意发挥。 注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaooo.github.io/tags/hexo/"},{"name":"BlueLake","slug":"BlueLake","permalink":"http://chaooo.github.io/tags/BlueLake/"}]},{"title":"自定义HEXO站内搜索Javascript+json","date":"2016-11-09T01:24:56.000Z","path":"2016/11/09/自定义HEXO站内搜索Javascript-json.html","text":"开始之前目前很多Hexo博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源： hexo-generator-search生成xml格式的数据文件。 hexo-generator-json-content 生成json格式的数据文件。今天的主角是hexo-generator-json-content，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。 1.安装1$ npm install hexo-generator-json-content@2.2.0 --save 然后执行hexo generate时会自动生成content.json文件，若使用默认设置，生成的数据结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445meta: &#123; title: hexo.config.title, subtitle: hexo.config.subtitle, description: hexo.config.description, author: hexo.config.author, url: hexo.config.url&#125;,pages: [&#123; //-&gt; all pages title: page.title, slug: page.slug, date: page.date, updated: page.updated, comments: page.comments, permalink: page.permalink, path: page.path, excerpt: page.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: page.content, //-&gt; only text minified ;) raw: page.raw, //-&gt; original MD content content: page.content //-&gt; final HTML content&#125;],posts: [&#123; //-&gt; only published posts title: post.title, slug: post.slug, date: post.date, updated: post.updated, comments: post.comments, permalink: post.permalink, path: post.path, excerpt: post.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: post.content, //-&gt; only text minified ;) raw: post.raw, //-&gt; original MD content content: post.content, //-&gt; final HTML content categories: [&#123; name: category.name, slug: category.slug, permalink: category.permalink &#125;], tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;]&#125;] 2.配置hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下： 123456789101112131415161718192021222324252627282930313233jsonContent: meta: true keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish) pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false categories: true tags: true 因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在hexo/_config.yml中加入： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true #文章标题 date: true #发表日期 path: true #路径 text: true #文本字段 raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true #标签 这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。例如： 1234567891011&#123; \"title\": \"自定义HEXO站内搜索Javascript+json\", \"date\": \"2016-11-09T01:24:56.000Z\", \"path\": \"2016/11/09/自定义HEXO站内搜索Javascript-json.html\", \"text\": \"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\", \"tags\": [&#123; \"name\": \"javascript,hexo\", \"slug\": \"javascript-hexo\", \"permalink\": \"http://chaoo.oschina.io/tags/javascript-hexo/\" &#125;]&#125; 3.JavaScript实现代码接下来就是用JS实现查询方法并把结果渲染到页面。 3.1 xhr加载数据12345678910111213141516171819202122var searchData;function loadData(success) &#123; if (!searchData) &#123; var xhr = new XMLHttpRequest(); xhr.open('GET', '/content.json', true); xhr.onload = function() &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; var res = JSON.parse(this.response || this.responseText); searchData = res instanceof Array ? res : res.posts; success(searchData); &#125; else &#123; console.error(this.statusText); &#125; &#125;; xhr.onerror = function() &#123; console.error(this.statusText); &#125;; xhr.send(); &#125; else &#123; success(searchData); &#125;&#125; 3.2 匹配文章内容返回结果12345678910function matcher(post, regExp) &#123; // 匹配优先级：title &gt; tags &gt; text return regtest(post.title, regExp) || post.tags.some(function(tag) &#123; return regtest(tag.name, regExp); &#125;) || regtest(post.text, regExp);&#125;function regtest(raw, regExp) &#123; regExp.lastIndex = 0; return regExp.test(raw);&#125; 3.3 结果渲染到页面123456789101112131415function render(data) &#123; var html = ''; if (data.length) &#123; html = data.map(function(post) &#123; return tpl(searchTpl, &#123; title: post.title, path: post.path, date: new Date(post.date).toLocaleDateString(), tags: post.tags.map(function(tag) &#123; return '&lt;span&gt;' + tag.name + '&lt;/span&gt;'; &#125;).join('') &#125;); &#125;).join(''); &#125; &#125; 3.3 查询匹配1234567891011function search(key) &#123; // 关键字 =&gt; 正则，空格隔开的看作多个关键字 // a b c =&gt; /a|b|c/gmi var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi'); loadData(function(data) &#123; var result = data.filter(function(post) &#123; return matcher(post, regExp); &#125;); render(result); &#125;);&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaooo.github.io/tags/hexo/"},{"name":"javascript","slug":"javascript","permalink":"http://chaooo.github.io/tags/javascript/"}]},{"title":"好用的Web包管理器-Bower","date":"2016-08-12T07:32:41.000Z","path":"2016/08/12/Web包管理器-Bower.html","text":"Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。 开始之前在安装bower之前，必须确认你已经安装了Node.js和Git。 1.安装Bower使用npm，打开终端，键入： 1npm install -g bower #全局安装bower 移步这里查看不同平台上安装的问题。 2.使用Bower使用help命令查看帮助。 12345678910111213141516171819202122232425262728293031323334bower helpUsage: bower &lt;command&gt; [&lt;args&gt;] [&lt;options&gt;]Commands: cache Manage bower cache help Display help information about Bower home Opens a package homepage into your favorite browser info Info of a particular package init Interactively create a bower.json file install Install a package locally link Symlink a package folder list List local packages - and possible updates login Authenticate with GitHub and store credentials lookup Look up a package URL by name prune Removes local extraneous packages register Register a package search Search for a package by name update Update a local package uninstall Remove a local package unregister Remove a package from the registry version Bump a package versionOptions: -f, --force Makes various commands more forceful -j, --json Output consumable JSON -l, --loglevel What level of logs to report -o, --offline Do not hit the network -q, --quiet Only output important information -s, --silent Do not output anything, besides errors -V, --verbose Makes output more verbose --allow-root Allows running commands as root -v, --version Output Bower version --no-color Disable colorsSee 'bower help &lt;command&gt;' for more information on a specific command. 3.安装包到本地通过命令bower install安装软件包默认到bower_components/目录。 1bower install &lt;package&gt; #package为包名 想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它. 12345bower install # 通过 bower.json 文件安装bower install jquery # 通过在github上注册的包名安装bower install desandro/masonry # GitHub短链接bower install git://github.com/user/package.git # Github上的 .gitbower install http://example.com/script.js # URL 安装选项 12345-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Save installed packages into the project’s bower.json dependencies-D, --save-dev: Save installed packages into the project’s bower.json devDependencies-E, --save-exact: Configure installed packages with an exact version rather than semver 4.用bower.json文件来管理依赖发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。在项目中执行 1bower init 会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上--save即可。 5.使用下载好的包对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如： 12&lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt;&lt;script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; 6.更新包若下载的包升级了，只需执行update命令即可更新，例如： 1bower update jquery 这样就可以自动升级到最新版的jquery了。更新选项 1234-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Update dependencies in bower.json-D, --save-dev: Update devDependencies in bower.json 7.搜索包12bower search #搜索所有包bower search &lt;packageName&gt; #搜索指定名称的包 或者可以在这里:https://bower.io/search/搜索喜欢的包. 8.卸载包1bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;] 卸载选项 12-S, --save: Remove uninstalled packages from the project’s bower.json dependencies-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies","tags":[{"name":"bower","slug":"bower","permalink":"http://chaooo.github.io/tags/bower/"}]},{"title":"MongoDB学习笔记","date":"2016-07-30T10:20:16.000Z","path":"2016/07/30/MongoDB学习笔记.html","text":"part1 安装配置一、安装：在mongodb官网下载对应自己电脑系统的安装包，地址为： http://www.mongodb.org/downloads。 1、以Windows64bit为例，下载.msi文件双击安装。2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db) 123D:cd D:\\MongoDB\\binmongod --dbpath D:\\MongoDB\\data\\db 5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：) 12MongoDB shell version: 3.2.4 //mongodb版本connecting to: test //默认shell连接的是本机localhost 上面的test库 此时就可以操作数据库了。 二、将MongoDB服务器作为Windows服务运行1、在D:\\MongoDB目录下创建mongodb.config,写入如下： 12345## 数据库文件目录dbpath=D:/MongoDB/data## 日志目录logpath=D:/MongoDB/log/mongo.logdiaglog=3 2、常规命令(cmd管理员): 123D:cd D:\\MongoDB\\binmongod --config D:\\MongoDB\\mongodb.config 3、若常规方式失败，则sc方式(cmd管理员)： 123D:cd D:\\MongoDB\\binsc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot; 访问地址：localhost:27017测试是否启动成功 part2 CRUD操作(Creat,Read,Update,Delete)一、基础：1、document(文档) MongoDB把所有数据存放在类似于JSON数据结构的文档内： 1&#123; \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" &#125; 2、collection(集合) 集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。 123&#123; \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" &#125;&#123; \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" &#125;&#123; \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" &#125; 3、database(数据库) MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。 二、数据库操作：连接及运行mongoDB“show dbs“命令可以显示所有的数据的列表“db“命令可以显示当前数据库对象或集合“use“命令可以连接到一个指定的数据库数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。 1.不能是空字符串（””)。 2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。 3.应全部小写。 4.最多64字节。 1、创建数据库：use Database_Name 1use test ##创建名为test的数据库 2、删除当前数据库： 1db.dropDatabase() 三、文档操作（以 Collection_Name = col 为例）1、插入：12345678910db.col.insert(Document) ##插入一条或多组数据db.col.insertOne(Document) ##插入一条数据db.col.insertMany(Document) ##插入多条数据##例如： db.col.insertOne(&#123; \"item\": \"pencil\", \"type\": \"no.1\" &#125;) db.col.insertMany([ &#123; \"item\": \"dog\", \"type\": \"no.2\" &#125;, &#123; \"item\": \"apple\", \"type\": \"no.3\" &#125;, &#123; \"item\": \"orange\", \"type\": \"no.4\" &#125; ]) 2、删除：123456789db.col.remove(&#123;&#125;) ##删除所有数据db.col.remove(query &lt;,options&gt;) # query: 查询条件(数据索引或名字) # ptions:两个可选参数 # &#123;justOne: &lt;boolean&gt;, //默认false，删除所有匹配到的。 # writeConcern: &lt;document&gt;//抛出异常的级别。 # &#125;db.col.deleteOne(query &lt;,options&gt;) ##同上，无justOne参数，只删除第一条db.col.deleteMany(query &lt;,options&gt;) ##同上，无justOne参数，只删除多条 3、更新：123456789101112131415161718db.col.update(query, update &lt;,options&gt;) # query: 查询条件(数据索引或名字) # update: 更新的内容，语法：&#123;$set:query&#125; # options:三个可选参数 # &#123;upsert: &lt;boolean&gt;, //如果不存在update的记录，是否插入新数据，默认:false。 # multi: &lt;boolean&gt;, //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。 # writeConcern: &lt;document&gt;//#抛出异常的级别。 # &#125;##例如： db.col.update( &#123;\"type\": \"no.1\"&#125;, &#123;$set: &#123;\"item\": \"human\"&#125;&#125;, &#123;upsert: true, multi: true&#125; )db.col.updateOne() ##同上，无multi参数，只更新第一条db.col.updateMany() ##同上，无multi参数db.col.replaceOne() ##同updateOnedb.col.save(document &lt;,writeConcern&gt;) ##通过传入的文档整个替换 insert 与 save的区别如果插入的数据的_id相同,save将会更新该文档,而insert将会报错 update常用操作符1234567891011$set ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.$unset ##删除文档中的一个字段.$rename ##重命名某个列$inc ##增长某个列$setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段$push ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.$pushAll ##将多个数值一次存入数组.上面的push只能一个一个的存入$addToSet ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.$pop ##删除数组最后一个元素$pull ##删除数组中的指定的元素,如果删除的字段不是数组,会报错$pullAll ##删除数组中的多个值,跟pushAll与push的关系类似. 4、查询12345db.col.find(&#123;&#125;) ##查询所有文档db.col.find().pretty() ##以易读的方式来读取数据db.collection.find(query, projection) # query：查询条件(数据索引或名字) # projection：可选。指定返回的字段。 4.1、深入查询表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647db.col.find()##查询所有db.col.find(&#123;filed: value&#125;) ##等值查询db.col.find(&#123;filed: &#123;$ne: value&#125;&#125;) ##不等于 $nedb.col.find(&#123;filed: &#123;$nin: [value1, value2, ...]&#125;&#125;) ##不能包含给定的值 $nindb.col.find(&#123;filed: &#123;$all: [value1, value2, ...]&#125;&#125;) ##必须包含所有给定的值 $alldb.col.find(&#123;filed: &#123;$in: [value1, value2, ...]&#125;&#125;) ##只要包含一个或多个给定的值 $indb.col.find(&#123;filed: &#123;$exists:1&#125;&#125;) ##存在filed字段的db.col.find(&#123;filed: &#123;$exists:0&#125;&#125;) ##不存在filed字段的db.col.find(&#123;filed: &#123;$mod:[3,1]&#125;&#125;) ##模三余一，$mod(取模操作)db.col.find(&#123;$or: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) ##或 $ordb.col.find(&#123;$nor: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)##排除 $nordb.col.find(&#123;filed: &#123;$size: 3&#125;&#125;) ##返回值得数组是给定的长度(3) $sizedb.col.find(&#123;$where: function()&#123;return ...&#125;&#125;) ##回调，隐式迭代，符合条件才返回db.col.find(&#123;$where: '...'&#125;&#125;) ##同上db.col.find(&#123;age: &#123;$lt: 5&#125;&#125;).limit(3) ##查询age的值小于5，限制3条 #范围查询： # $lt （小于） # $gt （大于） # $lte （小于等于） # $gte （大于等于） # limit（限制显示）db.col.find().skip(2).limit(3) ##跳过前两个文档查询后面三个 # skip(num):表示跳过前面num个文档db.col.find().sort(&#123;age: 1&#125;) ##查询后以age升序排列显示 # sort():排序，这里 1 代表升序, -1 代表降序.db.col.find(&#123;filed: /user.*/i&#125;) ##正则，查询filed以user开头不区分大小写（正则效率低）db.col.find(&#123;filed: &#123;$type: 1&#125;&#125;) ##查找filed为双精度的文档 # 根据数据类型查询 $type # |类型 |编号| # |双精度 |1 | # |字符串 |2 | # |对象 |3 | # |数组 |4 | # |二进制数据 |5 | # |对象ID |7 | # |布尔值 |8 | # |日期 |9 | # |空 |10 | # |正则表达式 |11 | # |JavaScript |13 | # |符号 |14 | # |JavaScript(带范围)|15 | # |32位整数 |16 | # |时间戳 |17 | # |64位整数 |18 | # |最小键 |255 | # |最大键 |127 | 4.2、group分组查询group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。 12345group(&#123; key:&#123;字段:1&#125;, initial:&#123;变量:初始值&#125;, $reduce:function(doc,prev)&#123;函数代码&#125;&#125;) 其中key下的字段代表,需要按哪个字段分组.initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果. 栗子：如下我们按年龄分组,同级不同年龄的用户的多少: 123456789101112131415161718192021222324252627282930313233db.user.find() &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 &#125;db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;count:0&#125;, $reduce:function(doc,prev)&#123; prev.count++ &#125;&#125;); [ &#123;\"age\": 0, \"count\": 1&#125;, &#123;\"age\": 1, \"count\": 3&#125;, &#123;\"age\": 2, \"count\": 2&#125; ]db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;users:[]&#125;, reduce:function(doc,prev)&#123; prev.users.push(doc.name) &#125;&#125;); [ &#123;\"age\": 0, \"users\": [\"user0\"]&#125;, &#123;\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]&#125;, &#123;\"age\": 2, \"users\": [\"user2\", \"user5\"]&#125; ] 另外本函数还有两个可选参数 condition 和 finalizecondition就是分组的条件筛选类似mysql中的having 123456789101112db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;users:[]&#125;, $reduce:function(doc,prev)&#123; prev.users.push(doc.name) &#125;, condition:&#123;age:&#123;$gt:0&#125;&#125;&#125;) ##筛选出age大于0的:[ &#123;\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]&#125;, &#123;\"age\": 2, \"users\": [\"user2\", \"user5\"]&#125;] 4.3、count统计12db.goods.count() ##统计该集合总数db.goods.count(&#123;cat_id: 3&#125;) ##统计cat_id=3的总数 4.4、distinct排重12345678910db.user.find() &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 &#125; db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象; [0, 1, 2] 4.5、子文档查询$elemMatchelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。注意：(1)数组中元素是内嵌文档。(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。假设集合school有如下数据： 1234567891011121314151617181920212223242526272829303132&#123; _id: 1, zipcode: 63109, students: [ &#123; name: \"john\", school: 102, age: 10 &#125;, &#123; name: \"jess\", school: 102, age: 11 &#125;, &#123; name: \"jeff\", school: 108, age: 15 &#125; ]&#125;&#123; _id: 2, zipcode: 63110, students: [ &#123; name: \"ajax\", school: 100, age: 7 &#125;, &#123; name: \"achilles\", school: 100, age: 8 &#125;, ]&#125;&#123; _id: 3, zipcode: 63109, students: [ &#123; name: \"ajax\", school: 100, age: 7 &#125;, &#123; name: \"achilles\", school: 100, age: 8 &#125;, ]&#125;&#123; _id: 4, zipcode: 63109, students: [ &#123; name: \"barney\", school: 102, age: 7 &#125;, ]&#125; 下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。 12345db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; $elemMatch: &#123; school: 102 &#125; &#125; &#125; );&#123;\"_id\": 1, \"students\": [&#123;\"name\":\"john\", \"school\":102, \"age\":10&#125;]&#125;&#123;\"_id\": 3&#125;&#123;\"_id\": 4, \"students\": [&#123;\"name\":\"barney\", \"school\":102, \"age\":7&#125;]&#125; 查询结果说明：_id为1的文档，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。_id为3的文档，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。 $elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。 12345db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; $elemMatch: &#123; school: 102, age: &#123; $gt: 10&#125; &#125; &#125; &#125; ); &#123;\"_id\": 1, \"students\": [&#123;\"name\":\"jess\", \"school\":102, \"age\":11&#125;]&#125; &#123;\"_id\": 3&#125; &#123;\"_id\": 4&#125;","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://chaooo.github.io/tags/mongodb/"}]},{"title":"sublime text3个人习惯配置","date":"2016-06-29T01:41:48.000Z","path":"2016/06/29/sublime-text3个人习惯配置-C.html","text":"1、安装分别在官网下载并安装 nodejs 和 sublime text3。 2、sublime text3注册： 点击菜单【help】－&gt;【Enter License】，粘贴注册码。 3、安装package control组件，用于管理所有插件按ctrl + ~调出控制台(或点击菜单栏的【View】-&gt;【Show Console】)，在Console窗口中输入以下代码，按回车键： 1import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 等待安装完毕，重启Sublime Text3。按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control： 4、用Package Control安装插件按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）Material ThemeEmmetCSS FormatCSScombjsFormatAutoFileNameAutoprefixerDoc BlockrSublimeLinterSublimeLinter-jshintSublimeLinter-csslintColor HighlighterBracketHighlighter 5、配置nodejs方法1(1)下载sublime Text的nodejs插件(2)下载后解压:直接改名为nodejs 放到 Preferences–&gt;浏览程序包Browse Packages所在的文件夹(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示： 12345678910111213141516171819&#123; \"cmd\": [\"node\", \"$file\"], \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"selector\": \"source.js\", \"shell\":true, \"encoding\": \"cp1252\", \"windows\": &#123; \"cmd\": [\"taskkill /F /IM node.exe &amp; node\", \"$file\"] &#125;, \"linux\": &#123; \"cmd\": [\"killall node; node\", \"$file\"] &#125;, \"osx\": &#123; \"cmd\": [\"killall node; node $file\"] &#125;&#125; (4)修改为： 1234567891011121314151617181920&#123; \"cmd\": [\"node\", \"$file\"], \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"selector\": \"source.js\", \"shell\":true, \"encoding\": \"utf-8\", \"windows\": &#123; \"cmd\": [\"taskkill /F /IM node.exe\", \"\"], \"cmd\": [\"node\", \"$file\"] &#125;, \"linux\": &#123; \"cmd\": [\"killall node; node\", \"$file\"] &#125;, \"osx\": &#123; \"cmd\": [\"killall node; node $file\"] &#125;&#125; (5)完成:随便写一段nodejs代码，ctrl+B运行(6)注意：在手动解压sublime Text插件后，需要在preference-&gt;package settings-&gt;package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。 方法2首先需要先安装nodejs。(1)运行Sublime,菜单上找到Tools —&gt; Build System —&gt; new Build System(2)输入：{ “cmd”: [“node”, “$file”], “file_regex”: “^[ ]File &quot;(…?)&quot;, line ([0-9]*)”, “selector”: “source.js”, “shell”:true, “encoding”: “utf-8”, “windows”: { “cmd”: [“taskkill /F /IM node.exe”, “”], “cmd”: [“node”, “$file”] }}(3)保存文件为NodeJs.sublime-build(4)菜单上找到Tools —&gt; Build System —&gt;选择 NodeJs(5)安装sublime插件 JavaScript &amp; NodeJs Snippets(6)新建test.js文件，输入 console.log(‘Hello Node.js’); 按快捷键 Ctrl + B 运行，成功输出","tags":[{"name":"sublime","slug":"sublime","permalink":"http://chaooo.github.io/tags/sublime/"}]},{"title":"Hexo3.2+GitHub搭建静态博客","date":"2016-05-23T03:16:51.000Z","path":"2016/05/23/Hexo3-2-github搭建静态博客.html","text":"开始之前在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.创建GitHub仓库注册GitHub账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：chaooo.github.io，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。 2.配置Git设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入： 12$ git config --global user.name \"username\"$ git config --global user.email \"email@example.com\" 3.本地Git与GitHub建立联系这里介绍SSH的配置，先检查电脑是否已经有SSH 1$ ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。输入以下指令后，一路回车就好： 1$ ssh-keygen -t rsa -C \"emailt@example.com\" 然后键入以下指令： 12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可： 1$ ssh-agent bash 再重新输入指令： 1$ ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）： 1$ clip &lt; ~/.ssh/id_rsa.pub 在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH keyTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。最后还是测试一下吧，键入以下命令： 1$ ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 4.初始化hexo文件夹到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt; 12$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git$ mkdir Hexo-admin Hexo安装配置1.Hexo初始化进入Hexo-admin文件夹 1$ cd Hexo-admin 接下来只需要使用 npm 即可完成 Hexo 的安装: 1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件: 12$ hexo init$ npm install 接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。 12$ hexo generate$ hexo server 输入Ctrl+C停止服务。 2.Hexo配置用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到： 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repository: 到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 3.完成部署最后一步，快要成功了，键入指令： 123$ npm install hexo-deployer-git --save$ hexo generate$ hexo deploy 输入弹出框的用户名与密码(首次使用git会弹出)。OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：chaooo.github.io/每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样： 123To https://github.com/chaooo/chaooo.github.io.git 7f3b50a..128a10d HEAD -&gt; masterINFO Deploy done: git 当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。 日常操作1.写文章执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。 1$ hexo new [layout] \"文章标题\" #新建文章 然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout， 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md 1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下： 12345title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:--- 文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。 2.提交每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。 123$ git add .$ git commit -m \"...\"$ git push origin develop 然后才执行hexo generate -d发布网站到master分支上。 1$ hexo generate -d 3.本地仓库丢失当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤： 3.1拷贝仓库1$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git 3.2配置Hexo在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令: 1234$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save 小Tips:hexo 命令1234567891011121314hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo deploy -g #生成加部署hexo server -g #生成加预览#命令的简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaooo.github.io/tags/hexo/"}]},{"title":"Hello World","date":"2015-12-31T15:59:59.000Z","path":"2015/12/31/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaooo.github.io/tags/hexo/"}]}]