[{"title":"二十、SSM框架整合(Spring+SpringMVC+MyBatis)","date":"2019-08-27T14:52:55.000Z","path":"2019/08/27/20-SSM框架整合.html","text":"SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。 使用spring MVC负责请求的转发和视图管理 spring实现业务对象管理 mybatis作为数据对象的持久化引擎 1.搭建SSM架构步骤： 设计数据库 先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。 编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。 编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。 配置spring和mybatis框架的整合(applicationContext.xml) 编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。 配置SpringMVC(web.xml) 编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。 编写JSP页面调用，请求哪些参数，需要获取什么数据。 DataBase –&gt; Entity –&gt; Mapper.xml –&gt; Mapper.Java(DAO) –&gt; Service.java –&gt; Controller.java –&gt; Jsp 2.搭建SSM架构实例（管理员登录）1. 设计数据库(以MySql为例)建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行 1234567891011121314CREATE DATABASE exam_sys;/** 管理员表 */DROP TABLE admin;CREATE TABLE admin( id INT AUTO_INCREMENT COMMENT '管理员ID', name VARCHAR(30) NOT NULL COMMENT '管理员账号', password VARCHAR(30) COMMENT '管理员密码', CONSTRAINT et_admin_id_pk PRIMARY KEY(id), CONSTRAINT et_admin_name_uk UNIQUE(NAME));/** 插入数据 */INSERT INTO admin (name, password) VALUES('admin', '123456');SELECT * FROM admin;COMMIT; 2. 先写实体类entity，定义对象的属性参照数据库中表的字段来设置 123456789101112package com.exam.entity;public class Admin &#123; private int id; private String name; private String password; /** 添加 getter/setter方法 * 添加 无参，有参构造 * 重写toString()以便于测试 */ // ...&#125; 3. 编写AdminMapper.xml（Mybatis），定义功能对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\"&gt;&lt;!-- namespace指定和哪个Mapper映射器接口对应 --&gt;&lt;mapper namespace=\"com.exam.mapper.AdminDao\"&gt; &lt;!-- 定义SQL语句 --&gt; &lt;select id=\"findByNameAndPassword\" resultType=\"com.exam.entity.Admin\"&gt; select * from admin where name=#&#123;name, jdbcType=VARCHAR&#125; and password=#&#123;password, jdbcType=VARCHAR&#125; &lt;/select&gt;&lt;/mapper&gt; 4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合) 12345678package com.exam.mapper;import org.apache.ibatis.annotations.Param;import com.exam.entity.Admin;public interface AdminDao &#123; public Admin findByNameAndPassword(@Param(\"name\") String name, @Param(\"password\") String password);&#125; 5. 配置spring和mybatis框架的整合导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。 123456789101112131415161718192021222324252627&lt;!-- 配置连接池对象 --&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/exam_sys\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory 属性dataSource：注入连接池对象 属性mapperLocations：指定MyBatis的映射器XML配置文件的位置 属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名 --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/exam/mapper/*.xml\"&gt;&lt;/property&gt; &lt;!-- &lt;property name=\"typeAliasesPackage\" value=\"com.exam.entity\"&gt;&lt;/property&gt; --&gt;&lt;/bean&gt;&lt;!-- 批量生产DAO接口实现类 ,实现类id为类名首字母小写 --&gt;&lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; --&gt; &lt;property name=\"basePackage\" value=\"com.exam.mapper\"&gt;&lt;/property&gt; &lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt; &lt;!-- &lt;property name=\"annotationClass\" value=\"com.annotation.MyAnnotation\"&gt;&lt;/property&gt; --&gt;&lt;/bean&gt;&lt;!-- 开启服务层组件扫描 --&gt;&lt;context:component-scan base-package=\"com.exam.service\"/&gt; 6. 编写Service.java，为控制层提供服务接受控制层的参数，完成相应的功能，并返回给控制层。 1234567891011121314151617181920package com.exam.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.exam.mapper.AdminDao;@Service(\"adminService\")public class AdminService &#123; @Autowired private AdminDao dao; public boolean Login(String name, String password) &#123; try &#123; return dao.findByNameAndPassword(name, password)!=null?true:false; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 7. 配置SpringMVC导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。 12345678910111213141516171819202122232425262728&lt;!-- 配置编码过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 配置DispatcherServlet分发请求 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler--&gt; 在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。 1234567891011&lt;!-- 开启控制器组件扫描 --&gt;&lt;context:component-scan base-package=\"com.exam.controller\"/&gt;&lt;!-- 开启标注形式mvc --&gt;&lt;mvc:annotation-driven /&gt;&lt;!-- 配置视图处理器 --&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 对静态资源进行放行 --&gt;&lt;mvc:default-servlet-handler/&gt; 8. 编写Controller.java，连接页面请求和服务层获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar） 12345678910111213141516171819202122232425262728293031323334353637package com.exam.controller;import javax.servlet.http.HttpServletRequest;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import com.exam.entity.Admin;import com.exam.service.AdminService;@Controller@RequestMapping(\"/admin\")public class AdminController &#123; @Autowired private AdminService as; @RequestMapping(\"/tologin\") public String toLogin() &#123; return \"admin/login\"; &#125; @RequestMapping(value=\"/login\",method=RequestMethod.POST) @ResponseBody public boolean addUser(Admin admin, HttpServletRequest request) &#123; System.out.println(\"add:\"+admin); System.out.println(admin.getName()+\"---\"+admin.getPassword()); boolean bl = as.Login(admin.getName(), admin.getPassword()); if(bl) &#123; //登录成功的逻辑 request.getSession().setAttribute(\"admin\", admin); return true; &#125; //登录失败的逻辑 request.setAttribute(\"msg\", \"登录失败\"); return false; &#125;&#125; 9. 编写JSP页面调用123456789101112131415161718192021&lt;form&gt; 管理员: &lt;input id=\"aName\" type=\"text\"&gt;&lt;br&gt; 密码:&lt;input id=\"aPassword\" type=\"text\"&gt;&lt;br&gt; &lt;input id=\"loginBtn\" type=\"button\" value=\"登录\"&gt;&lt;/form&gt;&lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(\"#loginBtn\").on(\"click\", function()&#123; $.ajax(&#123; url: \"admin/login\", type: \"post\", data: &#123; name: $(\"#aName\").val(), password: $(\"#aPassword\").val() &#125;, success: function(res)&#123; alert(res); &#125; &#125;);&#125;);&lt;/script&gt;","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://chaooo.github.io/tags/Spring/"}]},{"title":"十九、Java持久层框架Mybatis","date":"2019-08-27T14:51:34.000Z","path":"2019/08/27/19-Java持久层框架Mybatis.html","text":"Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。 MyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 Mybatis框架的构成 使用Mybatis访问数据库 Mybatis的CRUD操作 Mapper映射器 向mapper传多个参数 结果集列名和属性名不一致的解决方法 类型的别名和日志输出 JdbcType 1. Mybatis框架的构成 实体类 ： 封装记录信息（JavaBean） SQL定义文件 ：定义sql语句（编写SQL语句的XML） 主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML 框架API ：用于实现数据库增删改查操作（主要通过SqlSession） 2. 使用Mybatis访问数据库以员工表Emp(id,name,salary)为例 准备数据库及创建项目（需要mybatis的jar包和数据库驱动包） 根据表建立对应的实体类：Emp(id,name,salary) 在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等 123456789101112131415161718&lt;configuration&gt; &lt;environments default=\"environment\"&gt; &lt;environment id=\"environment\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/mapper/EmpMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 在【src】包路径下创建配置文件（com/mapper/EmpMapper.xml）,然后根据需求定义sql 1234567891011&lt;mapper namespace=\"com.mapper.EmpMapper\"&gt; &lt;!-- 定义SQL语句 --&gt; &lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.mapper.Emp\"&gt; select * from emp32 where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=\"findByName\" parameterType=\"String\" resultType=\"com.mapper.Emp\"&gt; select * from emp32 where name = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; parameterType：要求输入参数的类型 resultType：输出的类型 封装工具类获取SQLSession 123456789101112131415public class SqlSessionUtil &#123; public static SqlSessionFactory ssf; static &#123; // 先构建SQLSession工厂构建器 SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); // 构建SqlSessionFactory关联主配置文件 InputStream inputStream = SqlSessionUtil.class.getClassLoader().getResourceAsStream(\"mybatis-config.xml\"); ssf = ssfb.build(inputStream); &#125; // 获取SQLSession public static SqlSession getSqlSession() &#123; // 通过SqlSession 工厂对象 来获取SqlSession return ssf.openSession(); &#125;&#125; 编写测试类 1234567public class EmpTest &#123; public static void main(String[] args) &#123; SqlSession ss =SqlSessionUtil.getSqlSession(); Emp emp = ss.selectOne(\"findById\", 6); System.out.println(emp); &#125;&#125; 基本原理 应用程序找 MyBatis 要数据 MyBatis 从数据库中找来数据 通过 mybatis-config.xml 定位哪个数据库 通过 EmpMapper.xml 执行对应的 sql 语句 基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中 返回一个 Emp 对象 3. Mybatis的CRUD操作以员工表Emp(id,name,salary)为例 第一步：配置EmpMapper.xml 123456789101112131415&lt;insert id=\"insertEmp\" parameterType=\"com.mapper.Emp\"&gt; insert into emp32(name, salary) values(#&#123;name&#125;, #&#123;salary&#125;)&lt;/insert&gt;&lt;delete id=\"deleteEmpById\" parameterType=\"int\"&gt; delete from emp32 where id=#&#123;id&#125;&lt;/delete&gt;&lt;update id=\"updateEmpById\" parameterType=\"com.mapper.Emp\"&gt; update emp32 set name=#&#123;name&#125; where id=#&#123;id&#125;&lt;/update&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"com.mapper.Emp\"&gt; select * from emp32 where id = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"findAll\" resultType=\"com.mapper.Emp\"&gt; select * from emp32&lt;/select&gt; parameterType：要求输入参数的类型 resultType：输出的类型 第二步：SQLSession实现增删改查 123456789101112131415161718192021// 先构建SQLSession工厂构建器SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();// 构建SqlSessionFactory关联主配置文件InputStream inputStream = EmpTest.class.getClassLoader().getResourceAsStream(\"sqlmap-config.xml\");SqlSessionFactory ssf = ssfb.build(inputStream);// 通过SqlSession 工厂对象 来获取SqlSessionSqlSession ss = ssf.openSession();//增加Emp emp = new Emp(0,\"ef2\",50000);int addRows = ss.insert(\"insertEmp\", emp);//删除int delRows = ss.delete(\"deleteEmpById\", 12);//更新Emp emp2 = new Emp(1,\"hello\",0);int updateRows = ss.update(\"updateEmpById\", emp2);//查找Emp emp3 = ss.selectOne(\"findById\", 6);List&lt;Emp&gt; empList = ss.selectList(\"findAll\");ss.commit(); SqlSession对象的操作方法如下： insert(..) 插入操作 update(..) 更新操作 delete(..) 删除操作 selectOne(..) 单行查询操作 selectList(..) 多行查询操作 通过 session.commit() 来提交事务，也可以简单理解为更新到数据库 4. Mapper映射器使用规则： 接口的方法名和SQL定义文件中的id保持一致 接口方法的返回值类型 要和resultType 保持一致 单行：resultType 多行：List&lt;resultType&gt; 增删改返回值，推荐int，也可以是void 接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意 SQL定义文件中的namespace必须包名.接口名 5. 向mapper传多个参数5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}DAO层的函数方法 1public Emp findByIdAndName(int id, String name); 对应的Mapper.xml 123&lt;select id=\"findByIdAndName\" resultType=\"com.bean.Emp\"&gt; select * from emp32 where id = #&#123;0&#125; and name = #&#123;1&#125;&lt;/select&gt; 其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。也可以用#{param1} 和 #{param2}实现同意效果。 5.2 第二种方案@paramDao层的函数方法 1public Emp findByIdAndName(@param(\"id\")int id, @param(\"name\")String name); 对应的Mapper.xml 123&lt;select id=\"findByIdAndName\" resultType=\"com.bean.Emp\"&gt; select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 5.3 第三种方案：采用对象或Map传多参数Dao层的函数方法 12public Emp findByIdAndName(Emp emp);public Emp findByIdAndName2(Map&lt;String, Object&gt; params); 对应的Mapper.xml 1234567&lt;select id=\"findByIdAndName\" parameterType=\"com.bean.Emp\" resultType=\"com.bean.Emp\"&gt; select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt;&lt;select id=\"findByIdAndName2\" parameterType=\"map\" resultType=\"com.bean.Emp\"&gt; select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 6. 结果集列名和属性名不一致的解决方法在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。解决方法： 使用别名，select语句使用与属性一致的别名 使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系 123456789101112131415161718&lt;!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系 type:resultMap最终所映射的Java对象类型，可以使用别名 id:对resultMap的唯一标识 --&gt;&lt;resultMap type=\"com.bean.Emp\" id=\"empMap\"&gt; &lt;!-- id表示查询结果集中唯一标识 column:查询出的列名 property:type所指定的类中的属性名 --&gt; &lt;id column=\"e_id\" property=\"id\"/&gt; &lt;!-- 对普通列的映射定义 --&gt; &lt;result column=\"salary\" property=\"sal\"/&gt;&lt;/resultMap&gt;&lt;!-- 使用resultMap --&gt;&lt;select id=\"findEmpById\" parameterType=\"int\" resultMap=\"empMap\"&gt; select * from emp32 where id = #&#123;id&#125;&lt;/select&gt; 7. 类型的别名和日志输出在mybatis-config.xml中自定义类型的别名 123&lt;typeAliases&gt; &lt;typeAlias alias=\"emp\" type=\"com.bean.Emp\"/&gt;&lt;/typeAliases&gt; 在EmpMapper.xml中使用别名 resultType=”emp” 123&lt;select id=\"findById\" parameterType=\"int\" resultType=\"emp\"&gt; select id,name,salary sal from emp32 where id = #&#123;id&#125;&lt;/select&gt; 设置MyBatis的日志输出到控制台 123456&lt;settings&gt; &lt;!--设置是否允许缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!--设置日志输出的目标--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;&lt;/settings&gt; 8. JdbcType在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。 所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。 一般情况下，我们没有必要按个字段去识别/判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。 MyBatis包含的JdbcType类型，主要有下面这些： BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR 123&lt;select id=\"findByName\" parameterType=\"String\" resultType=\"com.bean.Emp\"&gt; select * from emp32 where name = #&#123;name, jdbcType=VARCHAR&#125;&lt;/select&gt; 9. Mabatis中#{}和${}的区别 ${}是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂） 支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号 #{}是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入） 不支持表名、排序方式等的占位，默认会将其当成字符串 10. 分页 在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar） 1234&lt;!-- 配置分页拦截器 --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt;&lt;/plugin&gt;&lt;/plugins&gt; 查询前使用分页API 12345PageHelper.startPage(2, 2);List&lt;Emp&gt; emps = dao.orderBySalary();for(Emp emp: emps) &#123; System.out.println(emp);&#125; 11. Spring+MyBatis整合Spring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API: SqlSessionFactoryBean 创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源 依赖于dataSource 和加载SQL定义文件 MapperFactoryBean 根据指定的某一个Mapper接口生成Bean实例 依赖于SqlSessionFactory 和 MApper接口 MapperScannerConfigurer 根据指定包批量扫描Mapper接口并生成实例 SqlSessionTemplate 类似于JdbcTemplate，便于程序员自己编写Mapper实现类 12. Spring+MyBatis完成sql操作第一步：使用Mybatis（同上） 导jar包(mybatis包/数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口 第二步：配置SqlSessionFactoryBean 导入jar包（mabatis-spring/ioc/aop/dao/连接池） 配置SqlSessionFactoryBean注入dataSource和指定sql定义文件 123456789101112&lt;!-- 配置SqlSessionFactory --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置连接池对象 --&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt; 第三步： 方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory 最终产生Mapper接口的 实现类，注意这是实现类 123456789&lt;!-- 配置SqlSessionFactoryBean 产生Mapper接口的 实现类 --&gt;&lt;bean id=\"empDao\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;property name=\"mapperInterface\" value=\"com.dao.EmpDao\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"empDao2\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;property name=\"mapperInterface\" value=\"com.dao.EmpDao2\"&gt;&lt;/property&gt;&lt;/bean&gt; 方式二： MapperScannerConfigurer MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类 1234567&lt;!-- 批量生产DAO接口实现类 ,实现类id为类名首字母小写 --&gt;&lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; --&gt; &lt;property name=\"basePackage\" value=\"com.dao\"&gt;&lt;/property&gt; &lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt; &lt;property name=\"annotationClass\" value=\"com.annotation.MyAnnotation\"&gt;&lt;/property&gt;&lt;/bean&gt; 13. 使用SqlSessionTemplate模板来完成DAO接口的实现类 使用Mybatis（同上） 配置SqlSessionFactoryBean（同上） 编写DAO接口的实现类 开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory 使用SqlSessionTemplate对应API完成增删改查 123456&lt;!-- 开启组件扫描 --&gt;&lt;context:component-scan base-package=\"com.mapper\"&gt;&lt;/context:component-scan&gt;&lt;!-- 创建SqlSessionTemplate --&gt;&lt;bean id=\"sqlSessionTemplate\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123456789@Repository(\"empDao\")public class EmpDaoImpl implements EmpDao &#123; @Autowired private SqlSessionTemplate sqlSessionTemplate; @Override public Emp findById(int id) &#123; return sqlSessionTemplate.selectOne(\"findById\", id); &#125;&#125;","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://chaooo.github.io/tags/Spring/"}]},{"title":"十八、Spring MVC框架","date":"2019-08-27T14:50:22.000Z","path":"2019/08/27/18-SpringMVC框架.html","text":"Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。 Spring MVC基本概念 Spring MVC的编写步骤 标注(注解)形式的MVC mvc控制器接收页面参数 mvc控制器把数据传递给页面 Spring MVC实现重定向 Spring MVC 中文参数的乱码问题 Spring MVC 拦截器 Spring MVC 拦截器的使用步骤 Spring MVC异常处理 Spring MVC文件上传 文件上传与异常处理的结合 Spring MVC响应JSON REST REST实例 1. Spring MVC基本概念1.1 Spring MVC 五大核心组件Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。 DispatcherServlet：控制器，请求入口 HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系 Controller：控制器，处理请求 ModelAndView：封装了 数据信息和视图信息 ViewResolver：视图处理器 他的两个核心是两个核心： 处理器映射：选择使用哪个控制器来处理请求 视图解析器：选择结果应该如何渲染 通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。 1.2 SpringMVC运行原理 Http请求：客户端请求提交到DispatcherServlet。 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 调用处理器：DispatcherServlet将请求提交到Controller。 调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 Http响应：视图负责将结果显示到客户端。 1.3 SpringMVC接口解释 DispatcherServlet接口：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： 截获符合特定格式的URL请求。 初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。 HandlerMapping接口：能够完成客户请求到Controller映射。 Controller接口： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 ViewResolver接口：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。 1.4 SpringMVC配置 在web.xml文件中进行配置applicationContext.xml路径 1234567891011121314&lt;!-- 配置DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置applicationContext.xml，开启注解功能、配置试图解析器 123456789101112131415&lt;!-- 配置HandlerMapping --&gt;&lt;bean id=\"handlerMapping\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;prop key=\"/toHello.do\"&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 控制器对象 --&gt;&lt;bean id=\"helloController\" class=\"com.controller.MyHelleController\"&gt;&lt;/bean&gt;&lt;!-- 配置视图处理器 --&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt; 2. Spring MVC的编写步骤 建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。 在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。 在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。 编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象 在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。 3. 标注(注解)形式的MVC 建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。 在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。 开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。 12&lt;context:component-scan base-package=\"包名\" /&gt;&lt;mvc:annotation-driven /&gt; 编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了） 使用@Controller 可以把普通Java类转换成控制器，同时在容器中创建对象 使用@RequestMapping(&quot;/路径&quot;) 设置方法上 在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。 4. mvc控制器接收页面参数 使用HttpServletRequest类型的参数来接收 123456@RequestMapping(\"/login.do\")public String login(HttpServletRequest request) &#123; String acc_no = request.getParameter(\"acc_no\"); String acc_pwd = request.getParameter(\"acc_password\"); return \"main\";&#125; 直接定义和页面请求参数同名的控制器参数 12345@RequestMapping(\"/login2.do\")public ModelAndView login2(String acc_no,String acc_password, ModelAndView mav) &#123; mav.setViewName(\"main\"); return mav;&#125; 当页面参数和控制器参数名字不一致，@RequestParam(“acc_no”) 让请求参数和控制器参数对应 12345@RequestMapping(\"/login3.do\")public ModelAndView login3(@RequestParam(\"acc_no\") String a,String acc_password, ModelAndView mav) &#123; mav.setViewName(\"main\"); return mav;&#125; 控制器中 直接定义对象类型的参数 12345@RequestMapping(\"/login4.do\")public ModelAndView login4(Account acc, ModelAndView mav) &#123; mav.setViewName(\"main\"); return mav;&#125; 5. mvc控制器把数据传递给页面使用EL表达式在jsp页面接收数据&lt;h1&gt;欢迎 ${acc_no} &lt;/h1&gt; 使用域对象 进行传输 (request session ServletContext ) 12345@RequestMapping(\"/login6.do\")public String login6(String acc_no, HttpServletRequest req) &#123; req.setAttribute(\"acc_no\", acc_no); return \"main\";&#125; 使用ModelAndView进行数据传输 mav.getModel().put(&quot;acc_no&quot;, acc_no); mav.getModelMap().put(key, value); mav.getModelMap().addAttribute(&quot;acc_no&quot;, acc_no); 12345678@RequestMapping(\"/login7.do\")public ModelAndView login7(String acc_no, ModelAndView mav) &#123; mav.setViewName(\"main\"); //mav.getModel().put(\"acc_no\", acc_no); //mav.getModelMap().put(key, value) mav.getModelMap().addAttribute(\"acc_no\", acc_no); return mav;&#125; 使用Model进行数据传输 12345@RequestMapping(\"/login8.do\")public String login8(String acc_no, Model m) &#123; m.addAttribute(\"acc_no\", acc_no); return \"main\";&#125; 使用ModelMap进行数据传输 123456@RequestMapping(\"/login9.do\")public String login9(String acc_no, ModelMap m) &#123; //m.addAttribute(\"acc_no\", acc_no); m.put(\"acc_no\", acc_no); return \"main\";&#125; 使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(“新名”)修改） 默认名：&lt;h1&gt;欢迎 ${ account.acc_no } &lt;/h1&gt; @ModelAttribute(“acc”)：&lt;h1&gt;欢迎 ${ acc.acc_no } &lt;/h1&gt; 1234@RequestMapping(\"/login10.do\")public String login10(@ModelAttribute(\"acc\") Account acc) &#123; return \"main\";&#125; 6. Spring MVC实现重定向 控制器方法返回String redirect:请求路径 12345678910@RequestMapping(\"/login11.do\")public String login11(@ModelAttribute(\"acc\") Account acc) &#123; //return \"forward:toMain.do\"; return \"redirect:toMain.do\";&#125;@RequestMapping(\"/toMain.do\")public String toMain() &#123; // 干其它的事情 return \"main\";&#125; 控制器方法返回ModelAndView 使用RedirectView 完成 12345678@RequestMapping(\"/login12.do\")public ModelAndView login12(@ModelAttribute(\"acc\") Account acc) &#123; ModelAndView mav = new ModelAndView(); //重定向 RedirectView rv = new RedirectView(\"toMain.do\"); mav.setView(rv); return mav;&#125; 7. Spring MVC 中文参数的乱码问题tomcat8中 get 没有乱码问题，post 请求有乱码问题 参数为页面(HttpServletRequest request)与(HttpServletResponse response)时 12request.setCharacterEncoding(\"UTF-8\");response.setContentType(\"application/json;charset=UTF-8\"); 传入参数为@RequestParam时，可以通过字符串重新编码来解决 1new String(string.getBytes(\"ISO-8859-1\"),\"UTF-8\"); 方法名前出现@RequestMapping(value=&quot;XXX&quot;)时可以在value属性后再加一个属性produces=&quot;text/html;charset=UTF-8&quot;来解决 在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器 123456789101112&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 8. Spring MVC 拦截器 拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置） HandlerMapping接口 preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。 postHandle：处理器执行后、视图处理前调用。 afterCompletion：整个请求处理完毕后调用。 9. Spring MVC 拦截器的使用步骤 搭建一个基于标注的mvc 编写一个类实现HandlerInterceptor接口 在Spring配置文件中配置拦截器1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;mvc:exclude-mapping path=\"/login.do\"/&gt; &lt;bean class=\"com.xdl.interceptor.SomeInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 10. Spring MVC异常处理 配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常 12345678&lt;bean id=\"simpleExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;props&gt; &lt;prop key=\"java.lang.RuntimeException\"&gt;error&lt;/prop&gt; &lt;prop key=\"java.lang.Exception\"&gt;error2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常 12345678910111213@Controllerpublic class MyExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e) &#123; ModelAndView mav = new ModelAndView(); if(e instanceof RuntimeException) &#123; mav.setViewName(\"error\"); &#125;else if(e instanceof Exception) &#123; mav.setViewName(\"error2\"); &#125; return mav; &#125;&#125; 使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex) 1234567//@Controller//public class MyController &#123;@ExceptionHandlerpublic String processException(Exception e) &#123; System.out.println(e.getMessage()); return \"error3\";&#125; 11. Spring MVC文件上传 jsp页面（method=”POST” enctype=”multipart/form-data type=”file”） 1234&lt;form action=\"upload.do\" method=\"post\" enctype=\"multipart/form-data\"&gt; 头像：&lt;input type=\"file\" name=\"head_img\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;br&gt;&lt;/form&gt; 控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包） 123&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;&lt;/bean&gt; 12. 文件上传与异常处理的结合12345678910111213141516171819202122232425262728293031323334@Controllerpublic class fileController &#123; @RequestMapping(\"/toFile.do\") public String tofile() &#123; return \"file\"; &#125; @RequestMapping(\"/upload.do\") public String upload(String acc_no, MultipartFile head_img) &#123; System.out.println(\"acc_no:\" + acc_no ); if(head_img.getSize()&gt;1024*10) &#123; throw new RuntimeException(\"文件过大！\"); &#125; // 把文件写入磁盘 String uniqueStr = UUID.randomUUID().toString(); String oriFilename = head_img.getOriginalFilename(); String suffix = oriFilename.substring(oriFilename.lastIndexOf(\".\")); File file = new File(\"F:/Eclipse/datas/\"+uniqueStr+suffix); try &#123; head_img.transferTo(file); &#125; catch (IllegalStateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(oriFilename); System.out.println(file); return \"file\"; &#125; /** 局部异常 */ @ExceptionHandler public String processError(Exception e) &#123; return \"error4\"; &#125;&#125; 13. Spring MVC响应JSON 搭建基于标注的mvc 在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON 给方法加@RequestMapping(“/请求路径”)、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包 14. RESTREST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。 REST两个核心规范 url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:http://test/source/1234） 对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新 restful 符合REST设计规范和风格的应用程序或设计 就是RESTful Spring MVC对REST的支持 @RequestMapping支持URI的模板，以及http请求方式设定的支持 @RequestMapping(value=&quot;/account/{id}&quot;,method=RequestMethod.POST) 对URI上路径变量的处理的支持，@PathVariable @PathVariable(&quot;id&quot;) int id rest请求路径是没有后缀的，需要把url-parttern修改成/ &lt;servlet-mapping&gt;&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 需要对静态资源进行放行&lt;mvc:default-servlet-handler/&gt; 15. REST实例 配置web.xml与applicationContext.xml(部分配置) 12345678910&lt;!-- 修改rest请求路径 --&gt;&lt;!-- web.xml --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 对静态资源进行放行 --&gt;&lt;!-- applicationContext.xml --&gt; &lt;mvc:default-servlet-handler/&gt; 编写控制类 12345678910111213141516171819202122232425262728293031323334353637383940@Controllerpublic class AccountController &#123; @RequestMapping(\"/toLogin.do\") public String toLogin() &#123; return \"login\"; &#125;/** 根据id查询账户 GET */ @RequestMapping(value=\"/account/&#123;id&#125;\", method=RequestMethod.GET) @ResponseBody public Account getAccountById(@PathVariable(\"id\") int id) &#123; Random rm = new Random(); Account acc = new Account(id, \"test\"+rm.nextInt(100),\"123\", rm.nextInt(999)+1000); return acc; &#125;/** 新增账户 POST */ @RequestMapping(value=\"/account/&#123;id&#125;\",method=RequestMethod.POST) @ResponseBody public boolean addAccount(Account acc) &#123; System.out.println(\"add:\"+acc); if(acc.getId()&gt;100) return true; return false; &#125;/** 根据id删除帐户对象 DELETE */ @RequestMapping(value=\"/account/&#123;id&#125;\",method=RequestMethod.DELETE) @ResponseBody public boolean deleteAccountById(@PathVariable(\"id\") int id) &#123; System.out.println(\"delete:\"+id); if(id&gt;100) return true; return false; &#125;/** 根据id更新帐户 PUT */ @RequestMapping(value=\"/account/&#123;id&#125;\",method=RequestMethod.PUT) @ResponseBody public boolean putAccount(@RequestBody Account acc) &#123; //@RequestBody将接收的ajax请求的json字符串写入Account对象中 System.out.println(\"update:\"+acc); if(acc.getId()&gt;100) return true; return false; &#125;&#125; 编写jsp页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;form&gt; &lt;p&gt;ID：&lt;input id=\"accountId\"&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;input id=\"accountNo\"&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input id=\"accountPassword\"&gt;&lt;/p&gt; &lt;p&gt;金额：&lt;input id=\"accountMoney\"&gt;&lt;/p&gt; &lt;button id=\"findBtn\" type=\"button\"&gt;查询&lt;/button&gt; &lt;button id=\"addBtn\" type=\"button\"&gt;添加&lt;/button&gt; &lt;button id=\"updateBtn\" type=\"button\"&gt;更新&lt;/button&gt; &lt;button id=\"delBtn\" type=\"button\"&gt;删除&lt;/button&gt;&lt;/form&gt;&lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(\"#findBtn\").on(\"click\", function()&#123; findAccount();&#125;);$(\"#addBtn\").on(\"click\", function()&#123; addAccount();&#125;);$(\"#updateBtn\").on(\"click\", function()&#123; updateAccount();&#125;);$(\"#delBtn\").on(\"click\", function()&#123; delAccount();&#125;);function getDatas()&#123; var accountId = $(\"#accountId\").val(); var accountNo = $(\"#accountNo\").val(); var accountPassword = $(\"#accountPassword\").val(); var accountMoney = $(\"#accountMoney\").val(); return &#123; id: accountId, acc_no: accountNo, acc_password: accountPassword, acc_money: accountMoney &#125;;&#125;function findAccount()&#123; var datas = getDatas(); $.ajax(&#123; url: \"account/\" + datas.id, type: \"get\", success: function(res)&#123; $(\"#accountNo\").val(res.acc_no); $(\"#accountPassword\").val(res.acc_password); $(\"#accountMoney\").val(res.acc_money); &#125;, &#125;);&#125;function addAccount()&#123; var datas = getDatas(); $.ajax(&#123; url: \"account/\" + datas.id, type: \"post\", data: datas, success: function(res)&#123; alert(res); &#125;, &#125;);&#125;function delAccount()&#123; var datas = getDatas(); $.ajax(&#123; url: \"account/\" + datas.id, type: \"delete\", success: function(res)&#123; alert(res); &#125;, &#125;);&#125;function updateAccount()&#123; var datas = getDatas(); $.ajax(&#123; url:\"account/\"+ datas.id, type:\"put\", data:JSON.stringify(datas), contentType:\"application/json\",//以json字符串提交数据 success: function(res)&#123; alert(res); &#125;, &#125;);&#125;&lt;/script&gt; 注意： PUT需要以json字符串提交数据contentType:&quot;application/json&quot; @RequestBody将接收的ajax请求的json字符串写入Account对象中 JSON.stringify()：将json对象转换为json字符串 JSON.parse()：将json字符串转换为json对象","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://chaooo.github.io/tags/Spring/"}]},{"title":"十七、Spring面向切面编程(AOP模块)","date":"2019-08-27T14:48:36.000Z","path":"2019/08/27/17-Spring面向切面编程AOP.html","text":"AOP（Aspect Oriented Programming）：面向切面编程，它是面向对象基础上发展来的技术，是面向对象更高层次的应用，它可以在不修改原有代码的情况给组件增强功能。 AOP涉及到的概念 编写AOP程序步骤 切点表达式 通知的五种类型 标注形式AOP步骤 AOP 通知对应的标注 @Around具体用法 异常通知 1. AOP涉及到的概念 Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。 JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息） Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点 Target：目标，要被切入共通业务逻辑的对象 Proxy：代理，被增强之后的目标对象就是代理 Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常 2. 编写AOP程序步骤 编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法 在不修改登录和注册原有代码的情况下，让两个方法调用前输出****** 添加aop的jar包到lib 编写一个类，定义共同业务逻辑 配置aplicationContext.xml，创建切面对象 配置aop:config，切面–&gt;通知–&gt;切点 3. 切点表达式 Bean限定表达式 bean(&quot;容器内组件id&quot;)，支持通配符，如：bean(&quot;*Dao&quot;)，`bean(“acc“)` 类型限定表达式 within(&quot;包名.类型&quot;)，要求表达式最后一部分必须是类型，如：com.dao.impl.类型，com.dao.impl.*，com.dao..* 方法限定表达式 execution(&quot;表达式&quot;)，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:返回值类型 方法名() 4. 通知的五种类型 &lt;aop:before：前置通知，目标方法执行之前调用 &lt;aop:after-returning：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行） &lt;aop:after-throwing：异常通知，目标方法出异常才调用 &lt;aop:after：最终通知，目标方法之后一定会执行 &lt;aop:around：环绕通知，目标方法执行前后都调用 5. 标注形式AOP步骤 建项目，添加jar包(ioc,aop)，src下添加配置文件 编写一个Sevice类，里面有登录和注册两个方法 开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑 定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象 开启标注形式aop：&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true|false&quot; /&gt; 使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： @Aspect，@Before... 6. AOP 通知对应的标注 @Before：前置通知，目标方法执行之前调用 @AfterReturning：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行） @AfterThrowing：异常通知，目标方法出异常才调用 @After：最终通知，目标方法之后一定会执行 @Around：环绕通知，目标方法执行前后都调用 7. @Around具体用法@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作； 12345678@Around(\"within(com..*)\")public Object showAfterDate(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"开始时间：\" + new Date().getTime()); Object obj = pjp.proceed(); System.out.println(\"结束时间：\" + new Date().getTime()); System.out.println(\"执行时间：\"date2.getTime() - date.getTime()); return obj;&#125; 虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。 8. 异常通知JoinPoint可以获取出异常的方法 1234@AfterThrowing(value=\"within(com..*)\", throwing=\"e\")public void processException(JoinPoint jp, Exception e) &#123; System.out.println(\"捕获到异常\" + jp.getSignature() + \":\\n【\" + e +\"】\");&#125;","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://chaooo.github.io/tags/Spring/"}]},{"title":"十六、Spring事务管理","date":"2019-08-27T14:47:30.000Z","path":"2019/08/27/16-Spring事务管理.html","text":"事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。 事务的特性(ACID) Spring提供事务管理的3个接口 TransactionDefinition接口 TransactionStatus接口 PlatformTransactionManager接口（事务管理器） 基于AspectJ的xml方式的声明式事务管理 基于注解的声明式事务管理 1. 事务的特性(ACID) 事务的特性：原子性、一致性、隔离性、持久性。 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）：事务前后数据的完整性必须保持一致。 隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。 持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。 2. Spring提供事务管理的3个接口： PlatformTransactionManager：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。 TransactionDefinition：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。 TransactionStatus：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。 Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。 3. TransactionDefinition接口TransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation) 如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。 事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。 3.1 安全问题 脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。 不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。 幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。 3.2 事务的隔离级别(Isolation)： READ_UNCOMMITED(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。 READ_COMMITED(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。 REPEATABLE_READ(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。 SERIALIZABLE(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。 DEFAULT(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用REPEATABLE_READ隔离级别，Oracle默认采用READ_COMMITTED隔离级别）。 3.3 事务的传播特性(Propagation)： 第一类：运行在同一个事务 REQUIRED：默认，支持当前事务，如果当前没有事务，就新建一个事务。 SUPPORTS：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行) MANDATORY：支持当前事务，如果当前没有事务，就抛出异常 第二类：运行在不同事务 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常 第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态 NESTED：如果当前事务存在，则嵌套事务执行 4. TransactionStatus接口平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。 5. PlatformTransactionManager接口（事务管理器）该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。 5.1 Spring支持两种方式事务管理： 编程式事务管理 手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用） 声明式事务管理 基于TransactionProxyFactoryBean的方式（很少使用） 基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用） 基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加@Transactional注解（经常使用） 6. 基于AspectJ的xml方式的声明式事务管理123456789101112131415161718192021222324&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"jdbc连接池对象id\"/&gt;&lt;/bean&gt;&lt;!-- 配置事务的通知（事务的增强） --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- propagation:事务传播行为 isolation:事务的隔离级别 read-only:只读 rollback-for:发生哪些异常回滚 no-rollback-for:发生哪些异常不回滚 timeout:过期信息 --&gt; &lt;tx:method name=\"transfer\" propagation=\"REQUIRED\" isolation=\"DEFAULT\" read-only=\"false\" rollback-for=\"\" timeout=\"\" no-rollback-for=\"\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切面 --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点 --&gt; &lt;aop:pointcut id=\"pointcut1\" expression=\"execution(*cn.muke.spring.demo3.AccountService+.*(.))\"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut1\"/&gt;&lt;/aop:config&gt; 7. 基于注解的声明式事务管理 配置事务管理器 1234567&lt;!-- 1.创建一个事务管理器对象 --&gt;&lt;bean id=\"事务管理器id\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"jdbc连接池对象id\"/&gt;&lt;/bean&gt;&lt;!-- 2.开启声明式事务 --&gt;&lt;tx:annotation-driven transaction-manager=\"事务管理器id\" proxy-target-class=\"true|false\" /&gt; transaction-manager：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource) proxy-target-class：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。 使用，在类上或者方法上标注@Transactional 123456@Transactional( rollbackFor=&#123;Exception.class&#125;, readOnly=false, isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED)public void transfer()&#123;..&#125; @Transactional的属性 rollbackFor：设置检查异常也回滚 noRollbackFor：指定运行时异常不回滚 readOnly： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。 isolation：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE) propagation：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER) Spring中事务管理器默认值针对运行时异常回滚，对检查异常不回滚。","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://chaooo.github.io/tags/Spring/"}]},{"title":"十五、SpringJDBC详解","date":"2019-08-27T14:46:07.000Z","path":"2019/08/27/15-SpringJDBC详解.html","text":"Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的声明式事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。 数据源配置 JdbcTemplate的使用 通过实现RowMapper接口把查询结果映射到Java对象 JdbcTemplate对象的主要方法 异常转换 1. 数据源配置1234567891011121314151617@Configuration@ComponentScan(\"com.jdbc\")public class MyConfiguration &#123; @Bean public DataSource mysqlDataSource() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"123456\"); return dataSource; &#125; @Bean public JdbcTemplate jdbcTemplate() &#123; return new JdbcTemplate(mysqlDataSource()); &#125;&#125; 也可以使用XML配置来实现配置效果： 12345678910111213&lt;!-- 配置连接池对象 --&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 定义jdbcTemplate对象 --&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"dataSource\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 开启组件扫描 --&gt;&lt;context:component-scan base-package=\"com.jdbc\"&gt;&lt;/context:component-scan&gt; 2. JdbcTemplate的使用JdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。JdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。 基本的查询： 1234567891011//DAO实现类@Repository(\"empDao\")public class EmpDaoImpl implements EmpDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int getCount() &#123; String sql = \"select count(*) from emp32\"; return jdbcTemplate.queryForObject(sql, Integer.class); &#125;//... 3. 通过实现RowMapper接口把查询结果映射到Java对象12345678910public class EmpRowMapper implements RowMapper&lt;Emp&gt; &#123; @Override public Emp mapRow(ResultSet rs, int n) throws SQLException &#123; return new Emp( rs.getInt(\"id\"), rs.getString(\"name\"), rs.getDouble(\"salary\") ); &#125;&#125; 1234567891011//DAO实现类@Repository(\"empDao\")public class EmpDaoImpl implements EmpDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Emp getEmpById(int id) &#123; String sql = \"select * from emp32 where id=?\"; return jdbcTemplate.queryForObject(sql, new EmpRowMapper(), id); &#125;//... 4. JdbcTemplate对象的主要方法 queryForInt()： 12345//查询一个整数类型int count = jdbcTemplateObject.queryForInt(\"select count(*) from emp32\");//一个使用绑定变量的简单查询int age = jdbcTemplateObject.queryForInt(\"select age from emp32 where id = ?\", new Object[]&#123;10&#125;); queryForLong()： 12//查询一个 long类型long count = jdbcTemplateObject.queryForLong(\"select count(*) from emp32\"); queryForObject()： 1234567891011//查询字符串String SQL = \"select name from emp32 where id = ?\";String name = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;10&#125;, String.class);//查询并返回一个对象：String SQL = \"select * from emp32 where id = ?\";emp32 student = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;10&#125;, new EmpRowMapper());//查询并返回多个对象：String SQL = \"select * from emp32\";List&lt;emp32&gt; students = jdbcTemplateObject.query(SQL, new EmpRowMapper()); update()： 1234567891011//在表中插入一行：String SQL = \"insert into emp32 (name, age) values (?, ?)\";jdbcTemplateObject.update( SQL, new Object[]&#123;\"Zara\", 11&#125; );//更新表中的一行：String SQL = \"update emp32 set name = ? where id = ?\";jdbcTemplateObject.update( SQL, new Object[]&#123;\"Zara\", 10&#125; );//从表中删除一行：String SQL = \"delete emp32 where id = ?\";jdbcTemplateObject.update( SQL, new Object[]&#123;20&#125; ); execute()：执行DDL语句 12345678String SQL = \"CREATE TABLE emp32( id INT AUTO_INCREMENT, NAME VARCHAR(30), salary DOUBLE DEFAULT 5000, CONSTRAINT student_id_pk PRIMARY KEY(id), CONSTRAINT student_name_uk UNIQUE(NAME))\";jdbcTemplateObject.execute( SQL ); 5. 异常转换 Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。 所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。 这样可以使异常处理机制独立于当前使用的具体数据库。 除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。 例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息： 12345678910public class CustomSQLErrorCodeTranslator extends SQLErrorCodeSQLExceptionTranslator &#123; @Override protected DataAccessException customTranslate (String task, String sql, SQLException sqlException) &#123; if (sqlException.getErrorCode() == -104) &#123; return new DuplicateKeyException(\"完整性约束冲突\", sqlException); &#125; return null; &#125;&#125;","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://chaooo.github.io/tags/Spring/"}]},{"title":"十四、Spring IoC注解实现","date":"2019-08-27T14:44:07.000Z","path":"2019/08/27/14-SpringIoC注解实现.html","text":"回顾xml方式管理Java Bean 注解方式管理Java Bean 注解方式Bean的注入 注解方式Bean的常用配置项(作用域,生命周期,懒加载等) 1. 回顾xml方式管理Java Bean 将一个Bean交由Spring创建并管理 &lt;baen id=&quot;bean&quot; class=&quot;包名.Bean&quot;&gt;&lt;/baen&gt; 获取Spring上下文 ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 获取Bean Bean bean = app.getBean(&quot;bean&quot;, Bean.class); 2. 注解方式管理Java Bean一、创建一个class配置文件 12345678@Configurationpublic class MyConfiguration&#123; //将一个Bean交由Spring创建并管理 @Bean(name=\"bean1\") public Bean bean()&#123; return Bean = new Bean(); &#125;&#125; 二、获取Spring上下文 12ApplicationContext context = new AnnotationConfigApplicationContext(MyConfiguration.class); 三、获取Bean 1Bean1 bean1 = context.getBean(\"bean1\", Bean1.class); 2.1 简化注解方式的步骤1一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法） 123@Configuration //该注解可理解当前class等同于一个xml文件@ComponentScan(\"包路径\") //开启组件扫描public class MyConfiguration&#123;&#125; 在applicationContext.xml中开启组件扫描方式&lt;context:component-scan base-package=&quot;包路径&quot;/&gt;。 二、 将交由Spring管理的类加上@Component注解，或（@Repository，@Controller，@Service） 1234@Component(\"bean1\")//通过构造方法实例化Bean1public class Bean1&#123; //...&#125; @Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 @Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 @Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 @Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 2.2 Bean别名一、 xml形式：通过name属性或alias标签 12&lt;bean id=\"bean1\" name=\"bean2,bean3\" class=\"com...Bean\"/&gt;&lt;alias name=\"bean1\" alias=\"bean4\"/&gt; 二、 注解形式 1234567@Configurationpublic class MyConfiguration&#123; @Bean(name=&#123;\"bean1\",\"bean2\",\"bean3\"&#125;) public Bean1 bean1()&#123; return Bean1 = new Bean1(); &#125;&#125; 注意：@Component只能指定一个名字，@Component默认值为类名首字母小写，也可以自定义，如:@Component(&quot;bean1&quot;)； 默认@scope为singleton单例，也可以进行指定 3. 注解方式Bean的注入一、 @Value(&quot;值&quot;)：常用于基本数据类型值注入，值可用EL表达式。 123456@Componentpublic class Player&#123; @Value(\"张三\") private String name; //...&#125; 二、 @Autowired：常用于复杂类型值的注入 + @Autowired：可以用在成员变量，setter方法，构造方法上；优先按照类型进行匹配，匹配不上启用名字进行匹配。 + @Qualifier(&quot;名字&quot;) 根据名字匹配，配合@Autowired，不能用在构造方法上；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，@Autowired(required=false):尽量去找，组件不存在也不报错。 + @Autowired的原理：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性 1234567891011121314151617181920212223@Componentpublic class Player&#123; @Value(\"张三\") private String name; /** 用于成员变量 */ //@Autowired //@Qualifier(\"card1\") private Card card; /** 用于构造方法 */ //@Autowired public Player(Card card) &#123; super(); this.card = card; &#125; /** 用于setter方法 */ @Autowired(required=false) public void setCard(Card card) &#123; this.card = card; &#125;&#125; 三、 @Resource：常用于复杂类型值的注入 + @Resource：用在成员变量和setter方法上，是JDK1.6支持的注解，优先按照名字匹配，可以通过@Resource(name=&quot;名&quot;)指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。 123456@Componentpublic class Player&#123; @Resource(name=\"card\") private Card card; //...&#125; 集合类型值注入实例 123456789101112131415161718@Configuration@ComponentScan(\"包路径\")public class MyConfiguration&#123; @Bean public List&lt;String&gt; list()&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); return list; &#125;&#125;@Componentpublic class Player&#123; @Autowired private List&lt;String&gt; list; //...&#125; 4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)4.1 注解方式Bean的作用域12345678910111213@Configuration@ComponentScan(\"包路径\")public class MyConfiguration&#123; @Bean(name=\"bean1\") @Scope(\"singleton\") public Bean1 bean1()&#123; return Bean1 = new Bean1(); &#125;&#125;@Component@Scope(\"singleton\")public class Bean&#123;&#125; 4.2 注解方式Bean的懒加载1234567891011121314@Configuration@ComponentScan(\"包路径\")@Lazy //相当于xml中default-lazy-init=\"true\"public class MyConfiguration&#123; @Bean(name=\"bean1\") @Lazy public Bean1 bean1()&#123; return Bean1 = new Bean1(); &#125;&#125;@Component@Lazypublic class Bean&#123;&#125; 4.3 Bean初始化和销毁一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。 12345678910111213public class Bean implements InitializingBean&#123; @Override public void afterPropertiesSet()&#123; //执行一些初始化后的工作 &#125;&#125;public class Bean implements DisposableBean&#123; @Override public void destroy()&#123; //执行一些销毁前的工作 &#125;&#125; 二、xml形式 12345678public class Bean&#123; public void init()&#123; //执行一些初始化后的工作 &#125; public void cleanup()&#123; //执行一些销毁前的工作 &#125;&#125; 123&lt;bean id=\"bean\" class=\"example.Bean\" init-method=\"init\" destroy-method=\"cleanup\"&gt;&lt;/bean&gt; 三、注解形式1，@Bean(initMethod=”init”, destroyMethod=”cleanup”) 12345678910111213141516public class Bean&#123; public void init()&#123; //执行一些初始化后的工作 &#125; public void cleanup()&#123; //执行一些销毁前的工作 &#125;&#125;@Configurationpublic class MyConfiguration&#123; @Bean(initMethod=\"init\", destroyMethod=\"cleanup\") public Bean bean()&#123; return new Bean(); &#125;&#125; 四、注解形式2，添加@PostConstruct，@PreDestroy 1234567891011@Componentpublic class Bean&#123; @PostConstruct public void init()&#123; //执行一些初始化后的工作 &#125; @PreDestroy public void cleanup()&#123; //执行一些销毁前的工作 &#125;&#125;","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://chaooo.github.io/tags/Spring/"}]},{"title":"十三、Spring基础和IoC控制反转","date":"2019-08-27T14:38:23.000Z","path":"2019/08/27/13-Spring基础和IoC控制反转.html","text":"Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。 IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础 DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装 WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持 AOP：是在面向对象的基础上发展来的更高级的技术 ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库 JEE：Java的消息服务，远程调用，邮件服务等 IoC（控制反转） Spring容器初始化 spring容器创建对象(实例化) Spring DI注入的实现 DI的参数的注入 Bean的常用配置项(作用域,生命周期,懒加载等) 1. IoC（控制反转）IoC：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。 控制：控制对象的创建及销毁（生命周期） 反转：将对象的控制权交给IoC容器 DI：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。 简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入 IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。 2. Spring容器初始化任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext BeanFactory提供配置结构和基本功能，加载并初始化Bean ApplicationContext保存了Bean对象并在Spring中被广泛使用 2.1 初始化ApplicationContext的几种方式： 本地文件 12FileSystemXmlApplicationContext app = new FileSystemXmlApplicationContext(\"F:/workspace/appcontext.xml\"); Classpath 12ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(\"classath:applicationContext.xml\"); Web应用中依赖Servlet或Listener 123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 2.2 Spring容器完成IOC的步骤 建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下 在spring容器配置文件中配置文件中配置一个对象的创建 &lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt; 写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件 applicationContext.getBean(&quot;对象引用名&quot;, 类名.class) 3. spring容器创建对象(实例化)3.1 构造器方式实例化 配置文件：&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt; applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)默认调用类型对应的无参构造方法1&lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 12ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");Date date = app.getBean(\"date\", Date.class); 3.2 静态工厂方法实例化 使用一个类型对应的静态方法来获取这个类型的对象 &lt;bean id=&quot;对象引用名&quot; class=&quot;包名.工厂类名&quot; factory-method=&quot;静态方法名&quot;&gt;&lt;/bean&gt;1&lt;bean id=\"cal\" class=\"java.util.Calendar\" factory-method=\"getInstance\"&gt;&lt;/bean&gt; 12ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");Calendar cal = app.getBean(\"cal\", Calendar.class); 3.3 实例工厂方法实例化 使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象 &lt;bean id=&quot;对象的引用名&quot; factory-bean=&quot;工厂方法的id&quot; factory-method=&quot;成员方法名&quot;&gt;&lt;/bean&gt;12&lt;bean id=\"cal\" class=\"java.util.Calendar\" factory-method=\"getInstance\"&gt;&lt;/bean&gt;&lt;bean id=\"time\" factory-bean=\"cal\" factory-method=\"getTime\"&gt;&lt;/bean&gt; 12ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");Date time = app.getBean(\"time\", Date.class); 4. Spring DI注入的实现Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。Bean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。DI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配) 实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。 4.1 设值注入property(属性)的name参考对象set方法 123456789&lt;bean id=\"card\" class=\"bean.Card\"&gt; &lt;property name=\"suit\" value=\"黑桃\"&gt;&lt;/property&gt; &lt;property name=\"point\" value=\"A\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- Player参考其setCard方法 --&gt;&lt;bean id=\"player\" class=\"bean.Player\"&gt; &lt;property name=\"name\" value=\"玩家1\"&gt;&lt;/property&gt; &lt;property name=\"card\" ref=\"card\"&gt;&lt;/property&gt;&lt;/bean&gt; 4.2 构造注入（Constructor arguments）构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始） 123456789&lt;bean id=\"card2\" class=\"bean.Card\"&gt; &lt;constructor-arg name=\"suit\" value=\"红桃\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"point\" value=\"K\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- Player参考其构造方法Player(name,card) --&gt;&lt;bean id=\"player2\" class=\"bean.Player\"&gt; &lt;constructor-arg name=\"name\" value=\"玩家2\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"card\" ref=\"card2\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 4.3 自动化注入（Autowiring mode）一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire=”byName/byType/constructor”)指定对应的自动化的注入方式 1&lt;bean id=\"bean1\" class=\"example.exampleBean\" autowire=\"\" /&gt; 自动装配autowire属性 有五种自动装配的方式： No：默认，需要通过ref属性来连接bean。 byName： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。 1234567&lt;bean id=\"card3\" class=\"bean.Card\"&gt; &lt;property name=\"suit\" value=\"方片\"&gt;&lt;/property&gt; &lt;property name=\"point\" value=\"J\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应) 否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)--&gt;&lt;bean id=\"player3\" class=\"bean.Player\" autowire=\"byName\"&gt;&lt;/bean&gt; byType：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。 123456&lt;bean class=\"bean.Card\"&gt; &lt;property name=\"suit\" value=\"方片\"&gt;&lt;/property&gt; &lt;property name=\"point\" value=\"J\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) --&gt;&lt;bean id=\"player4\" class=\"bean.Player\" autowire=\"byType\"&gt;&lt;/bean&gt; constructor：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。 123456&lt;bean id=\"card5\" class=\"bean.Card\"&gt; &lt;property name=\"suit\" value=\"方片\"&gt;&lt;/property&gt; &lt;property name=\"point\" value=\"J\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 --&gt;&lt;bean id=\"player5\" class=\"bean.Player\" autowire=\"constructor\"&gt;&lt;/bean&gt; autodetect：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。 5. DI的参数的注入Bean对象 注入类型 可以是 字符串、集合、bean对象。 5.1 注入字符串12345&lt;bean id=\"msg\" class=\"com.xdl.bean.OracleDataSource\"&gt; &lt;property name=\"username\" value=\"scott\"/&gt; &lt;property name=\"password\"&gt;&lt;value&gt;tiger&lt;/value&gt;&lt;/property&gt; &lt;property name=\"msg\"&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt; 5.2 注入集合12345678910111213141516171819202122232425262728&lt;!-- 1. 定义list集合 --&gt;&lt;property name=\"friends\"&gt; &lt;list&gt; &lt;value&gt;值1&lt;/value&gt; &lt;value&gt;值2&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- 2. 定义set集合 --&gt;&lt;property name=\"friends2\"&gt; &lt;set&gt; &lt;value&gt;值1&lt;/value&gt; &lt;value&gt;值2&lt;/value&gt; &lt;/set&gt;&lt;/property&gt;&lt;!-- 3. 定义map集合 --&gt;&lt;property name=\"phones\"&gt; &lt;map&gt; &lt;entry key=\"1594546454\" value=\"值1\"&gt;&lt;/entry&gt; &lt;entry key=\"1594546464\" value=\"值2\"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;!-- 4. props集合 --&gt;&lt;property name=\"phones2\"&gt; &lt;props&gt; &lt;prop key=\"164545564\"&gt;值1&lt;/prop&gt; &lt;prop key=\"164546756\"&gt;值2&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 5.3 集合参数的单独定义注入集合–引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。 123456789101112131415161718192021222324&lt;!-- 1. 定义list集合 --&gt;&lt;util:list id=\"ref_friends\"&gt; &lt;value&gt;值1&lt;/value&gt; &lt;value&gt;值2&lt;/value&gt;&lt;/util:list&gt;&lt;!-- 2. 定义set集合 --&gt;&lt;util:set id=\"ref_buddys\"&gt; &lt;value&gt;值&lt;/value&gt; &lt;value&gt;值2&lt;/value&gt;&lt;/util:set&gt;&lt;!-- 3. 定义map集合 --&gt;&lt;util:map id=\"ref_phones\"&gt; &lt;entry key=\"159454644\" value=\"值1\"&gt;&lt;/entry&gt; &lt;entry key=\"1594546454\" value=\"值2\"&gt;&lt;/entry&gt;&lt;/util:map&gt;&lt;!-- 4. props集合 --&gt;&lt;util:properties id=\"ref_phonePro\"&gt; &lt;prop key=\"164545564\"&gt;值1&lt;/prop&gt; &lt;prop key=\"16454675665564\"&gt;值2&lt;/prop&gt;&lt;/util:properties&gt;&lt;util:properties id=\"ref_db\" location=\"classpath:db.properties\"&gt;&lt;/util:properties&gt;&lt;!-- 使用 --&gt;&lt;property name=\"phones\" ref=\"ref_phones\"&gt;&lt;/property&gt;&lt;property name=\"phones2\" ref=\"ref_phonePro\"&gt;&lt;/property&gt; 5.3 Spring的’EL’表达式它和EL在语法上很 相似，可以读取一个bean对象/集合中的数据。Spring EL 采用 #{Sp Expression Language} 即 #{spring表达式}，可在xml配置和注解中使用。 Spring EL配置连接池对象12345678&lt;!-- 引入数据库配置文件 --&gt;&lt;util:properties id=\"db\" location=\"classpath:db.properties\"/&gt;&lt;!-- 配置连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.xdl.bean.OracleDataSource\"&gt; &lt;property name=\"username\" value=\"#&#123;db.name&#125;\"/&gt; &lt;property name=\"password\" value=\"#&#123;db.password&#125;\"/&gt; &lt;property name=\"url\" value=\"#&#123;db.url&#125;\"/&gt;&lt;/bean&gt; 6. Bean的常用配置项(作用域,生命周期,懒加载等)Bean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization/destruction method 6.1 Bean作用域（Scope） Singleton作用域 单例，指一个Bean容器只存在一份 prototype作用域 每次请求(使用)创建新的实例，destroy方式不生效 Web环境作用域： request作用域：每个request请求都会创建一个单独的实例。 session作用域：每个session都会创建一个单独的实例。 application作用域：每个servletContext都会创建一个单独的实例。 websocket作用域：每个websocket连接都会创建一个单独的实例。 自定义作用域 SimpleThreadScope作用域：每个线程都会创建一个单独的实例。 6.2 Bean的生命周期（Initialization/destruction method）Bean的生命周期：定义 –&gt; 初始化 –&gt; 使用 –&gt; 销毁 6.2.1 Bean初始化如果需要在Bean实例化之后执行一些逻辑，有两种方法： 实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。 配置init-method 配置beans的default-init-method属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。 配置bean的init-method来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。1&lt;bean id=\"exampleId\" class=\"example.exampleBean\" init-method=\"init\"&gt;&lt;/bean&gt; 12345public class ExampleBean&#123; public void init()&#123; //执行一些初始化后的工作 &#125;&#125; 6.2.2 Bean销毁如果需要在Bean销毁之前执行一些逻辑，有两种方法： 实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。 配置destroy-method 配置beans的default-destroy-method属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。 配置bean的destroy-method来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。1&lt;bean id=\"exampleId\" class=\"example.exampleBean\" destroy-method=\"cleanup\"&gt;&lt;/bean&gt; 12345public class ExampleBean&#123; public void cleanup()&#123; //执行一些销毁前的工作 &#125;&#125; 注意：销毁方法只针对单例模式的对象 6.3 Bean的懒加载（Lazy-initialization mode）Spring容器会在创建容器时提前初始化Singleton作用域的bean，可以通过bean标记lazy-init=&quot;true&quot;延迟实例化(对象被使用时才创建)。 配置lazy-init 配置beans的default-lazy-init=&quot;true&quot;为所有Bean设定懒加载。 配置bean的lazy-init=&quot;true&quot;为单独的某个Bean设定懒加载。1&lt;bean id=\"bean1\" class=\"example.exampleBean\" lazy-init=\"true\"/&gt; 适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载 优点：尽可能的节约了资源 缺点：可能导致某个操作响应时间增加 6.4 Bean装配的Aware接口实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。 ApplicationContextAware 接口方法：setApplicationContext 作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用 实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。 BeanNameAware 接口方法：setBeanName 作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用 实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。 6.4 Bean装配之ResourceResources（针对于资源文件的统一接口） UrlResource：URL 对应的资源，根据一个 URL 地址即可获取 ClassPathResource：获取类路径下的资源 FileSystemResource：获取文件系统里面的资源 ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源 InputStreamResource：获取输入流封装的资源 ByteArrayResource：获取字节数组封装的资源 ResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。 getResource()参数： classPath方式：”classPath:class路径下文件” file方式： “file:本地磁盘文件绝对地址” url方式： “url:URL地址下文件” 没有前缀时依赖applicationContext的配置文件路径: “文件全名” eg:applicationContext.getResource(&quot;classpath:config.txt&quot;)","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"},{"name":"Spring","slug":"Spring","permalink":"http://chaooo.github.io/tags/Spring/"}]},{"title":"数据库系统基础","date":"2019-07-22T12:20:19.000Z","path":"2019/07/22/01-数据库系统基础.html","text":"1. 概述 数据库 是 电子化信息的集合 将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。 表(Table)：以按行按列形式组织及展现的数据 数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系 数据库系统的构成（概念层次）: 数据库(DB):Database：相互之间有关联关系的数据的集合 数据库管理系统(DBMS):Database Management System 数据库应用(DBAP):Database Application 数据库管理员(DBA):Database Asministrator 计算机基本系统 2. 数据库管理系统(DBMS)2.1 从用户角度看DBMS(数据库管理系统) 数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等 DBMS提供了一套数据定义语言(DDL: Data Definition Language)给用户 用户使用DDL描述其所要建立的表的格式 DBMS依照用户的定义，创建数据库及其中的表 数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等 DBMS提供了一套数据库操纵语言(DML: Data Manipulation Language)给用户 用户使用DML描述其所要进行的增、删、改、查等操作 DBMS依照用户的操作描述，实际执行这些操作 数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以) DBMS提供了一套数据控制语言(DCL: Data Control Language)给用户 用户使用DCL描述其对数据库所要实施的控制 DBMS依照用户描述，实际ijnx控制 数据库维护：转储/恢复/重组/性能监测/分析… DBMS提供了一系列程序(实用程序/例行程序)给用户 在这些程序中提供了对数据库维护的各种功能 用户使用这些程序进行各种数据库维护操作 (数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的) 2.2 数据库语言 使用者使用数据库语言，利用DBMS操纵数据库 SQL语言：结构化的数据库语言 高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用 2.3 从系统实现角度看DBMS的功能 数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化 DBMS为完成DB管理，在后台运行着一系列程序… 语言编译器：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等 查询优化(执行引擎)与查询实现(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序 数据存取与索引：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等 通信控制：提供网络环境下数据库操作与数据传输的手段 事务管理：提供提高可靠性并避免并发操作错误的手段 故障恢复：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序 安全性控制：提供合法性检验，避免非授权非法用户访问数据库的手段 完整性控制：提供数据及数据操作正确性检查的手段 数据字典管理：管理用户已经定义的信息 应用程序接口(API)：提供应用程序使用DBMS特定功能的二首段 数据库数据装载、重组等实用程序 数据库性能分析：统计在运行过程中数据库的各种性能数据，便于优化运行 典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL 3. 数据库系统的标准结构3.1 DBMS管理数据的三个层次 External Level = User Level（外部级别 = 用户级别） 某一用户能够看到与处理的数据, 全局数据中的某一部分 Conceptual Level = Logic level（概念级别 = 逻辑级别） 从全局角度理解/管理的数据, 含相应的关联约束 Internal Level = Physical level（内部级别 = 物理级别） 存储在介质上的数据，含存储路径、存储方式 、索引方式等 3.2 三级模式两层映像3.2.1 数据(视图)与模式(数据的结构) 模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息 视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据 3.2.2 三级模式(三级视图) External Schema —-(External) View 某一用户能够看到与处理的数据的结构描述 (Conceptual) Schema —- Conceptual View 从全局角度理解/管理的数据的结构描述, 含相应的关联约束 体现在数据之间的内在本质联系 Internal Schema —- Internal View 存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等 3.2.3 两层映像 E-C Mapping：External Schema-Conceptual Schema Mapping 将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换 便于用户观察和使用 C-I Mapping：Conceptual Schema-Internal Schema Mapping 将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换 便于计算机进行存储和处理 3.3 标准结构的两个独立性 逻辑数据独立性 当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序 物理数据独立性 当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式 4. 数据模型 数据模型：模式 与 模式的结构 规定模式统一描述方式的模型，包括：数据结构、操作和约束 数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象 比如：关系模型：所有模式都可为抽象表(Table)的形式[数据结构]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[操作]和[约束] 三大经典数据模型 关系模型：表的形式组织数据 层次模型：树的形式组织数据 网状模型：图的形式组织数据 5. 关系模型 形象地说，一个关系(relation)就是一个Table，关系模型就是处理Table的，它由三个部分组成： 描述DB各种数据的基本结构形式(Table/Relation) 描述Table与Table之间所可能发生的各种操作(关系运算) 描述这些操作所应遵循的约束条件(完整性约束) 关系模型的三个要素： 基本结构：Relation/Table 基本操作：Relation Operator 基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。 扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算 完整性约束：实体完整性、参照完整性和用户自定义的完整性 表(Table)的基本构成要素 列/字段/属性/数据项：列名，列值 行/元组/记录 标题/模式 5.1 “表”的严格定义 域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型 笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组 关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation) 5.2 关系模式与关系 同一关系模式下，可有很多的关系 关系模式是关系的结构, 关系是关系模式在某一时刻的数据 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的 5.3 关系的特性 列是同质：即每一列中的分量来自同一域，是同一类型的数据 不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。 列位置互换性：区分哪一列是靠列名 行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字) 关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分 理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。 属性不可再分特性:又被称为关系第一范式 5.4 关系的一些重要概念 候选码(Candidate Key)/候选键 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。 主码(Primary Key)/主键 当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组 主属性与非主属性 包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性 最简单的，候选码只包含一个属性； 极端的，所有属性构成这个关系的候选码，称为全码(All-Key) 外码(Foreign Key)/外键 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。 两个关系通常是靠外码连接起来的。 6. 关系模型中的完整性6.1 实体完整性 关系的主码中的属性值不能为空值； 意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。 6.2 参照完整性 如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值 意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在 6.3 用户自定义完整性 用户针对具体的应用环境定义的完整性约束条件 6.4 DBMS对关系完整性的支持 实体完整性和参照完整性由DBMS系统自动支持 DBMS系统通常提供了如下机制： 它使用户可以自行定义有关的完整性约束条件 当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性 7. 关系代数7.1 关系代数的特点 基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作 以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。 关系代数操作以一个或多个关系为输入，结果是一个新的关系。 用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。 是一种抽象的语言，是学习其他数据库语言，如SQL等的基础 7.2 关系代数的约束某些关系代数操作，如并、差、交等，需满足”并相容性” 并相容性 参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性 定义：关系R与关系S存在相容性，当且仅当： (1) 关系R和关系S的属性数目必须相同； (2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同 示例：关系R：STUDENT(SID char(10), Sname char(8), Age char(3)) 示例：关系S：TEACHER(TID char(10), Tname char(8), Age char(3)) 7.3 关系代数的基本操作 集合操作 并（UNIO）：R∪S 交（INTERSECTION）：R∩S 差（DIFFERENCE）：R-S 笛卡儿积（Cartesian PRODUCT）：R×S 纯关系操作 投影（PROJECT）：∏ a(R) 选择（SELECT）：σ Con(R) 连接（JOIN）：R⋈S 除（DIVISION）：R÷S 7.3.1 并(Union) 操作 定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：R∪S, 它由 或者出现在关系R中，或者出现在S中的元组构成。 数学描述：R∪S = {t|t∈R ∨ t∈S}，其中t是元组 并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。 汉语中的“或者…或者…”通常意义是并运算的要求。 R ∪S 与 S∪R 运算的结果是同一个关系 7.3.2 差(Difference) 操作 定义：假设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：R-S, 它由出现在关系R中但不出现在关系S中的元组构成。 数学描述：R-S ={t|t∈R ∧ t(!∈)S } ，其中t是元组 汉语中的“是…但不含…”通常意义是差运算的要求。 R-S 与 S-R 是不同的 7.3.3 广义笛卡尔积(Cartesian Product) 操作 定义：关系R(&lt;a1,a2, …,an&gt;)与关系S(&lt;b1,b2, …,bm &gt;)的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：RxS, 它由关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。 数学描述：RxS = {&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S} RxS=SxR：RxS为R中的每一个元组都和S中的所有元组进行串接。SxR为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。 两个关系R和S，它们的属性个数分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系). 两个关系R和S，它们的元组个数分别为x和y(关系R的基数×,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y). 7.3.4 选择(Select) 定义：给定一个关系R, 同时给定一个选择的条件condition(简记con), 选择运算结果也是一个关系，记作σ con(R), 它从关系R中选择出满足给定条件condition的元组构成。 数学描述：con(R)={t|t(R)={t|t∈R ∧ con(t)=&#39;真&#39;}， 选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ 括弧()；θ；﹁；∧；∨ } 7.3.5 投影(Project) 定义：给定一个关系R, 投影运算结果也是一个关系，记作A(R), 它从关系R中选出属性包含在A中的列构成。 数学描述：∏ Ai1,Ai2,…,Aik (R) = {&lt;t[Ai1],t[Ai2],…,t[Aik]&gt; | t∈R} 投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系 7.4 关系代数的扩展操作7.4.1 交(Intersection) 定义：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：R∩S, 它由同时出现在关系R和关系S中的元组构成。 数学描述：R∩S = {t|t∈R ∧ t∈S}，其中t是元组 R∩S 和 S∩R 运算的结果是同一个关系 交运算可以通过差运算来实现：R∩S = R-(R-S) = S-(S-R) 汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求 7.4.2 θ-连接(θ-Join, theta-Join) 投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作 定义：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 R⋈[AθB]S：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。 数学描述：R⋈[AθB]S = σ t[A] θ s[B] (R×S) 在实际应用中，θ-连接操作经常与投影∏、选择σ操作一起使用 特别注意：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。 7.4.3 等值连接(Equi-Join) 定义：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作R⋈[A=B]S：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。 数学描述：R⋈[A=B]S = σ t[A] = s[B] (R×S) 当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例； 广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用θ-连接/等值连接运算可大幅度降低中间结果的保存量，提高速度。 7.4.4 自然连接(Natural-Join) 定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。 数学描述：R⋈S = σ t[B]=s[B](R×S) 自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列 7.5 关系代数的基本书写思路 选出将用到的关系/表 做”积”运算（可用连接运算替换） 做选择运算保留所需的行/元组 做投影运算保留所需的列/属性 基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可 如涉及多个表，则检查： 能否使用自然连接，将多个表连接起来(多数情况是这样的) 如不能，能否使用等值或不等值连接(-连接) 还不能，则使用广义笛卡尔积，注意相关条件的书写 连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作 7.6 关系代数之复杂扩展操作7.6.1 除(Division) 除法运算经常用于求解“查询… 全部的/所有的…”问题 前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。 定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。 数学描述：12R÷S = &#123;t|t∈∏[R-S](R) ∧ ▽u∈S(tu∈R) &#125; = ∏[R-S](R) - ∏[R-S]((∏[R-S](R)×S)-R) 7.6.2 外连接(Outer-Join) 定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。 外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接) 外连接的形式：左外连接、右外连接、全外连接 左外连接 = 自然连接(或连接) + 左侧表中失配的元组 右外连接 = 自然连接(或连接) + 右侧表中失配的元组 全外连接 = 自然连接(或连接) + 两侧表中失配的元组 左外连接(Left Outer Join)记为：⋊ 右外连接(Right Outer Join)记为：⋉ 全外连接(Full Outer Join)记为：× 8. 关系演算 关系演算是描述关系运算的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的 按照谓词变量的不同，可分为关系元组演算和关系域演算 关系元组演算是以元组变量作为谓词变量的基本对象 关系域演算是以域变量作为谓词变量的基本对象 8.1 关系元组演算 关系元组演算公式：{ t | P(t) } 表示：所有使谓词 P 为真的元组 t 的集合 t 是元组变量 t ∈ r 表示元组 t 在关系 r 中 t[A] 表示元组 t 的分量，即 t 在属性 A 上的值 P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式 关系元组演算公式的基本形式：{ t | P(t) } P(t)可以是如下三种形式之一的原子公式： t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student} s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;= s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ， P(t)可以由公式加运算符 ∧(与)、∨(或)、﹁(非)递归地构造 如果F是一个公式，则 ﹁F 也是公式 如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式 P(t)运算符优先次序(括弧；θ；E；▽；﹁；∧；∨)示例","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"数据库","slug":"数据库","permalink":"http://chaooo.github.io/tags/数据库/"}]},{"title":"十二、JavaWeb编程基础","date":"2019-07-20T12:59:40.000Z","path":"2019/07/20/12_JavaWeb编程基础.html","text":"JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。 http协议 Servlet get和post区别 上下文对象ServletContext 会话跟踪（状态管理） JSP 内置对象(隐含对象) taglib指令 JavaWeb三大组件 JSON在Java中的使用 AJAX 1. http协议超文本传输协议，是一种应用层的网络传输协议 http协议的特点： 简单，快速：支持多种不同的的数据提交方式，如get/post 数据传输灵活，支持任意类型数据的传输 无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。 无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。 http协议的组成部分： 请求：浏览器连接服务器的过程 响应：服务器回复浏览器的过程 http协议的请求： 请求头：描述客户端的信息 请求体：GET没有请求体，请求体用于存储POST请求发送的数据。 请求空行：请求头与请求体之间的一行空白 请求行：描述请求方式，服务器地址，协议版本等 http协议的响应： 响应头：描述服务器的信息 响应体：响应的内容，文本，json数据等。 响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。 2. Servletservlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。 2.1 Servlet编写步骤： 编写一个Java类，继承HttpServlet类 重新service方法 在service方法中，对用户请求进行响应。 123456789101112131415//注解：添加访问的网址@WebServlet(\"/hello\")public class MyServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override public void service(ServletRequest req, ServletResponse res) throws IOException &#123; //1.设置响应体的编码，以及内容类型 res.setContentType(\"text/html;charset=utf-8\"); //2.得到响应体输出的打印流 PrintWriter out = res.getWriter(); //3.打印文字 out.println(\"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;\"); &#125;&#125; 2.2 配置ervlet类的访问网址 web3.0版本之后使用注解的方式配置ervlet类的访问网址 web3.0版本之前配置Servlet访问网址的方式： 将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 配置Servlet类的别名，并给指定别名的Servlet添加映射网址。 123456789101112&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;&lt;servlet&gt; &lt;!-- Servlet类别名，用于后续添加映射网址 --&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;!-- Servlet类全名 --&gt; &lt;servlet-class&gt;day01_Servlet.demo1.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;!-- 给指定别名的Servlet添加映射网址 --&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.3 Servlet生命周期 实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用 创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。 销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。 tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法： init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。 service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。 destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。 2.4 get和post区别 GET请求： 没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&amp;连接键值对。 只能传输字符串类型参数 浏览器url地址最大长度4kb 数据传输时，参数在url中明文显示，不安全。 POST请求： 有请求体，是一个单独的数据包，用于存储请求中的多个参数 可传输任意类型的数据，进行文件上传必须POST请求 可以传递的数据大小，理论上没有上限 数据传输时在单独的数据包，较为安全。 2.5 接收请求中的参数 根据参数的名称，接收参数的单个值 String value = request.getParameter(String name); 根据参数的名称，接收一组参数的值 String[] values = request.getParameterValues(String name); 1234567891011121314protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=utf-8\"); //1.接收 String username = request.getParameter(\"username\"); String[] password = request.getParameterValues(\"password\"); //2.打印 System.out.println(\"username:\" + username); System.out.println(\"password:\" + password[0]); System.out.println(\"password2:\" + password[1]); //3.浏览器输出 response.getWriter().append(\"&lt;div&gt;很遗憾注册失败，点击&lt;a href=\\\"demo1.html\\\"&gt;重新注册&lt;/a&gt;&lt;/div&gt;\");&#125; 2.6 乱码处理2.6.1 乱码情况： 浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。 tomcat8版本之前(不包含tomcat8版本), GET请求乱码 任何版本, POST请求乱码 2.6.2 请求乱码处理： 适用于所有乱码问题：(Tomcat8之后get无乱码) 指定浏览器打开页面的编码&lt;meta charset=&quot;UTF-8&quot;&gt;; 将接收到的中文乱码重新编码： 12String name = request.getParameter(\"userName\");String userName = new String( name.getByte(\"ISO-8859-1\"),\"utf-8\"); 仅适用于POST请求： 指定浏览器打开页面的编码&lt;meta charset=&quot;UTF-8&quot;&gt;; Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）request.setCharacterEncoding(&quot;utf-8&quot;); 2.6.3 响应乱码的处理： 方式一：设置响应的内容类型, 以及编码格式:response.setContentType(&quot;text/html;charset=utf-8&quot;); 方式二：进设置编码格式, 不设置响应内容类型:response.setCharacterEncoding(&quot;UTF-8&quot;)(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码); 2.7 Servlet的创建时机 通过web.xml配置Servlet, 可以修改Servlet加载的时机。 可以给Servlet节点，添加&lt;load-on-startup&gt;节点来制定servlet启动顺序。 节点中的值为数字： -1：默认-1，表示当用户第一次请求时，创建对象 &gt;=0：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建 123456789101112&lt;servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;s1&lt;/servlet-name&gt; &lt;servlet-class&gt;demo.ServletDemo&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;s1&lt;/servlet-name&gt; &lt;url-pattern&gt;/s1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 3. 请求的转发与重定向3.1 请求对象request的常用操作 getMethod() : 得到请求的方式 getRequestURI() : 获取浏览器请求地址 getRemoteAddr() : 获取客户端ip地址 getRemoteHost() : 获取客户端名称 getServerName() : 获取服务器名称 getServerPort() : 获取服务器端口号 getQueryString() : 获取get请求参数字符串，其他请求返回null 3.1 请求的转发与重定向注意事项 请求转发与重定向操作，必须要有出口。 当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了 3.2 转发* 一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理 步骤： 获取请求转发器：RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;); 进行转发操作：rd.forward(request, response); 因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写: request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response); 特点： 转发过程中，多个web组件之间共享一个请求对象request与响应对象response 在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变 转发不能跨项目实现 比重定向效率更高 3.3 重定向* 一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址 格式：response.sendRedirect(&quot;重定向地址&quot;)； 原理：当客户端请求服务器时，发起重定向流程： 给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址. 当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址. 浏览器自动发起新的请求 , 跳转到新地址. 特点： 重定向会产生两个请求对象，多个请求对象中数据不互通 浏览器地址发生了改变 重定向可以跨域实现 比转发效率低 4. 上下文对象ServletContext 用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享 每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。 获取ServletContext对象：ServletContext context = getServletContext(); 常用方法 context.setAttributes(String key, Objexct value); //设置替换数据 context.getAttributes(String key); //获取数据 context.removeAttributes(String key); //删除数据 context.getRealPath(“/“); //获取项目运行时所在文件路径 5. 会话跟踪（状态管理） 存在两种实现： cookie: 将浏览器产生的状态存储在浏览器中 Session: 将浏览器产生的状态存储在服务器中 cookie技术原理： 服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器， 浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来 当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器 Session技术原理： 当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)， 该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器 浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。 5.1 Cookie 创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对 Cookie cookie = new Cookie(String key, String value); 注意：tomcat8.5版本之前，cookie无法出场中文 通过响应对象，将cookie添加到响应头,可添加多个 response.addCookie(Cookie cookie); 通过请求头得到cookie数组，没有则返回null Cookie[] cookies = request.getCookies(); 取键：cookie.getName(); 取值：cookie.getValue() Cookie的存储时长： cookie.setMaxAge(int 秒)； 正数：倒计时秒数 0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它 负数：默认-1，表示会话结束时自动删除（关闭浏览器） Cookie的存储路径问题 存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同 为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“/“); 5.2 Cookie的优缺点 缺点： Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。 数据存储在客户的计算机中，不安全，不建议存储安全敏感数据 保存数据量有限制，大约4kb左右 依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除 优点： 分散服务器的压力 5.3 Session 获取Session 格式1：request.getSession();//等价参数传true 格式2：request.getSession(boolean isNew); true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回 false，根据浏览器的SessionId查找一个session，若没有就返回null Session常用方法 session.setAttribute(String key, object value);//设置/替换值 session.getAttribute(String key);//获取值 session.invalidate();//销毁 设置session存活时长 默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。 可以通过修改配置文件，修改所有的session时长 修改conf/web.xml的&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt; 可以通过session对象，修改单个对象的session时长 void session.setMaxInactiveInterval(int seconds) 5.4 Session的优缺点 缺点： 数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源 优点： 数据存储在服务器中，安全 数据类型为Object，在Java中表示可以存储所有类型的数据 session存储的数据大小，理论上无限的。 5.5 Cookie和Session的使用 Cookie和Session不是互斥的，是相辅相成的 在项目开发时： 对安全敏感的数据，存储在session中 对安全不敏感的字符串数据，可以选择存储在Cookie中 对于大的数据，应该存在数据库和文件中 注意：cookie和session是为了管理状态而非存储数据。 6.JSP6.1 JSP语法基础 Java Server Pages：java动态网页技术 JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应 注意： JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet 执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html JSP语法结构 html代码 Java代码 Jsp特有的语法结构 Java代码声明区：指的是类的成员位置 123&lt;%! // Java代码声明区%&gt; Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来 123&lt;% // Java代码执行区%&gt; JSP输出表达式 用于快速的将Java中的数据，输出到网页中.. 语法格式：&lt;%=数据 %&gt;，编译后被转换成out.print(数据) JSP注释： html中可以用&lt;!-- --&gt; java中可以用//，/**/，/** */ jsp注释&lt;%-- --%&gt; html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略 6.2 JSP三大指令 page指令 include指令 taglib指令 指令使用格式：&lt;%@ 指令名称 属性1=值 属性2=值 属性n=值 %&gt;*语法上，JSP允许在单个页面出现多个相同的JSP指令 6.2.1 page指令 用于配置页面信息 12345678910111213&lt;%@ page language=\"java\"：语言 contentType=\"text/html;charset=utf-8\"：响应的内容类型，以及响应的编码格式 pageEncoding=\"UTF-8\"：文件存储的编码格式 extends=\"继承的父类\" buffer=\"数字/none\"：是否允许缓存，默认值8kb autoFlush=\"true/false\"：是否自动清除缓存，默认true session=\"true/false\"：是否提前准备session对象，默认true isThreadSafe=\"true/false\"：是否线程安全的 import=\"java.util.List\"：用于导包，多个包使用\",\"隔开 errorPage=\"网址\"：当页面发生BUG后，显示哪个页面 isErrorPage=\"true/false\"：当前页面是否是一个错误处理页面，如果结果为true，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息%&gt; 6.3 项目发生错误时，统一的处理方式 打开项目的web.xml 加入子节点&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt; 12345678&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt;&lt;/error-page&gt; include指令：用于将jsp或html引入到另一个jsp中 语法格式：&lt;%@ include file=&quot;地址&quot; %&gt; include动作：用于将jsp或html引入到另一个jsp中 语法格式：&lt;jsp:include page=&quot;地址&quot;&gt; include指令 与 include动作区别： include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp =&gt; 一个Servlet） include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp =&gt; 多个Servlet） 7.内置对象(隐含对象) 在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。 内置对象通常是我们会主动创建的对象 7.1 九大内置对象 request 对象类型：java.servlet.HttpServletRequest request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。 response 对象类型：javax.servlet.HttpServletResponse response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。 config 对象类型：javax.servlet.ServletConfig 在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。 out 对象类型：javax.servlet.jsp.JspWriter 在JSP开发过程中使用得最为频繁的对象 page 对象类型：java.lang.Object page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。 pageContext 对象类型：pageContext pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象 session 对象类型：java.servlet.http.HttpSession session是与请求有关的会话期，用来表示和存储当前页面的请求信息。 application 对象类型：javax.servlet.ServletContext 用于实现用户之间的数据共享（多使用于网络聊天系统）。 exception 对象类型：java.lang.Throwable 作用 exception内置对象是用来处理页面出现的异常错误。 7.2 JSP四大域对象 九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据 域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法： 存储数据：setAttribute(String key, Object value); 获取数据：Object value = getAttribute(String); 删除数据： removeAttribute(String key); 四大内置对象，分别指的是： pageContext: (作用域：1个页面) 页面上下文，存储在pageContext中的数据, 作用域是最小的, pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁. request: (作用域：一次请求，如果请求被转发，可能跨越多个页面) 请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁. session: (作用域：一次会话，一次会话可能包含多个请求) 会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。 application: (域范围：一次服务，应用从启动到关闭application一直都在) Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用. 7.3 EL表达式 用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。 格式：${表达式} EL表达式用于运算 在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是: 246 用于取出域对象中的数据 取出数据直接输出：${域对象中存储的键} 如果取出的数据不存在, 则不输出 (不可能显示null) 取出对象数据的属性值: 格式1： ${对象存储的键.属性名} 格式2： ${对象存储的键[“属性名”]} 格式3(动态取值)： ${对象存储的键[属性存储的键]} 取出集合中的数据 格式: ${集合存储时的key[下标]} 7.4 EL表达式取出数据的流程 四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据. 步骤: 先从pageContext中, 寻找数据是否存在. 如果pageContext中数据不存在, 则去request中寻找数据是否存在 如果request 中数据不存在, 则去session中寻找数据是否存在 如果session中数据不存在, 则去application中寻找数据是否存在 如果application中数据不存在,则不输出任何数据. 8. taglib指令用于在JSP文件中，引入标签库文件。 格式： &lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt; prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：&lt;标签库名称:标签名&gt; uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性 JSTL(JSP Standard Tag Library): JSP标准标签库 使用时，需要引入jar文件 if 标签，格式：&lt;库名称:if text=”${ booble }”&gt; forEach 标签，格式：&lt;库名称:forEach items=”${ List }” var=”item”&gt; 自定义标签库: 编写一个Java类, 继承SimpleTagSupport类. 重写父类的doTag方法. 在doTag方法中, 通过getJspContext方法, 的到JSP页面的上下文 通过上下文对象, 得到JSP中的out对象, 通过out对象, 向网页中输出内容 编写tld文件 , 描述标签库 以及 标签. 自定义标签库案例: 1234567891011121314public class MyTag1 extends SimpleTagSupport &#123; private static ArrayList&lt;String&gt; data = new ArrayList&lt;&gt;(); static &#123; data.add(\"流水在碰到底处时才会释放活力。——歌德\"); &#125; @Override public void doTag() throws JspException, IOException &#123; JspContext context = getJspContext(); JspWriter out = context.getOut(); Random r = new Random(); int index = r.nextInt(data.size()); out.println(\"&lt;span&gt;\"+data.get(index)+\"&lt;/span&gt;\"); &#125;&#125; 12345678910111213141516171819202122232425262728&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"version=\"2.0\"&gt; &lt;!-- 描述标签库 --&gt; &lt;!-- 是对于标签库的介绍 --&gt; &lt;description&gt;我们这个标签库, 是闲的慌 , 所以写的.&lt;/description&gt; &lt;!-- 描述标签库的名称 --&gt; &lt;display-name&gt;xdl&lt;/display-name&gt; &lt;!-- 标签库的版本 --&gt; &lt;tlib-version&gt;11.88&lt;/tlib-version&gt; &lt;!-- 建议的短命名称 --&gt; &lt;short-name&gt;xdl&lt;/short-name&gt; &lt;!-- 标签库的表示, 用于引入时匹配标签库 --&gt; &lt;uri&gt;http://shuidianshuisg.com&lt;/uri&gt; &lt;!-- 开始描述标签 --&gt; &lt;tag&gt; &lt;!-- 对于标签的介绍 --&gt; &lt;description&gt;这个标签用于随机向网页中, 输出一句名言&lt;/description&gt; &lt;!-- 标签名称 --&gt; &lt;name&gt;heiheihei&lt;/name&gt; &lt;!-- 标签所对应的的Java类 --&gt; &lt;tag-class&gt;cn.xdl.tag.MyTag1&lt;/tag-class&gt; &lt;!-- 标签的内容 --&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 9. JavaWeb三大组件(Servlet,filter,Lister)9.1 Filter过滤器 请求的过滤器，面向切面编程思想（AOP） 使用步骤： 编写一个类，实现Filter接口 通过注解或web.xml配置过滤器规则 过滤器链： 当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求 过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml） 注解方式：按照类名的自然顺序先后 web.xml配置方式：按照web.xml配置顺序，先后执行 案例： 123456789101112131415161718192021222324252627282930313233343536373839@WebFilter(\"/home.jsp\")public class AdminFilter implements Filter &#123; /** * 当Filter即将销毁时执行 */ @Override public void destroy() &#123; &#125; /** * 有新的请求, 满足了过滤器的过滤规则, 正在过滤 * 参数1. 请求对象 * 参数2. 响应对象 * 参数3. 过滤器链对象 */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"过滤管理员登录的过滤器 正在执行\"); //1. 从请求中, 得到session HttpServletRequest req = (HttpServletRequest) request; HttpSession session = req.getSession(); //2. 判断session中是否存在username Object username = session.getAttribute(\"username\"); //3. 如果存在, 且值为admin , 则放行 if(username !=null &amp;&amp; username.equals(\"admin\")) &#123; //放行 chain.doFilter(request, response); &#125;else &#123; //4. 否则拦截, 并响应, 提示请先以管理员身份登录 response.getWriter().append(\"&lt;script&gt;alert('请先以管理员身份登录, 再访问管理页面');window.location.href='login.jsp'&lt;/script&gt;\"); &#125; &#125; /** * 当Filter初始化时 执行 */ @Override public void init(FilterConfig arg0) throws ServletException &#123; &#125;&#125; web.xml配置方式 12345678&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;cn.xdl.demo1.EnCodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/home.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 9.2 Listener监听器 监听服务器的一些状态事件，事件驱动机制。 分为两类状态事件： 服务器中组件的生命周期 一些域对象中数据变化的事件 监听服务器的启动与关闭：ServletContextListener 监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener 监听Session会话的开启与关闭：HttpSessionListener 监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener 10. JSON在Java中的使用 JSON：JavaScript Object Notation GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象 1234//引入jar文件Gson g = new Gson();String str = g.toJson(Java对象);//转换JSON字符串类型 对象名 = g.fromJson(Json字符串, 类型.class);//转换为Java对象 11. AJAX 一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作 Ajax请求的状态（readyState） 0：正在初始化 1：请求正在发送 2：请求发送完毕 3：服务器开始响应 4：响应接收完毕，连接断开 Ajax响应的状态（status） 200：成功 404：找不到资源 500：服务器错误 11.1 GET请求AJAX12345678910var xhr = new XMLHttpRequest();xhr.open(\"GET\", \"地址?参数列表\");xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; //通过xhr.responseText接收响应体 &#125;else&#123; //失败处理 &#125;&#125;xhr.send(); 11.2 POST请求AJAX123456789101112var xhr = new XMLHttpRequest();xhr.open(\"POST\", \"地址\");xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; //通过xhr.responseText接收响应体 &#125;else&#123; //失败处理 &#125;&#125;//POST请求设置请求头xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(参数列表); //发送请求参数 11.2 Jquery中的AJAX $.ajax({url,[settings]}) 1234567891011$.ajax(&#123; url:\"请求的网址\", type:\"请求方式GET/POST...\", async:\"请求是否异步, 默认true\", data:\"请求的参数列表, 格式与GET请求?后的格式一致\", dataType:\"TEXT或JSON\",//服务器返回的数据类型 success:function(data)&#123;//当服务器响应状态码在200-299之间时, 这里执行 //参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object &#125;, error:function()&#123;&#125; //当服务器响应状态码不再200-299之间时, 这里执行&#125;); $.get(url, [data], [callback], [type]) 123$.get(\"请求的网址\", &#123; 请求参数键值对 &#125;,function(data)&#123; //data:响应的内容&#125;); $.post(url, [data], [callback], [type]) 123$.post(\"请求的网址\", &#123; 请求参数键值对 &#125;,function(data)&#123; //data:响应的内容&#125;, \"json\"); $.getJSON(url, [data], [callback]) 123$.getJSON(\"请求的网址\", &#123; 请求参数键值对 &#125;,function(data)&#123; //data:响应的内容&#125;); jquery对象.load(url, [data], [callback]) 载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。 123$(\"#dom\").load(\"请求的网址\", &#123; 请求参数键值对 &#125;,function()&#123; //加载成功&#125;); 11.3 Vue中的AJAX 使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js 不创建Vue对象的情况下, 使用的ajax: Vue.http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error); Vue.http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error); 创建Vue实例, 使用ajax this.$http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error); this.$http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error); 1234567891011121314//GET请求: 传递参数列表: &#123; params:&#123; 参数名1:值1, 参数名2:值2 ... &#125; &#125;POST请求: 传递参数列表:&#123; 参数名1:值1, 参数名2:值2 ...&#125; success函数 与 error函数 格式: function(res){} //res , 就是响应对象, 包含了响应的相关信息 响应对象的常用属性: url : 响应的网址 body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string ok : boolean值, 响应码在200-299之间时 为 true status : 响应码, 例如: 200,302,404,500 statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok 响应对象的常用函数: text() : 以字符串的形式, 返回响应体 json() : 以对象的形式, 返回响应体 blob() : 以二进制的形式 , 返回响应体. 11.4 AJAX缓存问题 浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。 缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。 在请求地址加上随机参数可以比避免缓存，如:&quot;s1.do?time=&quot;+new Date().getTime(); 11.5 AJAX跨域问题 默认编写的Servlet . 不允许其他网站的ajax跨域请求. 我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域: response.addHeader(&quot;Access-Control-allow-Origin&quot;,&quot;*&quot;); response.addHeader(&quot;Access-Control-allow-Methods&quot;,&quot;GET,POST&quot;);","tags":[{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"},{"name":"javaEE","slug":"javaEE","permalink":"http://chaooo.github.io/tags/javaEE/"}]},{"title":"十一、JavaSE数据结构与算法入门","date":"2019-07-15T10:12:38.000Z","path":"2019/07/15/11_JavaSE数据结构与算法入门.html","text":"数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。 Java数据结构 时间复杂度与空间复杂度 算法的基本概念 1.Java数据结构(Data Structure)1.1 数据结构 数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。 而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。 而一个数据结构的设计过程分成抽象层、数据结构层和实现层。 1.2 Java数据结构 数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。 线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。 非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。 按数据的存储结构分为：顺序存储结构和链式存储结构 顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。 1.2.1 线性数据结构常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。 一维数组 在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。 ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。 数组的插入/更新/删除效率比较低，而查询效率非常高,查询效率时间复杂度是1。 线性表 线性表是有序的储存结构、链式的储存结构。 链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。 常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。 线性表插入效率比较高，而查询效率就比较低（add(),get()）。 栈Stack 栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。 队列 队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。 Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。 使用场景也非常多，如线程池，mq，连接池等。 串 串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法） 1.2.2 非线性数据结构常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。 多维数组 Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。 集合 由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。 树 在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。 除了根节点，其他结点有且只有一个直接父节点 每个结点可以有任意多个直接子节点。 树的数据结构又分为： 自由树/普通树：对子节点没有任何约束。 二叉树：每个节点最多含有两个子节点的树称为二叉树。 二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树） B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。 B+tree：又称B+。是B-树的变体，也是一种多路搜索树。 Hash Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等） 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。 Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。 需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。 图 图状结构或网状结构：结构中的数据元素之间存在多对多的关系。 2. 时间复杂度与空间复杂度2.1 时间复杂度一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n) 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。 常见的算法的时间 复杂度之间的关系为：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn) 2.2 空间复杂度空间复杂度：算法所需存储空间的度量，记作：S(n)=O( f(n) )，其中 n 为问题的规模。 一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。 算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。 空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。 时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。 稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。 3.算法的基本概念 算法: 简单来说就是解决问题的步骤。 算法的五个特征:有穷性，确定性，可行性，有输入，有输出 有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。 算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求 描述算法的速度必须要和数据项的个数联系起来。 算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间； 一个算法的效率越高越好，而存储量是越低越好。 4. 常用的查找算法4.1 线性（顺序）查找算法 使用目标元素与样本数列中第一个元素起依次进行比较 若目标元素等于样本元素，则表示查找成功 若目标元素与样本元素比较完毕也不相等，则表示查找失败 4.2 二分查找算法二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。 普通循环实现二分查找算法 12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; int srcArray[] = &#123;3,5,11,17,21,23,28,30,32,50,64,78,81,95,101&#125;; System.out.println(binSearch(srcArray, 28));&#125;/** * 二分查找普通循环实现 * * @param srcArray 有序数组 * @param key 查找元素 * @return */public static int binSearch(int srcArray[], int key) &#123; int mid = srcArray.length / 2; if (key == srcArray[mid]) return mid; int start = 0; int end = srcArray.length - 1; while (start &lt;= end) &#123; mid = (end - start) / 2 + start; if (key &lt; srcArray[mid]) &#123; end = mid - 1; &#125; else if (key &gt; srcArray[mid]) &#123; start = mid + 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125; 二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。 递归实现二分查找递归实现算法 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; int srcArray[] = &#123;3,5,11,17,21,23,28,30,32,50,64,78,81,95,101&#125;; System.out.println(binSearch(srcArray, 0,15,28));&#125;/** * 二分查找递归实现 * * @param srcArray 有序数组 * @param start 数组低地址下标 * @param end 数组高地址下标 * @param key 查找元素 * @return 查找元素不存在返回-1 */public static int binSearch(int srcArray[], int start, int end, int key) &#123; int mid = (end - start) / 2 + start; if (srcArray[mid] == key) &#123; return mid; &#125; if (start &gt;= end) &#123; return -1; &#125; else if (key &gt; srcArray[mid]) &#123; return binSearch(srcArray, mid + 1, end, key); &#125; else if (key &lt; srcArray[mid]) &#123; return binSearch(srcArray, start, mid - 1, key); &#125; return -1;&#125; 递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。 4. 常用的排序算法 八大排序算法 一、直接插入排序（Insertion Sort） 二、希尔排序（Shell Sort） 三、选择排序（Selection Sort） 四、堆排序（Heap Sort） 五、冒泡排序（Bubble Sort） 六、快速排序（Quick Sort） 七、归并排序（Merging Sort） 八、基数排序（Radix Sort） 4.1 冒泡排序算法冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。 代码实现： 123456789101112131415public static void bubbleSort(int[] arr)&#123; for (int i=1; i&lt;arr.length; i++)&#123; boolean flag = true;//声明标志位 for(int j=0; j&lt;arr.length-i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j+1]; arr[j] = arr[j+1]; arr[j++1] = temp; flag = false; &#125; &#125; //若此轮结束flag还是为true,则证明已经有序 if(flag) break; &#125;&#125; 冒泡排序算法复杂度: 平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1) 冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1). Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"十、JavaSE常用设计模式","date":"2019-07-15T00:34:55.000Z","path":"2019/07/15/10_JavaSE常用设计模式.html","text":"设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 常用的设计原则 设计模式分类 单例模式 模板模式 工厂模式 适配器模式 1.常用的设计原则 开闭原则：对扩展开发，对修改方便 里氏代换原则：任何父类出现的的地方，子类一定可以出现（多使用继承和多态） 依赖倒转原则：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性 接口隔离原则：尽量多依赖小接口而不是大接口 迪米特法则（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。 合成复用原则：尽量多使用合成/聚合的方式，而不是继承的方式。 2.设计模式分类2.1 基本概念 设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。 设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。 设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性 2.2 具体分类 创建型模式：用于对象创建的过程 单例模式、工厂方法模式、抽象工厂模式、建造者模式(生成器模式)、原型模式 结构型模式：用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构 适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式) 行为型模式：用于解决类或对象之间的交互，更合理的优化类或对象之间的关系 责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、模板模式、访问者模式、备忘录模式、 JEE 设计模式 数据访问对象模式 3.单例模式（Singleton）3.1 实现流程： 私有的构造方法 私有的静态的当前类的对象作为属性 共有的静态方法返回当前对象3.1 实现方式： 饿汉式：立即加载，对象启动时就加载 懒汉式：延迟加载，对象什么时候用到时才会加载 生命周期托管：单例对象交给别人处理 4.模板模式在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。 eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 // 抽象类abstract class Software &#123; abstract void initialize(); abstract void start(); abstract void end(); public final void play()&#123; initialize(); start(); end(); &#125;&#125; // 不同子类以不同方法实现抽象类的的方法class Browser extends Software &#123; @Override void end() &#123; System.out.println(\"Browser Finished!\"); &#125; @Override void initialize() &#123; System.out.println(\"Browser Initialized!.\"); &#125; @Override void start() &#123; System.out.println(\"Browser Started.\"); &#125;&#125;class Editor extends Software &#123; @Override void end() &#123; System.out.println(\"Editor Finished!\"); &#125; @Override void initialize() &#123; System.out.println(\"Editor Initialized!\"); &#125; @Override void start() &#123; System.out.println(\"Editor Started!\"); &#125;&#125;// 使用public class Main &#123; public static void main(String[] args) &#123; Software s1 = new Browser(); s1.play(); s1 = new Editor(); s1.play(); &#125;&#125; 4.1 模式模式优缺点： 优点 模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。 缺点 每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。 适用场景 在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。 5. 工厂模式 简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象； 工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定； 抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。 5.1 简单工厂模式的实现：1234567891011121314151617181920212223242526 // 产品接口public interface Fruit &#123; void whatIm(); &#125; // 具体类public class Apple implements Fruit &#123; @Override public void whatIm() &#123; /*苹果*/&#125;&#125;public class Pear implements Fruit &#123; @Override public void whatIm() &#123; /* 梨 */ &#125;&#125; // 工厂public class FruitFactory &#123; public Fruit createFruit(String type) &#123; if (type.equals(\"apple\")) &#123;//生产苹果 return new Apple(); &#125; else if (type.equals(\"pear\")) &#123;//生产梨 return new Pear(); &#125; return null; &#125;&#125; // 使用FruitFactory mFactory = new FruitFactory();Apple apple = (Apple) mFactory.createFruit(\"apple\");//获得苹果Pear pear = (Pear) mFactory.createFruit(\"pear\");//获得梨 简单工厂只适合于产品对象较少，且产品固定的需求 5.2 工厂方法模式实现：12345678910111213141516171819202122 // 工厂接口public interface FruitFactory &#123; Fruit createFruit();//生产水果&#125; // 具体工厂public class AppleFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Apple(); &#125;&#125;public class PearFactory implements FruitFactory &#123; @Override public Fruit createFruit() &#123; return new Pear(); &#125;&#125; // 使用AppleFactory appleFactory = new AppleFactory();PearFactory pearFactory = new PearFactory();Apple apple = (Apple) appleFactory.createFruit();//获得苹果Pear pear = (Pear) pearFactory.createFruit();//获得梨 工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂 5.3 抽象工厂模式实现： 抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列； eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 // cpu接口和实现类public interface Cpu &#123; void run(); class Cpu650 implements Cpu &#123; @Override public void run() &#123;/* 625 也厉害 */ &#125; &#125; class Cpu825 implements Cpu &#123; @Override public void run() &#123; /* 825 处理更强劲 */ &#125; &#125;&#125; // 屏幕接口和实现类public interface Screen &#123; void size(); class Screen5 implements Screen &#123; @Override public void size() &#123;/* 5寸 */&#125; &#125; class Screen6 implements Screen &#123; @Override public void size() &#123; /* 6寸 */ &#125; &#125;&#125; // 工厂接口public interface PhoneFactory &#123; Cpu getCpu();//使用的cpu Screen getScreen();//使用的屏幕&#125; // 具体工厂实现类public class XiaoMiFactory implements PhoneFactory &#123; @Override public Cpu getCpu() &#123; return new Cpu.Cpu825();//高性能处理器 &#125; @Override public Screen getScreen() &#123; return new Screen.Screen6();//6寸大屏 &#125;&#125;public class HongMiFactory implements PhoneFactory &#123; @Override public Cpu getCpu() &#123; return new Cpu.Cpu650();//高效处理器 &#125; @Override public Screen getScreen() &#123; return new Screen.Screen5();//小屏手机 &#125;&#125; 对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展； 5.4 三种工厂方式总结： 对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式； 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产； 6.适配器模式（Adapter） 适配器模式Adapter是结构型模式的一种，分为类适配器模式，对象适配器模式，缺省适配器模式。 类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式； 对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。 适配器模式的缺点过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 6.1 缺省适配器模式 缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。 缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了) 适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"九、JavaSE网络编程","date":"2019-07-12T03:59:46.000Z","path":"2019/07/12/09_JavaSE网络编程.html","text":"网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。 网络编程常识 基于tcp协议的编程模型 基于udp协议的编程模型 1. 网络编程常识1.1 七层网络模型为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去； 当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来； 1.2 IP地址 IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。 日常生活中采用点分十进制表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1 1.3 端口号 根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。 网络编程需要提供：IP地址 和 端口号 端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。 1.4 tcp协议与udp协议 TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。 UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 tcp协议与udp协议比较： tcp协议 udp协议 传输控制协议，面向连接 用户数据报协议，非面向连接 通信过程全程保持连接 通信过程不需要全程连接 保证了数据传输的可靠性和有序性 不保证数据传输的可靠性和有序性 全双工的字节流的通信方式 全双工的数据报的通信方式 服务器的资源消耗多，压力大，效率低 服务器资源消耗少，压力小，效率高 2. 基于tcp协议的编程模型2.1 编程模型123456服务器端 客户端创建监听服务等待连接 &lt;----建立连接------ 连接服务器 进行通讯 &lt;----进行通讯-----&gt; 进行通讯关闭连接 关闭连接 服务器： 创建ServerSocket类型的对象并提供端口号； 等待客户端的连接请求，调用accept方法； 使用输入输出流进行通信； 关闭Socket； 客户端： 创建Socket类型的对象并提供服务器的通信地址和端口号； 使用输入输出流进行通信； 关闭Socket； 2.2 ServerSocket类和Socket类 java.net.ServerSocket类主要用于描述服务器套接字信息。 常用方法 ServerSocket(int port) 根据参数指定的端口号来构造对象 Socket accept() 监听并接收到此套接字的连接请求 void close() 用于关闭套接字 java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。 常用方法 Socket(String host, int port) 根据指定主机名和端口号来构造对象 InputStream getInputStream() 用于获取当前套接字的输入流 OutputStream getOutputStream() 用于获取当前套接字的输出流 void close() 用于关闭套接字 3.客户端与服务端通信演示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//服务端线程public class ServerThread extends Thread &#123; private Socket s; public ServerThread(Socket s) &#123; this.s = s; &#125; @Override public void run() &#123; try &#123; // 3.使用输入输出流进行通信 BufferedReader br = new BufferedReader( new InputStreamReader(s.getInputStream())); PrintStream ps = new PrintStream(s.getOutputStream()); while(true) &#123; // 实现服务器接收到字符串内容后打印出来 // 当客户端没有发送数据时，服务器会在这里阻塞 String str = br.readLine(); //System.out.println(\"服务器接收到的数据是：\" + str); // 当服务器接收到\"bye\"后，则聊天结束 if(\"bye\".equalsIgnoreCase(str)) &#123; System.out.println(\"客户端\" + s.getInetAddress() + \"已下线！\"); break; &#125; System.out.println(\"客户端\" + s.getInetAddress() + \"发来的消息是：\" + str); // 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\" ps.println(\"I received!\"); //System.out.println(\"服务器发送数据成功！\"); &#125; // 4.关闭Socket ps.close(); br.close(); s.close(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;//服务端测试public class ServerStringTest &#123; public static void main(String[] args) &#123; try &#123; // 1.创建ServerSocket类型的对象并提供端口号 ServerSocket ss = new ServerSocket(8888); // 2.等待客户端的连接请求，调用accept方法 while(true) &#123; System.out.println(\"等待客户端的连接请求...\"); // 当没有客户端连接时，阻塞在accept方法的调用这里 Socket s = ss.accept(); // 获取连接成功的客户端通信地址 System.out.println(\"客户端\" + s.getInetAddress() + \"连接成功！\"); // 当有客户端连接成功后，则启动一个新的线程为之服务 new ServerThread(s).start(); &#125; //ss.close(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;//客户端测试public class ClientStringTest &#123; public static void main(String[] args) &#123; try &#123; // 1.创建Socket类型的对象并提供服务器的通信地址和端口号 Socket s = new Socket(\"XDL-20170621QCO\", 8888); System.out.println(\"连接服务器成功！\"); // 2.使用输入输出流进行通信 Scanner sc = new Scanner(System.in); PrintStream ps = new PrintStream(s.getOutputStream()); BufferedReader br = new BufferedReader( new InputStreamReader(s.getInputStream())); while(true) &#123; // 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞 //Thread.sleep(10000); // 练习：实现客户端向服务器发送的内容由用户从键盘输入 System.out.println(\"请输入要发送的内容：\"); //String msg = sc.next(); // 读取字符串内容时，遇到空格停止 String msg = sc.nextLine(); // 实现客户端向服务器发送字符串内容\"hello\" //ps.println(\"hello\"); ps.println(msg); System.out.println(\"客户端发送数据成功！\"); // 判断客户端发送的内容是否为\"bye\"，若是则聊天结束 if(\"bye\".equalsIgnoreCase(msg)) &#123; System.out.println(\"聊天结束！\"); break; &#125; // 实现服务器回发消息的接收 // 当客户端没有发送数据时，服务器会在这里阻塞 String str = br.readLine(); System.out.println(\"客户端接收到的数据是：\" + str); &#125; // 3.关闭Socket br.close(); sc.close(); ps.close(); s.close(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4. 基于udp协议的编程模型4.1 编程模型 主机A(接收方): 创建DatagramSocket类型的对象，并提供端口号； 创建DatagramPacket类型的对象，用于接收发来的数据； 从Socket中接收数据，调用receive()方法； 关闭Socket并释放有关的资源； 主机B(发送方) 创建DatagramSocket类型的对象； 创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号； 通过Socket发送数据，调用send()方法； 关闭Socket并释放有关的资源； 4.2 DatagramSocket类 java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点); 常用方法 DatagramSocket() 无参的方式构造对象。 DatagramSocket(int port) 根据参数指定的端口号来构造对象。 void receive(DatagramPacket p) 用于接收数据并存放到参数指定的变量中。 void send(DatagramPacket p) 用于将参数指定的数据发送出去。 void close() 4.3 DatagramPacket类 java.net.DatagramPacket类用于描述数据报信息(信件)； 常用方法 DatagramPacket(byte[] buf, int length) 用于接收数据包并记录到参数变量中； DatagramPacket(byte[] buf, int length, InetAddress address, int port) 用于将参数指定的数据发送到参数指定的位置 InetAddress getAddress() 用于获取发送方或接收方的通信地址信息。 int getPort() 用于获取发送方或接收方的端口信息。 int getLength() 用于获取发送或接收数据的长度。 4.4 InetAddress类 java.net.InetAddress类用于描述互联网协议地址。 常用方法 static InetAddress getLocalHost() 用于获取本地主机的通信地址信息。 static InetAddress getByName(String host) 根据参数指定的主机名来获取通信地址。 String getHostName() 用于获取通信地址中的主机名信息。 String getHostAddress() 用于获取通信地址中的IP地址信息。","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"谈谈开源","date":"2019-07-11T12:13:15.000Z","path":"2019/07/11/谈谈开源.html","text":"什么是开源所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。 在IT领域来说的话，字面意思就是开放源代码，开源软件的源代码任何人都可以审查、修改和增强。 虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。 开源是否等于免费开源等于免费是对开源的最大误解。 商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于License（许可协议）。 商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。 开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的约束和保护。 目前使用最广泛的一种开源协议便是MIT License，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。 为什么要选择开源软件开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！ 对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步相互切磋与学习。 开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。 最后最后还要说一点：不要把开源软件与盗版混为一谈。 如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。 开源的观念并不只限于软件的开发与使用，而是希望能够抱着开放的心态，分享与合作的精神，相互切磋与学习，当你的代码被分享时它会变得更好。 参考连接： https://blog.csdn.net/happmaoo/article/details/83201544 https://www.oschina.net/news/58921/what-is-open-source","tags":[{"name":"开源","slug":"开源","permalink":"http://chaooo.github.io/tags/开源/"}]},{"title":"八、JavaSE反射机制","date":"2019-07-10T07:47:15.000Z","path":"2019/07/10/08_JavaSE反射机制.html","text":"反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。 基本概念 Class类 Constructor类 Field类 Method类 原始方式与反射方式构造对象实例 注解(Annotation) 1. 基本概念JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；类是用来描述一组对象，反射机制可以理解为是用来描述一组类 通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。 1.1 相关类及描述 Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成 Package：用来描述类所属的包 Field：用来描述类中的属性 Method：用来描述类中的方法 Constructor：用来描述类中的构造方法 Annotation：用来描述类中的注解 2. Class类java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成 2.1 获取Class类型对象的三种方式1234Class clazz = Class.forName(\"包名.类名\");//用的最多，但可能抛出ClassNotFoundException异常Class clazz = 类名.class;//任何类都有一个隐含的静态成员变量classClass clazz = 对象.getClass();//Object类中的方法Class clazz = 包装类.TYPE;//获取对应基本数据类型的class对象 2.2 常用方法 static Class&lt;?&gt; forName(String className) 用于获取参数指定对应的Class对象并返回 T newInstance() 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 用于获取此Class对象所表示类型中参数指定的公共构造方法。 Constructor&lt;?&gt;[] getConstructors() 用于获取此Class对象所表示类型中所有的公共构造方法 Field getDeclaredField(String name) 用于获取此Class对象所表示类中参数指定的单个成员变量信息 Field[] fs = getDeclaredFields() 用于获取此Class对象所表示类中所有成员变量信息 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法 Method[] getMethods() 用于获取该Class对象表示类中所有公共成员方法。 获取私有相关方法 getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有) getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有) getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有) getDeclaredMethods(); 获取全部的方法(自己类 公有 私有) 2.3 其他方法 int result = getModifiers(); 获取类的修饰符(权限+特征) 每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract String name = getName(); 获取类的全名(包名.类名) String name = getSimpleName(); 获取类简单名(只有类名 缺少包) Package p = getPackage(); 获取当前类所属的包 p.getName(); 获取包名(Package类中的方法) Class sclazz = getSuperClass(); 获取超类(父类)对应Class Class[] classes = getInterface(); 获取当前类父亲接口 Class[] classes = getClasses(); 获取类中的内部类 Object obj = newInstance(); 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException Field f = getField(“属性名”); 获取类中的属性(公有的 自己类+父类) Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类) getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类) Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类) 3. Constructor类java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息 3.1 Constructor类中的常用方法 T newInstance(Object… initargs) 使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。 3.2 其他方法 con.getModifiers(); con.getName(); con.getParameterTypes(); con.getExceptionTypes(); 如何操作构造方法 执行一次,创建对象 Object = newInstance(执行构造方法时的所有参数); con.setAccessible(true); 4. Field类java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。 4.1 Field类中的常用方法 Object get(Object obj) 调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。 Object set(Object obj, Object value) 将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。 void setAccessible(boolean flag) 当实参传递true时，则反射的对象在使用时应该取消java语言访问检查 4.2 其他方法 int = getModifiers(); 获取属性修饰符(权限+特征) Class = getType(); 获取属性的类型对应的那个class String = getName(); 获取属性的名字 操作属性: set(对象,值); Object = get(对象); 如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入 5. Method类java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。 5.1 Method类中的常用方法 Object invoke(Object obj, Object… args) 使用对象obj来调用此Method对象所表示的成员方法，实参传递args。 5.2 其他方法 int mm = m.getModifiers(); 获取方法的修饰符(权限+特征) Class mrt = m.getReturnType(); 获取返回值数据类型 String mn = m.getName(); 获取方法的名字 Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型 Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型 如何操作方法 调用方法 让他执行一次 Object result = invoke(对象,执行方法需要传递的所有参数…); 若方法是私有的方法 不允许操作 可以设置setAccessable(true) 设置方法使用权 准入 6. 原始方式与反射方式构造对象实例 使用原始方式来构造对象 123456789 //1.采用无参的方式构造Person对象并打印Person p = new Person();System.out.println(p); //null 0 //2.使用有参方式来构造Person对象Person p2 = new Person(\"zhangfei\", 30);System.out.println(p2); //zhangfei 30 //3.修改与获取属性(成员变量)，调用get,set方法p2.setName(\"guanyu\");System.out.println(\"修改后的姓名是：\" + p2.getName()); //guanyu 使用反射机制来构造对象 123456789101112131415161718192021 //1.使用获取到的Class对象来构造Person对象并打印Class c1 = Class.forName(\"myproject.Person\");//不可省略包名System.out.println(c1.newInstance());//null 0 //2.使用有参方式来构造对象Class c2 = Class.forName(\"myproject.Person\");Constructor ct2 = c2.getConstructor(String.class, int.class);Object obj = ct2.newInstance(\"zhangfei\", 30);System.out.println(obj);//zhangfei 30 //3.修改与获取属性(成员变量)Field f2 = c2.getDeclaredField(\"name\");f2.setAccessible(true);//暴力反射，设置使用权f2.set(obj, \"guanyu\");System.out.println(\"修改后的姓名是：\" + f2.get(obj)); //guanyu //4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来Method m1 = c2.getMethod(\"getName\");System.out.println(\"获取到的姓名是：\" + m1.invoke(obj)); //zhangfei //5.成员方法setName，调用getMethod方法来修改姓名并打印出来Method m2 = c2.getMethod(\"setName\", String.class);Object res = m2.invoke(obj, \"guanyu\");System.out.println(\"方法调用的返回值是：\" + res); //nullSystem.out.println(\"修改后的姓名是：\" + m1.invoke(obj)); //guanyu 7. 注解(Annotation)7.1 注解相关概念 注释 单行注释：// 多行注释：/* */ 文档注释：/** */ 注解的写法 @XXX [(一些信息)] 注解位置 类的上面，属性上面，方法上面，构造方法上面，参数前面 注解的作用 用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated 用来做代码的检测(验证)，@Override *可以携带一些信息(内容)，文件.properties/.xml，注解 常用的注解 @Deprecated：用来说明方法是废弃的 @Override：用来做代码检测 检测此方法是否是一个重写 @SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{} unused：变量定义后未被使用 serial：类实现了序列化接口 不添加序列化ID号 rawtypes：集合没有定义泛型 deprecation：方法以废弃 *unchecked：出现了泛型的问题 可以不检测 all：包含了以上所有(不推荐) 注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型： 基本数据类型 String类型 枚举类型enum 注解类型@ 数组类型[]，数组的内部需要是如上的四种类型 注解的分类 按运行机制分：源码注解，编译时注解，运行时注解 按照来源分：来自JDK的注解，来自第三方的注解，自定义注解 7.2 自定义注解类型的语法要求： 使用@interface关键字定义注解 成员以无参无异常方式声明 可以用default为成员指定一个默认值 成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration 如果注解只有一个成员，则成员名必须取名value(),在使用时可以忽略成员名和赋值号(=) 注解类可以没有成员，没有成员的注解称为标识注解 需要元注解来描述说明 @Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE) @Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME) @Inherited：允许子类继承 @Document：当前注解是否能被文档(javadoc)所记录 123456789@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description&#123; String desc(); String author(); int age() default 18;&#125; 7.3 使用自定义注解： @&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…) 1234@Description(desc=\"I am eyeColor\", author=\"Chao\", age=18)public String eyeColor()&#123; return \"red\";&#125; 如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字 1234567891011121314@Description(\"I am class annotation\")public class Child implements Person&#123; @Override @Description(\"I am method annotation\") public String name()&#123; return null; &#125; @Override public int age()&#123; return 0; &#125; @Override public void sing()&#123; &#125;&#125; 7.4 解析注解通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。 使用类加载器加载类 Class c=Class.forName（&quot;com.ann.test.Child&quot;) 找到类上面的注解 isAnnotationPresent（类类型）：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。 拿到注解实例，需要强制类型转换。 Description d=（Description）c.getAnnotation(Description.class); 找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。 12345678910111213141516171819202122232425public class ParseAnn&#123; public static void main(String[])&#123; try&#123;//1. 使用类加载器加载类 Class c=Class.forName（\"com.ann.test.Child\") //2. 找到类上面的注解 boolean isExist = c.isAnnotationPresent(Description.class); if(isExist)&#123; //3. 拿到注解实例 Description d=（Description）c.getAnnotation(Description.class); System.out.println(d.value()); &#125; //4.找到方法上的注解 Method[] ms = c.getMethods(); for(Method m:ms)&#123; boolean isMExist = m.isAnnotationPresent(Description.class); if(isMExist)&#123; Description md=（Description）c.getAnnotation(Description.class); System.out.println(md.value()); &#125; &#125; &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 另一种解析方法上的注解: 获取这个方法的所有注解，Annotation [] as=m.getAnnotations();然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。 123456789for(Method m:ms)&#123; Annotation [] as=m.getAnnotations(); for(Annotation a:as)&#123; if(a instanceof Description)&#123; Description md = (Description)a; System.out.println(md.value()); &#125; &#125;&#125; @Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"七、JavaSE多线程","date":"2019-07-09T10:07:41.000Z","path":"2019/07/09/07_JavaSE多线程.html","text":"多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。程序的执行其实都是在抢CPU的资源，CPU的执行权。多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。 基本概念 实现线程的过程 线程常用方法 线程池 线程的主要状态 线程的同步机制 线程的死锁 内存可见性 1. 基本概念 程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。 进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含n个线程；(进程是系统进行资源分配和调度的一个独立单位)。 线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序(一个进程)中有多个顺序流在执行。 并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程和进程一样分为五个阶段：创建、就绪状态、执行状态、等待/挂起/阻塞、终止/异常/消亡。 2. 实现线程的过程java.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。 自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。 自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 2.1 实现方式一：继承Thread类 自己描述一个类 继承父类Thread 重写run方法 new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的) 12345678class MyThread extends Thread&#123; @Override public void run()&#123; //这里编写该线程的执行任务 &#125;&#125;MyThread mt = new MyThread();mt.start(); 2.2 实现方式二：实现Runnable接口 自己描述一个类 实现一个父接口Runnable 重写run方法 new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态 123456789class MyThread implements Runnable&#123; @Override public void run()&#123; //这里编写该线程的执行任务 &#125;&#125;MyThread mt = new MyThread();Thread td = new Thread(mt);td.start(); 2.3 两种方式优缺点： 使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类 使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。 3. 线程常用方法 3.1 相关方法的解析： Thread()：使用无参方式构造对象 Thread(String name)：根据参数指定的名称来构造对象。 Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。 Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。 void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。 void start()：用于启动线程，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。 int getPriority()：用于获取线程的优先级，优先级1-10 void setPriority(int)：更改线程的优先级 3.2 多线程原理分析 执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。 对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。 当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。 两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。 3.3 线程的编号和名称 long getId()：用于获取调用对象所表示线程的编号 String getName()：用于获取调用对象所表示线程的名称 void setName()：用于设置线程的名称为参数指定的数值 static Thread currentThread()：获取当前正在执行线程的引用 4. 线程池 为了避免重复的创建线程，线程池的出现可以让线程进行复用。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。 在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务 接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService 抽象类：AbstractExecutorService 实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor 创建线程的第三种方式是实现Callable接口，主要用于线程池 5. 线程的主要状态 新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行 就绪状态：调用start()进入的状态，此时线程还是没有开始执行 运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态 消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止 阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态 5.1 线程的休眠 终止线程：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。 static void yield()：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。 static void sleep(times)：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。 5.1 线程的等待 void join()：等待该线程终止，让多个线程同步执行，变成单个线程 void join(long millis)：表示等待参数指定的毫秒数 对象.wait() 和 对象.notify()/notifyAll()可以让线程的状态来回切换 sleep()和wait()的区别： sleep()和wait()的区别 sleep() wait() 1.类 Thread类 Object类 2.调用 静态 类名. 对象. 3.理解 调用位置的线程等待 对象调用，访问对象的其他线程等待 4.唤醒 不需要唤醒 需要其他对象调用notify唤醒 5.锁 不会释放锁 等待后会释放锁 5.2 守护线程 boolean isDeamon()：用于判断是否为守护线程 void setDeamon(boolean on)：用于设置线程为守护线程 Java线程有两类： 用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程 守护线程：运行在后台，为其他前台线程服务 守护线程特点： 一旦所有线程都结束运行，守护线程会随JVM一起结束工作 守护线程应用： 数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。 设置守护线程： 可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程 6. 线程的同步机制 条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。 当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做线程的同步机制。 Java提供了一种内置的锁机制来支持原子性，使用synchronized关键字来保证线程执行操作的原子性，叫做对象/同步锁机制。 特征修饰符synchronized：表示同步，一个时间点只有一个线程访问 线程安全锁：两种形式是（锁定的永远是对象） 使用同步代码块的方式，将synchronized关键字放在方法体内部 123synchronized(对象)&#123; //需同步执行(锁定)的代码&#125; 使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象 1public synchronized void 方法名()&#123;&#125; 使用synchronized保证线程同步时应当注意： 多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用 在使用同步块时应当尽量减少同步范围以提高并发的执行效率 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。 每个对象只有一个锁（lock）与之相关联。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 7. 线程的死锁Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。 123456789101112131415161718/**当两个线程或多个线程之间相互锁定时就形成了死锁**///线程一：public void run() &#123; synchronized(a) &#123; //表示:持有对象锁a,等待对象锁b synchronized(b) &#123; //... &#125; &#125;&#125;//线程二：public void run() &#123; synchronized(b) &#123; //表示:持有对象锁b,等待对象锁a synchronized(a) &#123; //... &#125; &#125;&#125;// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。 产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。 隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。 两种导致隐性死锁的情况：加锁次序和占有并等待。 加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。 占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。 7.1 死锁的避免 避免死锁的原则：顺序上锁，反向解锁，不要回头 静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。 动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：安全序列和银行家算法。 8.内存可见性8.1 基本概念 可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量 Java内存模型(JMM)： Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。 所有的变量都存储在主内存中 每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝) Java内存模型规定： 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。 要实现共享变量的可见性，必须保证两点： 线程修改后的共享变量值能够及时从工作内存中刷新到主内存中 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。 Java语言层面支持的可见性实现方式：Synchronized，volatile 8.2 Synchronized实现可见性 Synchronized能够实现：原子性(同步)、可见性 JMM关于synchronized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁） 线程执行互斥代码的过程： 获得互斥锁 清空工作内存 从主内存拷贝变量的最新副本到工作内存 执行代码 将更改后的共享变量的值刷新到主内存 释放互斥锁 重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化 编译器优化重排序（编译器处理） 指令级并行重排序（处理器优化） 内存系统的重排序（处理器读写缓存的优化） as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致 单线程中重排序不会带来内存可见性问题 多线程中程序交错执行时，重排序可能造成内存可见性问题 不可见的原因 syschronized解决方案 1.线程的交叉执行 原子性 2.重排序结合线程交叉执行 原子性 3.共享变量未及时更新 可见性 8.3 volatile实现可见性 深入来说：通过加入内存屏障和禁止重排序优化来实现的。 对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令 对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令 通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。 线程写volatile变量的过程： 改变线程工作内存中volatile变量副本的值 将改变后的副本的值从工作内存刷新到主内存 线程读volatile变量的过程： 从主内存中读取volatile变量的最新值到线程的工作内存中 从工作内存中读取volatile变量的副本 volatile不能保证volatile变量复合操作的原子性 volatile适用场景： 对变量的写操作不依赖其当前值 该变量没有包含在具有其他变量的不变式中 8.4 Synchronized和volatile比较 volatile不需要加锁，比synchronized更轻量级，不会阻塞线程； 从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁 synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性 volatile没有synchronized使用广泛。","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"六、JavaSE输入输出(IO)","date":"2019-07-09T09:31:22.000Z","path":"2019/07/09/06_JavaSE输入输出-IO.html","text":"输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。 File类 IO流 文件流 字节型文件流 字符型文件流 *缓冲流 转换流 对象流 打印流(PrintStream类) Properties类的使用 1. File类 File与真实硬盘中的文件或文件夹 不是一个东西 File是在内存中的一个对象&lt;—映射—&gt;硬盘上的文件或文件夹 java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。 File类中的常用的方法 canRead()，canWrite()，isHidden()，isFile()，isDirectory() length()，获取文件中字节的个数 lastModified()，获取文件最后的修改时间—&gt;毫秒值 *String path = getAbsolutePath()，获取文件的绝对路径 D://test//Test.txt 绝对路径&lt;—-&gt;相对路径 绝对路径可以通过完整的字符串，定位盘符，文件夹，文件 相对路径没有盘符的写法，当前工程(项目)所在的位置找寻 String name = getName()，获取文件的名字 Test.txt boolean = *createNewFile()**，创建新的文件 boolean = *mkdir** ，创建新的文件夹 外层没有 不能创建 boolean = *mkdirs**，创建新的文件夹 外层没有 可以自动创建 String pname = getParent()，获取当前file的父亲file名字 *File file = getParentFile()，获取当前file的父亲file对象 String[] names = list()，获取当前file的所有儿子名字 *File[] files = listFiles()，获取当前file的所有儿子对象 *boolean = delete()，删除文件或空的文件夹 不能删除带元素的文件夹 文件夹的路径(找父目录) 1234567//查找当前file的所有父目录File file = new File(\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\");File pfile = file.getParentFile();while(pfile!=null)&#123; System.out.println(pfile.getAbsolutePath()); pfile = pfile.getParentFile();//再找一遍&#125; 文件夹的遍历—-需要一个递归 123456789101112131415//设计一个方法 用来展示(遍历)文件夹,参数--&gt;file(代表文件或文件夹)public void showFile(File file)&#123; //获取file的子元素 //files==null是个文件 //files!=null是个文件夹 //files.length!=0是一个带元素的文件夹 File[] files = file.listFiles();//test文件夹所有子元素 if(files!=null &amp;&amp; files.length!=0)&#123; for(File f:files)&#123; this.showFile(f); &#125; &#125; //做自己的显示(file是文件或file是一个空的文件夹) System.out.println(file.getAbsolutePath());&#125; 文件夹的删除—-需要一个递归 123456789101112//设计一个方法 删除文件夹,参数 filepublic void deleteFile(File file)&#123; //判断file不是空文件夹 File[] files = file.listFiles(); if(files!=null &amp;&amp; files.length!=0)&#123; for(File f:files)&#123; this.deleteFile(f); &#125; &#125; //删除file (file是个文件或file是一个空文件夹) file.delete();&#125; 2. IO流 流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 流的分类: 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流in(读取)和输出流out(写入) 操作的目标来区分: 文件流，数组流，字符串流，数据流，对象流，网络流… IO流的框架结构 123456789101112131415161718|——IO流 |————字节流 |————InputStream |————FileInputStream |————DataInputStream |————ObjectInputStream |————OutputStream |————FileOutputStream |————DataOutputStream |————ObjectOutputStream |————PrintStream |————字符流 |————Reader |————BufferedReader |————InputStreamReader |————Writer |————BufferedWriter |————OutputStreamWriter 3. 文件流读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分 字节型文件流(1字节)：FileInputStream/FileOutputStream 字符型文件流(2字节–1字符)：FileReader/FileWriter 字节流和字符流的区别： 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。 输入流和输出流 对输入流只能进行读操作，对输出流只能进行写操作。 4. 字节型文件流4.1 字节型文件输入流FileInputStream(读) FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。 创建对象 调用一个带File类型的构造方法 调用一个带String类型的构造方法 常用方法 int code = read(); 每次从流管道中读取一个字节，返回字节的code码 *int count = read(byte[] ) 每次从流管道中读取若干个字节，存入数组内 返回有效元素个数 int count = available(); 返回流管道中还有多少缓存的字节数 skip(long n);跳过几个字节 读取 多线程—&gt;利用几个线程同时读取文件 *close() 将流管道关闭—必须要做,最好放在finally里 注意代码的健壮性，判断严谨（eg:非空判断） 4.2 字节型文件输出流FileOutputStream(写) FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。 创建对象 调用一个带File参数，还有File boolean重载 调用一个带String参数，还有String boolean重载 eg: new FileOutputStream(“D://test//bbb.txt”, true)//第二个参控制每次写入追加还是重载 常用方法 write(int code); 将给定code对应的字符写入文件 ‘=’ write(byte[]); 将数组中的全部字节写入文件 getByte() write(byte[] b, int off, int len); flush(); 将管道内的字节推入(刷新)文件 close(); 注意在finally中关闭 创建的是文件输入流，若文件路径有问题，则抛出异常 FileNotFoundException 创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件 设计一个文件复制的方法 12345678910111213141516171819202122232425262728293031323334public void copyFile(File file, String path) &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; //创建输入流读取信息 fis = new FileInputStream(file); //创建一个新的File对象 File newFile = new File(path +\"\\\\\"+ file.getName());//\"E:\\\\test\\\\test.txt\" //创建一个输出流 fos = new FileOutputStream(newFile); byte[] b = new byte[1024];//通常1kb-8kb之间 int count = fis.read(b); while(count != -1) &#123; fos.write(b, 0, count);//将读取到的有效字节写入 fos.flush(); count = fis.read(b); &#125; System.out.println(\"复制完毕！\"); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭 if(fis!=null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123;e.printStackTrace();&#125; &#125; if(fos!=null) &#123; try &#123;fos.close();&#125; catch (IOException e) &#123;e.printStackTrace();&#125; &#125; &#125;&#125; 5. 字符型文件流FileReader/FileWriter：只能操作纯文本的文件 .txt / .properties 5.1 字符型文件输入流FileReader(读) FileReader类在java.io包，继承自InputStreamReader，Reader 创建对象 调用一个带File类型的构造方法 调用一个带String类型的构造方法 常用方法 read() read(char[]) close() 12345678910111213141516File file = new File(\"F://test//Test.txt\");try &#123; FileReader fr = new FileReader(file); // int code = fr.read(); // System.out.println(code); char[] c = new char[1024]; int count = fr.read(c); while(count!=-1) &#123; System.out.println(new String(c, 0, count)); count = fr.read(c); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 5.2 字符型文件输出流FileWriter(写) FileWriter类在java.io包，继承自OutputStreamWriter，Writer 构造方法 带file参数，带file,boolean参数 带String参数，带String,boolean参数 常用方法 write(int) write(char[]) write(string) flush()，close() 6. *缓冲流 缓冲流,也叫高效流，是对4个基本的File…流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 缓冲流读写方法与基本的流是一致 6.1 字节缓冲流 BufferedInputStream，BufferedOutputStream 构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\")); 6.2 字符缓冲流 BufferedReader，BufferedWriter 构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 1234// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\")); 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 特有方法: BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 12345678910111213141516171819202122//设计一个方法，用来用户登录认证public String login(String username, String password) &#123; try &#123; BufferedReader br = new BufferedReader(new FileReader(\"F://test//User.txt\")); //User.txt每行存储格式：张三-123 String user = br.readLine();//user表示一行记录，记录账号密码 while(user!=null) &#123; //将user信息拆分，分别与参数比较 String[] value = user.split(\"-\");//value[0]账号，value[1]密码 System.out.println(value[0]); if(value[0].equals(username)) &#123; if(value[1].equals(password)) &#123; return \"登录成功\"; &#125; &#125; user = br.readLine(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return \"账号或密码错误！\";&#125; readLine方法演示: 12345678try &#123; BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;F://test//User.txt&quot;, true)); bw.newLine(); bw.write(&quot;java-888&quot;); bw.flush();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 7. 转换流7.1 字符编码 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 常见字符集: ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码） ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表） Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。 编码引出的问题 在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 7.2 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 12InputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\"); 指定编码读取: 12345678910111213141516171819202122public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = \"E:\\\\file_gbk.txt\"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");// 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; 7.3 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\"); 指定编码写出 123456789101112131415161718public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = \"E:\\\\out.txt\"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(\"你好\"); // 保存为6个字节 osw.close();// 定义文件路径String FileName2 = \"E:\\\\out2.txt\"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\"); // 写出数据 osw2.write(\"你好\");// 保存为4个字节 osw2.close(); &#125;&#125; 8. 对象流 对象序列化和反序列化 Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象 简单来讲 对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中 对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象 如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口；如果想要将对象反序列化：需要给对象提供一个序列化的版本号，private long serialVersionUID = 任意L; 8.1 ObjectOutputStream类 java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 12FileOutputStream fileOut = new FileOutputStream(\"employee.txt\");ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。1234567891011121314151617181920212223242526272829303132//满足两个条件public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(\"Address check : \" + name + \" -- \" + address); &#125;&#125;//写出对象方法public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = \"zhangsan\"; e.address = \"beiqinglu\"; e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\")); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;//输出结果：//Serialized data is saved 8.1 ObjectInputStream类 ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1 如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728public class DeserializeDemo &#123; public static void main(String [] args) &#123; Employee e = null; try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream(\"employee.txt\"); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); &#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println(\"Employee class not found\"); c.printStackTrace(); return; &#125; // 无异常,直接打印输出 System.out.println(\"Name: \" + e.name);// zhangsan System.out.println(\"Address: \" + e.address); // beiqinglu System.out.println(\"age: \" + e.age); // 0 &#125;&#125; 反序列化操作2 另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 123456789101112public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println(\"Address check : \" + name + \" -- \" + address); &#125;&#125; 9. 打印流(PrintStream类) 平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 构造方法 public PrintStream(String fileName); 使用指定的文件名创建一个新的打印流。 1PrintStream ps = new PrintStream(\"ps.txt\")； 改变打印流向 System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。 123456789101112public class PrintDemo &#123; public static void main(String[] args) throws IOException &#123; // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(\"ps.txt\"); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); &#125;&#125; 10. Properties类的使用 Java.util.Properties，主要用于读取Java的配置文件。 Properties类继承自Hashtable 配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用”#”来注释。 Properties类的主要方法： getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。 load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。 setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。 store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。 clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"五、JavaSE异常处理机制","date":"2019-07-09T00:34:31.000Z","path":"2019/07/09/05_JavaSE异常处理机制.html","text":"Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。 基本概念 异常的分支结构 添加处理异常的手段 异常的捕获 异常的抛出 自定义异常 总结 1. 基本概念 异常用于在Java语言中描述运行阶段发生的错误。 在Java中有一个定义好的规则Throwable（可以抛出的） java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。 Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。 Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。 java.lang.Exception类是所有异常的超类，主要分为两大类： RuntimeException - 运行时异常，也叫非检测性异常 IOException和其他异常 - 其他异常也叫做检测性异常 注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。 12345678910Throwable类 |————Exception类 |————RuntimeException异常 |————ArithmeticException类 |————ArrayIndexOutOfBoundsException类 |————NullPointerException类 |————ClassCastException类 |————NumberFormatException类 |————IOException和其他异常 |————Error类 2. 异常的分支结构2.1 运行时异常（非检查异常） Error和RuntimeException都算作运行时异常 javac编译的时候，不会提示和发现的， 在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws) 要求大家出现这样异常的时候 知道怎么产生及如何修改 InputMisMatchException 输入不匹配 int value = input.nextInt();// abc *NumberFormatException 数字格式化 int value = Integer.parseInt(“123.45”); NegativeArraySizeException 数组长度负数 int[] array = new int[-2]; *ArrayIndexOutOfBoundsException 数组索引越界 int[] array = {1,2,3}; array[5]; *5NullPointerException 空指针异常 int[][] array = new int[3][]; array[0][0] =10; Person p = null; p.getName(); ArithmeticException 数字异常 10/0 整数不允许除以0 Infinity小数除以0会产生无穷 *ClassCastException 造型异常 Person p = new Teacher(); Student s = (Student)p; *StringIndexOutOfBoundsException 字符串越界 String str = “abc”; str.charAt(5); *IndexOutOfBoundsException 集合越界 List家族 ArrayList list = new ArrayList(); list.add(); list.add(); list.add(); list.get(5); IllegalArgumentException 非法参数异常 ArrayList list = new ArrayList(-1); 2.2 编译时异常(检查异常) 除了Error和RuntimeException以外其他的异常 javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws) 因为这样的异常在程序运行过程中极有可能产生问题的 异常产生后后续的所有执行就停止 123456//eg: InterruptExceptiontry&#123; Thread.sleep(5000);&#125;catch(Exception e)&#123; //...&#125; 3. 添加处理异常的手段 处理异常不是 异常消失了 处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行 两种手段： 异常的捕获：try{}catch(){}[ finally{} ] throws抛出 final，finally，finalize区别 final：特征修饰符，修饰变量，属性，方法，类 修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值) 修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错) 修饰方法：不能被子类重写 修饰类：不能被其他的子类继承 finally：处理异常手段的一部分 try{}catch(){}后面的一个部分 这个部分可有可无，如果有只能含有一份，且必须执行 finalize：是Object类中的一个protected方法 对象没有任何引用指向的时候 – 会被GC回收 当对象回收的时候 默认调用finalize方法 若想要看到对象回收的效果，可以重写 public void finalize(){} 4. 异常的捕获12345678try&#123; 可能发生异常的代码;&#125;catch(异常类型 引用变量)&#123; 针对该异常的处理代码;&#125;catch ...finally&#123; 无论是否发生异常都要执行的代码;&#125; 处理异常放在方法内部 可能会出现的小问题 如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。 1234567891011public String test() &#123; try &#123; //...可能产生异常的的代码 return &quot;值1&quot;;//事先约定好 返回值 &#125;catch(Exception e)&#123; e.printStackTrace();//打印输出异常的名字 &#125;finally &#123; System.out.println(&quot;finally块执行啦&quot;); &#125; return &quot;值2&quot;;&#125; 上述执行结果：若try中代码块产生异常return返回 值2，若try中无异常则return返回 值1，无论return在哪finally都会执行。 异常捕获的注意事项： 当需要多分catch分子时，切记小类型应该放在大类型的前面； 懒人写法：catch(Exception e){…} finally通常用于善后处理，如：关闭已经打开的文件等。 5. 异常的抛出 当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。 语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{} ，如：public void show() throw Exception {} 重写方法的抛出规则： 不抛出异常 抛出父类异常中的子类异常 抛出和父类一样的异常 不能抛出同级不一样的异常 不能抛出更大的异常 6. 自定义异常 可以根据需要自定义异常类。 自定义异常的方式： 继承Exception或者异常的子类。 提供两个构造，无参构造和String做参数的构造。 异常的手段 如果继承是RuntimeException—-&gt;运行时异常(不需要必须添加处理手段) 如果继承是Exception—–&gt;编译时异常(必须添加处理手段) 类中可以写带String参数的构造方法，可以做细致的说明 通过throw关键字，new一个异常的对象 主动产生异常：throw new 异常类型(); 7. 总结 1.在开发中尽量使用条件判断避免异常的发生; 2.若实在避免不了，则进行异常捕获； 3.若实在捕获不了，则进行异常抛出； 4.若需要使用针对性异常，则自定义异常。","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"四、JavaSE集合框架","date":"2019-07-08T14:10:57.000Z","path":"2019/07/08/04_JavaSE集合框架.html","text":"为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。 Collection集合 List集合 泛型机制 Queue集合 *ArrayList类 Vector类 Stack类 *LinkedList类 Set集合 HashSet类 TreeSet类 Map集合 HashMap类 TreeMap类 Lambda表达式 Stream API 1. Collection集合 Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。 数组与集合的比较 数组的特点： 数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容； 支持下标访问，实现随机访问非常方便； 增删操作不方便，可能会移动大量元素； 数组一旦声明长度固定无法更改； 数组支持基本数据类型，也支持引用数据类型； 集合的特点： 集合的存储单元可以不连续，数据类容可以不相同； 集合部分支持下标访问，部分不支持； 集合中增删元素可以不移动大量元素； 集合大小可以随时动态调整； 集合中的元素必须是引用数据类型（基本数据类型可用包装类）； 1234567891011121314-Collection接口 |————List接口 |————ArrayList类 |————LinkedList类 |————Stack类 |————Vector类 |————Queue接口 |————LinkedList类 |————Set接口 |————HashSet类 |————TreeSet类-Map接口 |————HashMap类 |————TreeMap类 Collection存储的都是value,其中List有序可重复，Set无序无重复 Map存储的是以key-value形式,key无序无重复 value无序可重复 序 : 顺序–添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序 Collection集合的常用方法 boolean add(E e); 向集合中添加对象 boolean contains(Object o); 判断是否包含指定对象 boolean remove(Object o); 从集合中删除对象 void clear(); 清空集合 int size(); 返回包含对象的个数 boolean isEmpty(); 判断是否为空 1234567Collection c2 = new ArrayList(); //多态boolean b1 = c2.add(new String(\"one\")); //trueboolean b2 = c2.add(new Integer(2)); //trueSystem.out.println(\"c2 = \" + c2); //[one, 2]boolean b3 = c2.contains(new Integer(2));//true//contains方法工作原理：(o==null ? e==null : o.equals(e)); 2. List集合 java.util.List集合是Collection集合的子集合。 List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。 ArrayList类的底层使用数组进行数据管理，访问元素方便，增删不方便。 LinkedList类的底层使用链表进行数据管理，访问不方便，增删方便。 Stark类的底层使用数组进行数据管理，该类主要描述具有后进先出的特征的数据结构，叫做栈。 Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。 List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。 List类常用方法 void add(int index, E element) 向集合指定位置添加元素 boolean addAll(int index, Collection&lt;?extends E&gt; c) 向集合中添加所有元素 E get(int index) 从集合中获取指定位置的元素 E set(int index, E element) 修改指定位置的元素 E remove(int index) 删除指定位置的元素 int indexOf(Object o) 在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i))) T[] toArray(T[] a) 将集合中的对象序列化以对象数组的形式返回。 List subList(int fromIndex, int toIndex) 获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图 3. 泛型机制 集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。 从jdk1.5开始推出泛型机制，在集合名称后面使用&lt;数据类型&gt;的方式明确要求该集合中可以存放的数据类型。如：List&lt;String&gt; lt = new LinkedList&lt;String&gt;();。 从jdk1.7开始可省略后面&lt;&gt;的数据类型，叫做菱形特性，如：List&lt;String&gt; lt = new ArrayList&lt;&gt;();。 泛型本质就是参数化类型，让数据类型作为参数传递，public interface List&lt;E&gt;{}其中E是占位形参，由于实参可以支持各种广泛的类型，因此得名泛型。 泛型可以用在哪里： 泛型类：类定义的时候描述某种数据类型，集合的使用就是这样 泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型 泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中 方法参数泛型限制，高级泛型，规范边界，extends，super 4. Queue集合 java.util.Queue集合是Collection集合的子集合。 Queue集合主要描述具有先进先出特性的数据结构，叫做队列(FIFO:First Input First Output)。 Queue集合主要实现类是LinkedList类，因为该类在增删方面有一定优势。 Queue接口中主要方法 boolean offer(E e) 将一个对象添加至队尾，若添加成功则返回true E poll() 从队首删除并返回一个元素 E peek() 返回队首的元素（但并不删除） 12345Queue&lt;Integer&gt; q1 = new LinkedList&lt;Integer&gt;();//将数据11、22、33、44、55依次入队for(int i=1; i&lt;=5; i++) &#123; q1.offer(i*11);&#125; 5. *ArrayList类 底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util ArrayList特点适合遍历轮询，不适合插入删除 如何构建一个ArrayList对象 无参数构造方法，带默认容量构造方法，带collection参数的构造方法 ArrayList中常用的方法 增删改查：add(E e)，remove(index)，set(index value)，get(index)，size() 类中其他常用的方法 addAll并集，removeAll差集，ratainAll交集; indexOf()，lastIndexOf()，contains()，List=subList(); isEmpty()，clear()，ensureCapacity()，iterator();迭代器 toArray(T[] x)，trimToSize(); 6. Vector类 是ArrayList集合的早期版本，所属的包 java.util Vector底层也是利用(动态)数组的形式存储 Vector是线程同步的(synchronized)，安全性高，效率较低 扩容方式与ArrayList不同 默认是扩容2倍，可以通过构造方法创建对象时修改这一机制 构造方法和常用方法与ArrayList类似 7. Stack类 Stack类，栈，java.util包 构造方法只有一个无参数 除了继承自Vacton类的方法外还有特殊的方法 push(E e)将某一个元素压入栈顶(add()) E = pop()将某一个元素从栈顶取出并删掉(E = remove()) E = peek()查看栈顶的一个元素 不删除(get()) boolean = empty()判断栈内元素是否为空(isEmpty()) int = search()查找给定的元素在占中的位置(indexOf()) 应用场景 中国象棋，悔棋 栈中存储每一次操作的步骤 撤销功能 8. *LinkedList类 LinkedList类，java.util包 底层使用双向链表的数据结构形式来存储 适合于插入或删除 不适合遍历轮询 构建对象 无参数构造方法，带参数的构造方法(collection) 常用的方法 增删改查：add()，remove()，set()，get()，size()，offer，poll，peek 手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex() 插入删除的特性是否像想的那样 对比ArrayList Linked 9. Set集合 java.util.Set集合是Collection集合的子集合。 Set集合没有先后放入次序，并且不允许有重复关系，实现类有HashSet类和TreeSet类。 其中HashSet类底层是采用哈希表进行数据管理的。 其中TreeSet类的底层是采用二叉树进行数据管理的。 1234//方法和Collection集合基本一样Set&lt;String&gt; set1 = new HashSet&lt;String&gt;();set1.add(\"one\");System.out.println(\"s1=\"+s1); set集合的无重复特性 HashSet，无重复原则有两个方法同时起作用 equals hashCode 默认比较的是两个对象的地址 若第二个对象地址与之前的一致 不再存入 如果想要改变其比较的规则 可以重写上述两个方法 TreeSet，无重复原则有一个方法起作用 compareTo 上述这个方法不是每一个对象都有的 若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable 实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后 9.1 Set集合的遍历 所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。 迭代器Iterator&lt;E&gt; iterator()，主要方法有 boolean hasNext() 判断集合中是否有可以迭代/访问的元素 E next() 用于取出一个元素并指向下一个元素 void remove() 用于删除访问到的最后一个元素 12345678Iterator&lt;String&gt; it = set1.iterator();//获取当前集合的迭代器对象while(it.hasNext()) &#123;//判断是否有可以访问的元素 String temp = it.next();//取出一个并指向下一个 System.out.println( temp ); if(\"two\".equals(temp))&#123; it.remove();//删除set1中该元素 &#125;&#125; 增强for循环(for each结构) 语法格式：for(元素类型 变量名:集合/数组){ 循环体; }。 执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。 123456789//遍历集合for(String ts : s1) &#123; System.out.println(ts);&#125;//遍历数组int[] arr = &#123;11,22,33,44,55&#125;;for(int ti : arr) &#123; System.out.println(ti);&#125; 10. HashSet类 HashSet集合底层采用HashMap（数组+链表–&gt;散列表），java.util包。 它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 创建对象：无参数，有参数 集合容器的基本使用 增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object) 没有修改方法 iterator() 获取一个迭代器对象 size() 无重复的原则 在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。) 11. TreeSet类 TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right)) 创建对象： 无参数构造方法 ，带Collection构造方法 基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size() 二叉树主要指每个节点最多只有两个子节点的树形结构。 满足以下三个特征的二叉树叫做有序二叉树： 左子树中的任意节点元素都小于根节点元素； 右子树中的任意节点元素都大于根节点元素； 左子树和右子树内部也遵守上述规则； 无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。 元素放入TreeSet集合过程：由于TreeSet集合底层采用有序二叉树进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式： 使用元素的自然排序规则进行比较并排序，让元素类型实现java.lang.Comparable接口； 使用比较器规则进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口； 注意： 1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序； 2. 可以使用Collections工具类对集合中的元素进行操作； 12. Map集合 java.util.Map&lt;K, V&gt;集合存取元素的基本单位是：单对元素（键值对key-value）。 Map：映射，通过某一个key可以直接定位到一个value值 key无序无重复 value无序可重复 key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致 主要有两个实现类：HashMap类和TreeMap类。 Map基本使用：HashMap，TreeMap，Properties Map集合常用方法： 增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value) Map集合的遍历方式：a.迭代Key，b.迭代Entry Map集合的性能调优： 加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75） 13. HashMap类 包:java.util，底层散列表的形式（数组+链表） 构造方法创建对象 无参数 带默认容量的 带map参数的构造方法 特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复 找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry 基本方法： 增 put(key,value)，存放一组映射关系key-value key存储的顺序与取得顺序不同 不同的key可以存储相同的value key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反) 删 E = remove(key); 改 replace(key,newValue)，put(key,value2) 查 E = get(key)； Set = keySet()获取全部的key Set = entrySet(); size(); 12345678Set&lt;Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();//获取集合中全部的entry对象Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = entrys.iterator();while(it.hasNext())&#123; Entry&lt;Integer,String&gt; entry = it.next();//entry key value Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\"--\"+value);&#125; 除了上述几个常用的方法外 其他API中提供的方法 clear，containsKey(key)，containsValue(value) getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值 isEmpty() putAll(map) putIfAbsent(key,value);//如果key不存在才向集合内添加 如果key存在就不添加啦 map集合在什么情形下用? 想要存储一组元素 数组 or 集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合 如果发现长度以后不确定—&gt;集合 list Set Map List家族有序的 Set家族无重复 Map家族k-v 存储有顺序用这个 存储元素希望自动去掉重复元素用这个 通过唯一的k快速找寻v用这个 ArrayList:更适合遍历轮询 HashSet:性能更高 HashMap:性能更高 LinkedList:更适合插入和删除 TreeSet:希望存进去的元素自动去重复,同时还能自动排序 Tree:希望存进去的元素key自动排序 Stack:LIFO - - 14. TreeMap类 java.util包 构造方法：无参数，带map参数 常用方法：put， get，remove，replace，size 底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋） 自然有序，按照Unicode编码自然有序 ap集合中的key需要可比较的 key的对象需要实现Comparable接口 15. Lambda表达式 java8支持的新的语法格式，Lambda允许把函数作为一个方法的参数(函数作为参数传递进方法中)，使用lambda表达式可以使代码变得更加简洁紧凑。 函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。 lambda表达式语法由参数列表、箭头函数-&gt;和函数体组成，函数体即可以是一个表达式，也可以是一个语句块。 123(int a, int b) -&gt; a+b() -&gt; 42(String s) -&gt; &#123;System.out.println(s);&#125; 函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。 jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。 15.1 Lambda表达式-方法引用 方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。 方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。 16. Stream API Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。 虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同： 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。 惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 对stream的操作分为为两类，中间操作和结束操作，二者特点是： 中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。 结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。 16.1 stream方法使用 stream跟函数接口关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。 12345// 找出最长的单词Stream&lt;String&gt; stream = Stream.of(\"I\", \"love\", \"you\", \"too\");Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());System.out.println(longest.get());","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"三、JavaSE核心工具类","date":"2019-07-08T08:42:47.000Z","path":"2019/07/08/03_JavaSE核心工具类.html","text":"API (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。 Object类与其常用方法 包装类 数学处理类 Scanner类和System类 日期类 String类 StringBuilder类/StringBuffer类 Optional类 常用的包 java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类… java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类… java.io包：是输入输出包，包括读写各种设备。 java.net包：是网络编程的包，包括各种网络编程。 java.sql包：是操作数据库的所有类和接口。 1. Object类与其常用方法1.1 Object类 java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。 Object定义了“对象”的基本行为，被子类默认继承。 1.2 equals() 和 hashCode() boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。 equals()方法要求：自反性/对称性/传递性/一致性/非空性。 Java类可以根据需要重写继承自Object的equals()方法。 注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 int hashCode():返回对象的哈希码值，对应一个内存。 hashCode规范要求： 一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的 如果两个对象判定相等，它们的hashCode应该时同一个值 如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。 hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。 1.3 toString() String toString()：用于获取调用对象的字符串形式，返回”包名.类名@hashCode值的16进制”。 Java类可以根据需要重写toString方法返回更有意义的信息。 Java在使用System.out.println()打印对象时或者+连接字符串时，默认调用toString()方法。 2. 包装类2.1 包装类 由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。 Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。 基本类型 对应包装类 byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double boolean java.lang.Boolean char java.lang.Character 八个包装类都在同一个包下（java.lang包），不需要import导包直接使用 八个包装类中有六个是与数字相关，都默认继承父类Number 八个包装类都实现了Serializable, Comparable 八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型 八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型 2.2 Integer类 java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。 Integer类重写了equals()方法（重写后比较的是数值）、hashCode()以及toString()方法。 Integer类的常用方法 Integer(int i) 根据参数指定整数来构造对象 Integer(String s) 根据参数指定的字符串来构造对象 int intValue() 获取调用对象中整数值并返回 static Integer valueOf(int i) 根据参数指定整数值得到Integer类型对象 static int parseInt(String s) 将字符串类型转换为int类型并返回 2.3 装箱和拆箱123456int i = 100;Integer it = Integer.valueOf(i); //实现了int类型到Integer类型的转换，这个过程叫做装箱int ia = it.intValue();//实现了Integer类型到int类型的转换，这个过程叫做拆箱//jdk5增加了自动拆箱和装箱功能（编译器预处理）:Integer i = 100;//自动装箱int ia = i;//自动拆箱 笔试考点： 在Integer类部提供了自动装箱池技术，将-128~127间的整数已经装箱完毕，当使用该范围整数时直接取池中的对象即可，从而提高效率。 Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。 1234567891011121314151617Integer it1 = 128;Integer it2 = 128;Integer it3 = new Integer(128);Integer it4 = new Integer(128);System.out.println(it1.equals(it2));//比较内容 trueSystem.out.println(it1 == it2);//比较地址 falseSystem.out.println(it3.equals(it4));//比较内容 trueSystem.out.println(it3 == it4);//比较地址 falseInteger it5 = 127;Integer it6 = 127;Integer it7 = new Integer(127);Integer it8 = new Integer(127);System.out.println(it5.equals(it6));//比较内容 trueSystem.out.println(it5 == it6);//比较地址 true, 自动装箱池范围-128~127。System.out.println(it7.equals(it8));//比较内容 trueSystem.out.println(it7 == it8);//比较地址 false 3. 数学处理类 java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static 不需要创建对象。 常用的方法 返回值类型 Math.abs() 返回给定数字的绝对值(参数 int long float double) Math.ceil() double 向上取整 Math.floor() double 向下取整 Math.rint() double 临近的整数 如果两边距离一样 则返回偶数 Math.round() int 四舍五入的整数 Math.max(a,b)/min(a,b) (参数int long float double) Math.pow(a,b) double a的b次方 (参数double 返回值double) Math.sqrt(double a) 获取给定参数的平方根 Math.random() double 随机产生一个[0.0–1.0) 0-9之间的随机整数：int value = (int)(Math.random()*10); Math.random()计算小数的时候精确程度可能有些损失 3.1 Random类 java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系 默认继承Object类 常用的方法 Random r = new Random(); r.nextInt(); 随机产生 int取值范围的整数 有正有负(-2^31~2^31-1即正负21亿之间) r.nextInt(int bound); 随机产生一个[0–bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException r.nextFloat() 随机产生一个 [0.0—1.0) r.nextBoolean() 随机产生一个boolean值 true false 3.2 UUID类 java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系 默认继承Object类 只有有参构造方法，我们通常不会创建对象 UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key 产生一个32位的随机元素 每一个位置是一个16进制的数字 3.3 BigDecimal java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。 提供的构造方法全部都是带参数的 通常利用带String参数的构造方法创建这个类的对象：BigDecimal bi = new BigDecimal(“1.23”); BigDecimal类的常用方法 BigDecimal(String val) 根据参数指定的字符串来构造对象 BigDecimal setScale(int newScale, RoundingMode roundingMode) 两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等) BigDecimal add(BigDecimal augend) 用于实现加法运算 BigDecimal subtract(BigDecimal subtrahend) 用于实现减法运算 BigDecimal multiply(BigDecimal multiplicand) 用于实现乘法运算 BigDecimal divide(BigDecimal divisor) 用于实现除法运算，也可传入更多参数设置保留小数点位数和取值模式 123456BigDecimal d3 = new BigDecimal(\"3.0\");BigDecimal d4 = new BigDecimal(\"2.9\");System.out.println(d3.add(d4));//加：5.9System.out.println(d3.subtract(d4));//减：0.1System.out.println(d3.multiply(d4));//乘：8.70System.out.println(d3.divide(d4, 8, BigDecimal.ROUND_HALF_UP));//除：1.03448276 对于divide方法，通常需要制定精度和舍入模式，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。 3.4 BigInteger java.math.BigInteger类处理大整数，需要import导入，继承自Number java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 如何创建对象，提供的构造方法全部都是带参数的 通常利用带String参数的构造方法创建这个类的对象：BigInteger bi = new BigInteger(“123”); 和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。 3.5 DecimalFormat类 所属的包 java.text，import导入才能使用 通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补） 123456789101112 //调用format方法将一个小数格式化成一个字符串DecimalFormat df = new DecimalFormat(\"000.000\");System.out.println(df.format(12.45)); //012.450System.out.println(df.format(12345.6789)); //12345.679DecimalFormat df2 = new DecimalFormat(\"###.###\");System.out.println(df2.format(12.45)); //12.45System.out.println(df2.format(12345.6789)); //12345.679DecimalFormat df3 = new DecimalFormat(\"000.###\");System.out.println(df3.format(12.45)); //012.45System.out.println(df3.format(12345.6789)); //12345.679 4. Scanner类和System类4.1 Scanner类 所属的包java.util包 需要import导包 通过一个带输入流的构造方法创建对象 常用方法 nextInt() nextFloat() next() nextLine() 4.1 System类 所属的包java.lang包 不需要导入 不需要创建对象 通过类名就可以访问 有三个属性及若干的方法 三个属性out in err 方法：gc() exit(0); currentTimeMillis()获取系统当前时间毫秒; 5. 日期类5.1 Date类 java.util.Date类表示特定的瞬间，精确到毫秒。 通常使用无参数的构造方法，或者带long构造方法 Date类中常用的方法 before(); after(); setTime() getTime();—–&gt;long compareTo(); //-1 1 0 Date类大多数用于进行时间分量计算的方法已经被Calender取代。 1234Date date = new Date();//当前日期信息 //Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019long time = date.getTime();//1970年1月1日距今毫秒数。date.setTime(time + 24\\*60\\*60\\*1000);//通过毫秒数设置时间 5.2 SimpleDateFormat类 java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类 其构造方法 SimpleDateFormat(String pattern) 12345678Date date = new Date();SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\");String dateStr = sdf.format(date);// format用于将日期按指定格式转换为字符串String str = \"2013-01-06\";SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd\");Date date2 = sdf2.parse(str);//如果字符串格式不匹配将抛出异常 常用格式字符串 含义 示例 y 年 yyyy年——2013年；yy——13年 M 月 MM月——01月；M月——1月 d 日 dd日——01日；d日——1日 H 小时(24) HH:mm:ss—12:46:33 h 小时(12) hh(a):mm:ss—12(下午):47:48 m 分钟 – s 秒 – 5.3 Calendar类 java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。 有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance(); 通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现 123Calendar c1 = Calendar.getInstance();c1.set(2008,9-1,20,8,8,8);System.out.println(c1.getTime()); 常用方法 after() before() setTime() getTime()—-&gt;Date getTimeInMillis()—-time getTimeZone()—TimeZone Calendar里面包含一个date属性 可以操作date的某一个局部信息 set get calendar.set(Calendar.YEAR,2015); int year = calendar.get(Calendar.YEAR); TimeZone java.util包 可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault(); 常用方法 tz.getID() —-&gt; Asia/Shanghai tz.getDisplayName() —-&gt; 中国标准时间 6. String类6.1 基本概念 String类 —&gt; 引用类型 —&gt; java.lang包 没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如”abc”等，任何一个字符对应2字节定长编码。 String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。 12345678910//如何构建对象String str1 = \"abc\"; //直接将字符串常量赋值给str (字符串常量池)String str2 = new String();//无参数构造方法创建空的对象String str3 = new String(\"abc\");//带string参数的构造方法创建对象byte[] bArr = &#123;97, 98, 99, 100, 101&#125;;//a:97，b:98，c:99，d:100String str4 = new String(bArr);//将数组中的每一个元素转化成对应的char 组合成Stringchar[] cArr = &#123;'h', 'e', 'l', 'l', 'o'&#125;;String str5 = new String(cArr);//将数组中的每一个char元素拼接成最终的StringString str6 = String(char[], index, count);//使用char数组中下标从index位置开始的count个字符来构造对象String str7 = String(byte[], index, length);//使用byte数组下标从index位置开始length个字节来构造对象 6.2 字符串常量池 由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。 出于性能考虑，Java虚拟机(JVM)将字符串字面量对象缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。 12345678910String str1 = \"Hello\";String str2 = \"Hello\";String str3 = new String(\"Hello\");System.out.println(str1.equals(str2));//比较内容 trueSystem.out.println(str1==str2);//比较地址 true，不会重新创建System.out.println(str1.equals(str3));//比较内容 trueSystem.out.println(str1==str3);//比较地址 false，使用new会重新创建新的String对象 //1.下面的代码中创建了几个对象并分别存放在什么位置？String s1 = \"hello\"; //1个对象，常量池。String s2 = new String(\"world\"); //2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本) 6.3 String类常用方法 第一梯队(重写): equals hashCode compareTo toString 第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。 第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。 重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口 boolean = equals(Object obj); 继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）; int = hashCode(); 继承自Object类中的方法，重写了：31*h+和… int = compareTo(); 实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致 则直接返回长度之差 String = toString() Object类中返回类名@hashCode(16进制形式) String类重写后返回的是String对象的字面值 忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase(); String类的成员方法 char charAt(int index) 返回字符串指定位置 int codePointAt(int index) “abc”0–&gt;97，返回给定index对应位置的那个char所对应的code码 String concat(String) 将给定的字符串拼接在当前字符串之后 int length() 返回字符串序列的长度 注意：区别数组的length是属性，String的length()是方法，集合是size()方法 123456789101112131415String str6 = new String(\"hello\");System.out.println(\"下标为0的字符是：\"+str6.charAt(0));// hSystem.out.println(\"字符串长度是：\"+str6.length());// 5 //将字符串\"12345\"转换为整数类型String str = new String(\"123456\"); //方式一：Integer类中的pareseInt方法int ia = Integer.parseInt(str);System.out.println(\"转换出来结果是：\"+ ia);//123456 //方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...int res = 0;for(int i=0; i&lt;str.length(); i++)&#123; res = res*10 + (str.charAt(i)-'0');&#125;System.out.println(\"转换出来结果是：\"+ res);//123456 String类的常用基本方法 boolean contains(CharSequence s) 判断当前字符串是否包含参数指定的内容 String toLowerCase() 返回小写形式 String toUpperCase() 返回大写形式 String trim() 返回去掉前后空格的字符串 boolean startsWith(String prefix) 判断是否以参数字符开头 boolean endsWith(String suffix) 判断是否以参数字符结尾 boolean equals(Object anObject) 比较字符串内容是否相等，String类已重写 boolean equalsIgnoreCase(String anotherString) 同上，并且忽略大小写 int indexOf(String str) 返回第一次出现str位置，找不到返回-1 int indexOf(String str, int fromIndex) 同上，从fromIndex开始检索 String substring(int beginIndex, int endIndex) 截取字符串，beginIndex开始，endIndex结束 String substring(int beginIndex) 截取字符串，beginIndex开始到结尾 6.4 正则相关方法 正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。 正则相关方法 boolean matches(String regex) 用于判断是否匹配正则表达式规则。 String[] split(String regx) 以正则为分割符，将字符串拆分成字符串数组 String replaceAll(String regex, String replacement) 正则替换 7. StringBuilder类/StringBuffer类7.1 基本概念 java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。 StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable StringBuffer/StringBuilder没有compareTo方法 StringBuffer/StringBuilder含有一个String没有的方法 append();拼接 7.2 特性可变字符串，char[] value; 动态扩容 7.3 对象的构建123456 //无参数构造方法 构建一个默认长度16个空间的对象 char[]StringBuilder builder = new StringBuilder(); //利用给定的参数 构建一个自定义长度空间的对象 char[]StringBuilder builder = new StringBuilder(20); //利用带String参数的构造方法 默认数组长度字符串长度+16个StringBuilder builder = new StringBuilder(\"abc\"); 7.4 StringBuilder中常用的方法 最主要的方法 append() 频繁的拼接字符串的时候使用此方法 提高性能 ensureCapacity(int minimumCapacity) 确保底层数组容量够用 capacity();//字符串底层char[]的容量 length();//字符串有效元素个数(长度) setLength();//设置字符串的有效元素个数 char = charAt(int index); int = codePointAt(int index); String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果 StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉 不用接受返回值就看到效果啦 StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦 int = indexOf(String str [,int fromIndex]); int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置 带重载 则从某一个位置开始找 insert(int index,value);//将给定的value插入在index位置之上 replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,”zzt”); setCharAt(int index,char value);//将index位置的字符改成给定的value toString();//将StringBuilder对象 构建成一个string对象 返回 trimToSize();//将数组中无用的容量去掉 变成length长度的数组 7.5 总结 StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能； 常用方法 与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()； 与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致 不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt(); String家族笔试中经常容易考察的知识点 String所属的包 继承关系 实现接口 java.lang 继承Object 接口Serializable,CharSequence,Comparable String构建方式 常量 构造方法 String对象内存结构 字符串常量区 new堆内存对象 == equals()区别 “a”+”b”+”c” String不可变特性 长度及内容 String中的常用方法 concat(); toUpperCase(); String和StringBuilder区别 | String和StringBuffer区别 String不可变字符串 JDK1.0 有一个接口Comparable 不可变体现在长度及内容 有一些方法StringBuilder没有 concat compareTo toUpperCase StringBuilder可变字符串 JDK1.5 有一个接口Appendable 可变字符串 没有final修饰 底层可以进行数组扩容 有一些方法String没有 append() insert() delete() reverse() StringBuffer和StringBuilder的不同 它们方法基本相同 StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低 StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高 8. Optional类 可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。 获取字符串长度： 方式1：if(null==str){return 0;}else{return str.length();} 方式2：return Optional.ofNullable(str).map(String::length).orElse(0); 1234567891011121314// 获取两个字符串长度和String str1 = \"zhangsan\";String str2 = null;int str1Length = Optional.ofNullable(str1).map(String::length).orElse(0);int str2Length = Optional.ofNullable(str2).map(String::length).orElse(0);System.out.println(str1Length + str2Length);//8，8+0//步骤分解://构建Optional对象Optional&lt;String&gt; op1 = Optional.ofNullable(str1);//将str1的长度的结果构建成Optional对象Optional&lt;Integer&gt; op2 = op1.map(String::length);//如果长度不为空，则获取长度值，否则返回默认值int len = op2.orElse(0);System.out.println(len);//8","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"二、JavaSE面向对象","date":"2019-07-07T10:50:47.000Z","path":"2019/07/07/02_JavaSE面向对象.html","text":"面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。Java中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。 类与对象 构造方法和方法重载 this关键字 方法的传递和递归 封装 static关键字 单例设计模式 继承（extends） 方法的重写（Override） 访问控制 包（Package） final关键字 对象的创建过程 多态 抽象类 接口 内部类 回调模式 抽象方法的笔试考点 枚举类（enum） 内存机制问题 1. 类与对象1.1 类的定义1class 类名 &#123;类体&#125; 类名由多个单词组成时，要求每个单词首字母大写 1.2 成员变量的定义1class 类名 &#123; 数据类型 成员变量名=初始值; ... &#125; 成员变量名由多个单词组成时，要求第二个起每个单词首字母大写 1.3 对象的创建1new 类名(); 当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。 1.4 引用12类名 引用变量名;Person p = new Person(); //声明person类型的引用p指向Person类型对象 12引用变量名.成员变量名;p.name = 'zhangsan'; 在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。 使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。 除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。 1.5 成员方法123class 类名 &#123; 返回值类型 成员方法名(形参列表)&#123;方法体;&#125;&#125; 返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void 形参列表：数据类型 形参1, 数据类型 形参2, … 2. 构造方法和方法重载2.1 构造方法1class 类名 &#123; 构造方法名(形参列表)&#123;构造方法体;&#125; &#125; 构造方法名与类名相同且没有返回值 当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。 2.2 默认构造方法 当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。 若类中出现自定义构造方法，则编译器不再提供构造方法。 2.3 方法重载（overload）在Java中，方法名相同，参数列表不同的方法构成重载关系。 体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同） 实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。 3. this关键字在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。 使用方式： 当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名 在构造方法的的第一行，可以调用本类中的其他构造方法。 4. 方法的传递和递归4.1 传参 基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。 引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。 引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。 4.2 递归的调用 递归是指方法体内部调用自身 必须有递归的规律和退出条件 使用递归必须使得问题简单化而不是复杂化 若递归影响到程序的执行性能时，则用递推取代之 5. 封装面向对象的三大特征：封装，继承，多态。 封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断 封装基本流程： 私有化成员变量(private) 提供公有的get、set方法，并在set方法体中进行合理性判断 在构方法中调用set方法进行合理值的判断 6. static关键字基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。 为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。 static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类) 特点 静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问 静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突 静态元素只加载一次，全部类对象及类本身共享 静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存 非静态成员和静态成员都可以访问静态成员 静态成员不可以访问非静态成员 静态元素中不可出现this或super关键字，静态元素属于类的 7. 单例设计模式基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。 12345678910/** * 编程实现Singleton类的封装 */public class Singleton&#123; private static Singleton sin = new Singleton();//2.提供本类的引用指向本类的对象 private Singleton()&#123;&#125; //1.私有化构造方法 public static Singleton getInstance()&#123;//3.提供公有的get方法将上述成员变量的数值返回出去 return sin; &#125;&#125; 实现流程： 私有化构造方法（private） 提供本类类型的引用指向本类类型对象（private static） 提供公有的get方法将上述对象return出去（public static） 实现方式：饿汉式和懒汉式，开发中推荐饿汉式。 8. 继承（extends） 继承就是子类复用父类的代码，关键字extends表示类和类的继承关系 使用继承可以提高代码复用性、扩展性、以及可维护性。 子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。 无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。 使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。 在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。 1234567891011class Cricle extends Shape&#123; int r; Cricle()&#123;&#125; //编译器会加入无参的调用 super()。 Cricle(int x, int y, int r)&#123; super(x, y); //通过super关键字调用父类的构造方法。 setR(r); &#125; public void setR(int r)&#123; this.r = r; &#125;&#125; 9. 方法的重写（Override）概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。原则： 要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。 要求访问权限不能变小，可以相同或变大 重写的方法不能抛出更大的异常 10. 访问控制 public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用， 通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰 访问控制符 访问权限 本类内部 本类中的包 子类 其他包 public 共有的 Y Y Y Y protected 保护的 Y Y Y N 不写 默认的 Y Y N N private 私有的 Y N N N 11. 包（Package）为了解决命名冲突问题，便于文件的管理 1234package 包名；package 包名1.包名2.包名3...包名n;/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */org.apache.commons.lang.StringUtil; 12. final关键字 final关键字修饰类体现该类不能被继承（防止滥用继承）。 final关键字修饰方法体现在该方法不能被重新，但可以被继承（防止不经意间造成的方法重写）。 final关键字修饰成员变量体现在改成员变量必须初始化且不能更改（防止不经意间造成的数据更改）。 扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用public static final共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。 13. 对象的创建过程 单个对象的创建过程 main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理； 若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理； 执行构造块中的代码可以对成员变量进行赋值； 执行构造方法体中的代码可以对成员变量进行再次赋值； 此时对象构造完毕，继续向下执行后续的代码； 子类对象的创建过程 main方法是程序的入口，先加载父类的的代码再加载子类的代码； 先执行父类静态代码块，再执行子类的静态代码块； 先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕； 先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。 14. 多态 语法：父类的引用指向子类的对象 123父类类型 引用变量名 = new 子类类型();Person pw = new Worker();pw.show();//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。 多态的效果： 父类的引用可以直接调用父类独有的方法。 父类的引用不可以直接调用子类独有的方法。 对于父类子类都有的非静态方法来说，编译阶段调用父类的，运行阶段调用子类重写后的。 对于父类子类都有的静态方法来说，只调用父类的。 多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。 多态的表现形式 多态的前提要有继承的关系 使用父类引用指向子类对象 Person p = new Teacher();//向上转型 该引用只能调用父类中定义的属性/方法 执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写 若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException 引用数据类型之间的转换 转换必须发生在父子类之间，否则编译报错。 自动类型转换：小到大，子类型向父类型的转换，eg:Person pw = new Worker();。 强制类型转换：大到小，父类型向子类型转换，eg:((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法。 为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。 123456/*语法格式：*/ 对象 instanceof 类型 //返回布尔值if(pw instanceof Teacher)&#123; Teacher t = (Teacher) pw;&#125;else&#123; System.out.println(\"转换会有异常\");&#125; 多态的使用场合： 1234567// 通过方法的参数传递形成多态。public static void draw(Shape s)&#123;&#125;TestShape.draw(new Rect(1,2,3,4));// 在方法体中直接使用多态的语法格式。TestAbstrat ta = new SubTestAbstract();ta.show(); 15. 抽象类 基本概念 用abstract关键字修饰的类称为抽象类。 抽象类不能实例化，抽象类的意义在于被继承。 抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。 抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。 12345public abstract class Shape&#123; //一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类 private int x; private int y; public abstract boolean contains(int x, int y);//用abstract修饰的方法，称之为抽象方法，没有方法体&#125; 注意： 抽象类中可以有成员变量，成员方法，以及构造方法。 抽象类中可以没有抽象方法，也可以有抽象方法。 具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。 子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。 抽象类对子类具有强制性和规范性，因此叫做模板设计模式。 推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。 多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。 16. 接口 基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过interface关键字定义。 1234interface Runner &#123; //-通过interface关键字定义接口 public static final int SEF_SPEED=100;//-接口中不能定义成员变量，只能定义常量 public void run();//-接口中只可以定义没有实现的方法（可以省略public abstract）&#125; 一个类可以通过implements关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。 12345678910class American implements Runner,... &#123; //与继承不同，可以实现多个接口 @Override public void run()&#123;//该类需要实现接口中定义的所有方法 System.out.println(\"run...\"); &#125; public static void main(String[] args) &#123; Runner ra = new American();//接口作为一种类型声明，并且声明的变量可以引用实现类的对象 ra.run();//通过该变量可以调用该接口定义的方法 &#125;&#125; 一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。 1interface Hunter extends Runner&#123;...&#125; 类与接口的关系 类和类使用extends继承，仅支持单继承。 接口和接口使用extends继承，支持多继承。 类使用implements实现接口，支持多实现。 抽象类与接口的关系（笔试题） 定义抽象类:abstract class，而定义接口:interface； 类继承抽象类:extends单继承，而类实现接口:implements多实现； 抽象类可以有构造方法，而接口不能有构造方法； 抽象类可以有成员变量，而接口只能有常量； 抽象类可以有成员方法，而接口只能有抽象方法； 抽象类中增加方法子类可以不用重写，而接口中增加方法子类必须重写； 从jdk1.8开始允许接口中有非抽象方法，但需要default关键字修饰。 17. 内部类 内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部 内部类定义在 类的内部 ，与类成员层次一致 内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次） 成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致 局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次 匿名内部类：成员匿名内部类，局部匿名内部类 静态内部类：成员静态内部类 17.1 *成员内部类 将一个类直接定义在类的里面，作为成员，与属性或方法层次一致 成员内部类可以与正常类一样 使用不同的修饰符来修饰 好处1.省略了一个.java文件 好处2.成员内部类中可以访问外部类的所有成员 包括私有的 若想要在内部类中通过对象.调用外部类成员 外部类.this.外部类成员; 内部类存在后 源代码进行编译 产生一个字节码 Demo$InnerDemo.class 17.2 局部内部类 将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次 局部内部类像是一个局部的变量一样，不能用public protected private及static 只能用abstract或final 局部内部类命名规则Demo$1InnerTestMethod Demo$2InnerTestMethod 局部内部类使用的变量只能是final修饰 17.3 *匿名内部类将类直接定义在类中 或者类成员中 成员匿名内部类 局部匿名内部类匿名内部类没有类的所有结构(名字 修饰符) 只有类体通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类匿名类内部没有构造方法，也不能用任何修饰符来修饰 当接口类型的引用作为方法的形参时，实参的传递方式有两种： 自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。 直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。 12345678910111213141516171819202122232425262728293031public interface A &#123; public abstract void show();&#125;//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递public class SubA implements A &#123; @Override public void show() &#123; System.out.println(\"这里自定义类实现接口并重写抽象方法！\"); &#125;&#125;//测试类public class ATest &#123; public static void test(A a) &#123; a.show(); &#125; public static void main(String[] args) &#123; //ATest.test(new A());//报错，A是接口，不能new对象 //-方式1：接口实现类的对象作为实参传递 ATest.test(new ASub());//接口类型引用指向实现类的对象，形成了多态。 //-方式2：匿名内部类 // 接口/父类类型 引用变量名 = new 接口/父类类型() &#123;方法的重写&#125;; A ta = new A() &#123; @Override public void show() &#123; System.out.println(\"这里是匿名内部类\"); &#125; &#125;; ATest.test(ta);//得到接口类型的引用，再作为实参传递 &#125;&#125; 匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。 语法格式：接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};。 1SuperType obj = new SuperType(...)&#123; ... &#125;; 17.4 静态内部类 成员静态内部类 不需要外部类对象，通过正常的方式直接创建内部类 静态元素不能访问非静态成员(自己类和外部类) 18. 回调模式回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法 123456789101112131415interface Action&#123; public void doSth();&#125;//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次public static void repeat(int n, Action ac)&#123; for(int i=0; i&lt;n; i++)&#123; ac.doSth();&#125;&#125;//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。public static void main(String[] args)&#123; repeat(5, new Action()&#123;//通过匿名内部类传递参数 public void doSth()&#123; System.out.println(\"Hello\") &#125; &#125;);&#125; 19. 抽象方法的笔试考点 abstract与哪些关键字不能共存： final关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。 static关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。 private关键字；因为private修饰的私有方法不能被继承，就不能重写，而abstract方法需要重写。 20. 枚举类（enum） 一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来 创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。 我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object Enum类型，有两个属性 name—–&gt;枚举对象的名字，name()获取name属性 ordinal—&gt;枚举对象在类中罗列的顺序 类似index 也从0开始 ordinal()获取序号 一些常用的方法 valueOf() 通过给定的name获取对应的枚举对象 values() 获取全部的枚举对象 —&gt; 返回一个数组 Day[] compareTo() 可以比较两个枚举对象 int toString() 由于这个方法没有final修饰 可以覆盖(重写) switch内部判断枚举的应用 我们也可以在enum中描述自己的一些属性或方法 必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束; 可以定义自己的属性 类创建的过程中 帮我们创建枚举类型的对象 需要给枚举类型提供对应样子的构造方法 构造方法只能private修饰 可以重载 1234567891011121314151617181920public enum Day&#123; //描述了七个当前类的对象 monday(\"星期一\",1),tuesday(\"星期二\",2),wednesday,thursday,friday,saturday,sunday; private String name; private int index; private Day()&#123;&#125; private Day(String name,int index)&#123; this.name=name; this.index=index; &#125; public String getName()&#123; return this.name; &#125; public void setName(String name)&#123; this.name=name; &#125;&#125; 21. 内存机制问题 类创建在哪儿 对象创建在哪里 继承关系 静态成员 方法执行 栈内存—&gt;Person p = new Person();—-&gt;堆内存 方法区—类模板 栈内存—-变量空间,方法临时执行空间（从创建开始执行完毕,立即回收） 堆内存—-new申请对象空间（垃圾回收器GC,对象空间没有任何引用指向视为垃圾） 方法区—-常量 类模板 静态成员（有且只有一份,不回收） Runtime类(是单例模式)之中提供了几个管理内存的方法 maxMemory totalMemory freeMemory 栈内存溢出错误StackOverflowError 堆内存溢出错误OutOfMemoryError Object类中有一个finalize方法 如果重写也能看见对象回收的效果 GC系统提供的一个线程 回收算法","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"一、JavaSE语法基础","date":"2019-07-07T09:33:54.000Z","path":"2019/07/07/01_JavaSE语法基础.html","text":"这是javaSE知识梳理的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。 数据类型 变量与常量 数据类型之间的转换 运算符 循环 数组 函数 1. 数据类型1.1 分为两大类： 基本数据类型：byte，short，int，long，float，double，boolean，char 引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface 注：单个字节表示8位二进制位，最左边表示符号位（0：正，1：负）。 1.2 整数类型（byte，short，int，long） byte： 1个字节，范围-2^7~2^7-1，即-128~127。 short：2个字节，范围-2^15~2^15-1，即-32768~32767。 int: 4个字节，范围-2^31~2^31-1，即正负21亿之间。 long： 8个字节，范围-2^63~2^63-1，比int更大。如果要表示long直接量，需要L或l结尾。 1.3 浮点类型（float，double） float： 4个字节，单精度浮点数，取到小数点后7位有效数字。如果要表示float直接量，需要F或f结尾 double：8个字节，双精度浮点数，取到小数点后15位有效数字。 扩展：浮点运算有时会有误差，为了实现精确运算可使用java.math.BigDecimal类型加以描述。 1.4 布尔类型（boolean） boolean：1个字节（未明确规定），值只有true和false。 1.5 字符类型（char） char：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：’a’,’1’,’中’ 等。 开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号””引起来。 需记住的ASII码字符：’a’:97，’A’:65，’0’:48，空格:32，换行符:10 常用转义符(逃逸字符)：\\t:制表符，\\n:换行，\\&quot;，\\&#39;，\\\\:反斜杠本身，\\b:回退一格，\\r:回车 字符类型计算 一个字符加一个数字，得到Unicode码表中那个数之后的字符 两个字符相减得到它们在表中的距离 char也可以和int之间相互赋值 2. 变量与常量2.1 常量 常量是一个值，在程序运行的过程中不能再次发生改变 基本类型的值都可以认为是常量 4 3.4 ‘a’ true，String类(引用数据类型)值”abc”视为常量 常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小 32bit–int 64bit–double 2.2 变量 变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的 变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字 变量空间 里面只能存储一个内容(值/引用) 空间内的内容的类型与定义时一致 内容可以改变 内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值 2.3 标识符（变量）命名规则 必须字母，数字，下划线以及美元$等组成，且首位非数字。 不能使用Java语言中的关键字，如class，static，void，int等。 区分大小写，长度无限制，但不能过长，尽量见名知意。 2.3 命名的规约 类名字：首字母大写，如果两个以上的单词，所有首字母都大写 变量名：首字母小写，如果两个以上的单词，之后的首字母大写 遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性 3. 数据类型之间的转换3.1 基本数据类型之间转换 自动类型转换：从小类型到大类型自动转换 12byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double char -----^ 强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出 12long big = 1024L\\*1024\\*1024;int i = (int)big; 3.2其他数据类型之间转换 同种大数据类型之间才能发生转换 类型转换之前，保证大前提：同种大数据类型一致 基本–基本 可以直接转换(自动 强制) 引用–引用 可以直接转化(自动 强制 – 上转型 下转型) 基本–引用 不可以直接进行转化(间接-桥梁-包装类) 保证大数据类型一致的前提下(都是基本类型) 小数据类型一致:整型–&gt;整型 / 浮点–&gt;浮点 比较内存空间的大小 大数据类型空间可以直接接受小数据类型的值(自动转换) 小数据类型空间不可以直接接受大数据类型的值(强制类型转换) 强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据1234byte a = 1; int b = a;//自动直接转化就可以int a = 1; byte b = (byte)a;//需要强制类型转换float x = 3.4F; double y = x;//自动直接转化double x = 3.4; float y = (float)x;//强制转换 小数据类型不一致:整型–&gt;浮点 比较精确程度 浮点型的精确程度更高 任何一个浮点型空间都可以直接接受一个整型的值 反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)12int a = 1; float b = a;//自动直接转化float a =1.0F; int b = (int)a;//强制类型转换 整型–&gt;字符 每一个字符都对应这一个Unicode码 a–9712char x = &apos;a&apos;; int y = x;//自动转化 y--97int x = 97; char y = (char)x;//强制的转化 布尔类型很特殊 不能与其他基本类型之间发生转化 4. 运算符 算术运算符： +，-，*，/，% 关系运算符： &gt;，&lt;，&gt;=，&lt;=，==，!= 自增减运算符： ++，-- 逻辑运算符： &amp;&amp;，||，！（短路特性：逻辑与&amp;&amp;运算，若第一个条件为假,跳过第二个条件；逻辑或||运算，若第一个条件为真，跳过第二个条件） 三目运算符： 条件 ? 表达式1 ： 表达式2 赋值运算符：=，+=，-=，*=，= 5. 循环 while循环和for循环完全可以互换。 while循环主要用于明确循环条件，但不明确循环次数的场合 for循环主要用于明确次数或范围的场合 while(true) 等价于 for(;;)，表示无限循环。 6. 数组6.1 一维数组 数组类型[] 数组名 = new 数据类型[长度] ：动态方式 12数组类型[] 数组名 = new 数据类型[长度] //动态方式int[] arr = new int[5]; 123数组类型[] 数组名 = &#123;初始值1, 初始值1, 初始值1, ...&#125; //静态方式int[] arr = &#123;10, 20, 30, 40&#125;;/*特殊方式：*/ int[] arr = new int[]&#123;10, 20, 30&#125;; 6.2 二维数组12数组类型[][] 数组名 = new 数据类型[行数][列数]int[][] arr = new int[5][6]; 12数组类型[][] 数组名 = &#123;&#123;初始值1, 初始值1, 初始值1&#125;,&#123;值2,...&#125; ...&#125;int[] arr = &#123;&#123;10, 20, 30&#125;, &#123;01, 5, 3&#125;, &#123;8, 20, 6&#125;&#125;; 二维数组arr.length表示行数，arr[0].length表示此行的长度 7. 函数 函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。 123456789public static int sum(int a, int b)&#123; int i; int sum=0; for(i=a; i&lt;=b; i++)&#123; sum += i; &#125; System.out.println(a +\"到\"+ b +\"的和是\"+ sum); return sum;&#125; 函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序 函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用","tags":[{"name":"javaSE","slug":"javaSE","permalink":"http://chaooo.github.io/tags/javaSE/"},{"name":"后端开发","slug":"后端开发","permalink":"http://chaooo.github.io/tags/后端开发/"}]},{"title":"Win10下配置Nginx+PHP-7+MySQL-5.6","date":"2019-02-22T03:39:12.000Z","path":"2019/02/22/Win10下配置Nginx-php7-mysql-5-6.html","text":"1. 软件下载 Windows操作系统。 Nginx，下载地址：http://nginx.org/en/download.html。 PHP，下载地址：http://php.net/downloads.php（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。 MySQL，下载地址：https://www.mysql.com/downloads/。（选择社区版Community-&gt;MySQL Community Server-&gt;MySQL Community Server 5.6，根据Windows系统选择对应zip包）。 2. 软件安装在C盘新建安装目录C:\\PHP。2.1 Nginx安装Nginx本身就是绿色软件，下载zip安装包解压到C:\\PHP，打开目录C:\\PHP\\nginx-1.15.8双击nginx.exe就可以运行，然后在浏览器打开http://127.0.0.1，出现欢迎界面表示NGINX正常工作。确认NGINX正常工作后在任务管理器中结束nginx.exe任务。2.2 PHP安装把PHP的zip安装包解压到C:\\PHP，解压后PHP安装目录为：C:\\PHP\\php-7.3.2。cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。将C:\\PHP\\php-7.3.2加入系统环境变量。2.3 准备网站根目录准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把C:\\PHP\\web作为我的网站根目录。在根目录C:\\PHP\\web下新建一个info.php文件，输入如下内容：123&lt;?php phpinfo();?&gt; 2.4 让nginx识别PHP 配置PHP (C:\\PHP\\php-7.3.2) 在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf: 在PHP根目录下修改配置文件C:\\PHP\\php-7.3.2\\php.ini-development并另存为php.ini,在其中修改或添加配置： 1cgi.fix_pathinfo=1 配置nginx conf(C:\\PHP\\nginx-1.15.8\\conf) 在Nginx根目录下找到conf目录，编辑器打开C:\\PHP\\nginx-1.15.8\\confnginx.conf: 123456789101112131415161718192021222324252627282930error_log logs/error.log; #打开error_loghttp &#123; # ... server &#123; # ... location / &#123; root C:\\PHP\\web; #配置根目录 index index.html index.htm index.php; &#125; # ... # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # 打开下面几行注释 location ~ \\.php$ &#123; root C:\\PHP\\web; #配置根目录 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; #重要: 把下面 /scripts 修改成 $document_root fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; # ... &#125;&#125; 2.5 运行与测试nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么nginx.conf中有这样一句fastcgi_pass 127.0.0.1:9000;。 在任务管理器中结束nginx.exe任务，然后到C:\\PHP\\nginx-1.15.8目录双击nginx.exe开启服务。 在命令行中，cd到php的home目录C:\\PHP\\php-7.3.2，然后执行如下命令： 1php-cgi.exe -b 127.0.0.1:9000 -c php.ini 打开浏览器，输入 http://127.0.0.1/info.php，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。 2.6 MySQL安装 把MySQL的zip安装包解压到C:\\PHP，解压后PHP安装目录为：C:\\PHP\\mysql-5.6.43-winx64。 将C:\\PHP\\mysql-5.6.43-winx64\\bin加入系统环境变量。 修改配置文件C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini并另存为my.ini,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）： 12basedir=C:\\PHP\\mysql-5.6.43-winx64 #mysql所在目录datadir=C:\\PHP\\mysql-5.6.43-winx64\\data #mysql所在目录\\data 以管理员身份运行cmd,到安装目录的bin下，输入mysqld -install： 12C:\\PHP\\mysql-5.6.43-winx64\\bin&gt; mysqld -installService successfully installed. 输入命令:mysql --version,正常会显示版本信息。 输入命令:net start mysql启动服务(停止命令：net stop mysql): 123C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;net start mysqlMySQL 服务正在启动 ..MySQL 服务已经启动成功。 服务启动成功之后，输入命令：mysql -u root -p（第一次登录没有密码，直接按回车过）: 1234567891011C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 1Server version: 5.6.43 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.mysql&gt; 如出现mysql&gt;,即登录成功。 输入命令exit,退出登录。 123mysql&gt; exitByeC:\\PHP\\mysql-5.6.43-winx64\\bin&gt; 3. 制作自动启动脚本控制台就一直开着，很不方便。这个时候可以使用 RunHiddenConsole.zip 来得管理服务的启动与关闭。 3.1 启动脚本在目录C:\\PHP下新建一个start.bat作为启动脚本文件： 12345678910111213141516171819202122:启动脚本@echo offset php_home=./php-7.3.2set nginx_home=./nginx-1.15.8REM Windows 下无效REM set PHP_FCGI_CHILDREN=5REM 每个进程处理的最大请求数，或设置为 Windows 环境变量set PHP_FCGI_MAX_REQUESTS=1000echo Starting PHP FastCGI...RunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.iniecho FastCGI 启动成功echo.echo Starting nginx...RunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%echo nginx 启动成功echo.:echo 15秒后自动退出:ping 0.0.0.0 -n 15 &gt; null:请按任意键继续. . .pause 3.2 停止脚本在目录C:\\PHP下新建一个stop.bat作为停止脚本文件： 123456789101112:停止脚本@echo offecho Stopping nginx... taskkill /F /IM nginx.exe &gt; nulecho nginx 已停止:换行echo.echo Stopping PHP FastCGI...taskkill /F /IM php-cgi.exe &gt; nulecho FastCGI 已停止:请按任意键继续. . .pause 3.3 重启脚本在目录C:\\PHP下新建一个restart.bat作为重启脚本文件： 12345678910111213141516171819202122232425262728293031323334:停止脚本@echo offecho Stopping nginx... taskkill /F /IM nginx.exe &gt; nulecho nginx 已停止:换行echo.echo Stopping PHP FastCGI...taskkill /F /IM php-cgi.exe &gt; nulecho FastCGI 已停止echo.:启动脚本@echo offset php_home=./php-7.3.2set nginx_home=./nginx-1.15.8REM Windows 下无效REM set PHP_FCGI_CHILDREN=5REM 每个进程处理的最大请求数，或设置为 Windows 环境变量set PHP_FCGI_MAX_REQUESTS=1000echo Starting PHP FastCGI...RunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.iniecho FastCGI 启动成功echo.echo Starting nginx...RunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%echo nginx 启动成功echo.:echo 15秒后自动退出:ping 0.0.0.0 -n 15 &gt; null:请按任意键继续. . .pause 4.最后我的根目录结构 123456789101112131415161718C:\\PHP&gt;dir 驱动器 C 中的卷是 系统 卷的序列号是 09C1-B27D C:\\PHP 的目录2019/02/22 15:46 &lt;DIR&gt; .2019/02/22 15:46 &lt;DIR&gt; ..2019/02/22 11:23 &lt;DIR&gt; mysql-5.6.43-winx642018/12/25 17:54 &lt;DIR&gt; nginx-1.15.82019/02/21 15:59 &lt;DIR&gt; php-7.3.22019/02/22 15:41 758 restart.bat2010/10/26 11:43 1,536 RunHiddenConsole.exe2019/02/22 15:41 549 start.bat2019/02/22 15:41 227 stop.bat2019/02/21 16:56 &lt;DIR&gt; web 4 个文件 3,070 字节 6 个目录 100,959,772,672 可用字节","tags":[]},{"title":"BlueLake博客主题的详细配置","date":"2016-12-29T03:25:33.000Z","path":"2016/12/29/BlueLake博客主题的详细配置.html","text":"开始之前BlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 1. 安装您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。 1.1 安装主题在根目录下打开终端窗口： git bash1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。 git bash12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。 根_config.yml_config.yml1theme: BlueLake 1.4 验证首先启动 Hexo 本地站点，并开启调试模式： git bash1$ hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 1.5 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。 git bash12cd themes/BlueLakegit pull 2. 配置2.1 配置网站头部显示文字打开根_config.yml，找到： 根_config.yml_config.yml1234title: subtitle: description: author: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。 2.2 设置语言该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下： 根_config.yml_config.yml1language: zh-CN 2.3 设置菜单打开主题_config.yml，找到： 主题_config.ymlthemes/BlueLake/_config.yml12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive # - page: about # directory: about/ # icon: fa-user - page: rss directory: atom.xml icon: fa-rss 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好： 主题_config.ymlthemes/BlueLake/_config.yml12345# About page about: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 2.3.1 添加about页此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面： git bash1$ hexo new page 'about' 打开主题_config.yml，补全关于我页面的详细信息： 主题_config.ymlthemes/BlueLake/_config.yml12345678# About page about: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件在根目录下打开命令行窗口： git bash123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置： 主题_config.ymlthemes/BlueLake/_config.yml1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.4 添加本地搜索默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件： git bash1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置： 根_config.yml_config.yml123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置： 主题_config.ymlthemes/BlueLake/_config.yml1local_search: true 2.5 修改站点图标站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为** favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。) 2.6 添加站点关键字请在hexo目录的根_config.yml中添加keywords字段，如： 根_config.yml_config.yml1234567# Sitetitle: Hexosubtitle: 副标题description: 网站简要描述,如：Charles·Zheng's blog.keywords: 网站关键字, key, key1, key2, key3author: Charleslanguage: zh-CN 2.7 首页添加文章置顶在根目录下打开命令行窗口安装： git bash12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。 123456---title: BlueLake博客主题的详细配置tags: [hexo,BlueLake]categories: hexo博客折腾top: true--- 2.8 更换主题背景和添加文章版权信息更换主题背景为深色 主题_config.ymlthemes/BlueLake/_config.yml 12# Theme tonedark: true #true/false 添加文章版权信息 主题_config.ymlthemes/BlueLake/_config.yml 12345# Theme tone#Copyrightcopyright: enable: true #true/false describe: 转载请注明出处(必须保留原文作者署名原文链接) #自定义描述替换默认描述 2.9 其他配置主题_config.yml的其他配置 show_category_count——是否显示分类下的文章数。 widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。主题_config.ymlthemes/BlueLake/_config.yml 12show_category_count: true widgets_on_small_screens: true 3.集成第三方服务3.1 添加评论目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。 注册并获得代码。 若使用多说评论，注册多说后获得short_name。 若使用Disqus评论，注册Disqus后获得short_name。 若使用来必力评论，注册来必力,获得data-uid。 若使用友言评论，注册友言,获得uid。 若使用网易云跟帖评论，注册网易云跟帖,获得productKey。 若使用畅言评论，注册畅言，获得appid，appkey。 配置主题_config.yml：主题_config.ymlthemes/BlueLake/_config.yml12345678910#Cmmentscomment: duoshuo: ## duoshuo_shortname disqus: ## disqus_shortname livere: ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey) 3.2 百度统计 登录百度统计，定位到站点的代码获取页面。 复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000) 配置主题_config.yml:主题_config.ymlthemes/BlueLake/_config.yml 1baidu_analytics: 8006843039519956000 注意： baidu_analytics不是你的百度id或者百度统计id如若使用谷歌统计，配置方法与百度统计类似。 3.3 卜算子阅读次数统计主题_config.ymlthemes/BlueLake/_config.yml1busuanzi: true 若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。 3.4 微博秀微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。 登录微博开放平台，选择微博秀。 为了与主题风格统一，作如下配置 基础设置：高400px；勾选宽度自适应；颜色选择白色； 样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8； 模块设置：去掉标题、边框、粉丝的勾选框，只留微博。 复制代码里src=&quot;&quot;里引号包裹的内容，替换到layout/_widget/weibo.jadeweibo.jadelayout/_widget/weibo.jade1234.widget .widget-title i(class='fa fa-weibo')= ' ' + __('新浪微博') iframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1\") 这只是为了和主题的风格统一，当然您也可以自由随意发挥。 注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaooo.github.io/tags/hexo/"},{"name":"BlueLake","slug":"BlueLake","permalink":"http://chaooo.github.io/tags/BlueLake/"}]},{"title":"自定义HEXO站内搜索Javascript+json","date":"2016-11-09T01:24:56.000Z","path":"2016/11/09/自定义HEXO站内搜索Javascript-json.html","text":"开始之前目前很多Hexo博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源： hexo-generator-search生成xml格式的数据文件。 hexo-generator-json-content 生成json格式的数据文件。今天的主角是hexo-generator-json-content，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。 1.安装1$ npm install hexo-generator-json-content@2.2.0 --save 然后执行hexo generate时会自动生成content.json文件，若使用默认设置，生成的数据结构如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445meta: &#123; title: hexo.config.title, subtitle: hexo.config.subtitle, description: hexo.config.description, author: hexo.config.author, url: hexo.config.url&#125;,pages: [&#123; //-&gt; all pages title: page.title, slug: page.slug, date: page.date, updated: page.updated, comments: page.comments, permalink: page.permalink, path: page.path, excerpt: page.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: page.content, //-&gt; only text minified ;) raw: page.raw, //-&gt; original MD content content: page.content //-&gt; final HTML content&#125;],posts: [&#123; //-&gt; only published posts title: post.title, slug: post.slug, date: post.date, updated: post.updated, comments: post.comments, permalink: post.permalink, path: post.path, excerpt: post.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: post.content, //-&gt; only text minified ;) raw: post.raw, //-&gt; original MD content content: post.content, //-&gt; final HTML content categories: [&#123; name: category.name, slug: category.slug, permalink: category.permalink &#125;], tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;]&#125;] 2.配置hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下： 123456789101112131415161718192021222324252627282930313233jsonContent: meta: true keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish) pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false categories: true tags: true 因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在hexo/_config.yml中加入： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true #文章标题 date: true #发表日期 path: true #路径 text: true #文本字段 raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true #标签 这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。例如： 1234567891011&#123; \"title\": \"自定义HEXO站内搜索Javascript+json\", \"date\": \"2016-11-09T01:24:56.000Z\", \"path\": \"2016/11/09/自定义HEXO站内搜索Javascript-json.html\", \"text\": \"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\", \"tags\": [&#123; \"name\": \"javascript,hexo\", \"slug\": \"javascript-hexo\", \"permalink\": \"http://chaoo.oschina.io/tags/javascript-hexo/\" &#125;]&#125; 3.JavaScript实现代码接下来就是用JS实现查询方法并把结果渲染到页面。 3.1 xhr加载数据12345678910111213141516171819202122var searchData;function loadData(success) &#123; if (!searchData) &#123; var xhr = new XMLHttpRequest(); xhr.open('GET', '/content.json', true); xhr.onload = function() &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; var res = JSON.parse(this.response || this.responseText); searchData = res instanceof Array ? res : res.posts; success(searchData); &#125; else &#123; console.error(this.statusText); &#125; &#125;; xhr.onerror = function() &#123; console.error(this.statusText); &#125;; xhr.send(); &#125; else &#123; success(searchData); &#125;&#125; 3.2 匹配文章内容返回结果12345678910function matcher(post, regExp) &#123; // 匹配优先级：title &gt; tags &gt; text return regtest(post.title, regExp) || post.tags.some(function(tag) &#123; return regtest(tag.name, regExp); &#125;) || regtest(post.text, regExp);&#125;function regtest(raw, regExp) &#123; regExp.lastIndex = 0; return regExp.test(raw);&#125; 3.3 结果渲染到页面123456789101112131415function render(data) &#123; var html = ''; if (data.length) &#123; html = data.map(function(post) &#123; return tpl(searchTpl, &#123; title: post.title, path: post.path, date: new Date(post.date).toLocaleDateString(), tags: post.tags.map(function(tag) &#123; return '&lt;span&gt;' + tag.name + '&lt;/span&gt;'; &#125;).join('') &#125;); &#125;).join(''); &#125; &#125; 3.3 查询匹配1234567891011function search(key) &#123; // 关键字 =&gt; 正则，空格隔开的看作多个关键字 // a b c =&gt; /a|b|c/gmi var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi'); loadData(function(data) &#123; var result = data.filter(function(post) &#123; return matcher(post, regExp); &#125;); render(result); &#125;);&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaooo.github.io/tags/hexo/"},{"name":"javascript","slug":"javascript","permalink":"http://chaooo.github.io/tags/javascript/"}]},{"title":"好用的Web包管理器-Bower","date":"2016-08-12T07:32:41.000Z","path":"2016/08/12/Web包管理器-Bower.html","text":"Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。 开始之前在安装bower之前，必须确认你已经安装了Node.js和Git。 1.安装Bower使用npm，打开终端，键入： 1npm install -g bower #全局安装bower 移步这里查看不同平台上安装的问题。 2.使用Bower使用help命令查看帮助。 12345678910111213141516171819202122232425262728293031323334bower helpUsage: bower &lt;command&gt; [&lt;args&gt;] [&lt;options&gt;]Commands: cache Manage bower cache help Display help information about Bower home Opens a package homepage into your favorite browser info Info of a particular package init Interactively create a bower.json file install Install a package locally link Symlink a package folder list List local packages - and possible updates login Authenticate with GitHub and store credentials lookup Look up a package URL by name prune Removes local extraneous packages register Register a package search Search for a package by name update Update a local package uninstall Remove a local package unregister Remove a package from the registry version Bump a package versionOptions: -f, --force Makes various commands more forceful -j, --json Output consumable JSON -l, --loglevel What level of logs to report -o, --offline Do not hit the network -q, --quiet Only output important information -s, --silent Do not output anything, besides errors -V, --verbose Makes output more verbose --allow-root Allows running commands as root -v, --version Output Bower version --no-color Disable colorsSee 'bower help &lt;command&gt;' for more information on a specific command. 3.安装包到本地通过命令bower install安装软件包默认到bower_components/目录。 1bower install &lt;package&gt; #package为包名 想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它. 12345bower install # 通过 bower.json 文件安装bower install jquery # 通过在github上注册的包名安装bower install desandro/masonry # GitHub短链接bower install git://github.com/user/package.git # Github上的 .gitbower install http://example.com/script.js # URL 安装选项 12345-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Save installed packages into the project’s bower.json dependencies-D, --save-dev: Save installed packages into the project’s bower.json devDependencies-E, --save-exact: Configure installed packages with an exact version rather than semver 4.用bower.json文件来管理依赖发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。在项目中执行 1bower init 会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上--save即可。 5.使用下载好的包对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如： 12&lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt;&lt;script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; 6.更新包若下载的包升级了，只需执行update命令即可更新，例如： 1bower update jquery 这样就可以自动升级到最新版的jquery了。更新选项 1234-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Update dependencies in bower.json-D, --save-dev: Update devDependencies in bower.json 7.搜索包12bower search #搜索所有包bower search &lt;packageName&gt; #搜索指定名称的包 或者可以在这里:https://bower.io/search/搜索喜欢的包. 8.卸载包1bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;] 卸载选项 12-S, --save: Remove uninstalled packages from the project’s bower.json dependencies-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies","tags":[{"name":"bower","slug":"bower","permalink":"http://chaooo.github.io/tags/bower/"}]},{"title":"MongoDB学习笔记","date":"2016-07-30T10:20:16.000Z","path":"2016/07/30/MongoDB学习笔记.html","text":"part1 安装配置一、安装：在mongodb官网下载对应自己电脑系统的安装包，地址为： http://www.mongodb.org/downloads。 1、以Windows64bit为例，下载.msi文件双击安装。2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db) 123D:cd D:\\MongoDB\\binmongod --dbpath D:\\MongoDB\\data\\db 5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：) 12MongoDB shell version: 3.2.4 //mongodb版本connecting to: test //默认shell连接的是本机localhost 上面的test库 此时就可以操作数据库了。 二、将MongoDB服务器作为Windows服务运行1、在D:\\MongoDB目录下创建mongodb.config,写入如下： 12345## 数据库文件目录dbpath=D:/MongoDB/data## 日志目录logpath=D:/MongoDB/log/mongo.logdiaglog=3 2、常规命令(cmd管理员): 123D:cd D:\\MongoDB\\binmongod --config D:\\MongoDB\\mongodb.config 3、若常规方式失败，则sc方式(cmd管理员)： 123D:cd D:\\MongoDB\\binsc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot; 访问地址：localhost:27017测试是否启动成功 part2 CRUD操作(Creat,Read,Update,Delete)一、基础：1、document(文档) MongoDB把所有数据存放在类似于JSON数据结构的文档内： 1&#123; \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" &#125; 2、collection(集合) 集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。 123&#123; \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" &#125;&#123; \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" &#125;&#123; \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" &#125; 3、database(数据库) MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。 二、数据库操作：连接及运行mongoDB“show dbs“命令可以显示所有的数据的列表“db“命令可以显示当前数据库对象或集合“use“命令可以连接到一个指定的数据库数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。 1.不能是空字符串（””)。 2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。 3.应全部小写。 4.最多64字节。 1、创建数据库：use Database_Name 1use test ##创建名为test的数据库 2、删除当前数据库： 1db.dropDatabase() 三、文档操作（以 Collection_Name = col 为例）1、插入：12345678910db.col.insert(Document) ##插入一条或多组数据db.col.insertOne(Document) ##插入一条数据db.col.insertMany(Document) ##插入多条数据##例如： db.col.insertOne(&#123; \"item\": \"pencil\", \"type\": \"no.1\" &#125;) db.col.insertMany([ &#123; \"item\": \"dog\", \"type\": \"no.2\" &#125;, &#123; \"item\": \"apple\", \"type\": \"no.3\" &#125;, &#123; \"item\": \"orange\", \"type\": \"no.4\" &#125; ]) 2、删除：123456789db.col.remove(&#123;&#125;) ##删除所有数据db.col.remove(query &lt;,options&gt;) # query: 查询条件(数据索引或名字) # ptions:两个可选参数 # &#123;justOne: &lt;boolean&gt;, //默认false，删除所有匹配到的。 # writeConcern: &lt;document&gt;//抛出异常的级别。 # &#125;db.col.deleteOne(query &lt;,options&gt;) ##同上，无justOne参数，只删除第一条db.col.deleteMany(query &lt;,options&gt;) ##同上，无justOne参数，只删除多条 3、更新：123456789101112131415161718db.col.update(query, update &lt;,options&gt;) # query: 查询条件(数据索引或名字) # update: 更新的内容，语法：&#123;$set:query&#125; # options:三个可选参数 # &#123;upsert: &lt;boolean&gt;, //如果不存在update的记录，是否插入新数据，默认:false。 # multi: &lt;boolean&gt;, //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。 # writeConcern: &lt;document&gt;//#抛出异常的级别。 # &#125;##例如： db.col.update( &#123;\"type\": \"no.1\"&#125;, &#123;$set: &#123;\"item\": \"human\"&#125;&#125;, &#123;upsert: true, multi: true&#125; )db.col.updateOne() ##同上，无multi参数，只更新第一条db.col.updateMany() ##同上，无multi参数db.col.replaceOne() ##同updateOnedb.col.save(document &lt;,writeConcern&gt;) ##通过传入的文档整个替换 insert 与 save的区别如果插入的数据的_id相同,save将会更新该文档,而insert将会报错 update常用操作符1234567891011$set ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.$unset ##删除文档中的一个字段.$rename ##重命名某个列$inc ##增长某个列$setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段$push ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.$pushAll ##将多个数值一次存入数组.上面的push只能一个一个的存入$addToSet ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.$pop ##删除数组最后一个元素$pull ##删除数组中的指定的元素,如果删除的字段不是数组,会报错$pullAll ##删除数组中的多个值,跟pushAll与push的关系类似. 4、查询12345db.col.find(&#123;&#125;) ##查询所有文档db.col.find().pretty() ##以易读的方式来读取数据db.collection.find(query, projection) # query：查询条件(数据索引或名字) # projection：可选。指定返回的字段。 4.1、深入查询表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647db.col.find()##查询所有db.col.find(&#123;filed: value&#125;) ##等值查询db.col.find(&#123;filed: &#123;$ne: value&#125;&#125;) ##不等于 $nedb.col.find(&#123;filed: &#123;$nin: [value1, value2, ...]&#125;&#125;) ##不能包含给定的值 $nindb.col.find(&#123;filed: &#123;$all: [value1, value2, ...]&#125;&#125;) ##必须包含所有给定的值 $alldb.col.find(&#123;filed: &#123;$in: [value1, value2, ...]&#125;&#125;) ##只要包含一个或多个给定的值 $indb.col.find(&#123;filed: &#123;$exists:1&#125;&#125;) ##存在filed字段的db.col.find(&#123;filed: &#123;$exists:0&#125;&#125;) ##不存在filed字段的db.col.find(&#123;filed: &#123;$mod:[3,1]&#125;&#125;) ##模三余一，$mod(取模操作)db.col.find(&#123;$or: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) ##或 $ordb.col.find(&#123;$nor: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)##排除 $nordb.col.find(&#123;filed: &#123;$size: 3&#125;&#125;) ##返回值得数组是给定的长度(3) $sizedb.col.find(&#123;$where: function()&#123;return ...&#125;&#125;) ##回调，隐式迭代，符合条件才返回db.col.find(&#123;$where: '...'&#125;&#125;) ##同上db.col.find(&#123;age: &#123;$lt: 5&#125;&#125;).limit(3) ##查询age的值小于5，限制3条 #范围查询： # $lt （小于） # $gt （大于） # $lte （小于等于） # $gte （大于等于） # limit（限制显示）db.col.find().skip(2).limit(3) ##跳过前两个文档查询后面三个 # skip(num):表示跳过前面num个文档db.col.find().sort(&#123;age: 1&#125;) ##查询后以age升序排列显示 # sort():排序，这里 1 代表升序, -1 代表降序.db.col.find(&#123;filed: /user.*/i&#125;) ##正则，查询filed以user开头不区分大小写（正则效率低）db.col.find(&#123;filed: &#123;$type: 1&#125;&#125;) ##查找filed为双精度的文档 # 根据数据类型查询 $type # |类型 |编号| # |双精度 |1 | # |字符串 |2 | # |对象 |3 | # |数组 |4 | # |二进制数据 |5 | # |对象ID |7 | # |布尔值 |8 | # |日期 |9 | # |空 |10 | # |正则表达式 |11 | # |JavaScript |13 | # |符号 |14 | # |JavaScript(带范围)|15 | # |32位整数 |16 | # |时间戳 |17 | # |64位整数 |18 | # |最小键 |255 | # |最大键 |127 | 4.2、group分组查询group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。 12345group(&#123; key:&#123;字段:1&#125;, initial:&#123;变量:初始值&#125;, $reduce:function(doc,prev)&#123;函数代码&#125;&#125;) 其中key下的字段代表,需要按哪个字段分组.initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果. 栗子：如下我们按年龄分组,同级不同年龄的用户的多少: 123456789101112131415161718192021222324252627282930313233db.user.find() &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 &#125;db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;count:0&#125;, $reduce:function(doc,prev)&#123; prev.count++ &#125;&#125;); [ &#123;\"age\": 0, \"count\": 1&#125;, &#123;\"age\": 1, \"count\": 3&#125;, &#123;\"age\": 2, \"count\": 2&#125; ]db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;users:[]&#125;, reduce:function(doc,prev)&#123; prev.users.push(doc.name) &#125;&#125;); [ &#123;\"age\": 0, \"users\": [\"user0\"]&#125;, &#123;\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]&#125;, &#123;\"age\": 2, \"users\": [\"user2\", \"user5\"]&#125; ] 另外本函数还有两个可选参数 condition 和 finalizecondition就是分组的条件筛选类似mysql中的having 123456789101112db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;users:[]&#125;, $reduce:function(doc,prev)&#123; prev.users.push(doc.name) &#125;, condition:&#123;age:&#123;$gt:0&#125;&#125;&#125;) ##筛选出age大于0的:[ &#123;\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]&#125;, &#123;\"age\": 2, \"users\": [\"user2\", \"user5\"]&#125;] 4.3、count统计12db.goods.count() ##统计该集合总数db.goods.count(&#123;cat_id: 3&#125;) ##统计cat_id=3的总数 4.4、distinct排重12345678910db.user.find() &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 &#125; db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象; [0, 1, 2] 4.5、子文档查询$elemMatchelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。注意：(1)数组中元素是内嵌文档。(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。假设集合school有如下数据： 1234567891011121314151617181920212223242526272829303132&#123; _id: 1, zipcode: 63109, students: [ &#123; name: \"john\", school: 102, age: 10 &#125;, &#123; name: \"jess\", school: 102, age: 11 &#125;, &#123; name: \"jeff\", school: 108, age: 15 &#125; ]&#125;&#123; _id: 2, zipcode: 63110, students: [ &#123; name: \"ajax\", school: 100, age: 7 &#125;, &#123; name: \"achilles\", school: 100, age: 8 &#125;, ]&#125;&#123; _id: 3, zipcode: 63109, students: [ &#123; name: \"ajax\", school: 100, age: 7 &#125;, &#123; name: \"achilles\", school: 100, age: 8 &#125;, ]&#125;&#123; _id: 4, zipcode: 63109, students: [ &#123; name: \"barney\", school: 102, age: 7 &#125;, ]&#125; 下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。 12345db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; $elemMatch: &#123; school: 102 &#125; &#125; &#125; );&#123;\"_id\": 1, \"students\": [&#123;\"name\":\"john\", \"school\":102, \"age\":10&#125;]&#125;&#123;\"_id\": 3&#125;&#123;\"_id\": 4, \"students\": [&#123;\"name\":\"barney\", \"school\":102, \"age\":7&#125;]&#125; 查询结果说明：_id为1的文档，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。_id为3的文档，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。 $elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。 12345db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; $elemMatch: &#123; school: 102, age: &#123; $gt: 10&#125; &#125; &#125; &#125; ); &#123;\"_id\": 1, \"students\": [&#123;\"name\":\"jess\", \"school\":102, \"age\":11&#125;]&#125; &#123;\"_id\": 3&#125; &#123;\"_id\": 4&#125;","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://chaooo.github.io/tags/mongodb/"}]},{"title":"sublime text3个人习惯配置","date":"2016-06-29T01:41:48.000Z","path":"2016/06/29/sublime-text3个人习惯配置-C.html","text":"1、安装分别在官网下载并安装 nodejs 和 sublime text3。 2、sublime text3注册： 点击菜单【help】－&gt;【Enter License】，粘贴注册码。 3、安装package control组件，用于管理所有插件按ctrl + ~调出控制台(或点击菜单栏的【View】-&gt;【Show Console】)，在Console窗口中输入以下代码，按回车键： 1import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 等待安装完毕，重启Sublime Text3。按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control： 4、用Package Control安装插件按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）Material ThemeEmmetCSS FormatCSScombjsFormatAutoFileNameAutoprefixerDoc BlockrSublimeLinterSublimeLinter-jshintSublimeLinter-csslintColor HighlighterBracketHighlighter 5、配置nodejs方法1(1)下载sublime Text的nodejs插件(2)下载后解压:直接改名为nodejs 放到 Preferences–&gt;浏览程序包Browse Packages所在的文件夹(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示： 12345678910111213141516171819&#123; \"cmd\": [\"node\", \"$file\"], \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"selector\": \"source.js\", \"shell\":true, \"encoding\": \"cp1252\", \"windows\": &#123; \"cmd\": [\"taskkill /F /IM node.exe &amp; node\", \"$file\"] &#125;, \"linux\": &#123; \"cmd\": [\"killall node; node\", \"$file\"] &#125;, \"osx\": &#123; \"cmd\": [\"killall node; node $file\"] &#125;&#125; (4)修改为： 1234567891011121314151617181920&#123; \"cmd\": [\"node\", \"$file\"], \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"selector\": \"source.js\", \"shell\":true, \"encoding\": \"utf-8\", \"windows\": &#123; \"cmd\": [\"taskkill /F /IM node.exe\", \"\"], \"cmd\": [\"node\", \"$file\"] &#125;, \"linux\": &#123; \"cmd\": [\"killall node; node\", \"$file\"] &#125;, \"osx\": &#123; \"cmd\": [\"killall node; node $file\"] &#125;&#125; (5)完成:随便写一段nodejs代码，ctrl+B运行(6)注意：在手动解压sublime Text插件后，需要在preference-&gt;package settings-&gt;package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。 方法2首先需要先安装nodejs。(1)运行Sublime,菜单上找到Tools —&gt; Build System —&gt; new Build System(2)输入：{ “cmd”: [“node”, “$file”], “file_regex”: “^[ ]File &quot;(…?)&quot;, line ([0-9]*)”, “selector”: “source.js”, “shell”:true, “encoding”: “utf-8”, “windows”: { “cmd”: [“taskkill /F /IM node.exe”, “”], “cmd”: [“node”, “$file”] }}(3)保存文件为NodeJs.sublime-build(4)菜单上找到Tools —&gt; Build System —&gt;选择 NodeJs(5)安装sublime插件 JavaScript &amp; NodeJs Snippets(6)新建test.js文件，输入 console.log(‘Hello Node.js’); 按快捷键 Ctrl + B 运行，成功输出","tags":[{"name":"sublime","slug":"sublime","permalink":"http://chaooo.github.io/tags/sublime/"}]},{"title":"Hexo3.2+GitHub搭建静态博客","date":"2016-05-23T03:16:51.000Z","path":"2016/05/23/Hexo3-2-github搭建静态博客.html","text":"开始之前在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.创建GitHub仓库注册GitHub账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：chaooo.github.io，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。 2.配置Git设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入： 12$ git config --global user.name \"username\"$ git config --global user.email \"email@example.com\" 3.本地Git与GitHub建立联系这里介绍SSH的配置，先检查电脑是否已经有SSH 1$ ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。输入以下指令后，一路回车就好： 1$ ssh-keygen -t rsa -C \"emailt@example.com\" 然后键入以下指令： 12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可： 1$ ssh-agent bash 再重新输入指令： 1$ ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）： 1$ clip &lt; ~/.ssh/id_rsa.pub 在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH keyTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。最后还是测试一下吧，键入以下命令： 1$ ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 4.初始化hexo文件夹到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt; 12$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git$ mkdir Hexo-admin Hexo安装配置1.Hexo初始化进入Hexo-admin文件夹 1$ cd Hexo-admin 接下来只需要使用 npm 即可完成 Hexo 的安装: 1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件: 12$ hexo init$ npm install 接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。 12$ hexo generate$ hexo server 输入Ctrl+C停止服务。 2.Hexo配置用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到： 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repository: 到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 3.完成部署最后一步，快要成功了，键入指令： 123$ npm install hexo-deployer-git --save$ hexo generate$ hexo deploy 输入弹出框的用户名与密码(首次使用git会弹出)。OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：chaooo.github.io/每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样： 123To https://github.com/chaooo/chaooo.github.io.git 7f3b50a..128a10d HEAD -&gt; masterINFO Deploy done: git 当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。 日常操作1.写文章执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。 1$ hexo new [layout] \"文章标题\" #新建文章 然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout， 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md 1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下： 12345title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:--- 文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。 2.提交每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。 123$ git add .$ git commit -m \"...\"$ git push origin develop 然后才执行hexo generate -d发布网站到master分支上。 1$ hexo generate -d 3.本地仓库丢失当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤： 3.1拷贝仓库1$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git 3.2配置Hexo在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令: 1234$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save 小Tips:hexo 命令1234567891011121314hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo deploy -g #生成加部署hexo server -g #生成加预览#命令的简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaooo.github.io/tags/hexo/"}]},{"title":"Hello World","date":"2015-12-31T15:59:59.000Z","path":"2015/12/31/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaooo.github.io/tags/hexo/"}]}]