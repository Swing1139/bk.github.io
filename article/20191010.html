<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="郑超的个人博客，Charles·Zheng's blog."><meta name="keywords" content="技术博客, 前端, JavaScript, Charles"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>【并发编程】AQS框架 与 锁框架（JUC.locks） | 秋过冬漫长</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【并发编程】AQS框架 与 锁框架（JUC.locks）</h1><a id="logo" href="/.">秋过冬漫长</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">【并发编程】AQS框架 与 锁框架（JUC.locks）</h1><div class="post-meta"><a href="/article/20191010.html#comments" class="comment-count"></a><p><span class="date">Oct 10,2019</span><span><a href="/categories/并发编程/" class="category">并发编程</a></span></p></div><div class="post-content"><h3 id="1-AQS（队列同步器）"><a href="#1-AQS（队列同步器）" class="headerlink" title="1. AQS（队列同步器）"></a>1. AQS（队列同步器）</h3><p><code>AbstractQueuedSynchronizer</code>：队列同步器，简称AQS。</p>
<ul>
<li><code>AQS</code>维护了一个<code>volatile int</code><strong><code>state</code></strong>(代表资源共享变量) 和一个<strong>FIFO线程等待队列</strong>(多线程争用资源被阻塞时会进入此队列)。</li>
<li><code>AQS</code>定义了两种资源共享方式：<code>Exclusive</code>(独占)，<code>Share</code>(共享)<a id="more"></a></li>
<li><code>isHeldExclusively</code>方法：该线程是否正在独占资源</li>
<li><code>tryAcquire</code>/<code>tryRelease</code>：独占的方式尝试获取和释放资源</li>
<li><code>tryAcquireShared</code>/<code>tryReleaseShared</code>：共享的方式尝试获取和释放资源</li>
</ul>
<p>整个框架的核心就是<strong>如何管理线程阻塞队列</strong>，该队列是严格的FIFO队列，因此不支持线程优先级的同步。</p>
<ul>
<li>AQS只有一个同步队列，可以有多个条件队列。<ul>
<li>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，同步队列选择了<strong>CLH</strong>作为实现的基础。</li>
<li>条件队列：AQS框架提供了一个ConditionObject类，给维护独占同步的类以及实现Lock接口的类使用。</li>
</ul>
</li>
<li>使用Node实现<strong>FIFO双向队列</strong>，可以用于构建锁 或 其他同步装置的基础框架</li>
<li>内部有一个int变量表示的<strong><code>同步状态</code></strong>(同步状态通过<strong>getState</strong>、<strong>setState</strong>、<strong>compareAndSetState</strong>来维护，同时这三个方法能够保证线程安全)</li>
<li>AQS是个<strong>抽象类</strong>（但没有抽象方法），同步组件一般通过维护AQS的<strong>继承子类来实现</strong>。</li>
<li>AQS<strong>既</strong>支持独占地获取同步状态(<strong>排它锁</strong>)，<strong>又</strong>支持共享地获取同步状态(<strong>共享锁</strong>)，从而实现不同类型的组件。</li>
<li>AQS是<strong>基于模板方法</strong>，同步组件需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</li>
</ul>
<blockquote>
<p>Synchronizer(同步器)：是一个对象，它根据本身的状态调节线程的控制流。常见类型的Synchronizer包括信号量、关卡和闭锁。</p>
</blockquote>
<h3 id="2-CountDownLatch（倒计时闭锁）"><a href="#2-CountDownLatch（倒计时闭锁）" class="headerlink" title="2. CountDownLatch（倒计时闭锁）"></a>2. CountDownLatch（倒计时闭锁）</h3><ul>
<li>闭锁(latch)是一种Synchronizer，它可以延迟线程的进度直到线程达到<strong>终止状态</strong>。</li>
<li><strong>CountDownLatch</strong>(倒计时闭锁)是一个灵活的闭锁实现。</li>
<li>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。</li>
<li>CountDownLatch<strong>原理</strong>：是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。<ul>
<li>await()，阻塞程序继续执行</li>
<li>countDown()，计数器的值减1，当计数器值减至零时，所有因调用await()方法而处于等待状态的线程就会继续往下执行。</li>
</ul>
</li>
<li>计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用CycliBarrier</li>
</ul>
<blockquote>
<p>CountDownLatch使用场景：应用初始化</p>
</blockquote>
<h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><ul>
<li><strong>Semaphore</strong>(信号量)：用来<strong>控制同时访问</strong>特定资源的线程<strong>数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。</li>
<li>Semaphore<strong>原理</strong>：线程需要通过acquire()方法获取许可，而release()释放许可。如果许可数达到最大活动数，那么调用acquire()之后，便进入等待队列，等待已获得许可的线程释放许可，从而使得多线程能够合理的运行。<ul>
<li>acquire()：获取权限，其底层实现与CountDownLatch.countdown()类似;</li>
<li>release()：释放权限，其底层实现与acquire()是一个互逆的过程。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。</p>
</blockquote>
<h3 id="4-CyclicBarrier（同步屏障）"><a href="#4-CyclicBarrier（同步屏障）" class="headerlink" title="4. CyclicBarrier（同步屏障）"></a>4. CyclicBarrier（同步屏障）</h3><ul>
<li><strong>CyclicBarrier</strong>(同步屏障)：可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所有被阻塞的线程才能继续执行。</li>
<li>CyclicBarrier类似于CountDownLatch，它也是通过计数器来实现的。但是相比于CountDownLatch功能更加强大。</li>
<li>CyclicBarrier<strong>原理</strong>：当某个线程调用await方法时，该线程进入等待状态，且计数器加1，当计数器的值达到设置的初始值时，所有因调用await进入等待状态的线程被唤醒，继续执行后续操作。因为CycliBarrier在释放等待线程后可以重用，所以称为循环barrier。</li>
</ul>
<h4 id="4-1-CountDownLatch-和-CyclicBarrier-对比"><a href="#4-1-CountDownLatch-和-CyclicBarrier-对比" class="headerlink" title="4.1 CountDownLatch 和 CyclicBarrier 对比"></a>4.1 CountDownLatch 和 CyclicBarrier 对比</h4><ol>
<li>CountDownLatch描述的是线程(1个或多个)等待其他线程的关系；CyclicBarrier描述的是多个线程相互等待的关系。</li>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset()方法重置并复用。</li>
<li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如：<ul>
<li>getNumberWaiting()：获取阻塞的线程数量。</li>
<li>isBroken()：获取阻塞线程的状态，被中断返回true，否则返回false。</li>
<li>CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；</li>
</ul>
</li>
</ol>
<blockquote>
<p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景</p>
</blockquote>
<h3 id="5-JUC-locks-锁框架"><a href="#5-JUC-locks-锁框架" class="headerlink" title="5. JUC.locks 锁框架"></a>5. JUC.locks 锁框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks</span><br><span class="line">    |———— Lock接口</span><br><span class="line">        |———— ReentrantLock类</span><br><span class="line">            |———— ReentrantReadWriteLock.ReadLock内部类</span><br><span class="line">            |———— ReentrantReadWriteLock.WriteLock内部类</span><br><span class="line">    |———— Condition接口</span><br><span class="line">    |———— ReadWriteLock接口</span><br><span class="line">        |———— ReentrantReadWriteLock类</span><br><span class="line">    |———— LockSupport类</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Lock接口</strong>核心方法：lock()，unlock()，lockInterruptibly()，newCondition()，tryClock()<ul>
<li>lock()方法类似于使用synchronized关键字加锁，如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</li>
<li>lockInterruptibly()方法顾名思义，就是如果锁不可用，那么当前正在等待的线程是可以被中断的，这比synchronized关键字更加灵活。</li>
</ul>
</li>
<li><strong>Condition接口</strong>核心方法：awit()，signal()，signalAll()<ul>
<li>可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用</li>
</ul>
</li>
<li><strong>ReadWriteLock接口</strong>核心方法：readLock()，writeLock()<ul>
<li>获取读锁和写锁，注意除非使用Java8新锁，否则读读不互斥，读写是互斥的</li>
</ul>
</li>
</ul>
<h3 id="6-ReentrantLock（可重入锁）"><a href="#6-ReentrantLock（可重入锁）" class="headerlink" title="6. ReentrantLock（可重入锁）"></a>6. ReentrantLock（可重入锁）</h3><p><strong><code>ReentrantLock</code>重入锁</strong>使用<strong>AQS同步状态</strong>来保存锁重复持有的次数</p>
<ul>
<li>底层代码分析：<ul>
<li><strong><code>state</code></strong>初始化为0，表示未锁定状态</li>
<li>A线程lock()时，会调用tryAcquire()独占该锁并将<strong><code>state+1</code></strong></li>
<li>此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0(即释放锁)为止，其他线程才有机会获取该锁</li>
<li>当然，锁释放之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念</li>
</ul>
</li>
</ul>
<p>synchronized实现的锁的重入依赖于JVM，是一种重量级锁。<br>ReentrantLock实现了在内存语义上的synchronized，使用<strong>AQS同步状态</strong>来保存锁重复持有的次数。当锁被一个线程获取时，ReentrantLock也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。</p>
<ul>
<li>公平锁和非公平锁<ul>
<li>公平锁还是非公平锁取决于ReentrantLock的构造方法，<strong>默认</strong>无参为<strong>非公平锁</strong>(NonfairSync)；含参构造方法，入参true为FairSync，入参false为NonfairSync。</li>
</ul>
</li>
<li>非公平锁中，抢到AQS的同步状态的未必是同步队列的首节点，只要线程通过CAS抢到了同步状态或者在acquire中抢到同步状态，就优先占有锁（插队），而相对同步队列这个严格的FIFO队列来说，所以会被认为是非公平锁。</li>
<li>公平锁的实现直接调用AQS的acquire方法，acquire中调用tryAcquire。和非公平锁相比，这里不会执行一次CAS，接下来在tryAcquire去抢占锁的时候，也会先调用hasQueuedPredecessors看看前面是否有节点已经在等待获取锁了，如果存在则同步队列的前驱节点优先（排队FIFO）。</li>
</ul>
<blockquote>
<p>虽然公平锁看起来在公平性上比非公平锁好，但是公平锁为此付出了大量线程切换的代价，而非公平锁在锁的获取上不能保证公平，就有可能出现锁饥饿，即有的线程多次获取锁而有的线程获取不到锁，没有大量的线程切换保证了非公平锁的吞吐量。</p>
</blockquote>
<h3 id="7-读写锁RRW（ReentrantReadWriteLock）"><a href="#7-读写锁RRW（ReentrantReadWriteLock）" class="headerlink" title="7. 读写锁RRW（ReentrantReadWriteLock）"></a>7. 读写锁RRW（ReentrantReadWriteLock）</h3><p>ReentrantLock是独占锁，ReentrantReadWriteLock是读写锁。</p>
<ul>
<li>独占锁通过state变量的0和1两个状态来控制是否有线程占有锁，共享锁通过state变量0或者非0来控制多个线程访问。</li>
<li>读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</li>
<li>ReentrantReadWriteLock的特殊之处其实就是用一个int值表示两种不同的状态（低16位表示写锁的重入次数，高16位表示读锁的使用次数），并通过两个内部类同时实现了AQS的两套API，核心部分与共享/独占锁并无什么区别。</li>
</ul>
<blockquote>
<p>ReentrantReadWriteLock也会发生<strong>写请求饥饿</strong>的情况，因为写请求一样会排队，不管是公平锁还是非公平锁，在有读锁的情况下，都<strong>不能保证写锁</strong>一定能获取到，这样只要读锁一直占用，就会发生写饥饿的情况。JDK8中新增的改进读写锁StampedLock可解决饥饿问题</p>
</blockquote>
<h3 id="8-LockSupport工具类"><a href="#8-LockSupport工具类" class="headerlink" title="8. LockSupport工具类"></a>8. LockSupport工具类</h3><p>归根结底，LockSupport调用的Unsafe中的native代码：park()，unpark()；</p>
<ul>
<li>park函数是将当前Thread阻塞，而unpark函数则是将另一个Thread唤醒。</li>
<li>与Object类的wait/notify机制相比，park/unpark有两个优点：<ol>
<li>以thread为操作对象更符合阻塞线程的直观定义；</li>
<li>操作更精准，可以准确地唤醒某一个线程（Object类的notify随机唤醒一个线程，notifyAll唤醒所有等待的线程），增加了灵活性</li>
</ol>
</li>
</ul>
<blockquote>
<p>park方法的调用一般要在方法一个循环判断体里面。之所以这样做，是为了防止线程被唤醒后，不进行判断而意外继续向下执行，这其实是一种的多线程设计模式-Guarded Suspension。</p>
</blockquote>
<h3 id="9-StampedLock（Java8新型锁）"><a href="#9-StampedLock（Java8新型锁）" class="headerlink" title="9. StampedLock（Java8新型锁）"></a>9. StampedLock（Java8新型锁）</h3><p>ReentrantReadWriteLock锁具有读写锁，问题在于ReentrantReadWriteLock使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的 ，很容易造成写锁获取不到资源(写请求饥饿)。</p>
<ul>
<li>Java 8 引入了一个新的读写锁叫StampedLock. 不仅这个锁更快，而且它提供强大的乐观锁API。这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会阻塞写线程。</li>
<li>StampedLock的主要特点：<ol>
<li>所有<strong>获取锁</strong>的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；</li>
<li>所有<strong>释放锁</strong>的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；</li>
<li>StampedLock是<strong>不可重入</strong>的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li>
<li>StampedLock有<strong>三种访问模式</strong>：<ul>
<li>Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似</li>
<li>Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似</li>
<li>Optimistic reading（乐观读模式）：这是一种优化的读模式。</li>
</ul>
</li>
<li>StampedLock支持读锁和写锁的相互转换</li>
<li>RRW(ReentrantReadWriteLock)中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的；StampedLock提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</li>
<li>无论写锁还是读锁，都不支持Conditon等待</li>
</ol>
</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: 郑超(Charles·Zheng)</p><p>原文链接: <a href="http://chaooo.github.io/article/20191010.html">http://chaooo.github.io/article/20191010.html</a></p><p>版权声明: 转载请注明出处(保留作者署名及原文链接)</p></blockquote></div><div class="tags"><a href="/tags/back-end/">后端开发</a><a href="/tags/java/">java</a><a href="/tags/并发编程/">并发编程</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/article/20191014.html" class="pre">【并发编程】阻塞队列 与 线程池</a><a href="/article/20191006.html" class="next">【并发编程】JUC并发容器类</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'dd644e0a840b03bbb238',
  clientSecret: 'de8b7f88cfa9812e15f93e986181d1c2194ba6e8',
  repo: 'BlogComments',
  owner: 'chaooo',
  admin: ['chaooo'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AQS（队列同步器）"><span class="toc-text">1. AQS（队列同步器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CountDownLatch（倒计时闭锁）"><span class="toc-text">2. CountDownLatch（倒计时闭锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Semaphore（信号量）"><span class="toc-text">3. Semaphore（信号量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CyclicBarrier（同步屏障）"><span class="toc-text">4. CyclicBarrier（同步屏障）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-CountDownLatch-和-CyclicBarrier-对比"><span class="toc-text">4.1 CountDownLatch 和 CyclicBarrier 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JUC-locks-锁框架"><span class="toc-text">5. JUC.locks 锁框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ReentrantLock（可重入锁）"><span class="toc-text">6. ReentrantLock（可重入锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-读写锁RRW（ReentrantReadWriteLock）"><span class="toc-text">7. 读写锁RRW（ReentrantReadWriteLock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-LockSupport工具类"><span class="toc-text">8. LockSupport工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-StampedLock（Java8新型锁）"><span class="toc-text">9. StampedLock（Java8新型锁）</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/20191014.html">【并发编程】阻塞队列 与 线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20191010.html">【并发编程】AQS框架 与 锁框架（JUC.locks）</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20191006.html">【并发编程】JUC并发容器类</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20191003.html">【Java知识梳理】常见集合类 的 数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20190927.html">【Redis】Redis穿透、击穿、雪崩和数据一致性</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20190920.html">【Redis】深入学习Redis及集群</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20190907.html">【数据库优化】MySQL事务处理与并发控制</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20190905.html">【数据库优化】MySQL索引的使用及优化</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20190901.html">【数据库优化】MySQL性能优化基础</a></li><li class="post-list-item"><a class="post-list-link" href="/article/20190829.html">【数据库优化】MySQL慢日志查询分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">Hexo博客折腾</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-learn/">Java教程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">Java知识梳理</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/safe/">安全认证</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/db/">数据库</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">杂谈</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/env/">环境配置</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/tool/" style="font-size: 15px;">工具</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/BlueLake/" style="font-size: 15px;">BlueLake</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/back-end/" style="font-size: 15px;">后端开发</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/sublime/" style="font-size: 15px;">sublime</a> <a href="/tags/Javascript/" style="font-size: 15px;">Javascript</a> <a href="/tags/ssafe/" style="font-size: 15px;">安全认证</a> <a href="/tags/bower/" style="font-size: 15px;">bower</a> <a href="/tags/other/" style="font-size: 15px;">杂谈</a> <a href="/tags/open-source/" style="font-size: 15px;">开源</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/tags/db/" style="font-size: 15px;">数据库</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/env/" style="font-size: 15px;">环境配置</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/chaooo" title="chaooo" target="_blank">chaooo</a><ul></ul><a href="https://github.com/chaooo/hexo-theme-BlueLake" title="BlueLake主题" target="_blank">BlueLake主题</a><ul></ul><a href="http://weibo.com/zhengchaooo" title="秋过冬漫长" target="_blank">秋过冬漫长</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p><span> Copyright &copy;<a href="/." rel="nofollow">郑超(Charles·Zheng).</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p><p><img src="https://bce.bdstatic.com/portal/img/gongan_25e86e61.png" style="width: 16px;margin-right: 8px;vertical-align: sub;"><a target="_blank" href="http://www.beian.miit.gov.cn">粤ICP备19039226号</a></p></div></div></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-78287143-2','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3190aa62d6a262eb340b2998ec3751bb";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>