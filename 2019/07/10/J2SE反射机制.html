<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="郑超的个人博客，Charles·Zheng's blog."><meta name="keywords" content="技术博客, 前端, JavaScript, Charles"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>J2SE反射机制 | 秋过冬漫长</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">J2SE反射机制</h1><a id="logo" href="/.">秋过冬漫长</a><p class="description">没有比脚更长的路，走过去，前面是个天！</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">J2SE反射机制</h1><div class="post-meta"><a href="/2019/07/10/J2SE反射机制.html#comments" class="comment-count"></a><p><span class="date">Jul 10,2019</span><span><a href="/categories/javaSE知识梳理/" class="category">javaSE知识梳理</a></span></p></div><div class="post-content"><h2 id="八、反射机制"><a href="#八、反射机制" class="headerlink" title="八、反射机制"></a>八、反射机制</h2><ol>
<li><a href="#id1">基本概念</a></li>
<li><a href="#id2">Class类</a></li>
<li><a href="#id3">Constructor类</a></li>
<li><a href="#id4">Field类</a></li>
<li><a href="#id5">Method类</a></li>
<li><a href="#id6">原始方式与反射方式构造对象实例</a></li>
<li><a href="#id7">注解(Annotation)</a></li>
<li><a href="#id8">Properties类的使用</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<p>反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；<br>类是用来描述一组对象，反射机制可以理解为是用来描述一组类</p>
<p>通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。</p>
<h4 id="1-1-相关类及描述"><a href="#1-1-相关类及描述" class="headerlink" title="1.1 相关类及描述"></a>1.1 相关类及描述</h4><ul>
<li>Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</li>
<li>Package：用来描述类所属的包</li>
<li>Field：用来描述类中的属性</li>
<li>Method：用来描述类中的方法</li>
<li>Constructor：用来描述类中的构造方法</li>
<li>Annotation：用来描述类中的注解</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-Class类"><a href="#2-Class类" class="headerlink" title="2. Class类"></a>2. Class类</h3><p>java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</p>
<h4 id="2-1-获取Class类型对象的三种方式"><a href="#2-1-获取Class类型对象的三种方式" class="headerlink" title="2.1 获取Class类型对象的三种方式"></a>2.1 获取Class类型对象的三种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"包名.类名"</span>);<span class="comment">//用的最多，但可能抛出ClassNotFoundException异常</span></span><br><span class="line">Class clazz = 类名.class;<span class="comment">//任何类都有一个隐含的静态成员变量class</span></span><br><span class="line">Class clazz = 对象.getClass();<span class="comment">//Object类中的方法</span></span><br><span class="line">Class clazz = 包装类.TYPE;<span class="comment">//获取对应基本数据类型的class对象</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-常用方法"><a href="#2-2-常用方法" class="headerlink" title="2.2 常用方法"></a>2.2 常用方法</h4><ul>
<li>static Class&lt;?&gt; forName(String className)<ul>
<li>用于获取参数指定对应的Class对象并返回</li>
</ul>
</li>
<li>T newInstance()<ul>
<li>默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>
</ul>
</li>
<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<ul>
<li>用于获取此Class对象所表示类型中参数指定的公共构造方法。</li>
</ul>
</t></li>
<li>Constructor&lt;?&gt;[] getConstructors()<ul>
<li>用于获取此Class对象所表示类型中所有的公共构造方法</li>
</ul>
</li>
<li>Field getDeclaredField(String name)<ul>
<li>用于获取此Class对象所表示类中参数指定的单个成员变量信息</li>
</ul>
</li>
<li>Field[] fs = getDeclaredFields()<ul>
<li>用于获取此Class对象所表示类中所有成员变量信息</li>
</ul>
</li>
<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<ul>
<li>用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法</li>
</ul>
</li>
<li>Method[] getMethods()<ul>
<li>用于获取该Class对象表示类中所有公共成员方法。</li>
</ul>
</li>
<li>获取私有相关方法<ul>
<li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)</li>
<li>getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)</li>
<li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有)</li>
<li>getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)</li>
</ul>
</li>
</ul>
<h4 id="2-3-其他方法"><a href="#2-3-其他方法" class="headerlink" title="2.3 其他方法"></a>2.3 其他方法</h4><ol>
<li>int result = getModifiers(); 获取类的修饰符(权限+特征)<ul>
<li>每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract</li>
</ul>
</li>
<li>String name = getName(); 获取类的全名(包名.类名)</li>
<li>String name = getSimpleName(); 获取类简单名(只有类名 缺少包)</li>
<li>Package p = getPackage(); 获取当前类所属的包<ul>
<li>p.getName(); 获取包名(Package类中的方法)</li>
</ul>
</li>
<li>Class sclazz = getSuperClass(); 获取超类(父类)对应Class</li>
<li>Class[] classes = getInterface(); 获取当前类父亲接口</li>
<li>Class[] classes = getClasses(); 获取类中的内部类</li>
<li>Object obj = <strong>newInstance()</strong>; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>
<li>Field f = getField(“属性名”); 获取类中的属性(公有的 自己类+父类)</li>
<li>Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)</li>
<li>getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类)</li>
<li>Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)</li>
</ol>
<p><span id="id3"><span></span></span></p>
<h3 id="3-Constructor类"><a href="#3-Constructor类" class="headerlink" title="3. Constructor类"></a>3. Constructor类</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>
<h4 id="3-1-Constructor类中的常用方法"><a href="#3-1-Constructor类中的常用方法" class="headerlink" title="3.1 Constructor类中的常用方法"></a>3.1 Constructor类中的常用方法</h4><ul>
<li>T newInstance(Object… initargs)<ul>
<li>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。</li>
</ul>
</li>
</ul>
<h4 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2 其他方法"></a>3.2 其他方法</h4><ul>
<li>con.getModifiers();</li>
<li>con.getName();</li>
<li>con.getParameterTypes();</li>
<li>con.getExceptionTypes();</li>
<li>如何操作构造方法<ul>
<li>执行一次,创建对象</li>
<li>Object = newInstance(执行构造方法时的所有参数);</li>
<li>con.setAccessible(true);</li>
</ul>
</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-Field类"><a href="#4-Field类" class="headerlink" title="4. Field类"></a>4. Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>
<h4 id="4-1-Field类中的常用方法"><a href="#4-1-Field类中的常用方法" class="headerlink" title="4.1 Field类中的常用方法"></a>4.1 Field类中的常用方法</h4><ul>
<li>Object get(Object obj)<ul>
<li>调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。</li>
</ul>
</li>
<li>Object set(Object obj, Object value)<ul>
<li>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。</li>
</ul>
</li>
<li>void setAccessible(boolean flag)<ul>
<li>当实参传递true时，则反射的对象在使用时应该取消java语言访问检查</li>
</ul>
</li>
</ul>
<h4 id="4-2-其他方法"><a href="#4-2-其他方法" class="headerlink" title="4.2 其他方法"></a>4.2 其他方法</h4><ol>
<li>int = getModifiers(); 获取属性修饰符(权限+特征)</li>
<li>Class = getType(); 获取属性的类型对应的那个class</li>
<li>String = getName(); 获取属性的名字</li>
<li>操作属性: set(对象,值); Object = get(对象);<ul>
<li>如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入</li>
</ul>
</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-Method类"><a href="#5-Method类" class="headerlink" title="5. Method类"></a>5. Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>
<h4 id="5-1-Method类中的常用方法"><a href="#5-1-Method类中的常用方法" class="headerlink" title="5.1 Method类中的常用方法"></a>5.1 Method类中的常用方法</h4><ul>
<li>Object invoke(Object obj, Object… args)<ul>
<li>使用对象obj来调用此Method对象所表示的成员方法，实参传递args。</li>
</ul>
</li>
</ul>
<h4 id="5-2-其他方法"><a href="#5-2-其他方法" class="headerlink" title="5.2 其他方法"></a>5.2 其他方法</h4><ul>
<li>int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)</li>
<li>Class mrt = m.getReturnType(); 获取返回值数据类型</li>
<li>String mn = m.getName(); 获取方法的名字</li>
<li>Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型</li>
<li>Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型</li>
<li>如何操作方法</li>
<li>调用方法   让他执行一次</li>
<li>Object result = invoke(对象,执行方法需要传递的所有参数…);</li>
<li>若方法是私有的方法  不允许操作</li>
<li>可以设置setAccessable(true)   设置方法使用权  准入</li>
</ul>
<p><span id="id6"><span></span></span></p>
<h3 id="6-原始方式与反射方式构造对象实例"><a href="#6-原始方式与反射方式构造对象实例" class="headerlink" title="6. 原始方式与反射方式构造对象实例"></a>6. 原始方式与反射方式构造对象实例</h3><ol>
<li>使用原始方式来构造对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//1.采用无参的方式构造Person对象并打印</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p); <span class="comment">//null 0</span></span><br><span class="line">	<span class="comment">//2.使用有参方式来构造Person对象</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"zhangfei"</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(p2); <span class="comment">//zhangfei 30</span></span><br><span class="line">	<span class="comment">//3.修改与获取属性(成员变量)，调用get,set方法</span></span><br><span class="line">p2.setName(<span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + p2.getName()); <span class="comment">//guanyu</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用反射机制来构造对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//1.使用获取到的Class对象来构造Person对象并打印</span></span><br><span class="line">Class c1 = Class.forName(<span class="string">"myproject.Person"</span>);<span class="comment">//不可省略包名</span></span><br><span class="line">System.out.println(c1.newInstance());<span class="comment">//null 0</span></span><br><span class="line">	<span class="comment">//2.使用有参方式来构造对象</span></span><br><span class="line">Class c2 = Class.forName(<span class="string">"myproject.Person"</span>);</span><br><span class="line">Constructor ct2 = c2.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">Object obj = ct2.newInstance(<span class="string">"zhangfei"</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(obj);<span class="comment">//zhangfei 30</span></span><br><span class="line">	<span class="comment">//3.修改与获取属性(成员变量)</span></span><br><span class="line">Field f2 = c2.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，设置使用权</span></span><br><span class="line">f2.set(obj, <span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + f2.get(obj)); <span class="comment">//guanyu</span></span><br><span class="line">	<span class="comment">//4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来</span></span><br><span class="line">Method m1 = c2.getMethod(<span class="string">"getName"</span>);</span><br><span class="line">System.out.println(<span class="string">"获取到的姓名是："</span> + m1.invoke(obj)); <span class="comment">//zhangfei</span></span><br><span class="line">	<span class="comment">//5.成员方法setName，调用getMethod方法来修改姓名并打印出来</span></span><br><span class="line">Method m2 = c2.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">Object res = m2.invoke(obj, <span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"方法调用的返回值是："</span> + res); <span class="comment">//null</span></span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + m1.invoke(obj)); <span class="comment">//guanyu</span></span><br></pre></td></tr></table></figure>

<p><span id="id7"><span></span></span></p>
<h3 id="7-注解-Annotation"><a href="#7-注解-Annotation" class="headerlink" title="7. 注解(Annotation)"></a>7. 注解(Annotation)</h3><ul>
<li>注释<ul>
<li>单行注释：<code>//</code></li>
<li>多行注释：<code>/*   */</code></li>
<li>文档注释：<code>/**   */</code></li>
</ul>
</li>
<li>注解的写法<ul>
<li><code>@XXX [(一些信息)]</code></li>
</ul>
</li>
<li>注解位置<ul>
<li>类的上面，属性上面，方法上面，构造方法上面，参数前面</li>
</ul>
</li>
<li>注解的作用<ol>
<li>用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated</li>
<li>用来做代码的检测(验证)，@Override</li>
<li>*可以携带一些信息(内容)，文件.properties/.xml，注解</li>
</ol>
</li>
<li>常用的注解<ul>
<li>@Deprecated：用来说明方法是废弃的</li>
<li>@Override：用来做代码检测   检测此方法是否是一个重写</li>
<li>@SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{}<ul>
<li>unused：变量定义后未被使用</li>
<li>serial：类实现了序列化接口  不添加序列化ID号</li>
<li>rawtypes：集合没有定义泛型</li>
<li>deprecation：方法以废弃    </li>
<li>*unchecked：出现了泛型的问题  可以不检测</li>
<li>all：包含了以上所有(不推荐)</li>
</ul>
</li>
</ul>
</li>
<li>注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：<ol>
<li>基本数据类型</li>
<li>String类型</li>
<li>枚举类型enum</li>
<li>注解类型@</li>
<li>数组类型[]，数组的内部需要是如上的四种类型</li>
</ol>
</li>
</ul>
<h4 id="7-1-自己描述一个注解类型"><a href="#7-1-自己描述一个注解类型" class="headerlink" title="7.1 自己描述一个注解类型"></a>7.1 自己描述一个注解类型</h4><ol>
<li>通过@interface 定义一个新的注解类型</li>
<li>发现写法与接口非常相似(可以利用接口的特点来记忆注解)<ul>
<li>可以描述public static final的属性，比较少见</li>
<li>可以描述public abstract的方法，方法要求返回值必须有，返回值类型是如上那些</li>
</ul>
</li>
<li>我们自己定义的注解如果想要拿来使用<ul>
<li>光定义还不够，还需要做很多细致的说明(需要利用Java提供好的注解来说明)</li>
<li>元注解(也是注解，不是拿来使用的，是用来说明注解)<ul>
<li>@Target：描述当前的这个注解可以放置在哪里写的</li>
<li>@Retention：描述当前的这个注解存在什么作用域中的(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME)</li>
<li>@Inherited：描述当前这个注解是否能被子类对象继承</li>
<li>@Document：描述这个注解是否能被文档所记录</li>
</ul>
</li>
</ul>
</li>
<li>自己使用自己描述的注解<ul>
<li>问题1：在注解里面描述了一个方法，方法没有参数，方法是有返回值String[]<ul>
<li>使用注解的时候   让我们传递参数</li>
<li>理解为  注解的方法做事   将我们传递给他的参数  搬运走了  给了别人</li>
</ul>
</li>
<li>问题2：使用别人写好的注解不用写方法名  我们自己定义的方法必须写名字<ul>
<li>如果我们自己定义的注解  只有一个方法  方法名字叫value，在使用的时候就可以省略方法名    </li>
<li>如果传递的信息是一个数组   数组内只有一个元素  可以省略{}</li>
<li>如果方法是两个以上  每一个方法必须写名字</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><span id="id8"><span></span></span></p>
<h3 id="8-Properties类的使用"><a href="#8-Properties类的使用" class="headerlink" title="8. Properties类的使用"></a>8. Properties类的使用</h3><ul>
<li>Java.util.Properties，主要用于读取Java的配置文件。</li>
<li>Properties类继承自Hashtable</li>
<li>配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用”#”来注释。</li>
<li>Properties类的主要方法：<ol>
<li>getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</li>
<li>load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</li>
<li>setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</li>
<li>store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</li>
<li>clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</li>
</ol>
</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: 郑超(Charles·Zheng)</p><p>原文链接: <a href="http://chaooo.github.io/2019/07/10/J2SE反射机制.html">http://chaooo.github.io/2019/07/10/J2SE反射机制.html</a></p><p>版权声明: 转载请注明出处(保留作者署名及原文链接)</p></blockquote></div><div class="tags"><a href="/tags/javaSE/">javaSE</a><a href="/tags/后端开发/">后端开发</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/07/09/J2SE多线程.html" class="next">J2SE多线程</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'dd644e0a840b03bbb238',
  clientSecret: 'de8b7f88cfa9812e15f93e986181d1c2194ba6e8',
  repo: 'BlogComments',
  owner: 'chaooo',
  admin: ['chaooo'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#八、反射机制"><span class="toc-text">八、反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-基本概念"><span class="toc-text">1. 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-相关类及描述"><span class="toc-text">1.1 相关类及描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Class类"><span class="toc-text">2. Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-获取Class类型对象的三种方式"><span class="toc-text">2.1 获取Class类型对象的三种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-常用方法"><span class="toc-text">2.2 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-其他方法"><span class="toc-text">2.3 其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Constructor类"><span class="toc-text">3. Constructor类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Constructor类中的常用方法"><span class="toc-text">3.1 Constructor类中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-其他方法"><span class="toc-text">3.2 其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Field类"><span class="toc-text">4. Field类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Field类中的常用方法"><span class="toc-text">4.1 Field类中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-其他方法"><span class="toc-text">4.2 其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Method类"><span class="toc-text">5. Method类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-Method类中的常用方法"><span class="toc-text">5.1 Method类中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-其他方法"><span class="toc-text">5.2 其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-原始方式与反射方式构造对象实例"><span class="toc-text">6. 原始方式与反射方式构造对象实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-注解-Annotation"><span class="toc-text">7. 注解(Annotation)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-自己描述一个注解类型"><span class="toc-text">7.1 自己描述一个注解类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Properties类的使用"><span class="toc-text">8. Properties类的使用</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/10/J2SE反射机制.html">J2SE反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/09/J2SE多线程.html">J2SE多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/09/J2SE输入输出-IO.html">J2SE输入输出(IO)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/09/J2SE异常处理机制.html">J2SE异常处理机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/08/J2SE集合框架.html">J2SE集合框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/08/J2SE核心工具类.html">J2SE核心工具类</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/07/J2SE面向对象.html">J2SE面向对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/07/J2SE语法基础.html">J2SE语法基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/22/Win10下配置Nginx-php7-mysql-5-6.html">Win10下配置Nginx+PHP-7+MySQL-5.6</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/29/BlueLake博客主题的详细配置.html">BlueLake博客主题的详细配置</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo博客折腾/">hexo博客折腾</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javaSE知识梳理/">javaSE知识梳理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端工具/">前端工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/javaSE/" style="font-size: 15px;">javaSE</a> <a href="/tags/后端开发/" style="font-size: 15px;">后端开发</a> <a href="/tags/bower/" style="font-size: 15px;">bower</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/sublime/" style="font-size: 15px;">sublime</a> <a href="/tags/BlueLake/" style="font-size: 15px;">BlueLake</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/chaooo" title="chaooo" target="_blank">chaooo</a><ul></ul><a href="https://github.com/chaooo/hexo-theme-BlueLake" title="BlueLake主题" target="_blank">BlueLake主题</a><ul></ul><a href="http://weibo.com/zhengchaooo" title="秋过冬漫长" target="_blank">秋过冬漫长</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p><span> Copyright &copy;<a href="/." rel="nofollow">郑超(Charles·Zheng).</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-78287143-2','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3190aa62d6a262eb340b2998ec3751bb";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>