<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JWT(JSON Web Token)安全认证]]></title>
      <url>http://chaooo.github.io/2019/09/17/JWT%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81.html</url>
      <content type="html"><![CDATA[<h2 id="JSON-Web-Token"><a href="#JSON-Web-Token" class="headerlink" title="JSON Web Token"></a>JSON Web Token</h2><p>JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。</p>
<ul>
<li>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</li>
<li>此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</li>
<li>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</li>
</ul>
<h3 id="1-JWT数据结构"><a href="#1-JWT数据结构" class="headerlink" title="1. JWT数据结构"></a>1. JWT数据结构</h3><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。</p>
<ul>
<li>例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<code>.</code>eyJhdWQiOiJjaGFvIiwidWlkIjoyOSwiZXhwIjoxNTY3OTM2NzgwfQ<code>.</code>6zvimBNs_MCiov4MOkkUodgKmRFBS2dVhmhIb1MV6m4。</li>
</ul>
<p>JWT 的三个部分(<code>Header.Payload.Signature</code>)依次如下:</p>
<ol>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ol>
<h4 id="1-1-Header（头部）"><a href="#1-1-Header（头部）" class="headerlink" title="1.1 Header（头部）"></a>1.1 Header（头部）</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>alg</code>：签名的算法（algorithm），默认是 HMAC SHA256（写成<code>HS256</code>）</li>
<li><code>typ</code>：表示这个令牌（token）的类型（type），JWT令牌统一写为<code>JWT</code>。</li>
</ul>
<p>最后，将上面的 JSON 对象使用 <code>Base64URL算法</code>转成字符串。</p>
<h4 id="1-2-Payload（负载）"><a href="#1-2-Payload（负载）" class="headerlink" title="1.2 Payload（负载）"></a>1.2 Payload（负载）</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段(Reserved claims)，供选用。标准中建议使用这些字段，但不强制。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号，JWT唯一标识，能用于防止JWT重复使用</li>
</ul>
<p>除了官方字段，还有公共声明的字段（见：<a href="http://www.iana.org/assignments/jwt/jwt.xhtml" target="_blank" rel="noopener">http://www.iana.org/assignments/jwt/jwt.xhtml</a>）也可以定义私有字段，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
</blockquote>
<p>这个 JSON 对象也要使用 <code>Base64URL算法</code>转成字符串。</p>
<h4 id="1-3-Signature（签名）"><a href="#1-3-Signature（签名）" class="headerlink" title="1.3 Signature（签名）"></a>1.3 Signature（签名）</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。该签名信息是通过header和payload，加上secret，通过算法加密生成。</p>
<ul>
<li>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<ul>
<li><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></li>
</ul>
</li>
<li>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</li>
</ul>
<h3 id="2-Base64URL算法"><a href="#2-Base64URL算法" class="headerlink" title="2. Base64URL算法"></a>2. Base64URL算法</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p>
<p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h3 id="3-JWT-的使用方式及特点"><a href="#3-JWT-的使用方式及特点" class="headerlink" title="3. JWT 的使用方式及特点"></a>3. JWT 的使用方式及特点</h3><ol>
<li><p>认证原理：</p>
<ul>
<li>客户端向服务器申请授权，服务器认证以后，生成一个token字符串并返回给客户端，此后客户端在请求受保护的资源时携带这个token，服务端进行验证再从这个token中解析出用户的身份信息。</li>
</ul>
</li>
<li><p>JWT的使用方式：</p>
<ul>
<li>客户端收到服务器返回的JWT，存储在浏览器（Cookie或localStorage）</li>
<li>此后，客户端每次与服务器通信，都要带上这个JWT。<ol>
<li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul>
<li><code>Authorization: &lt;token&gt;</code></li>
<li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li>
</ul>
</li>
<li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li>
</ol>
</li>
</ul>
</li>
<li><p>对JWT实现token续签的做法：</p>
<ol>
<li>额外生成一个refreshToken用于获取新token，refreshToken需存储于服务端，其过期时间比JWT的过期时间要稍长。</li>
<li>用户携带refreshToken参数请求token刷新接口，服务端在判断refreshToken未过期后，取出关联的用户信息和当前token。</li>
<li>使用当前用户信息重新生成token，并将旧的token置于黑名单中，返回新的token。</li>
</ol>
</li>
<li><p>JWT 的几个特点</p>
<ol>
<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ol>
</li>
</ol>
<h3 id="4-Java中JWT的使用"><a href="#4-Java中JWT的使用" class="headerlink" title="4. Java中JWT的使用"></a>4. Java中JWT的使用</h3><p>java-jwt工具包提供了<strong>JWT算法的封装</strong></p>
<ol>
<li>导入java-jwt，选择一种算法（HMAC256为例）<ul>
<li><strong><code>Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);</code></strong></li>
<li>算法定义了一个令牌是如何被签名和验证的。</li>
</ul>
</li>
<li>创建一个签名的<code>JWT token</code>（通过调用jwt.create()创建一个JWTCreator实例）<ul>
<li><strong><code>String token = JWT.create().withIssuer(&quot;auth0&quot;).sign(algorithm);</code></strong></li>
<li><em>如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出<strong>JWTCreationException</strong>异常</em></li>
</ul>
</li>
<li>验证令牌（调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。方法build()返回的实例是可重用的，因此可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token）<ul>
<li><strong><code>JWTVerifier verifier = JWT.require(algorithm).withIssuer(&quot;auth0&quot;).build();</code></strong></li>
<li><strong><code>verifier.verify(token);</code></strong></li>
<li><em>如果令牌有一个无效的签名，或者没有满足Claim要求，那么将会抛出<strong>JWTVerificationException</strong>异常</em></li>
</ul>
</li>
<li>jwt时间的验证（当验证一个令牌时，时间验证会自动发生；JWT令牌可能包括可用于验证的DateNumber字段）<ul>
<li><code>&quot;iat&quot; &lt; TODAY</code>：这个令牌发布了一个过期的时间</li>
<li><code>&quot;exp&quot; &gt; TODAY</code>：这个令牌还没过期</li>
<li><code>&quot;nbf&quot; &gt; TODAY</code>：这个令牌已经被使用了</li>
</ul>
</li>
<li>解码一个jwt令牌<ul>
<li><code>DecodedJWT jwt = JWT.decode(token);</code></li>
<li><code>jwt.getAlgorithm();</code>:返回jwt的算法值,如果没有定义则返回null</li>
<li><code>jwt.getType();</code>:返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）</li>
<li><em>如果令牌有无效的语法，或者消息头或有效负载不是JSONs，那么将会抛出<strong>JWTDecodeException</strong>异常</em></li>
</ul>
</li>
</ol>
<h3 id="5-Java中JWT的使用实例"><a href="#5-Java中JWT的使用实例" class="headerlink" title="5. Java中JWT的使用实例"></a>5. Java中JWT的使用实例</h3><p>封装一个JWT工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT; <span class="comment">//导入java-jwt</span></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.JWTVerifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.entity.User; <span class="comment">//引入User实体类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置过期时间，这里设置15分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">15</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//服务端的私钥secret,在任何场景都不应该流露出去</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_SECRET = <span class="string">"zhengchao"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **User**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **password**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createToken</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">            <span class="comment">// 私钥和加密算法</span></span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">// 设置头部信息</span></span><br><span class="line">            Map&lt;String, Object&gt; header = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            header.put(<span class="string">"typ"</span>, <span class="string">"JWT"</span>);</span><br><span class="line">            header.put(<span class="string">"alg"</span>, <span class="string">"HS256"</span>);</span><br><span class="line">            <span class="comment">// 返回token字符串</span></span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">"aud"</span>, user.getName())</span><br><span class="line">                    .withClaim(<span class="string">"uid"</span>, user.getId())</span><br><span class="line">                    .withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验token是否正确</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **token**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVerify</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出uid信息,用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseTokenUid</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"uid"</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出aud信息,用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseTokenAud</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"aud"</span>).asString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录成功后，生成token给浏览器，存储在浏览器（Cookie或localStorage）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String token = JwtUtil.createToken(user);</span><br></pre></td></tr></table></figure>

<p>此后，客户端每次与服务器通信（需权限的资源），都要带上这个JWT。</p>
<ol>
<li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul>
<li><code>Authorization: &lt;token&gt;</code></li>
<li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li>
</ul>
</li>
<li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li>
</ol>
<blockquote>
<p>jwt 适合做简单的 restful api 认证，颁发一个固定有效期的 jwt，降低 jwt 暴露的风险，尽量不要对 jwt 做服务端的状态管理，这样才能体现出 jwt 无状态的优势。</p>
</blockquote>
<h3 id="附：java-jwt已经实现的算法"><a href="#附：java-jwt已经实现的算法" class="headerlink" title="附：java-jwt已经实现的算法"></a>附：java-jwt已经实现的算法</h3><table>
<thead>
<tr>
<th>JWS</th>
<th>算法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>HS256</td>
<td>HMAC256</td>
<td>HMAC with SHA-256</td>
</tr>
<tr>
<td>HS384</td>
<td>HMAC384</td>
<td>HMAC with SHA-384</td>
</tr>
<tr>
<td>HS512</td>
<td>HMAC512</td>
<td>HMAC with SHA-512</td>
</tr>
<tr>
<td>RS256</td>
<td>RSA256</td>
<td>RSASSA-PKCS1-v1_5 with SHA-256</td>
</tr>
<tr>
<td>RS384</td>
<td>RSA384</td>
<td>RSASSA-PKCS1-v1_5 with SHA-384</td>
</tr>
<tr>
<td>RS512</td>
<td>RSA512</td>
<td>RSASSA-PKCS1-v1_5 with SHA-512</td>
</tr>
<tr>
<td>ES256</td>
<td>ECDSA256</td>
<td>ECDSA with curve P-256 and SHA-256</td>
</tr>
<tr>
<td>ES384</td>
<td>ECDSA384</td>
<td>ECDSA with curve P-384 and SHA-384</td>
</tr>
<tr>
<td>ES512</td>
<td>ECDSA512</td>
<td>ECDSA with curve P-521 and SHA-512</td>
</tr>
</tbody></table>
]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MD5算法加盐实现用户密码加密]]></title>
      <url>http://chaooo.github.io/2019/09/08/MD5%E7%AE%97%E6%B3%95%E5%8A%A0%E7%9B%90%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86.html</url>
      <content type="html"><![CDATA[<h3 id="1-MD5加密算法介绍"><a href="#1-MD5加密算法介绍" class="headerlink" title="1. MD5加密算法介绍"></a>1. MD5加密算法介绍</h3><p>MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。</p>
<h3 id="2-MD5加密算法特点："><a href="#2-MD5加密算法特点：" class="headerlink" title="2. MD5加密算法特点："></a>2. MD5加密算法特点：</h3><ol>
<li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li>
<li>容易计算：从原数据计算出MD5值很容易。</li>
<li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li>
<li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li>
</ol>
<h3 id="3-盐（Salt）"><a href="#3-盐（Salt）" class="headerlink" title="3. 盐（Salt）"></a>3. 盐（Salt）</h3><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p>
<h3 id="4-java-security-MessageDigest类"><a href="#4-java-security-MessageDigest类" class="headerlink" title="4. java.security.MessageDigest类"></a>4. java.security.MessageDigest类</h3><p>JDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。</p>
<ul>
<li>MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。</li>
<li>MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。</li>
<li>对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。</li>
</ul>
<h3 id="5-封装一个MD5加密工具类"><a href="#5-封装一个MD5加密工具类" class="headerlink" title="5. 封装一个MD5加密工具类"></a>5. 封装一个MD5加密工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s：待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化MessageDigest的MD5算法对象</span></span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="comment">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = md.digest(s.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="comment">//将字节数组转换为16进制字符串并返回</span></span><br><span class="line">            <span class="keyword">return</span> toHex(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随即盐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">salt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用UUID生成随机盐</span></span><br><span class="line">        UUID uuid = UUID.randomUUID();</span><br><span class="line">        <span class="comment">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class="line">        String[] arr = uuid.toString().split(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转换为16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] HEX_DIGITS = <span class="string">"0123456789ABCDEF"</span>.toCharArray();</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class="line">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]);</span><br><span class="line">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class="number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-使用封装的MD5工具类完成用户注册-主要代码"><a href="#6-使用封装的MD5工具类完成用户注册-主要代码" class="headerlink" title="6. 使用封装的MD5工具类完成用户注册(主要代码)"></a>6. 使用封装的MD5工具类完成用户注册(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">register</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">//设置用户名</span></span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="comment">//密码加密后再保存</span></span><br><span class="line">    String salt = MD5Util.salt();</span><br><span class="line">    String md5Password = MD5Util.md5(password+salt);</span><br><span class="line">    <span class="comment">//存入MD5加密后的密码</span></span><br><span class="line">    user.setPassword(md5Password);</span><br><span class="line">    <span class="comment">//随机盐存入数据库，用于登录校验</span></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line">    <span class="comment">//最后将用户数据数据存入数据库</span></span><br><span class="line">    <span class="keyword">int</span> row = userDao.insert(user);</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-使用封装的MD5工具类完成用户登录-主要代码"><a href="#7-使用封装的MD5工具类完成用户登录-主要代码" class="headerlink" title="7. 使用封装的MD5工具类完成用户登录(主要代码)"></a>7. 使用封装的MD5工具类完成用户登录(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据用户名在数据库查找用户</span></span><br><span class="line">    User user = userDao.selectByName(name);</span><br><span class="line">    <span class="comment">//取出用户信息比对</span></span><br><span class="line">    String dbPassword = user.getPassword();</span><br><span class="line">    String  salt = user.getSalt();</span><br><span class="line">    <span class="comment">//通过密码+盐 重新生成 MD5密码</span></span><br><span class="line">    String md5Password = MD5Util.md5(password+salt);</span><br><span class="line">    <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">        <span class="comment">//登录成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-扩展：MessageDigest类常用方法"><a href="#8-扩展：MessageDigest类常用方法" class="headerlink" title="8. 扩展：MessageDigest类常用方法"></a>8. 扩展：MessageDigest类常用方法</h3><h4 id="8-1-构造方法摘要"><a href="#8-1-构造方法摘要" class="headerlink" title="8.1 构造方法摘要"></a>8.1 构造方法摘要</h4><p><code>MessageDigest(String algorithm)</code> –创建具有指定算法名称的MessageDigest 实例对象。</p>
<ul>
<li>MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有”MD5”，”SHA”等。</li>
</ul>
<h4 id="8-2-成员方法摘要："><a href="#8-2-成员方法摘要：" class="headerlink" title="8.2 成员方法摘要："></a>8.2 成员方法摘要：</h4><table>
<thead>
<tr>
<th>返回值</th>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td><code>clone()</code></td>
<td>如果实现是可复制的，则返回一个副本。</td>
</tr>
<tr>
<td>byte[]</td>
<td><code>digest()</code></td>
<td>通过执行诸如填充之类的最终操作完成哈希计算。</td>
</tr>
<tr>
<td>byte[]</td>
<td><code>digest(byte[] input)</code></td>
<td>使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。</td>
</tr>
<tr>
<td>int</td>
<td><code>digest(byte[] buf, int offset, int len)</code></td>
<td>通过执行诸如填充之类的最终操作完成哈希计算。</td>
</tr>
<tr>
<td>String</td>
<td><code>getAlgorithm()</code></td>
<td>返回标识算法的独立于实现细节的字符串。</td>
</tr>
<tr>
<td>int</td>
<td><code>getDigestLength()</code></td>
<td>返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。</td>
</tr>
<tr>
<td>static MessageDigest</td>
<td><code>getInstance(String algorithm)</code></td>
<td>生成实现指定摘要算法的 MessageDigest 对象。</td>
</tr>
<tr>
<td>static MessageDigest</td>
<td><code>getInstance(String algorithm, Provider provider)</code></td>
<td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td>
</tr>
<tr>
<td>static MessageDigest</td>
<td><code>getInstance(String algorithm, String provider)</code></td>
<td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td>
</tr>
<tr>
<td>Provider</td>
<td><code>getProvider()</code></td>
<td>返回此信息摘要对象的提供程序。</td>
</tr>
<tr>
<td>static boolean</td>
<td><code>isEqual(byte[] digesta, byte[] digestb)</code></td>
<td>比较两个摘要的相等性。</td>
</tr>
<tr>
<td>void</td>
<td><code>reset()</code></td>
<td>重置摘要以供再次使用。</td>
</tr>
<tr>
<td>String</td>
<td><code>toString()</code></td>
<td>返回此信息摘要对象的字符串表示形式。</td>
</tr>
<tr>
<td>void</td>
<td><code>update(byte input)</code></td>
<td>使用指定的字节更新摘要。</td>
</tr>
<tr>
<td>void</td>
<td><code>update(byte[] input)</code></td>
<td>使用指定的字节数组更新摘要。</td>
</tr>
<tr>
<td>void</td>
<td><code>update(byte[] input, int offset, int len)</code></td>
<td>使用指定的字节数组，从指定的偏移量开始更新摘要。</td>
</tr>
<tr>
<td>void</td>
<td><code>update(ByteBuffer input)</code></td>
<td>使用指定的 ByteBuffer 更新摘要。</td>
</tr>
</tbody></table>
<blockquote>
<p>★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[嵌入式SQL语言]]></title>
      <url>http://chaooo.github.io/2019/09/02/03-%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AF%AD%E8%A8%80.html</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，</li>
<li>然而，交互式SQL本身也有很多局限：<a id="more"></a><ul>
<li>从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以</li>
<li>从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</li>
</ul>
</li>
<li>因此，高级语言+SQL语言：<ul>
<li>既继承高级语言的过程控制性</li>
<li>又结合SQL语言的复杂结果集操作的非过程性</li>
<li>同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作</li>
</ul>
</li>
<li>嵌入式SQL语言<ul>
<li>将SQL语言嵌入到某一种高级语言中使用</li>
<li>这种高级语言，如C/C++, Java, PowerBuilder等，又称宿主语言(Host Language)</li>
<li>嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式</li>
</ul>
</li>
</ul>
<h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol>
<li><a href="#id1">变量声明与数据库连接</a></li>
<li><a href="#id2">事务Transaction</a></li>
<li><a href="#id3">数据集与游标</a></li>
<li><a href="#id4">状态捕获及错误处理机制</a></li>
<li><a href="#id5">动态SQL</a></li>
<li><a href="#id6">数据字典与SQLDA</a></li>
<li><a href="#id7">ODBC简介</a></li>
<li><a href="#id8">JDBC简介</a></li>
<li><a href="#id9">嵌入式SQL-ODBC-JDBC三者比较</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-变量声明与数据库连接"><a href="#1-变量声明与数据库连接" class="headerlink" title="1. 变量声明与数据库连接"></a>1. 变量声明与数据库连接</h3><ol>
<li>以宿主语言<strong>C语言</strong>为例，对比交互式SQL语言与嵌入式SQL语言<ul>
<li>交互式SQL:<code>select Sname, Sage from Student where Sname=&#39;张三&#39;;</code></li>
<li>嵌入式SQL:<code>exec sql select Sname, Sage into :vSname, :vSage from Student where Sname=&#39;张三&#39;;</code></li>
</ul>
</li>
<li>典型特点<ul>
<li><strong>exec sql</strong>引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句</li>
<li>增加一 <strong>into子句</strong>: 该子句用于指出接收SQL语句检索结果的程序变量</li>
<li>由冒号引导的<strong>程序变量</strong>,如: ‘:vSname’, ‘:vSage’</li>
</ul>
</li>
</ol>
<h4 id="1-1-变量的声明与使用"><a href="#1-1-变量的声明与使用" class="headerlink" title="1.1 变量的声明与使用"></a>1.1 变量的声明与使用</h4><ul>
<li><p>在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">    char vSname[10], specName[10]="张三";</span><br><span class="line">    int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量声明和赋值中，要注意：</p>
<ul>
<li>宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为’\0’，而程序中用双引号来描述。</li>
<li>宿主程序变量类型与数据库字段类型之间有些是有差异的,有些DBMS可支持自动转换，有些不能。</li>
</ul>
</li>
<li><p>声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。</p>
</li>
<li><p>嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。</p>
</li>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">    char vSname[10], specName[10]="张三";</span><br><span class="line">    int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">//用户可在此处基于键盘输入给specName赋值</span><br><span class="line">exec sql <span class="keyword">select</span> Sname, Sage <span class="keyword">into</span> :vSname, :vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname = :specName;</span><br><span class="line">//比较相应的交互式SQL语句：</span><br><span class="line"><span class="keyword">select</span> Sname, Sage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-2-程序与数据库的连接和断开"><a href="#1-2-程序与数据库的连接和断开" class="headerlink" title="1.2 程序与数据库的连接和断开"></a>1.2 程序与数据库的连接和断开</h4><h5 id="1-2-1-数据库的连接connect"><a href="#1-2-1-数据库的连接connect" class="headerlink" title="1.2.1 数据库的连接connect"></a>1.2.1 数据库的连接connect</h5><p>在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异</p>
<ol>
<li>SQL标准中建议的连接语法为：<ul>
<li><code>execsql connecttotarget-server asconnect-name useruser-name;</code></li>
<li>或 <code>execsql connecttodefault;</code></li>
</ul>
</li>
<li>Oracle中数据库连接:<ul>
<li><code>execsql connect:user_name identified by :user_pwd;</code></li>
</ul>
</li>
<li>DB2 UDB中数据库连接:<ul>
<li><code>execsql connecttomydb user:user_name using:user_pwd;</code></li>
</ul>
</li>
</ol>
<h5 id="1-2-1-数据库的断开disconnect"><a href="#1-2-1-数据库的断开disconnect" class="headerlink" title="1.2.1 数据库的断开disconnect"></a>1.2.1 数据库的断开disconnect</h5><p>在嵌入式SQL程序执行之后，需要与数据库断开连接</p>
<ol>
<li>SQL标准中建议的断开连接的语法为：<ul>
<li><code>exec sql disconnect connect-name;</code></li>
<li>或 <code>exec sql disconnect current;</code></li>
</ul>
</li>
<li>Oracle中断开连接:<ul>
<li><code>exec sql commit release;</code></li>
<li>或 <code>exec sql rollback release;</code></li>
</ul>
</li>
<li>DB2 UDB中断开连接:<ul>
<li><code>exec sql connect reset;</code></li>
<li><code>exec sql disconnect current;</code></li>
</ul>
</li>
</ol>
<h4 id="1-3-SQL执行的提交与撤消"><a href="#1-3-SQL执行的提交与撤消" class="headerlink" title="1.3 SQL执行的提交与撤消"></a>1.3 SQL执行的提交与撤消</h4><p>SQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果</p>
<ol>
<li>SQL执行的提交：<ul>
<li><code>execsql commitwork;</code></li>
</ul>
</li>
<li>SQL执行的撤消：<ul>
<li><code>execsql rollbackwork;</code></li>
</ul>
</li>
<li>为此，很多DBMS都设计了捆绑提交/撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：<ul>
<li><code>execsql commitrelease;</code></li>
<li>或 <code>execsql rollbackrelease;</code></li>
</ul>
</li>
</ol>
<p><span id="id2"><span></span></span></p>
<h3 id="2-事务Transaction"><a href="#2-事务Transaction" class="headerlink" title="2. 事务Transaction"></a>2. 事务Transaction</h3><ol>
<li>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务</li>
<li>从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li>
<li>简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；<strong>事务是一个不可分割的工作逻辑单元</strong>。</li>
</ol>
<h4 id="2-1-事务的特性-ACID"><a href="#2-1-事务的特性-ACID" class="headerlink" title="2.1 事务的特性: ACID"></a>2.1 事务的特性: ACID</h4><ol>
<li><strong>原子性</strong>Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行</li>
<li><strong>一致性</strong>Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的</li>
<li><strong>隔离性</strong>Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。</li>
<li><strong>持久性</strong>Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。</li>
</ol>
<blockquote>
<p>换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。</p>
</blockquote>
<p><span id="id3"><span></span></span></p>
<h3 id="3-数据集与游标"><a href="#3-数据集与游标" class="headerlink" title="3. 数据集与游标"></a>3. 数据集与游标</h3><p>读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)</p>
<ol>
<li>检索单行结果，可将结果直接传送到宿主程序的变量中(Into)<ul>
<li>示例：<code>exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;</code></li>
</ul>
</li>
<li>检索多行结果，则需使用游标(Cursor)<ul>
<li>游标是指向某检索记录集的指针</li>
<li>通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕</li>
<li>读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取</li>
<li>记录集有结束标识EOF, 用来标记后面已没有记录了</li>
</ul>
</li>
</ol>
<ul>
<li>游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭</li>
<li>游标可以定义一次，多次打开(多次执行)，多次关闭</li>
</ul>
<h4 id="3-1-游标的使用方法"><a href="#3-1-游标的使用方法" class="headerlink" title="3.1 游标的使用方法"></a>3.1 游标的使用方法</h4><ol>
<li><p>Cursor的定义：declare cursor</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    Subquery</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">    [<span class="keyword">FOR</span> [ <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> columnname [, columnname…]]]];</span><br><span class="line">//示例:</span><br><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass= :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cursor的打开和关闭：open cursor //close cursor</p>
<ul>
<li>EXEC SQL OPEN cursor_name;</li>
<li>EXEC SQL CLOSE cursor_name;</li>
</ul>
</li>
<li><p>Cursor的数据读取：Fetch</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH cursor_name</span><br><span class="line">    INTO host-variable , [host-variable, …];</span><br><span class="line">//示例:</span><br><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass= :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br><span class="line">exec sql open cur_student;</span><br><span class="line">…</span><br><span class="line">exec sql fetch cur_student into :vSno, :vSname, :vSage</span><br><span class="line">…</span><br><span class="line">exec sql close cur_student;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-2-可滚动游标"><a href="#3-2-可滚动游标" class="headerlink" title="3.2 可滚动游标"></a>3.2 可滚动游标</h4><ol>
<li>ODBC支持的可滚动Cursor<ul>
<li>标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开</li>
<li>ODBC(OpenDataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口</li>
<li>许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能</li>
</ul>
</li>
<li>可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标<ul>
<li>可滚动游标移动时需判断是否到结束位置，或到起始位置<ul>
<li>可通过判断是否到EOF位置(最后一条记录的后面),或BOF位置(起始记录的前面)</li>
<li>如果不需区分，可通过whenevernotfound语句设置来检测</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name [INSENSITIVE] [<span class="keyword">SCROLL</span>] <span class="keyword">CURSOR</span></span><br><span class="line">[<span class="keyword">WITH</span> HOLD] <span class="keyword">FOR</span> Subquery</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> columnname [,</span><br><span class="line">columnname ]…];</span><br><span class="line">EXEC SQL FETCH</span><br><span class="line">[ NEXT | PRIOR | FIRST | LAST</span><br><span class="line">| [ABSOLUTE | RELATIVE] value_spec ]</span><br><span class="line">FROM cursor_name INTO host-variable [, host-variable …];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NEXT</code>向结束方向移动一条；</li>
<li><code>PRIOR</code>向开始方向移动一条；</li>
<li><code>FIRST</code>回到第一条；</li>
<li><code>LAST</code>移动到最后一条；</li>
<li><code>ABSOLUTvalue_spec</code>定向检索指定位置的行,value_spec由1至当前记录集最大值；</li>
<li><code>RELATIVEvalue_spec</code>相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动</li>
</ul>
<h4 id="3-3-数据库记录的增删改"><a href="#3-3-数据库记录的增删改" class="headerlink" title="3.3 数据库记录的增删改"></a>3.3 数据库记录的增删改</h4><ol>
<li>数据库记录的删除<ul>
<li>一种是查找删除(与交互式DELETE语句相同)，一种是定位删除</li>
</ul>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">WHERE</span> search_condition | <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line">//示例：查找删除</span><br><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city = ‘Harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid);</span><br><span class="line">//示例：定位删除</span><br><span class="line">exec sql <span class="keyword">declare</span> delcust <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> cid <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city =‘harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> cid;</span><br><span class="line">exec sql open delcust</span><br><span class="line">While (TRUE) &#123;</span><br><span class="line">    exec sql fetch delcust into :cust_id;</span><br><span class="line">    exec sql delete from customers where current of delcust ; &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据库记录的更新<ul>
<li>一种是查找更新(与交互式Update语句相同)，一种是定位更新</li>
</ul>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">UPDATE</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">SET</span> columnname = expr [, columnname = expr …]</span><br><span class="line">    [ <span class="keyword">WHERE</span> search_condition ] | <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line">//示例：查找更新</span><br><span class="line">exec sql <span class="keyword">update</span> student s <span class="keyword">set</span> sclass = ‘<span class="number">035102</span>’</span><br><span class="line">    <span class="keyword">where</span> s.sclass = ‘<span class="number">034101</span>’</span><br><span class="line">// 示例：定位更新</span><br><span class="line">exec <span class="keyword">sql</span> <span class="keyword">declare</span> stud <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.sclass =‘<span class="number">034101</span>’</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> sclass;</span><br><span class="line">exec sql open stud</span><br><span class="line">While (TRUE) &#123;</span><br><span class="line">    exec sql fetch stud into :vSno, :vSname, :vSclass;</span><br><span class="line">    exec sql update student set sclass = ‘035102’ where current of stud ; &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数据库记录的插入<ul>
<li>只有一种类型的插入语句</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename [ (columnname [,columnname, …] )]</span><br><span class="line">    [ <span class="keyword">VALUES</span> (expr [ , expr , …] ) | subqurey ] ;</span><br><span class="line">//示例：插入语句</span><br><span class="line">exec sql <span class="keyword">insert</span> <span class="keyword">into</span> student ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">values</span> (‘<span class="number">03510128</span>’, ‘张三’, ‘<span class="number">035101</span>’) ;</span><br><span class="line">//示例：插入语句</span><br><span class="line">exec sql <span class="keyword">insert</span> <span class="keyword">into</span> masterstudent ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">select</span> sno, sname, sclass <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>

<p><span id="id4"><span></span></span></p>
<h3 id="4-状态捕获及错误处理机制"><a href="#4-状态捕获及错误处理机制" class="headerlink" title="4. 状态捕获及错误处理机制"></a>4. 状态捕获及错误处理机制</h3><h4 id="4-1-基本机制"><a href="#4-1-基本机制" class="headerlink" title="4.1 基本机制"></a>4.1 基本机制</h4><ul>
<li><p>状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理</p>
</li>
<li><p>嵌入式 SQL程序中，状态捕获及处理有三部分构成</p>
<ol>
<li>设置SQL通信区:一般在嵌入式SQL程序的开始处便设置<ul>
<li><code>exec sql include sqlca;</code></li>
</ul>
</li>
<li>设置状态捕获语句:在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域<ul>
<li><code>exec sql whenever sqlerror goto report_error;</code></li>
</ul>
</li>
<li>状态处理语句:某一段程序以应对SQL操作的某种状态<ul>
<li><code>report_error: exec sql rollback;</code></li>
</ul>
</li>
</ol>
</li>
<li><p>SQL通信区: SQLCA</p>
<ol>
<li>SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理</li>
<li>SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一</li>
</ol>
</li>
<li><p>状态捕获语句: <code>exec sql whenever condition action;</code></p>
<ul>
<li>Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).<ul>
<li>SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS</li>
<li>NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现</li>
<li>SQLWARNING: 不是错误，但应引起注意的条件</li>
</ul>
</li>
<li>如果满足condition, 则要采取一些动作(由action指出)<ul>
<li>CONTINUE: 忽略条件或错误，继续执行</li>
<li>GOTO 标号: 转移到标号所指示的语句，去进行相应的处理</li>
<li>STOP: 终止程序运行、撤消当前的工作、断开数据库的连接</li>
<li>DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行</li>
</ul>
</li>
</ul>
</li>
<li><p>状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    exec sql whenever sqlerror <span class="keyword">stop</span>;</span><br><span class="line">    … …</span><br><span class="line">    goto s1</span><br><span class="line">    … …</span><br><span class="line">    exec sql whenever sqlerror continue;</span><br><span class="line">    s1: exec sql <span class="keyword">update</span> agents <span class="keyword">set</span> <span class="keyword">percent</span> = <span class="keyword">percent</span> + <span class="number">1</span>;</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br><span class="line">//S1标号指示的语句受第二个Whenever语句约束。</span><br><span class="line">//注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态捕获语句Whenever的使用容易引发无限循环</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    exec sql whenever sqlerror goto handle_error;</span><br><span class="line">    exec sql <span class="keyword">create</span> <span class="keyword">table</span> customers(cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cname <span class="built_in">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">    … …</span><br><span class="line">    handle_error:</span><br><span class="line">        exec sql whenever sqlerror continue;// 控制是否无限循环：无，则可能；有，则不会</span><br><span class="line">        exec sql <span class="keyword">drop</span> customers;</span><br><span class="line">        exec sql disconnect;</span><br><span class="line">        fprintf(stderr,”could not <span class="keyword">create</span> customers <span class="keyword">table</span>\n”);</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-2-状态信息"><a href="#4-2-状态信息" class="headerlink" title="4.2 状态信息"></a>4.2 状态信息</h4><p>典型DBMS系统记录状态信息的三种方法</p>
<ul>
<li>状态记录:<ol>
<li><code>sqlcode</code>: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。<ul>
<li>sqlcode== 0, successful call;</li>
<li>sqlcode &lt; 0, error, e.g., from connect, database does not exist , –16;</li>
<li>sqlcode &gt; 0, warning, e.g., no rows retrieved from fetch</li>
</ul>
</li>
<li><code>sqlca.sqlcode</code>: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录</li>
<li><code>sqlstate</code>: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate</li>
</ol>
</li>
<li>当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)</li>
<li>但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)</li>
</ul>
<h4 id="4-3-程序自身进行错误信息的处理"><a href="#4-3-程序自身进行错误信息的处理" class="headerlink" title="4.3 程序自身进行错误信息的处理"></a>4.3 程序自身进行错误信息的处理</h4><p>正确的显式状态处理示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> declar <span class="keyword">section</span>;</span><br><span class="line">    char SQLSTATE[6];</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">exec sql whenever sqlerror goto handle_error;</span><br><span class="line">… …</span><br><span class="line">exec sql whenever sqlerror continue;</span><br><span class="line">exec sql <span class="keyword">create</span> <span class="keyword">table</span> custs</span><br><span class="line">    (cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>, cname <span class="built_in">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">if (strcmp(SQLSTATE, “82100”)==0)</span><br><span class="line">    &lt;处理82100错误的程序&gt;</span><br><span class="line">    … …</span><br></pre></td></tr></table></figure>

<p>上述的if语句是能被执行的，因为createtable发生错误时是继续向下执行的。</p>
<p><span id="id5"><span></span></span></p>
<h3 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h3><h4 id="5-1-动态SQL的概念"><a href="#5-1-动态SQL的概念" class="headerlink" title="5.1 动态SQL的概念"></a>5.1 动态SQL的概念</h4><p>动态SQL是相对于静态SQL而言的</p>
<ul>
<li>静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)</li>
<li>动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量</li>
</ul>
<h4 id="5-2-动态SQL的两种执行方式"><a href="#5-2-动态SQL的两种执行方式" class="headerlink" title="5.2 动态SQL的两种执行方式"></a>5.2 动态SQL的两种执行方式</h4><p>如SQL语句已经被构造在host-variable字符串变量中,则：</p>
<ol>
<li><strong>立即执行语句</strong>: 运行时编译并执行<ul>
<li><code>EXEC SQL EXECUTE IMMEDIATE :host-variable;</code></li>
</ul>
</li>
<li><strong>Prepare-Execute-Using语句</strong>:PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句<ul>
<li><code>EXEC SQL PREPARE sql_temp FROM :host-variable;</code></li>
<li><code>EXEC SQL EXECUTE sql_temp USING :cond-variable</code></li>
</ul>
</li>
</ol>
<p><span id="id6"><span></span></span></p>
<h3 id="6-数据字典与SQLDA"><a href="#6-数据字典与SQLDA" class="headerlink" title="6. 数据字典与SQLDA"></a>6. 数据字典与SQLDA</h3><h4 id="6-1-数据字典的概念"><a href="#6-1-数据字典的概念" class="headerlink" title="6.1 数据字典的概念"></a>6.1 数据字典的概念</h4><p>数据字典(Data dictionary)，又称为系统目录(System Catalogs)</p>
<ul>
<li>是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等,这些信息又称数据库的元数据–关于数据的数据。</li>
<li>不同DBMS术语不一样：数据字典(DataDictionary(Oracle))、目录表(DB2UDB)、系统目录(INFORMIX)、系统视图(X/Open)</li>
<li>不同DBMS中系统目录存储方式可能是不同的,但会有一些信息对DBA公开。这些公开的信息,DBA可以使用一些特殊的SQL命令来检索。</li>
</ul>
<h4 id="6-2-数据字典的内容构成"><a href="#6-2-数据字典的内容构成" class="headerlink" title="6.2 数据字典的内容构成"></a>6.2 数据字典的内容构成</h4><p>数据字典通常存储的是数据库和表的元数据，即模式本身的信息：</p>
<ol>
<li>与关系相关的信息<ul>
<li>关系名字</li>
<li>每一个关系的属性名及其类型</li>
<li>视图的名字及其定义</li>
<li>完整性约束</li>
</ul>
</li>
<li>用户与账户信息，包括密码</li>
<li>统计与描述性数据：如每个关系中元组的数目</li>
<li>物理文件组织信息：<ul>
<li>关系是如何存储的(顺序/无序/散列等)</li>
<li>关系的物理位置</li>
</ul>
</li>
<li>索引相关的信息</li>
</ol>
<h4 id="6-3-数据字典的结构"><a href="#6-3-数据字典的结构" class="headerlink" title="6.3 数据字典的结构"></a>6.3 数据字典的结构</h4><ol>
<li>也是存储在磁盘上的关系</li>
<li>专为内存高效访问设计的特定的数据结构</li>
</ol>
<ul>
<li>可能的字典数据结构<ul>
<li><code>Relation_metadata</code> = <code>(relation_name, number_of_attributes, storage_organization, location)</code></li>
<li><code>Attribute_metadata</code> = <code>(attribute_name, relation_name, domain_type, position, length)</code></li>
<li><code>User_metadata</code> = <code>(user_name, encrypted_password, group)</code></li>
<li><code>Index_metadata</code> = <code>(index_name, relation_name, index_type, index_attributes)</code></li>
<li><code>View_metadata</code> = <code>(view_name, definition)</code></li>
</ul>
</li>
</ul>
<h4 id="6-4-X-Open标准的系统目录"><a href="#6-4-X-Open标准的系统目录" class="headerlink" title="6.4 X/Open标准的系统目录"></a>6.4 X/Open标准的系统目录</h4><ol>
<li>X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息<ul>
<li><code>Table_Schem</code>：表的模式名(通常是表所有者的用户名)</li>
<li><code>Table_Name</code>：表名</li>
<li><code>Table_Type</code>：<code>&#39;Base_Table&#39;</code>或<code>&#39;View&#39;</code></li>
</ul>
</li>
<li>可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：<ul>
<li><code>Select Table_Name From Tables;</code></li>
</ul>
</li>
<li>模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。</li>
<li>一般而言，一个用户有一个模式。可以使用CreateSchema语句来创建模式(用法参见相关文献)，在CreateTable等语句可以使用所定义的模式名称。</li>
</ol>
<h4 id="6-5-Oracle的数据字典"><a href="#6-5-Oracle的数据字典" class="headerlink" title="6.5 Oracle的数据字典"></a>6.5 Oracle的数据字典</h4><ol>
<li>Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识<ul>
<li><code>USER_</code> :用户视图，用户所拥有的对象，在用户模式中</li>
<li><code>ALL_</code>  :扩展的用户视图，用户可访问的对象</li>
<li><code>DBA_</code>  :DBA视图(所有用户都可访问的DBA对象的子集)</li>
</ul>
</li>
<li>Oracle数据字典中定义了三个视图<code>USER_Tables</code>,<code>ALL_Tables</code>,和<code>DBA_Tables</code>供DBA和用户使用数据字典中关于<strong>表的信息</strong></li>
<li>同样,Oracle数据字典中也定义了三个视图<code>USER_TAB_Columns</code>,<code>ALL_TAB_Columns</code>(<code>Accessible_Columns</code>),和<code>DBA_TAB_Columns</code>供DBA和用户使用数据字典中关于表的<strong>列的信息</strong></li>
<li>可以使用SQL语句来访问这些表中的信息：<ul>
<li><code>Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;</code></li>
</ul>
</li>
<li>Oracle数据字典中还定义了其他视图<ul>
<li><code>TABLE_PRIVILEDGE</code>(或<code>ALL_TAB_GRANTS</code>)</li>
<li><code>COLUMN_PRIVILEDGE</code>(或<code>ALL_COL_GRANTS</code>)可访问表的权限，列的权限</li>
<li><code>CONSTRAINT_DEFS</code>(或<code>ALL_CONSTRAINTS</code>)可访问表的各种约束</li>
</ul>
</li>
<li>可以使用下述命令获取Oracle定义的所有视图信息<ul>
<li><code>Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;</code></li>
</ul>
</li>
<li>如果用户使用Oracle,可使用其提供的<code>SQL*PLUS</code>进行交互式访问</li>
<li>动态SQL: 表和列都已知，动态构造检索条件。</li>
<li>动态SQL:检索条件可动态构造，表和列也可动态构造。</li>
</ol>
<h4 id="6-6-SQLDA"><a href="#6-6-SQLDA" class="headerlink" title="6.6 SQLDA"></a>6.6 SQLDA</h4><p>构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息</p>
<ol>
<li>SQLDA: SQLDescriptorArea,SQL描述符区域。<ul>
<li>SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等</li>
<li>通过读取SQLDA信息可以进行更为复杂的动态SQL的处理</li>
<li>不同DBMS提供的SQLDA格式并不是一致的。</li>
</ul>
</li>
</ol>
<p><span id="id7"><span></span></span></p>
<h3 id="7-ODBC简介"><a href="#7-ODBC简介" class="headerlink" title="7. ODBC简介"></a>7. ODBC简介</h3><h4 id="7-1-ODBC定义"><a href="#7-1-ODBC定义" class="headerlink" title="7.1 ODBC定义"></a>7.1 ODBC定义</h4><p>ODBC：Open DataBase Connection，ODBC是一种标准—不同语言的应用程序与不同数据库服务器之间通讯的标准。</p>
<ul>
<li>一组API(应用程序接口)，支持应用程序与数据库服务器的交互</li>
<li>应用程序通过调用ODBC API, 实现<ol>
<li>与数据服务器的连接</li>
<li>向数据库服务器发送SQL命令</li>
<li>一条一条的提取数据库检索结果中的元组传递给应用程序的变量</li>
</ol>
</li>
<li>具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。</li>
<li>ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；</li>
</ul>
<h4 id="7-2-通过ODBC连接数据库"><a href="#7-2-通过ODBC连接数据库" class="headerlink" title="7.2 通过ODBC连接数据库"></a>7.2 通过ODBC连接数据库</h4><ol>
<li>ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中</li>
<li>当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果</li>
<li>ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄</li>
<li>应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:<ul>
<li><code>connection handle</code>, 连接句柄</li>
<li><code>the server</code>，要连接的数据库服务器</li>
<li><code>the user identifier</code>，用户</li>
<li><code>password</code> ，密码</li>
<li><code>SQL_NTS</code> 类型说明前面的参数是空终止的字符串</li>
</ul>
</li>
<li>示例<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int ODBCexample()&#123;</span><br><span class="line">    RETCODE error; <span class="comment">/* 返回状态吗 */</span></span><br><span class="line">    HENV env; <span class="comment">/* 环境变量 */</span></span><br><span class="line">    HDBC conn; <span class="comment">/* 连接句柄 */</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line">    //分配数据库连接环境</span><br><span class="line">    SQLConnect(conn, "aura.bell-labs.com", SQL_NTS, "avi", SQL_NTS, avipasswd", SQL_NTS);</span><br><span class="line">    //打开一个数据库连接</span><br><span class="line">    &#123; …. Do actual work … &#125;</span><br><span class="line">    //与数据库通讯</span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">    //断开连接与释放环境</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="7-3-通过ODBC与数据库服务器进行通讯"><a href="#7-3-通过ODBC与数据库服务器进行通讯" class="headerlink" title="7.3 通过ODBC与数据库服务器进行通讯"></a>7.3 通过ODBC与数据库服务器进行通讯</h4><ol>
<li>应用程序使用SQLExecDirect()向数据库发送SQL命令；</li>
<li>使用SQLFetch()获取产生的结果元组；</li>
<li>使用SQLBindCol()绑定C语言变量与结果中的属性<ul>
<li>当获取一个元组时，属性值会自动地传送到相应的C语言变量中</li>
</ul>
</li>
<li>SQLBindCol()的参数：<ul>
<li>ODBC定义的stmt变量,查询结果中的属性位置</li>
<li>SQL到C的类型变换,变量的地址.</li>
<li>对于类似字符数组一样的可变长度类型，应给出<ul>
<li>•变量的最大长度</li>
<li>•当获取到一个元组后，实际长度的存储位置.</li>
<li>•注:当返回实际长度为负数，说明是一个空值。</li>
</ul>
</li>
</ul>
</li>
<li>示例<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">char branchname[80]; float balance;</span><br><span class="line">int lenOut1, lenOut2;</span><br><span class="line">HSTMT stmt;</span><br><span class="line">SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line">//分配一个与指定数据库连接的新的语句句柄</span><br><span class="line">char * sqlquery = "select branch_name, sum (balance)</span><br><span class="line">    from account</span><br><span class="line">    group by branch_name";</span><br><span class="line">error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line">//执行查询，stmt句柄指向结果集合</span><br><span class="line">if (error == SQL_SUCCESS) &#123;</span><br><span class="line">SQLBindCol(stmt, 1, SQL_C_CHAR, branchname , 80, &amp;lenOut1);</span><br><span class="line">SQLBindCol(stmt, 2, SQL_C_FLOAT, &amp;balance, 0 , &amp;lenOut2);</span><br><span class="line">//绑定高级语言变量与stmt句柄中的属性</span><br><span class="line">while (SQLFetch(stmt) &gt;= SQL_SUCCESS) &#123;</span><br><span class="line">//提取一条记录，结果数据被存入高级语言变量中</span><br><span class="line">    printf (" %s %g\n", branchname, balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SQLFreeStmt(stmt, SQL_DROP);</span><br><span class="line">//释放语句句柄</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="7-4-ODBC的其他功能"><a href="#7-4-ODBC的其他功能" class="headerlink" title="7.4 ODBC的其他功能"></a>7.4 ODBC的其他功能</h4><ol>
<li>动态SQL语句的预编译-动态参数传递功能</li>
<li>获取元数据特性<ul>
<li>发现数据库中的所有关系的特性 以及</li>
<li>发现每一个查询结果的列的名字和类型等；</li>
</ul>
</li>
<li>默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。<ul>
<li>应用程序可以关闭一个连接的自动提交特性<ul>
<li><code>SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)}</code></li>
</ul>
</li>
<li>此时事务要显式地给出提交和撤销的命令<ul>
<li><code>SQLTransact(conn, SQL_COMMIT)</code> or <code>SQLTransact(conn, SQL_ROLLBACK)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><span id="id8"><span></span></span></p>
<h3 id="8-JDBC简介"><a href="#8-JDBC简介" class="headerlink" title="8. JDBC简介"></a>8. JDBC简介</h3><h4 id="8-1-JDBC定义"><a href="#8-1-JDBC定义" class="headerlink" title="8.1 JDBC定义"></a>8.1 JDBC定义</h4><p>JDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。</p>
<ul>
<li>JDBCAPI分成两个程序包：<ul>
<li>Java.sql 核心API –J2SE(Java2标准版)的一部分。使用<code>java.sql.DriverManager</code>类、<code>java.sql.Driver</code>和<code>java.sql.Connection</code>接口连接到数据库</li>
<li>Javax.sql 可选扩展API–J2EE(Java2企业版)的一部分。包含了基于<code>JNDI(JavaNamingandDirectoryInterface,Java命名和目录接口)</code>的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。</li>
</ul>
</li>
</ul>
<h4 id="8-2-JDBC的功能"><a href="#8-2-JDBC的功能" class="headerlink" title="8.2 JDBC的功能"></a>8.2 JDBC的功能</h4><ol>
<li><code>java.sql.DriverManager</code>——处理驱动的调入并且对产生新数据库连接提供支持</li>
<li><code>Java.sql.Driver</code>——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。</li>
<li><code>java.sql.Connection</code>——代表对特定数据库的连接。</li>
<li><code>Try {…} Catch {…}</code> ——异常捕获及其处理</li>
<li><code>java.sql.Statement</code>——对特定的数据库执行SQL语句</li>
<li><code>java.sql.PreparedStatement</code> —— 用于执行预编译的SQL语句</li>
<li><code>java.sql.CallableStatement</code> ——用于执行对数据库内嵌过程的调用。</li>
<li><code>java.sql.ResultSet</code>——从当前执行的SQL语句中返回结果数据。</li>
</ol>
<h4 id="8-3-使用JDBC-API访问数据库的过程"><a href="#8-3-使用JDBC-API访问数据库的过程" class="headerlink" title="8.3 使用JDBC API访问数据库的过程"></a>8.3 使用JDBC API访问数据库的过程</h4><ol>
<li><p>概念性的基本过程</p>
<ul>
<li>打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制</li>
</ul>
</li>
<li><p>具体实施过程</p>
<ol>
<li>•传递一个Driver给DriverManager，加载数据库驱动。<ul>
<li><code>Class.forName()</code></li>
</ul>
</li>
<li>•通过URL得到一个Connection对象, 建立数据库连接<ul>
<li><code>DriverManager.getConnection(sDBUrl)</code></li>
<li><code>DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)</code></li>
</ul>
</li>
<li>•接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<ul>
<li><code>Statement stmt=con.createStatement()</code></li>
</ul>
</li>
<li>•查询返回一个ResultSet。<ul>
<li><code>ResultSet rs=stmt.executeQuery(sSQL)</code></li>
</ul>
</li>
</ol>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">try</span> &#123; <span class="comment">//错误捕获</span></span><br><span class="line">    Class.forName (<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    Connection conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span>, userid, passwd);</span><br><span class="line">    <span class="comment">//加载数据库驱动，建立数据库连接</span></span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    <span class="comment">//创建一个语句对象</span></span><br><span class="line">    … Do Actual Work ….</span><br><span class="line">    <span class="comment">//进行SQL语句的执行与处理工作</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    <span class="comment">//关闭语句对象，关闭连接</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">    System.out.println(<span class="string">"SQLException : "</span> + sqle); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整的示例程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName (<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    Connection conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span>, userid, passwd);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt.executeUpdate( <span class="string">"insert into instructor values</span></span><br><span class="line"><span class="string">        (‘77987', ‘Kim', ‘Physics’,98000)"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">"插入错误:"</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">    ResultSet rset = stmt.executeQuery(</span><br><span class="line">        <span class="string">"select dept_name, avg(salary) from instructor group by dept_name"</span>);</span><br><span class="line">    <span class="keyword">while</span> ( rset.next() ) &#123;</span><br><span class="line">        System.out.println(rset.getString(“dept_name<span class="string">") + "</span> <span class="string">" + rset.getFloat(2));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    stmt.close();</span></span><br><span class="line"><span class="string">    conn.close();</span></span><br><span class="line"><span class="string">&#125; catch (SQLException sqle) &#123;</span></span><br><span class="line"><span class="string">    System.out.println("</span>SQLException:<span class="string">" + sqle);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id9"><span></span></span></p>
<h3 id="9-嵌入式SQL-ODBC-JDBC三者比较"><a href="#9-嵌入式SQL-ODBC-JDBC三者比较" class="headerlink" title="9. 嵌入式SQL-ODBC-JDBC三者比较"></a>9. 嵌入式SQL-ODBC-JDBC三者比较</h3><p>执行一条SQL语句，读取执行的结果集合</p>
<ol>
<li>嵌入式SQL的思维模式<ol>
<li>建立数据库连接</li>
<li>声明一个游标</li>
<li>打开游标</li>
<li>读取一条记录(循环)</li>
<li>关闭游标</li>
<li>断开数据库连接</li>
</ol>
</li>
<li>ODBC的思维模式<ol>
<li>建立数据库连接</li>
<li>分配语句句柄</li>
<li>用句柄执行SQL</li>
<li>建立高级语言变量与句柄属性的对应</li>
<li>读取一条记录(循环)</li>
<li>释放语句句柄</li>
<li>断开数据库连接</li>
</ol>
</li>
<li>JDBC的思维模式<ol>
<li>建立数据库连接</li>
<li>创建语句对象</li>
<li>用语句对象执行SQL，并返回结果对象</li>
<li>从结果对象获取一条记录</li>
<li>提取对象的属性值传给高级语言变量(返回上一步)</li>
<li>释放语句对象</li>
<li>断开数据库连接</li>
</ol>
</li>
</ol>
<ul>
<li>相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致</li>
<li>不同点, 操作方式的不同:<ul>
<li>嵌入式SQL按照语句进行操作</li>
<li>ODBC按照函数来进行操作</li>
<li>JDBC按照对象来进行操作</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据库系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库语言SQL]]></title>
      <url>http://chaooo.github.io/2019/09/01/02-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80SQL.html</url>
      <content type="html"><![CDATA[<h3 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h3><p><strong>结构化查询语言</strong>(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>
<ul>
<li>SQL语言是集DDL、DML和DCL于一体的数据库语言<a id="more"></a><ol>
<li><strong>DDL语句</strong>引导词：Create(建立),Alter(修改),Drop(撤消)<ul>
<li>模式的定义和删除，包括定义Database,Table,View,Index,完整性约束条件等，也包括定义对象(RowType行对象,Type列对象)</li>
</ul>
</li>
<li><strong>DML语句</strong>引导词：Insert ,Delete, Update, Select<ul>
<li>各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入</li>
<li>各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等</li>
<li>各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等</li>
</ul>
</li>
<li><strong>DCL语句</strong>引导词：Grant,Revoke<ul>
<li>安全性控制：授权和撤消授权</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol>
<li><a href="#id1">利用SQL建立数据库</a></li>
<li><a href="#id2">利用SQL简单查询</a></li>
<li><a href="#id3">利用SQL多表联合查询</a></li>
<li><a href="#id4">利用SQL进行增-删-改</a></li>
<li><a href="#id5">利用SQL语言修正与撤销数据库</a></li>
<li><a href="#id6">SQL Server介绍</a></li>
<li><a href="#id7">SQL语言-子查询</a></li>
<li><a href="#id8">SQL语言-结果计算与聚集计算</a></li>
<li><a href="#id9">SQL语言-分组查询与分组过滤</a></li>
<li><a href="#id10">SQL语言实现关系代数操作</a></li>
<li><a href="#id11">SQL语言之视图及其应用</a></li>
<li><a href="#id12">数据库完整性</a></li>
<li><a href="#id13">数据库的静态完整性(约束)</a></li>
<li><a href="#id14">数据库的动态完整性(触发器)</a></li>
<li><a href="#id15">数据库索引</a></li>
<li><a href="#id16">数据库序列</a></li>
<li><a href="#id17">数据库安全性</a></li>
<li><a href="#id18">数据库自主安全性机制</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-利用SQL建立数据库"><a href="#1-利用SQL建立数据库" class="headerlink" title="1. 利用SQL建立数据库"></a>1. 利用SQL建立数据库</h3><p>DDL：数据定义语言（Data Definition Language)，<br>DDL通常由<strong>DBA(数据库管理员)</strong>来使用，也有经DBA授权后由应用程序员来使用</p>
<ol>
<li>创建数据库(DB)：<strong>Create Database</strong><ul>
<li>数据库(Database)是若干具有相互关联关系的Table/Relation的集合</li>
<li>简单语法形式：<code>create database database 数据库名;</code></li>
</ul>
</li>
<li>创建DB中的Table(定义关系模式)：<strong>Create Table</strong><ul>
<li><code>Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);</code><ul>
<li><code>[]</code>表示其括起的内容可以省略，<code>|</code>表示其隔开的两项可取其一</li>
<li><code>Primary key</code>: 主键约束。每个表只能创建一个主键约束</li>
<li><code>Unique</code>: 唯一性约束(即候选键)。可以有多个唯一性约束</li>
<li><code>Not null</code>: 非空约束。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据类型</strong>（SQL-92标准）<ul>
<li><code>char(n)</code>:固定长度的字符串</li>
<li><code>varchar(n)</code>:可变长字符串</li>
<li><code>int</code>:整数 //有时不同系统也写作integer</li>
<li><code>numeric(p，q)</code>:固定精度数字，小数点左边p位，右边(p-q)位</li>
<li><code>real</code>:浮点精度数字 //有时不同系统也写作<code>float(n)</code>，小数点后保留n位</li>
<li><code>date</code>:日期 (如 2003-09-12)</li>
<li><code>time</code>:时间 (如 23:15:003)<blockquote>
<p>注意: 现行商用DBMS的数据类型有时有些差异</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><span id="id2"><span></span></span></p>
<h3 id="2-利用SQL简单查询"><a href="#2-利用SQL简单查询" class="headerlink" title="2. 利用SQL简单查询"></a>2. 利用SQL简单查询</h3><p>DML：数据操纵语言（Data Manipulation Language)，<br>DML通常由<strong>用户或应用程序员</strong>使用，访问经授权的数据库</p>
<ol>
<li><p>向Table中添加数据(追加元组)：<strong>Insert into</strong></p>
<ul>
<li><strong><code>insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);</code></strong><ul>
<li>values值的排列，须与列名排列一致</li>
<li>若所有列名省略，则values值的排列须与该表存储中的列名排列一致</li>
</ul>
</li>
</ul>
</li>
<li><p>单表查询<strong>Select</strong></p>
<ul>
<li><strong><code>Select Select 列名[[,列名] …] From 表名[Where 检索条件];</code></strong><ul>
<li>语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。</li>
<li>相当于：<code>Π[列名,...,列名](σ检索条件(表名))</code></li>
</ul>
</li>
<li>Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。</li>
</ul>
</li>
<li><p>检索条件的书写<strong>Where</strong></p>
<ul>
<li>与选择运算<code>σF(R)</code>的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。</li>
<li><code>Select Tname From Teacher Where Salary &gt; 2000 and D# = ’03’;</code>//检索教师表中所有工资大于2000元 并且是03系的教师姓名</li>
</ul>
</li>
<li><p>排重(<code>DISTINCT</code>)</p>
<ul>
<li>关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。</li>
<li>在Table中要求无重复元组是通过定义Primary key或Unique来保证的;</li>
<li>而在检索结果中要求无重复元组, 是通过<strong>DISTINCT保留字</strong>的使用来实现的。</li>
<li><code>Select DISTINCT S# From SC Where Score &gt; 80;</code></li>
</ul>
</li>
<li><p>排序(<code>ORDER BY</code>)</p>
<ul>
<li>Select语句中结果排序是通过增加<strong>order by</strong>子句实现的</li>
<li><code>order by 列名 [asc|desc]</code></li>
<li>意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。</li>
</ul>
</li>
<li><p>模糊查询(<code>*LIKE*</code>)</p>
<ul>
<li><code>_</code>：一个字符，<code>%</code>：任意长度字符。</li>
<li><code>Select Sname From Student Where Sname Like &#39;张_ _&#39;;</code>//检索名字为张某某的所有同学姓名</li>
<li><code>Select Sname From Student Where Sname Not Like &#39;张%&#39;;</code>//检索名字不姓张的所有同学姓名</li>
</ul>
</li>
</ol>
<p><span id="id3"><span></span></span></p>
<h3 id="3-利用SQL多表联合查询"><a href="#3-利用SQL多表联合查询" class="headerlink" title="3. 利用SQL多表联合查询"></a>3. 利用SQL多表联合查询</h3><p>多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。</p>
<ul>
<li>检索语句: <strong><code>Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;</code></strong></li>
<li>相当于<code>Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))</code></li>
<li>检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接</li>
</ul>
<ol>
<li><p>θ-连接之<strong>等值连接</strong></p>
<ul>
<li>多表连接时，如两个表的属性名相同，则需采用<strong><code>表名.属性名</code></strong>方式来限定该属性是属于哪一个表</li>
<li><code>Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#=&#39;001&#39; Order By Score DESC;</code>//按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)</li>
</ul>
</li>
<li><p>属性重名重名处理(表别名)</p>
<ul>
<li>连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用<strong><code>别名</code></strong>以便区分</li>
<li><code>Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;</code></li>
<li>当定义了别名后，在检索条件中可以使用别名来限定属性</li>
<li>as 可以省略</li>
</ul>
</li>
<li><p>θ-连接之<strong>不等值连接</strong></p>
<ul>
<li><code>Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary&gt;T2.Salary;</code>//求有薪水差额的任意两位教师</li>
</ul>
</li>
<li><p>实例：</p>
<ul>
<li><code>Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#=&#39;001&#39; and S2.C#=&#39;002&#39; and S1.Score &gt; S2.Score;</code>//求“001”号课成绩比“002”号课成绩高的所有学生的学号</li>
</ul>
</li>
</ol>
<p><span id="id4"><span></span></span></p>
<h3 id="4-利用SQL进行增-删-改"><a href="#4-利用SQL进行增-删-改" class="headerlink" title="4. 利用SQL进行增-删-改"></a>4. 利用SQL进行增-删-改</h3><ol>
<li>SQL-之<strong>更新操作</strong><ul>
<li>元组新增Insert：新增一个或一些元组到数据库的Table中</li>
<li>元组更新Update:对某些元组中的某些属性值进行重新设定</li>
<li>元组删除Delete：删除某些元组</li>
</ul>
</li>
</ol>
<blockquote>
<ul>
<li>SQL-DML既能单一记录操作，也能对记录集合进行批更新操作</li>
<li>SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等</li>
</ul>
</blockquote>
<ol start="2">
<li>SQL-之<strong>INSERT</strong><ul>
<li>单一元组新增命令形式：插入一条指定元组值的元组<ul>
<li><strong><code>insert into 表名 [(列名[,列名]…)] values (值 [,值]…);</code></strong></li>
</ul>
</li>
<li>批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。<ul>
<li><strong><code>insert into 表名 [(列名[，列名]…)] 子查询;</code></strong></li>
<li>示例：<code>Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like &#39;%伟&#39;;</code>//将检索到的满足条件的同学新增到该表中</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。</p>
</blockquote>
<ol start="3">
<li><p>SQL-之<strong>DELETE</strong></p>
<ul>
<li>元组删除Delete命令: 删除满足指定条件的元组</li>
<li><strong><code>Delete From 表名 [ Where 条件表达式];</code></strong></li>
<li>如果Where条件省略，则删除所有的元组(清空表)。</li>
<li>示例：<code>Delete From Student Where S# in ( Select S# From SC Where Score &lt; 60 Group by S# Having Count(*)&gt;= 4);</code>//删除有四门不及格课程的所有同学</li>
</ul>
</li>
<li><p>SQL-之<strong>UPDATE</strong></p>
<ul>
<li>元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值</li>
<li><strong><code>Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];</code></strong></li>
<li>如果Where条件省略，则更新所有的元组。</li>
<li>示例：<code>Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname=&#39;计算机&#39;);</code>//将所有计算机系的教师工资上调10%</li>
</ul>
</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-利用SQL语言修正与撤销数据库"><a href="#5-利用SQL语言修正与撤销数据库" class="headerlink" title="5. 利用SQL语言修正与撤销数据库"></a>5. 利用SQL语言修正与撤销数据库</h3><ol>
<li><p>修正基本表的定义</p>
<ul>
<li><strong><code>alter table tablename</code></strong></li>
<li><strong><code>[add {colname datatype, …}]</code></strong> //增加新列</li>
<li><strong><code>[drop {完整性约束名}]</code></strong> //删除完整性约束</li>
<li><strong><code>[modify {colname datatype, …}]</code></strong> //修改列定义</li>
<li>示例：<code>Alter Table Student Drop Unique(Sname);</code>删除学生姓名必须取唯一值的约束</li>
<li>示例：<code>Alter Table Student Add Saddr char[40],PID char[18];</code>在学生表Student上增加二列Saddr, PID</li>
</ul>
</li>
<li><p>SQL-DDL之撤销与修改</p>
<ul>
<li><code>drop table 表名;</code> //撤消基本表</li>
<li><code>drop database 数据库名;</code> //撤消数据库</li>
</ul>
</li>
<li><p>SQL-DDL之数据库指定与关闭命令</p>
<ul>
<li>有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。</li>
<li><code>use 数据库名;</code> //指定当前数据库</li>
<li><code>close 数据库名;</code> //关闭当前数据库</li>
</ul>
</li>
</ol>
<p><span id="id6"><span></span></span></p>
<h3 id="6-SQL-Server介绍"><a href="#6-SQL-Server介绍" class="headerlink" title="6. SQL Server介绍"></a>6. SQL Server介绍</h3><p>SQL Server 是 Microsoft提供的一款关系数据库管理系统</p>
<ol>
<li>SQL Server 的系统数据库<ul>
<li>Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。</li>
<li>Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。</li>
<li>Msdb：代理服务数据库，提供一个存储空间。</li>
<li>Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。</li>
</ul>
</li>
<li>SQL Server的数据库<ul>
<li>文件：有三种文件扩展名：.mdf、.ndf、.ldf<ul>
<li>主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。</li>
<li>辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。</li>
<li>日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。</li>
</ul>
</li>
<li>页面：是SQL Server存储的最小单位。一页为8K或8192字节。</li>
<li>空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位</li>
</ul>
</li>
</ol>
<h4 id="6-1-SQL-Server数据库的创建-删除与维护"><a href="#6-1-SQL-Server数据库的创建-删除与维护" class="headerlink" title="6.1 SQL Server数据库的创建-删除与维护"></a>6.1 SQL Server数据库的创建-删除与维护</h4><ol>
<li>创建数据库<ul>
<li>语法形式：Create Database 库名</li>
<li>可视化操作(查询分析器)：Database(鼠标右键) -&gt; new Database… -&gt; 填写数据库名及配置</li>
<li>创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。</li>
<li>创建数据库的用户自动成为数据库的拥有者。</li>
</ul>
</li>
<li>删除数据库<ul>
<li>语法形式：Drop Database 库名</li>
<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Delete</li>
<li>对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。</li>
<li>当数据库处于正在使用或正在恢复状态时，不能删除。</li>
</ul>
</li>
<li>备份数据库<ul>
<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Back Up…</li>
<li>备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。<ul>
<li>完全数据库备份：完全备份数据文件和日志文件。</li>
<li>差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。</li>
<li>事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。</li>
<li>数据库文件和文件组备份：用在数据库相当大的情况下。</li>
</ul>
</li>
</ul>
</li>
<li>恢复数据库<ul>
<li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Restore</li>
<li>数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。</li>
<li>数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。</li>
<li>可以通过企业管理器来完成数据库恢复。</li>
</ul>
</li>
<li>数据库授权: <ul>
<li>语法形式：grant 权限 on 表名 to 用户名</li>
<li>权限有：select,update,insert,delete,exec,dri。</li>
<li>对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.</li>
</ul>
</li>
</ol>
<h4 id="6-2-SQL-Server数据表的创建-与增-删-改-查"><a href="#6-2-SQL-Server数据表的创建-与增-删-改-查" class="headerlink" title="6.2 SQL Server数据表的创建-与增/删/改/查"></a>6.2 SQL Server数据表的创建-与增/删/改/查</h4><ol>
<li>创建表<ul>
<li>同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。</li>
<li>用T-SQL语句创建表，语法形式：<code>CREATE TABLE [数据库名.所有者名.]表名 ({&lt;列名 数据类型&gt;} [缺省值][约束][是否为空] …)</code><blockquote>
<p>注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持</p>
</blockquote>
</li>
<li>可视化操作(查询分析器)：数据库名 -&gt; Tables -&gt; New Table…</li>
</ul>
</li>
<li>增加、修改表字段<ul>
<li>语法形式：<code>ALTER TABLE ADD | ALTER 字段名 &lt;类型&gt;</code></li>
</ul>
</li>
<li>创建、删除与修改约束<ul>
<li>约束是SQL提供自动保持数据库完整性的一种方法，共5种。</li>
<li>用T-SQL语句建立约束，语法形式：<code>CONSTRAINT 约束名 约束类型 (列名)</code><ul>
<li>约束名：在库中应该唯一，如不指定，系统会给出</li>
<li>约束类型 (5种)：<ul>
<li>primary key constraint (主键值)</li>
<li>unique constraint (唯一性)</li>
<li>check constraint (检查性)</li>
<li>default constraint (默认)</li>
<li>foreign key constraint (外部键)</li>
</ul>
</li>
<li>列名：要约束的字段名</li>
</ul>
</li>
<li>示例:<code>Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));</code></li>
</ul>
</li>
</ol>
<p><span id="id7"><span></span></span></p>
<h3 id="7-SQL语言-子查询"><a href="#7-SQL语言-子查询" class="headerlink" title="7. SQL语言-子查询"></a>7. SQL语言-子查询</h3><ul>
<li>子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。</li>
<li>三种类型的子查询：(NOT) IN-子查询；θ-Some/θ-All子查询；(NOT) EXISTS子查询</li>
</ul>
<h4 id="7-1-NOT-IN子查询"><a href="#7-1-NOT-IN子查询" class="headerlink" title="7.1 (NOT) IN子查询"></a>7.1 (NOT) IN子查询</h4><ol>
<li>基本语法：<code>表达式 [not] in (子查询)</code><ul>
<li>语法中，表达式的最简单形式就是列名或常数。</li>
<li>语义：判断某一表达式的值是否在子查询的结果中。</li>
<li>示例：<ul>
<li><code>Select * From Student Where Sname in (&#39;张三&#39;, &#39;王三&#39;);</code>//列出张三、王三同学的所有信息</li>
<li><code>Select S#, Sname From Student Where S# in (Select S# From SC Where C#=&#39;001&#39;);</code>//列出选修了001号课程的学生的学号和姓名</li>
</ul>
</li>
</ul>
</li>
<li>非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询</li>
<li>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询</li>
<li>外层向内层传递的参量需要使用外层的表名或表别名来限定<ul>
<li>示例：<code>Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#=&#39;001&#39;);</code>//求学过001号课程的同学的姓名</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。</p>
</blockquote>
<h4 id="7-2-θ-Some-θ-All子查询"><a href="#7-2-θ-Some-θ-All子查询" class="headerlink" title="7.2 θ-Some/θ-All子查询"></a>7.2 θ-Some/θ-All子查询</h4><ol>
<li>基本语法：<code>表达式 θ some (子查询)</code> / <code>表达式 θ all (子查询)</code><ul>
<li>语法中，θ是比较运算符：<code>&lt;, &gt;, &gt;=, &lt;=, =, &lt;&gt;</code>。</li>
<li>语义：将表达式的值与子查询的结果进行比较：<ul>
<li>如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则<code>表达式 θ some (子查询)</code>的结果便为真</li>
<li>如果表达式的值与子查询结果的所有值相比较都满足 关系，则<code>表达式 θ all (子查询)</code>的结果便为真</li>
</ul>
</li>
<li>示例：<ul>
<li><code>Select Tname From Teacher Where Salary &lt;= all ( Select Salary From Teacher);</code>//找出工资最低的教师姓名</li>
<li><code>Select S# From SC Where C# = “001” and Score &lt; some ( Select Score From SC Where C#=&#39;001&#39;);</code>//找出001号课成绩不是最高的所有学生的学号</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>在SQL标准中，也有θ-Any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。</p>
</blockquote>
<ol start="2">
<li>等价性变换需要注意<ul>
<li><code>表达式 = some (子查询)</code>和<code>表达式 in (子查询)</code>含义<strong>相同</strong></li>
<li><code>表达式 &lt;&gt; some (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>不同</strong></li>
<li><code>表达式 &lt;&gt; all (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>相同</strong></li>
</ul>
</li>
</ol>
<h4 id="7-3-NOT-EXISTS子查询"><a href="#7-3-NOT-EXISTS子查询" class="headerlink" title="7.3 (NOT) EXISTS子查询"></a>7.3 (NOT) EXISTS子查询</h4><ol>
<li>基本语法：<code>[not] Exists [not] Exists (子查询)</code><ul>
<li>语义：子查询结果中有无元组存在</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：检索选修了赵三老师主讲课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC, Course, Teacher</span><br><span class="line">        <span class="keyword">Where</span> SC.C<span class="comment">#=Course.C# and SC. S#=Student.S#</span></span><br><span class="line">        <span class="keyword">and</span> Course.T<span class="comment"># = Teacher.T# and Tname='赵三');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--示例：检索学过001号教师主讲的所有课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> //不存在</span><br><span class="line">        ( <span class="keyword">Select</span> * <span class="keyword">From</span> Course //有一门<span class="number">001</span>教师主讲课程</span><br><span class="line">        <span class="keyword">Where</span> Course.T<span class="comment"># = ‘001’ and not exists //该同学没学过</span></span><br><span class="line">            ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC</span><br><span class="line">            <span class="keyword">Where</span> S<span class="comment"># = Student.S# and C# = Course.C#));</span></span><br><span class="line"><span class="comment">--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过</span></span><br></pre></td></tr></table></figure>

<p><span id="id8"><span></span></span></p>
<h3 id="8-SQL语言-结果计算与聚集计算"><a href="#8-SQL语言-结果计算与聚集计算" class="headerlink" title="8. SQL语言-结果计算与聚集计算"></a>8. SQL语言-结果计算与聚集计算</h3><h4 id="8-1-结果计算"><a href="#8-1-结果计算" class="headerlink" title="8.1 结果计算"></a>8.1 结果计算</h4><p>Select-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算</p>
<ul>
<li><code>Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];</code><ul>
<li>expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书</li>
<li>agfunc()是一些聚集函数</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求有差额(差额&gt;0)的任意两位教师的薪水差额</span></span><br><span class="line"><span class="keyword">Select</span> T1.Tname <span class="keyword">as</span> TR1, T2.Tname <span class="keyword">as</span> TR2, T1.Salary – T2.Salary</span><br><span class="line">    <span class="keyword">From</span> Teacher T1, Teacher T2</span><br><span class="line">    <span class="keyword">Where</span> T1.Salary &gt; T2.Salary;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-聚集函数"><a href="#8-2-聚集函数" class="headerlink" title="8.2 聚集函数"></a>8.2 聚集函数</h4><p>SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc,分别是：COUNT、SUM、AVG、MAX、MIN</p>
<table>
<thead>
<tr>
<th>聚合函数</th>
<th>支持的数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>count()</td>
<td>任何类型/*</td>
<td>计算结果集中的总行数</td>
</tr>
<tr>
<td>sum()</td>
<td>Numeric</td>
<td>计算指定列中所有非空值的总和</td>
</tr>
<tr>
<td>avg()</td>
<td>numeric</td>
<td>计算指定列中所有非空值的平均值</td>
</tr>
<tr>
<td>max()</td>
<td>char/numeric</td>
<td>返回指定列中最大值</td>
</tr>
<tr>
<td>min()</td>
<td>char/numeric</td>
<td>返回指定列中最小值</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Sum</span>(Salary) <span class="keyword">From</span> Teacher;</span><br><span class="line"><span class="comment">--示例：求计算机系教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Sum</span>(Salary) <span class="keyword">From</span> Teacher T, Dept</span><br><span class="line">    <span class="keyword">Where</span> Dept.Dname = ‘计算机’ <span class="keyword">and</span> Dept.D<span class="comment"># = T.D#;</span></span><br><span class="line"><span class="comment">--示例：求数据库课程的平均成绩</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">AVG</span>(Score) <span class="keyword">From</span> Course C, SC</span><br><span class="line">    <span class="keyword">Where</span> C.Cname = ‘数据库’ <span class="keyword">and</span> C.C<span class="comment"># = SC.C#;</span></span><br></pre></td></tr></table></figure>

<p><span id="id9"><span></span></span></p>
<h3 id="9-SQL语言-分组查询与分组过滤"><a href="#9-SQL语言-分组查询与分组过滤" class="headerlink" title="9. SQL语言-分组查询与分组过滤"></a>9. SQL语言-分组查询与分组过滤</h3><h4 id="9-1-分组查询"><a href="#9-1-分组查询" class="headerlink" title="9.1 分组查询"></a>9.1 分组查询</h4><p>分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。</p>
<ol>
<li><p>分组的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 ] ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分组条件可以是：<code>列名1, 列名2, …</code></p>
</li>
<li><p>示例： 求每一个学生的平均成绩</p>
<ul>
<li><code>Select S#, AVG(Score) From SC Group by S#;</code></li>
</ul>
</li>
</ol>
<h4 id="9-2-分组过滤"><a href="#9-2-分组过滤" class="headerlink" title="9.2 分组过滤"></a>9.2 分组过滤</h4><p>聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤</p>
<ul>
<li>分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。</li>
<li>Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。</li>
</ul>
<ol>
<li><p>基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 [ <span class="keyword">Having</span> <span class="keyword">Having</span> 分组过滤条件] ] ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：求不及格课程超过两门的同学的学号</p>
<ul>
<li><code>Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2;</code> </li>
</ul>
</li>
</ol>
<h4 id="9-3-where子句与having子句的区别"><a href="#9-3-where子句与having子句的区别" class="headerlink" title="9.3 where子句与having子句的区别"></a>9.3 where子句与having子句的区别</h4><ol>
<li>聚合函数是比较where、having 的关键。在from后面的执行顺序：<ul>
<li><code>where -&gt; 聚合函数(sum,min,max,avg,count) -&gt;having</code></li>
</ul>
</li>
<li>列出group by来比较二者:<ul>
<li>where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。</li>
<li>having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意事项 ： </p>
<ol>
<li>where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 </li>
<li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 </li>
<li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</li>
</ol>
</blockquote>
<p><span id="id10"><span></span></span></p>
<h3 id="10-SQL语言实现关系代数操作"><a href="#10-SQL语言实现关系代数操作" class="headerlink" title="10. SQL语言实现关系代数操作"></a>10. SQL语言实现关系代数操作</h3><p>SQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。</p>
<ul>
<li>基本语法形式：<ul>
<li><code>子查询 {Union [ALL] | Intersect [ALL] | Except [ALL] 子查询}</code></li>
</ul>
</li>
<li>通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。<ul>
<li>假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：<ul>
<li>子查询1 Union ALL 子查询2 ，出现m + n次</li>
<li>子查询1 Intersect ALL 子查询2 ，出现min(m,n)次</li>
<li>子查询1 Except ALL 子查询2 ，出现max(0, m – n)次</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但<strong>有些DBMS并不支持</strong>这些运算，使用时要注意。</p>
</blockquote>
<h4 id="10-1-SQL并运算-UNION"><a href="#10-1-SQL并运算-UNION" class="headerlink" title="10.1 SQL并运算(UNION)"></a>10.1 SQL并运算(UNION)</h4><ol>
<li>示例：已知两个表<ul>
<li>Customers(Cid, Cname, City, Discnt)</li>
<li>Agents(Aid, Aname, City, Percent)</li>
</ul>
</li>
<li>求客户所在的或者代理商所在的城市<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Customers</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Agents;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="10-2-SQL交运算-INTERSECT"><a href="#10-2-SQL交运算-INTERSECT" class="headerlink" title="10.2 SQL交运算(INTERSECT)"></a>10.2 SQL交运算(INTERSECT)</h4><ol>
<li><p>示例：求既学过002号课，又学过003号课的同学学号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘002’</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘003’;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p>
<ul>
<li><code>Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);</code></li>
</ul>
</li>
<li><p>交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。</p>
</li>
</ol>
<h4 id="10-3-SQL差运算-EXCEPT"><a href="#10-3-SQL差运算-EXCEPT" class="headerlink" title="10.3 SQL差运算(EXCEPT)"></a>10.3 SQL差运算(EXCEPT)</h4><ol>
<li><p>示例： 假定所有学生都有选课，求没学过002号课程的学生学号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S<span class="comment"># From SC</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘002’;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S<span class="comment"># From SC SC1</span></span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC</span><br><span class="line">        <span class="keyword">Where</span> C<span class="comment"># = ‘002’ and S# = SC1.S#);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。</p>
</li>
</ol>
<h4 id="10-4-空值的处理"><a href="#10-4-空值的处理" class="headerlink" title="10.4 空值的处理"></a>10.4 空值的处理</h4><p>空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p>
<ol>
<li>在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。</li>
<li>空值检测：<ul>
<li><code>is [not ] null</code> //测试指定列的值是否为空值</li>
</ul>
</li>
<li>示例：找出年龄值为空的学生姓名<ul>
<li><code>Select Sname From Student Where Sage is null;</code></li>
</ul>
</li>
<li>现行DBMS的空值处理小结<ul>
<li>除is[not]null之外，空值不满足任何查找条件</li>
<li>如果null参与算术运算，则该算术表达式的值为null</li>
<li>如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown</li>
<li>如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li>
</ul>
</li>
</ol>
<h4 id="10-5-内连接、外连接"><a href="#10-5-内连接、外连接" class="headerlink" title="10.5 内连接、外连接"></a>10.5 内连接、外连接</h4><ol>
<li><p>标准SQL语言中连接运算通常为：</p>
<ul>
<li><code>Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;</code></li>
<li>即相当于采用<code>Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))</code>。</li>
</ul>
</li>
<li><p>SQL的高级语法中引入了内连接与外连接运算，具体形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 [ [, 列名] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [<span class="keyword">NATURAL</span>]</span><br><span class="line">    [ <span class="keyword">INNER</span> | &#123; <span class="keyword">LEFT</span> | <span class="keyword">RIGHT</span> | <span class="keyword">FULL</span>&#125; [<span class="keyword">OUTER</span>]] <span class="keyword">JOIN</span> 表名<span class="number">2</span></span><br><span class="line">    &#123; <span class="keyword">ON</span> 连接条件 | <span class="keyword">Using</span> (Colname &#123;, Colname …&#125;) &#125;</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ] … ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由 <strong>连接类型</strong> 和 <strong>连接条件</strong> 构成连接运算。</p>
<ul>
<li><strong><code>Natural</code></strong>：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次</li>
<li><strong><code>Inner Join</code></strong>: 即关系代数中的θ-连接运算</li>
<li><strong><code>Left Outer Join, Right Outer Join, Full Outer Join</code></strong>: 即关系代数中的外连接运算</li>
<li><strong><code>on &lt;连接条件&gt;</code></strong>：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li>
<li><strong><code>using (Col1, Col2, …, Coln)</code></strong>：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次</li>
</ul>
</li>
<li><p>示例:</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher.T<span class="comment">#, Tname, Cname</span></span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Inner</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T<span class="comment"># = Course.T#</span></span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T<span class="comment"># ASC;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher. T<span class="comment">#, Tname, Cname</span></span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Left</span> <span class="keyword">Outer</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T<span class="comment"># = Course.T#</span></span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T<span class="comment"># ASC ;</span></span><br></pre></td></tr></table></figure>

<p><span id="id11"><span></span></span></p>
<h3 id="11-SQL语言之视图及其应用"><a href="#11-SQL语言之视图及其应用" class="headerlink" title="11. SQL语言之视图及其应用"></a>11. SQL语言之视图及其应用</h3><ol>
<li>数据库的三级模式两层映像<ul>
<li>三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成</li>
<li>应用–&gt; <strong>外模式</strong>(多个) –&gt; <strong>概念模式</strong>(一个) –&gt; <strong>内模式</strong>(一个) –&gt; 数据库</li>
<li>两层映像：<code>E-C</code>映像(外模式-&gt;概念模式)、<code>C-I</code>映像(概念模式-&gt;内模式)。</li>
</ul>
</li>
<li>对应概念模式的数据在SQL中被称为<strong>基本表(Table)</strong>,而对应外模式的数据称为<strong>视图(View)</strong>。<strong>视图不仅包含外模式，而且包含其E-C映像</strong>。</li>
<li><strong>基本表</strong>是实际存储于存储文件中的表，基本表中的<strong>数据是需要存储的</strong></li>
<li><strong>视图</strong>在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其<strong>数据并不存储</strong>，而是在运行过程中动态产生与维护的</li>
<li>对视图数据的更改最终要反映在对基本表的更改上。</li>
</ol>
<h4 id="11-1-视图的定义"><a href="#11-1-视图的定义" class="headerlink" title="11.1 视图的定义"></a>11.1 视图的定义</h4><p>视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。</p>
<ol>
<li>定义视图: <code>create view view_name [(列名[列名] …)] as 子查询 [with check option]</code><ul>
<li>如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。</li>
<li>with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式</li>
</ul>
</li>
<li>示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> CompStud <span class="keyword">AS</span></span><br><span class="line">    (<span class="keyword">Select</span> * <span class="keyword">From</span> Student</span><br><span class="line">        <span class="keyword">Where</span> D<span class="comment"># in (Select D# From Dept</span></span><br><span class="line">            <span class="keyword">Where</span> Dname = ‘计算机’));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="11-2-视图的使用"><a href="#11-2-视图的使用" class="headerlink" title="11.2 视图的使用"></a>11.2 视图的使用</h4><p>使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用</p>
<ul>
<li>示例：检索计算机系的所有学生，我们可使用CompStud<ul>
<li><code>Select * From CompStud;</code></li>
</ul>
</li>
<li>示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud<ul>
<li><code>Select * From CompStud Where Sage&lt;20;</code></li>
</ul>
</li>
</ul>
<h4 id="11-3-视图的更新"><a href="#11-3-视图的更新" class="headerlink" title="11.3 视图的更新"></a>11.3 视图的更新</h4><p>SQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。</p>
<ol>
<li>SQL视图更新的可执行性<ul>
<li>如果视图的select目标列包含聚集函数，则不能更新</li>
<li>如果视图的select子句使用了unique或distinct，则不能更新</li>
<li>如果视图中包括了groupby子句，则不能更新</li>
<li>如果视图中包括经算术表达式计算出来的列，则不能更新</li>
<li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li>
</ul>
</li>
<li>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新</li>
<li>可更新SQL视图示例：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CStud(S<span class="comment">#, Sname, Sclass)</span></span><br><span class="line"><span class="keyword">as</span> ( <span class="keyword">select</span> S<span class="comment">#, Sname, Sclass from Student where D# ='03');</span></span><br><span class="line"><span class="comment">-- 更新视图</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> CStud <span class="keyword">Values</span> (<span class="string">'98030104'</span>, <span class="string">'张三丰'</span>, <span class="string">'980301'</span>);</span><br><span class="line"><span class="comment">-- 更新视图 将转换为 更新基本表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span> (<span class="string">'98030104'</span>, <span class="string">'张三丰'</span>, <span class="literal">Null</span>, <span class="literal">Null</span>, <span class="string">'03'</span>, <span class="string">'980301'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="11-4-视图的撤销"><a href="#11-4-视图的撤销" class="headerlink" title="11.4 视图的撤销"></a>11.4 视图的撤销</h4><p>已经定义的视图也可以撤消</p>
<ul>
<li>撤消视图：<code>Drop View view_name</code></li>
</ul>
<p>不仅视图可以撤消，基本表、数据库等都可以撤消</p>
<ul>
<li>撤消基本表：<code>Drop Table 表名</code></li>
</ul>
<p><span id="id12"><span></span></span></p>
<h3 id="12-数据库完整性"><a href="#12-数据库完整性" class="headerlink" title="12. 数据库完整性"></a>12. 数据库完整性</h3><p>数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性–在任何情况下的正确性、有效性和一致性</p>
<ul>
<li>广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等</li>
<li>狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。</li>
</ul>
<h4 id="12-1-基本概念"><a href="#12-1-基本概念" class="headerlink" title="12.1 基本概念"></a>12.1 基本概念</h4><p>关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性</p>
<ol>
<li>数据库完整性管理的作用<ul>
<li>防止和避免数据库中不合理数据的出现</li>
<li>DBMS应尽可能地自动防止DB中语义不合理现象</li>
<li>如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担</li>
</ul>
</li>
<li>DBMS怎样自动保证完整性：<ul>
<li>DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)</li>
<li>当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性</li>
</ul>
</li>
<li><strong>完整性约束条件</strong>(或称完整性约束规则)的一般形式：Integrity Constraint::=(O,P,A,R)<ul>
<li>O：数据集合：约束的对象(列、多列(元组)、元组集合)</li>
<li>P：谓词条件：需要定义什么样的约束</li>
<li>A：触发条件：默认更新时检查</li>
<li>R：响应动作：默认拒绝</li>
</ul>
</li>
</ol>
<h4 id="12-2-数据库完整性的分类"><a href="#12-2-数据库完整性的分类" class="headerlink" title="12.2 数据库完整性的分类"></a>12.2 数据库完整性的分类</h4><ol>
<li><p>按约束对象分类:</p>
<ul>
<li>域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的</li>
<li>关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断</li>
</ul>
</li>
<li><p>按约束来源分类:</p>
<ul>
<li>结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；</li>
<li>内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。</li>
</ul>
</li>
<li><p>按约束状态分类:</p>
<ul>
<li>静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。</li>
<li>动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。</li>
</ul>
</li>
</ol>
<p><span id="id13"><span></span></span></p>
<h3 id="13-数据库的静态完整性-约束"><a href="#13-数据库的静态完整性-约束" class="headerlink" title="13. 数据库的静态完整性(约束)"></a>13. 数据库的静态完整性(约束)</h3><ol>
<li><p>SQL语言支持的约束类别：</p>
<ul>
<li>静态约束<ul>
<li>列完整性—域完整性约束</li>
<li>表完整性–关系完整性约束</li>
</ul>
</li>
<li>动态约束<ul>
<li>触发器</li>
</ul>
</li>
</ul>
</li>
<li><p>CreateTable有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性</p>
<ul>
<li>定义完整性约束条件：列完整性、表完整性</li>
</ul>
</li>
<li><p>列约束：一种<strong>域约束类型</strong>，对单一列的值进行约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; NOT NULL |                  //列值非空</span><br><span class="line">[ CONSTRAINT constraintname ] //为约束命名，便于以后撤消</span><br><span class="line">&#123; UNIQUE                      //列值是唯一</span><br><span class="line">| PRIMARY KEY                 //列为主键</span><br><span class="line">| <span class="keyword">CHECK</span> (search_cond)         //列值满足条件,条件只能使用列当前值</span><br><span class="line">| <span class="keyword">REFERENCES</span> tablename [(colname) ]</span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">DELETE</span> &#123; <span class="keyword">CASCADE</span> | <span class="keyword">SET</span> <span class="literal">NULL</span> &#125; ] &#125; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表约束：一种<strong>关系约束类型</strong>，对多列或元组的值进行约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ CONSTRAINT constraintname ]       //为约束命名，便于以后撤消</span><br><span class="line">&#123; UNIQUE (colname &#123;,colname…&#125;)      //几列值组合在一起是唯一</span><br><span class="line">| PRIMARY KEY (colname &#123;,colname…&#125;) //几列联合为主键</span><br><span class="line">| <span class="keyword">CHECK</span> (search_condition)          //元组多列值共同满足条件</span><br><span class="line">                                    //条件中只能使用同一元组的不同列当前值</span><br><span class="line">| <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (colname &#123;,colname…&#125;)</span><br><span class="line"><span class="keyword">REFERENCES</span> tablename [(colname &#123;,colname…&#125;)]//引用另一表tablename的若干列的值作为外键</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。</p>
</blockquote>
<ol start="5">
<li><p>Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)</p>
<ul>
<li>示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)<ul>
<li><code>Alter Table SC DROP CONSTRAINT ctscore;</code></li>
</ul>
</li>
<li>有些DBMS支持独立的追加约束,注意书写格式可能有些差异<ul>
<li>示例：<code>Alter Table SC Add Constraint nctscore check (Score&gt;=0.0 and Score&lt;=150.0));</code></li>
</ul>
</li>
</ul>
</li>
<li><p>现约束的方法-断言ASSERTION</p>
<ul>
<li>一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件</li>
<li>表约束和列约束就是一些特殊的断言</li>
<li>SQL还提供了复杂条件表达的断言。其语法形式为：<ul>
<li><code>CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt;</code></li>
</ul>
</li>
<li>当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">assertion</span> sum_constraint <span class="keyword">check</span></span><br><span class="line">    (<span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> branch</span><br><span class="line">    <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">sum</span>(amount ) <span class="keyword">from</span> loan</span><br><span class="line">        <span class="keyword">where</span> loan.branch_name = branch.branch_name )</span><br><span class="line">    &gt;= (<span class="keyword">select</span> <span class="keyword">sum</span> (balance ) <span class="keyword">from</span> <span class="keyword">account</span></span><br><span class="line">        <span class="keyword">where</span> account.branch_name = branch.branch_name )))</span><br><span class="line"><span class="comment">-- 数据表：</span></span><br><span class="line"><span class="keyword">account</span>(branch_name, account_number,…, balance) //分行，账户及其余额</span><br><span class="line">loan(branch_name , loan_number, amount,) //分行的每一笔贷款</span><br><span class="line">branch(branch_name, … ) //分行</span><br></pre></td></tr></table></figure>

<blockquote>
<p>断言测试增加了数据库维护的负担，要小心使用复杂的断言。</p>
</blockquote>
<p><span id="id14"><span></span></span></p>
<h3 id="14-数据库的动态完整性-触发器"><a href="#14-数据库的动态完整性-触发器" class="headerlink" title="14. 数据库的动态完整性(触发器)"></a>14. 数据库的动态完整性(触发器)</h3><p>实现数据库动态完整的方法—触发器Trigger</p>
<ol>
<li><p>触发器Trigger</p>
<ul>
<li>Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger</li>
<li>Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。</li>
</ul>
</li>
<li><p>基本语法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span></span><br><span class="line">    &#123; <span class="keyword">INSERT</span> | <span class="keyword">DELETE</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> colname &#123;, colname...&#125;] &#125;</span><br><span class="line">    <span class="keyword">ON</span> tablename [<span class="keyword">REFERENCING</span> corr_name_def &#123;, corr_name_def...&#125; ]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> | <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span>]</span><br><span class="line">                //对更新操作的每一条结果(前者)，或整个更新操作完成(后者)</span><br><span class="line">    [<span class="keyword">WHEN</span> (search_condition)]           //检查条件，如满足执行下述程序</span><br><span class="line">    &#123; <span class="keyword">statement</span>         //单行程序直接书写，多行程序要用下行方式</span><br><span class="line">    | BEGIN ATOMIC statement; &#123; statement;...&#125; END &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发器Trigger意义：</p>
<ul>
<li>当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件<code>search_condition</code>,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用<code>corr_name_def</code>来限定。</li>
</ul>
</li>
<li><p>事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}</p>
<ul>
<li>当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发</li>
<li>操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由<code>corr_name_def</code>的使用来区分</li>
</ul>
</li>
<li><p><code>corr_name_def</code>的定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; OLD [ROW] [AS] old_row_corr_name //更新前的旧元组命别名为</span><br><span class="line">| NEW [ROW] [AS] new_row_corr_name //更新后的新元组命别名为</span><br><span class="line">| OLD TABLE [AS] old_table_corr_name //更新前的旧Table命别名为</span><br><span class="line">| NEW TABLE [AS] new_table_corr_name //更新后的新Table命别名为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p><code>corr_name_def</code>将在检测条件或后面的动作程序段中被引用处理</p>
</blockquote>
<ol start="6">
<li><p>示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> teacher_chgsal <span class="keyword">before</span> <span class="keyword">update</span> <span class="keyword">of</span> salary</span><br><span class="line">    <span class="keyword">on</span> teacher</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> x, <span class="keyword">old</span> y</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">when</span> (x.salary &lt; y.salary)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    raise_application_error(<span class="number">-20003</span>, <span class="string">'invalid salary on update'</span>);</span><br><span class="line">    //此条语句为Oracle的错误处理函数</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> sumc <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> sc</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> <span class="keyword">row</span> newi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> SumCourse = SumCourse + <span class="number">1</span></span><br><span class="line">    <span class="keyword">where</span> S<span class="comment"># = :newi.S# ;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> delS<span class="comment"># after delete on Student</span></span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">old</span> oldi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> sc <span class="keyword">where</span> S<span class="comment"># = :oldi.S# ;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id15"><span></span></span></p>
<h3 id="15-数据库索引"><a href="#15-数据库索引" class="headerlink" title="15. 数据库索引"></a>15. 数据库索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种<strong>数据结构</strong>（最常见的是B-Tree）</p>
<ol>
<li>索引的作用<ol>
<li>快速取数据；</li>
<li>保证数据记录的唯一性；</li>
<li>实现表与表之间的参照完整性；</li>
<li>在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。</li>
</ol>
</li>
<li>创建索引：<code>CREATE INDEX  索引名称  on 表名(字段名);</code></li>
<li>删除索引：<code>DROP INDEX 索引名称</code></li>
<li>索引注意事项：<ol>
<li>查询时减少使用<code>*</code>返回全部列，不要返回不需要的列</li>
<li>where表达式子句包含索引的表达式置前</li>
<li>避免在Order by中使用表达式</li>
<li>索引技术是数据库自动使用，一个表格只存在一个索引就够了</li>
</ol>
</li>
<li>缺点<ol>
<li>索引的缺点是创建和维护索引需要耗费时间和空间</li>
<li>索引可以提高查询速度，会减慢写入速度</li>
<li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>
</ol>
</li>
</ol>
<h4 id="15-1-索引主要种类"><a href="#15-1-索引主要种类" class="headerlink" title="15.1 索引主要种类"></a>15.1 索引主要种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p>
<ol>
<li>唯一索引<ul>
<li>唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</li>
</ul>
</li>
<li>主键索引<ul>
<li>数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</li>
</ul>
</li>
<li>聚集索引<ul>
<li>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</li>
</ul>
</li>
<li>索引列<ul>
<li>可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</li>
</ul>
</li>
</ol>
<p><span id="id16"><span></span></span></p>
<h3 id="16-数据库序列"><a href="#16-数据库序列" class="headerlink" title="16. 数据库序列"></a>16. 数据库序列</h3><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要<code>CREATE SEQUENCE</code>系统权限。</p>
<h4 id="16-1-Oracle中的序列（Sequence）"><a href="#16-1-Oracle中的序列（Sequence）" class="headerlink" title="16.1 Oracle中的序列（Sequence）"></a>16.1 Oracle中的序列（Sequence）</h4><ol>
<li><p>创建序列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> 序列名 </span><br><span class="line">    [<span class="keyword">increment</span> <span class="keyword">by</span> n]   <span class="comment">--每次增加n个，默认为1</span></span><br><span class="line">    [<span class="keyword">start</span> <span class="keyword">with</span> n]     <span class="comment">--起始值n，默认为1</span></span><br><span class="line">    [&#123;maxvalue n | <span class="keyword">nomaxvalue</span>&#125;]  <span class="comment">--最大值设置，递增默认10的27次方，递减默认-1</span></span><br><span class="line">    [&#123;<span class="keyword">minvalue</span> n | <span class="keyword">nominvalue</span>&#125;]  <span class="comment">--最小值设置，递增默认1，递减默认-10的26次方</span></span><br><span class="line">    [&#123;<span class="keyword">cycle</span> | <span class="keyword">nocycle</span>&#125;]   <span class="comment">--是否循环</span></span><br><span class="line">    [&#123;<span class="keyword">cache</span> n | nocache&#125;] <span class="comment">--是否对序列进行内存缓冲，默认为20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询序列</p>
<ul>
<li><code>NEXTVAL</code>:返回序列中下一个有效的值，任何用户都可以引用。</li>
<li><code>CURRVAL</code>:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询下一个将要使用的序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.nextval <span class="keyword">from</span> dual</span><br><span class="line"><span class="comment">--查询当前序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.currval <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Oracle将sequence的定义存储在数据字典之中。</li>
<li>Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。</li>
</ul>
</blockquote>
<ol start="3">
<li>删除序列：<code>Drop sequence 序列名</code></li>
<li>更改序列：<code>Alter sequence 序列名 [其余参数同创建序列]</code></li>
<li>使用序列示例：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.直接使用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person (<span class="keyword">id</span>, <span class="keyword">name</span>, <span class="keyword">password</span>) <span class="keyword">values</span> (序列名.nextval, <span class="string">'张三'</span>, <span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值</span></span><br><span class="line"><span class="comment">-- 2.1创建触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> 触发器名 <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> person</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> 序列名.nextval <span class="keyword">into</span> :new.id <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 2.2插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person ( username, age, <span class="keyword">password</span>) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="number">20</span>, <span class="string">'zhang123'</span>)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>注意点：<ul>
<li>一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。</li>
<li>当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。</li>
<li>大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。</li>
</ul>
</li>
</ol>
<h4 id="16-2-Mysql中的序列（AUTO-INCREMENT）"><a href="#16-2-Mysql中的序列（AUTO-INCREMENT）" class="headerlink" title="16.2 Mysql中的序列（AUTO_INCREMENT）"></a>16.2 Mysql中的序列（AUTO_INCREMENT）</h4><p>MySQL中最简单使用序列的方法就是使用<code>AUTO_INCREMENT</code>来定义列。</p>
<ol>
<li>orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。</li>
<li>首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。</li>
<li>mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.</li>
<li>mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。</li>
</ol>
<p><span id="id17"><span></span></span></p>
<h3 id="17-数据库安全性"><a href="#17-数据库安全性" class="headerlink" title="17. 数据库安全性"></a>17. 数据库安全性</h3><p>数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏</p>
<ol>
<li>数据库安全性管理涉及许多方面<ol>
<li>社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法</li>
<li>公共政策/制度方面：例如，政府或组织的信息公开或非公开制度</li>
<li>安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)</li>
<li>数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)</li>
<li>数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制</li>
</ol>
</li>
<li>DBMS的安全机制<ol>
<li><strong>自主安全性机制</strong>：存取控制(AccessControl)<ul>
<li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li>
</ul>
</li>
<li><strong>强制安全性机制</strong>：<ul>
<li>通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据</li>
</ul>
</li>
<li>推断控制机制：<ul>
<li>防止通过历史信息，推断出不该被其知道的信息；</li>
<li>防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li>
</ul>
</li>
<li>数据加密存储机制：<ul>
<li>通过加密、解密保护数据，密钥、加密/解密方法与传输</li>
</ul>
</li>
</ol>
</li>
<li>DBA的责任和义务<ul>
<li>熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略</li>
<li>规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，</li>
<li><strong>划分好数据的安全级别以及用户的安全级别</strong></li>
<li>实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等</li>
</ul>
</li>
</ol>
<p><span id="id18"><span></span></span></p>
<h3 id="18-数据库自主安全性机制"><a href="#18-数据库自主安全性机制" class="headerlink" title="18. 数据库自主安全性机制"></a>18. 数据库自主安全性机制</h3><ul>
<li>通常情况下，自主安全性是通过授权机制来实现的。</li>
<li>用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。<ul>
<li>授权者：决定用户权利的人</li>
<li>授权：授予用户访问的权利</li>
</ul>
</li>
</ul>
<ol>
<li>DBMS自动实现自主安全性：<ul>
<li>DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)</li>
<li>当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问</li>
</ul>
</li>
<li>DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制<ul>
<li><code>AccessRule ::=(S, O, t, P)</code><ul>
<li>S: 请求主体(用户)</li>
<li>O: 访问对象</li>
<li>t: 访问权利</li>
<li>P: 谓词</li>
</ul>
</li>
<li>{AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;</li>
<li>用户多时，可以按用户组建立访问规则</li>
<li>访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库</li>
<li>权利：包括创建、增、删、改、查等</li>
<li>谓词：拥有权利需满足的条件</li>
</ul>
</li>
<li><strong>示例</strong>：员工管理数据库的安全性控制示例<code>Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)</code><ul>
<li>示例要求：<ul>
<li>员工管理人员：能访问该数据库的所有内容，便于维护员工信息</li>
<li>收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问</li>
<li>每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改</li>
<li>部门领导：能够查询其所领导部门人员的所有情况</li>
<li>高层领导：能访问该数据库的所有内容，但只能读</li>
</ul>
</li>
<li>两种控制示例<ul>
<li>按名控制安全性：存储矩阵</li>
<li>按内容控制安全性：视图</li>
</ul>
</li>
<li>视图是安全性控制的重要手段</li>
<li>通过视图可以限制用户对关系中某些数据项的存取,例如：<ul>
<li>视图1：CreateEmpV1as select*fromEmployee</li>
<li>视图2：CreateEmpV2as selectPname,D#fromEmployee</li>
</ul>
</li>
<li>通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：<ul>
<li>视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId</li>
<li>视图2： CreateEmpV4asselect*fromEmployeewhereHead=:UserId</li>
</ul>
</li>
<li>用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述</li>
</ul>
</li>
</ol>
<h4 id="18-1-SQL语言的用户与权利"><a href="#18-1-SQL语言的用户与权利" class="headerlink" title="18.1 SQL语言的用户与权利"></a>18.1 SQL语言的用户与权利</h4><ol>
<li><p>SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴</p>
</li>
<li><p>授权机制—自主安全性；视图的运用</p>
</li>
<li><p>关系级别(普通用户) &lt;– 账户级别(程序员用户) &lt;– 超级用户(DBA) </p>
<ul>
<li>(级别1)Select : 读(读DB, Table, Record, Attribute, … )</li>
<li>(级别2)Modify : 更新<ul>
<li>Insert : 插入(插入新元组, … )</li>
<li>Update : 更新(更新元组中的某些值, …)</li>
<li>Delete : 删除(删除元组, …)</li>
</ul>
</li>
<li>(级别3)Create : 创建(创建表空间、模式、表、索引、视图等)<ul>
<li>Create : 创建</li>
<li>Alter : 更新</li>
<li>Drop : 删除</li>
</ul>
</li>
</ul>
</li>
<li><p>级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。</p>
</li>
<li><p>授权命令<code>GRANT</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &#123;<span class="keyword">all</span> <span class="keyword">PRIVILEGES</span> | privilege &#123;,privilege…&#125;&#125;</span><br><span class="line">    <span class="keyword">ON</span> [<span class="keyword">TABLE</span>] tablename | viewname</span><br><span class="line">    <span class="keyword">TO</span> &#123;<span class="keyword">public</span> | <span class="keyword">user</span>-<span class="keyword">id</span> &#123;, <span class="keyword">user</span>-<span class="keyword">id</span>…&#125;&#125;</span><br><span class="line">    [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>user-id ，某一个用户账户，由DBA创建的合法账户</li>
<li>public, 允许所有有效用户使用授予的权利</li>
<li>privilege是下面的权利<ul>
<li>SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES</li>
</ul>
</li>
<li>WITH GRANT OPTION选项是允许被授权者传播这些权利</li>
</ul>
</li>
<li><p>SQL-DCL的控制安全性-授权示例:</p>
<ul>
<li>假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)<ul>
<li>Grant All Priviledges ON Employee TO Emp2001;</li>
<li>Grant SELECT ON EmpV2 TO Emp5001;</li>
<li>Grant SELECT ON EmpV3 TO public;</li>
<li>Grant SELECT ON EmpV4 TO Emp0021;</li>
</ul>
</li>
<li>授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)</li>
<li>授权者授予的权利必须是授权者已经拥有的权利</li>
</ul>
</li>
<li><p>收回授权命令<code>REVOKE</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &#123;<span class="keyword">all</span> <span class="keyword">privilEges</span> | priv &#123;, priv…&#125; &#125; </span><br><span class="line">    <span class="keyword">ON</span> tablename | viewname</span><br><span class="line">    <span class="keyword">FROM</span> &#123;<span class="keyword">public</span> | <span class="keyword">user</span> &#123;, <span class="keyword">user</span>…&#125; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例: <code>revoke select on employee from UserB;</code></li>
</ul>
</li>
</ol>
<h4 id="18-2-自主安全性的授权过程及其问题"><a href="#18-2-自主安全性的授权过程及其问题" class="headerlink" title="18.2 自主安全性的授权过程及其问题"></a>18.2 自主安全性的授权过程及其问题</h4><h5 id="18-2-1-授权过程"><a href="#18-2-1-授权过程" class="headerlink" title="18.2.1 授权过程:"></a>18.2.1 授权过程:</h5><ol>
<li>第一步：DBA创建DB, 并为每一个用户创建一个账户<ul>
<li>假定建立了五个用户：UserA, UserB, UserC, UserD, UserE</li>
</ul>
</li>
<li>第二步：DBA授予某用户账户级别的权利<ul>
<li>假定授予UserA</li>
</ul>
</li>
<li>第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利<ul>
<li>假定UserA创建了Employee, 则UserA就是Employee表的属主账户</li>
</ul>
</li>
<li>第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…<ul>
<li>假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。</li>
</ul>
</li>
</ol>
<ul>
<li>注意授权的传播范围<ul>
<li>传播范围包括两个方面：水平传播数量和垂直传播数量<ul>
<li>水平传播数量是授权者的再授权用户数目(树的广度)</li>
<li>垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)</li>
</ul>
</li>
<li>有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。</li>
<li>当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回</li>
<li>如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。</li>
</ul>
</li>
</ul>
<h5 id="18-2-2-强制安全性机制"><a href="#18-2-2-强制安全性机制" class="headerlink" title="18.2.2 强制安全性机制"></a>18.2.2 强制安全性机制</h5><ol>
<li>强制安全性机制<ul>
<li>强制安全性通过对数据对象进行安全性分级<ul>
<li>绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)</li>
</ul>
</li>
<li>同时对用户也进行上述的安全性分级</li>
<li>从而强制实现不同级别用户访问不同级别数据的一种机制</li>
</ul>
</li>
<li>强制安全性机制的实现<ul>
<li>DBMS引入强制安全性机制, 可以通过扩展关系模式来实现<ul>
<li>关系模式: R(A1: D1, A2: D2, …, An:Dn)</li>
<li>对属性和元组引入安全性分级特性或称分类特性<ul>
<li>R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性</li>
</ul>
</li>
</ul>
</li>
<li>这样, 关系中的每个元组, 都将扩展为带有安全分级的元组</li>
<li>强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数据库系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二十三、SpringBoot MVC应用]]></title>
      <url>http://chaooo.github.io/2019/08/31/23-SpringBoot-MVC%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>对Spring Web MVC封装，简化MVC结构web应用开发。</p>
<a id="more"></a>

<h3 id="1-SpringBoot-MVC开发Restful服务（前后分离）"><a href="#1-SpringBoot-MVC开发Restful服务（前后分离）" class="headerlink" title="1. SpringBoot MVC开发Restful服务（前后分离）*"></a>1. SpringBoot MVC开发Restful服务（前后分离）*</h3><p>按rest规则发送HTTP请求–&gt;Spring MVC–&gt;返回JSON结果</p>
<p>主要步骤：</p>
<ol>
<li>导入spring-boot-starter-web（springmvc、rest、jackson、tomcat）</li>
<li>在application.properties修改tomcat端口</li>
<li>定义启动类RunBoot，追加@SpringBootApplication</li>
<li>定义Controller、Service、Dao组件</li>
</ol>
<h3 id="2-SpringBoot-MVC开发JSP应用（PC浏览器）"><a href="#2-SpringBoot-MVC开发JSP应用（PC浏览器）" class="headerlink" title="2. SpringBoot MVC开发JSP应用（PC浏览器）"></a>2. SpringBoot MVC开发JSP应用（PC浏览器）</h3><p>HTTP请求–&gt;Spring MVC–&gt;JSP–&gt;HTML响应输出结果</p>
<p>主要步骤：</p>
<ol>
<li>导入spring-boot-starter-web、jasper解析器、jstl</li>
<li>在application.properties修改tomcat端口、viewResolver</li>
<li>定义启动类RunBoot，追加@SpringBootApplication</li>
<li>定义Controller组件，返回ModelAndView</li>
<li>在src/main/webapp下定义JSP组件</li>
</ol>
<h3 id="3-SpringBoot-MVC开发Thymeleaf应用（PC浏览器）"><a href="#3-SpringBoot-MVC开发Thymeleaf应用（PC浏览器）" class="headerlink" title="3. SpringBoot MVC开发Thymeleaf应用（PC浏览器）*"></a>3. SpringBoot MVC开发Thymeleaf应用（PC浏览器）*</h3><p>HTTP请求–&gt;Spring MVC–&gt;Thymeleaf模板–&gt;HTML响应输出结果</p>
<p>主要步骤：</p>
<ol>
<li>导入spring-boot-starter-web、spring-boot-starter-thymeleaf</li>
<li>在application.properties修改tomcat端口</li>
<li>定义启动类RunBoot，追加@SpringBootApplication</li>
<li>定义Controller组件，返回ModelAndView</li>
<li>在src/main/resources/templates下定义模板文件<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"https://www.thymeleaf.org/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h2</span> <span class="attr">th:text</span>=<span class="string">"$&#123;data&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<ul>
<li>th:text表达式作用：将模型中的数据以只读文本显示到元素中</li>
<li>th:text表达式作用：将模型中的数据以只读文本显示到元素中。</li>
<li>th:if 表达式作用：if判断逻辑</li>
<li>th:each 表达式作用：循环逻辑</li>
<li>th:href 表达式作用：动态生成href链接</li>
</ul>
</blockquote>
<p>Thymeleaf模板和JSP区别</p>
<ol>
<li>运行机制不同<ul>
<li>JSP–&gt;Servlet–&gt;HTML</li>
<li>模板+数据–&gt;HTML输出</li>
</ul>
</li>
<li>模板简单易用;JSP相对复杂些<ul>
<li>JSP:9大内置对象、EL、JSTL、嵌入Java代码、框架标签</li>
<li>模板：模板表达式</li>
</ul>
</li>
<li>模板效率高,比JSP性能好<ul>
<li>模板：缓存</li>
</ul>
</li>
</ol>
<h3 id="4-SpringBoot-MVC静态资源处理"><a href="#4-SpringBoot-MVC静态资源处理" class="headerlink" title="4. SpringBoot MVC静态资源处理"></a>4. SpringBoot MVC静态资源处理</h3><p>静态资源包含图片、js、css等，动态资源servlet、jsp等。</p>
<p>SpringBoot中src/main/resources目录下有几个约定的静态资源存放位置</p>
<ul>
<li>META-INF/resources（优先级最高）</li>
<li>resources</li>
<li>static</li>
<li>public（优先级最低）</li>
</ul>
<p>自定义静态资源访问路径，编写一个配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStaticConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/**"</span>)</span><br><span class="line">            .addResourceLocations(</span><br><span class="line">                <span class="string">"classpath:/images/"</span>,</span><br><span class="line">                <span class="string">"classpath:/resources/"</span>,</span><br><span class="line">                <span class="string">"classpath:/static/"</span>,</span><br><span class="line">                <span class="string">"classpath:/public/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-SpringBoot-MVC异常处理"><a href="#5-SpringBoot-MVC异常处理" class="headerlink" title="5. SpringBoot MVC异常处理"></a>5. SpringBoot MVC异常处理</h3><ol>
<li><p>异常处理机制</p>
<ul>
<li>SpringBoot底层提供了异常处理机制。SpringBoot提供了一个ErrorMvcAutoConfiguration自动配置组件，创建了一个BasicErrorController对象，提供两个/error请求处理，一个返回html，另一个返回json。当MVC底层遇到异常会用转发方式发出/error请求。</li>
</ul>
</li>
<li><p>可以自定义ErrorController替代底层BasicErrorController，将错误提示转发到自定义提示界面(全局)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//@RequestMapping("/error")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorController</span> <span class="keyword">implements</span> <span class="title">ErrorController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/error"</span>,produces= MediaType.TEXT_HTML_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.setViewName(<span class="string">"myerror"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/error"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"程序发生了异常"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@ExceptionHandler异常处理（局部）</p>
<ul>
<li>ErrorController管理全局异常，@ExceptionHandler管理所在Controller组件的异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">"msg"</span>, <span class="string">"发生异常"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, ex.getClass());</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p>可以将上述方法封装成一个BasicController，通过@ControllerAdvice作用到所有Controller组件上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//等价于所有Controller都继承它</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"发生异常"</span>);</span><br><span class="line">        map.put(<span class="string">"type"</span>, ex.getClass());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-SpringBoot-AOP"><a href="#6-SpringBoot-AOP" class="headerlink" title="6. SpringBoot AOP"></a>6. SpringBoot AOP</h3><ol>
<li><p>引入spring-boot-starter-aop</p>
</li>
<li><p>定义一个切面组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//将Bean组件纳入Spring容器</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//将Bean组件定义为Aspect切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)<span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----开始处理----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)<span class="comment">//最终通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----处理完毕----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        Object obj = pjp.proceed();<span class="comment">//调用目标组件方法</span></span><br><span class="line">        watch.stop();</span><br><span class="line">        System.out.println(<span class="string">"处理时间:"</span>+watch.getTotalTimeMillis()+<span class="string">" 毫秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置切面组件</p>
<ul>
<li>@Aspect、@Before、@After、@Around、@AfterReturning、@AfterThrowing等</li>
</ul>
</li>
</ol>
<h3 id="7-SpringBoot-MVC拦截器"><a href="#7-SpringBoot-MVC拦截器" class="headerlink" title="7. SpringBoot MVC拦截器"></a>7. SpringBoot MVC拦截器</h3><ol>
<li><p>编写一个拦截器组件,实现HandlerInterceptor接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了MyInterceptor拦截器"</span>);</span><br><span class="line">        String user = (String)request.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.sendRedirect(<span class="string">"/tologin"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//阻止后续流程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续执行后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置拦截器组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyInterceptor my;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(my).addPathPatterns(<span class="string">"/direction/list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="8-SpringBoot整合Servlet-Filter"><a href="#8-SpringBoot整合Servlet-Filter" class="headerlink" title="8. SpringBoot整合Servlet/Filter"></a>8. SpringBoot整合Servlet/Filter</h3><h4 id="8-1-整合Servlet"><a href="#8-1-整合Servlet" class="headerlink" title="8.1 整合Servlet"></a>8.1 整合Servlet</h4><p>首先导入spring-boot-starter-web</p>
<h5 id="8-1-1-整合Servlet方式一："><a href="#8-1-1-整合Servlet方式一：" class="headerlink" title="8.1.1 整合Servlet方式一："></a>8.1.1 整合Servlet方式一：</h5><ol>
<li><p>编写一个Servlet组件，继承HttpServlet</p>
</li>
<li><p>在Servlet类定义前使用@WebServlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"helloservlet"</span>,urlPatterns= &#123;<span class="string">"/hello.do"</span>&#125;,loadOnStartup=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.getWriter().println(<span class="string">"Hello SpringBoot Servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类前需要使用@ServletComponentScan扫描@WebServlet配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//扫描@WebServlet、@WebFilter、@WebListener组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="8-1-2-整合Servlet方式二："><a href="#8-1-2-整合Servlet方式二：" class="headerlink" title="8.1.2 整合Servlet方式二："></a>8.1.2 整合Servlet方式二：</h5><ol>
<li><p>编写一个Servlet组件，继承HttpServlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.getWriter().println(<span class="string">"Hello Spring Some Servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ServletRegistrationBean+@Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="title">someservlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean&lt;Servlet&gt; bean = <span class="keyword">new</span> ServletRegistrationBean&lt;Servlet&gt;();</span><br><span class="line">        bean.setServlet(<span class="keyword">new</span> SomeServlet());</span><br><span class="line">        bean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        urls.add(<span class="string">"/some.do"</span>);</span><br><span class="line">        bean.setUrlMappings(urls);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="8-2-整合Filter"><a href="#8-2-整合Filter" class="headerlink" title="8.2 整合Filter"></a>8.2 整合Filter</h4><p>在SpringBoot整合Servlet的基础上整合Filter</p>
<h5 id="8-2-1-整合Filter方式一："><a href="#8-2-1-整合Filter方式一：" class="headerlink" title="8.2.1 整合Filter方式一："></a>8.2.1 整合Filter方式一：</h5><ol>
<li><p>编写一个Filter组件，继承Filter</p>
</li>
<li><p>在Filter类定义前使用@WebFilter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns=<span class="string">"/hello.do"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletRequest request, ServletResponse response, FilterChain chain</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----hello filter------servlet执行之前"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">"-----hello filter------servlet执行之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类前需要使用@ServletComponentScan扫描@WebServlet配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//扫描@WebServlet、@WebFilter、@WebListener组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="8-2-2-整合Filter方式二："><a href="#8-2-2-整合Filter方式二：" class="headerlink" title="8.2.2 整合Filter方式二："></a>8.2.2 整合Filter方式二：</h5><ol>
<li><p>编写一个Filter组件，继承Filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletRequest request, ServletResponse response, FilterChain chain</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----som filter------servlet执行之前"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">"-----som filter------servlet执行之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用FilterRegistrationBean+@Bean 注册过滤器并设置拦截的请求地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="title">somefilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; bean = <span class="keyword">new</span> FilterRegistrationBean&lt;Filter&gt;();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> SomeFilter());</span><br><span class="line">        <span class="comment">// 配置要拦截的请求</span></span><br><span class="line">        bean.addUrlPatterns(<span class="string">"/some.do"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="9-SpringBoot-任务调度"><a href="#9-SpringBoot-任务调度" class="headerlink" title="9. SpringBoot 任务调度"></a>9. SpringBoot 任务调度</h3><h4 id="9-1-服务器启动后自动调用"><a href="#9-1-服务器启动后自动调用" class="headerlink" title="9.1 服务器启动后自动调用"></a>9.1 服务器启动后自动调用</h4><p>tomcat服务器启动后自动调用任务，可以使用ApplicationRunner或CommandLineRunner接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask1</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务器启动后自动执行SomeTask1任务---"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask2</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务器启动后自动执行SomeTask2任务-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多个Task任务，可以通过@Order指定先后顺序，多个任务是线程同步调用。</p>
</blockquote>
<h4 id="9-2-程序运行后定时调用任务"><a href="#9-2-程序运行后定时调用任务" class="headerlink" title="9.2 程序运行后定时调用任务"></a>9.2 程序运行后定时调用任务</h4><p>Spring提供了一个Spring Schedule模块，封装了任务调用，之前都是采用Quartz组件调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span><span class="comment">//开启Schedule模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在服务器启动1秒后调用任务，每隔3秒调用一次</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(initialDelay=<span class="number">1000</span>,fixedRate=<span class="number">3000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----周期性调用SomeTask3-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在服务器启动0秒后调用任务，每隔5秒调用一次</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0/5 * * * * ?"</span>)<span class="comment">//秒 分 时 日 月 星期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----周期性调用SomeTask4-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Spring Schedule还需要指定cron表达式，表达式具体规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">秒   分    时    日   月   星期   年（可省略）</span><br><span class="line">0    0     10    1   10    ？</span><br><span class="line">秒： 0-59</span><br><span class="line">分： 0-59</span><br><span class="line">时： 0-23</span><br><span class="line">日： 1-31</span><br><span class="line">月： 1-12</span><br><span class="line">星期：1-7，1表示星期日，7表示星期六</span><br><span class="line">* ： 表示每一分、每一秒、每一天，任何一个可能值</span><br><span class="line">? ： 只用在日和星期部分，如果指定日，星期用？;如果指定星期，日用?，避免日和星期冲突 </span><br><span class="line">/ ： 表示增量，0/1表示0\1\2\3\4递增加1；0/5表示0\5\10\15；1/5表示1\6\11\16\21</span><br><span class="line">L ： 只用在日和星期部分，表示最后一天、周六</span><br></pre></td></tr></table></figure>

<p>cron表达式案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;30 * * * * ?&quot; 每半分钟触发任务</span><br><span class="line">&quot;30 10 * * * ?&quot; 每小时的10分30秒触发任务</span><br><span class="line">&quot;30 10 1 * * ?&quot; 每天1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 * ?&quot; 每月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 10 ? *&quot; 每年10月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 10 ? 2011&quot; 2011年10月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 ? 10 * 2011&quot; 2011年10月每天1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 ? 10 SUN 2011&quot; 2011年10月每周日1点10分30秒触发任务</span><br><span class="line">&quot;15,30,45 * * * * ?&quot; 每15秒，30秒，45秒时触发任务</span><br><span class="line">&quot;15-45 * * * * ?&quot; 15到45秒内，每秒都触发任务</span><br><span class="line">&quot;15/5 * * * * ?&quot; 每分钟的每15秒开始触发，每隔5秒触发一次</span><br><span class="line">&quot;15-30/5 * * * * ?&quot; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次</span><br><span class="line">&quot;0 0/3 * * * ?&quot; 每小时的第0分0秒开始，每三分钟触发一次</span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 星期一到星期五的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 L * ?&quot; 每个月最后一天的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 LW * ?&quot; 每个月最后一个工作日的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 ? * 5L&quot; 每个月最后一个星期四的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 ? * 5#3&quot; 每个月第三周的星期四的10点15分0秒触发任务</span><br></pre></td></tr></table></figure>

<h4 id="9-3-SpringBoot-Quartz"><a href="#9-3-SpringBoot-Quartz" class="headerlink" title="9.3 SpringBoot+Quartz"></a>9.3 SpringBoot+Quartz</h4><p>导入spring-boot-starter-quartz, 编写Job任务组件，继承QuartzJobBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask5</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过Quartz工具调用定时任务"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置Job组件（JobDetail、Tigger）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将MyTask5任务组件封装成JobDetail</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">task5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(MyTask5.class)</span><br><span class="line">            .withIdentity(<span class="string">"task5"</span>).storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//为JobDetail指定触发时间cron表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">task5Trigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CronScheduleBuilder cronScheduleBuilder = </span><br><span class="line">            CronScheduleBuilder.cronSchedule(<span class="string">"0/5 46 10 * * ?"</span>);</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(task5())</span><br><span class="line">                .withIdentity(<span class="string">"task5"</span>)</span><br><span class="line">                .withSchedule(cronScheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二十二、SpringBoot数据库访问]]></title>
      <url>http://chaooo.github.io/2019/08/31/22-SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE.html</url>
      <content type="html"><![CDATA[<p>Springboot对于数据访问层，无论是SQL还是NOSQL，都默认采用整合Spring Data的方式进行统一处理，Springboot添加大量自动配置，屏蔽了很多设置。并引入各种<em>Template，</em>Repository来简化我们对数据访问层的操作。</p>
<a id="more"></a>

<h3 id="1-SpringBoot数据库访问"><a href="#1-SpringBoot数据库访问" class="headerlink" title="1.SpringBoot数据库访问"></a>1.SpringBoot数据库访问</h3><h4 id="1-1-Spring-DAO-JdbcTemplate"><a href="#1-1-Spring-DAO-JdbcTemplate" class="headerlink" title="1.1 Spring DAO JdbcTemplate"></a>1.1 Spring DAO JdbcTemplate</h4><p>引入spring-boot-starter-jdbc后（hikari、spring-jdbc包），就可以借助DataSourceAutoConfiguration、JdbcTemplateAutoConfiguration自动配置组件创建出HikariDataSource、JdbcTemplate对象。</p>
<ol>
<li>引入jdbc启动器、驱动包，创建连接池</li>
<li>根据要操作表定义entity（pojo，属性名与字段名一致）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义Dao接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>定义Dao实现类，扫描并注入JdbcTemplate使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span><span class="comment">//通过组件扫描加载到Spring容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDirectionDao</span> <span class="keyword">implements</span> <span class="title">DirectionDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;<span class="comment">//通过自动配置加载到Spring容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from direction"</span>;</span><br><span class="line">        RowMapper&lt;Direction&gt; rowMapper = </span><br><span class="line">            <span class="keyword">new</span> BeanPropertyRowMapper&lt;Direction&gt;(Direction.class);</span><br><span class="line">        <span class="keyword">return</span> template.query(sql, rowMapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-Spring-MyBatis（XML-SQL版本）"><a href="#1-2-Spring-MyBatis（XML-SQL版本）" class="headerlink" title="1.2 Spring MyBatis（XML SQL版本）"></a>1.2 Spring MyBatis（XML SQL版本）</h4><ul>
<li>引入spring-boot-starter-jdbc、驱动包、mybatis-spring-boot-starter</li>
<li>引入application.properties（连接池参数）</li>
<li>实体类(同上)</li>
<li>SQL定义</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.xdl.dao.DirectionMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.xdl.entity.Direction"</span>&gt;</span></span><br><span class="line">        select * from direction</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"cn.xdl.entity.Direction"</span>&gt;</span></span><br><span class="line">        select * from direction where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Mapper接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direction <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用@MapperScan和mybatis.mapperLocations=classpath:sql/*.xml</p>
</li>
<li><p>在启动类前追加@MapperScan</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages=<span class="string">"cn.xdl.dao"</span>)<span class="comment">//扫描Mapper接口创建对象加载到Spring容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在application.properties追加mybatis.mapperLocations</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.mapperLocations=classpath:sql/*.xml</span><br></pre></td></tr></table></figure>

<h4 id="1-3-Spring-MyBatis（注解-SQL版本）"><a href="#1-3-Spring-MyBatis（注解-SQL版本）" class="headerlink" title="1.3 Spring MyBatis（注解 SQL版本）"></a>1.3 Spring MyBatis（注解 SQL版本）</h4><ul>
<li>引入spring-boot-starter-jdbc、驱动包、mybatis-spring-boot-starter</li>
<li>引入application.properties（连接池参数）</li>
<li>实体类(同上)</li>
<li>定义Mapper接口，使用@Select、@Update、@Insert、@Delete注解定义SQL</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from direction"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from direction where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direction <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update direction set name=#&#123;name&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateName</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id,@<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span>String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用@MapperScan（同上）</li>
</ul>
<h3 id="2-Spring-Data-JPA"><a href="#2-Spring-Data-JPA" class="headerlink" title="2. Spring Data JPA"></a>2. Spring Data JPA</h3><h4 id="2-1-Jpa"><a href="#2-1-Jpa" class="headerlink" title="2.1 Jpa"></a>2.1 Jpa</h4><p>Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<p>Sun引入新的JPA ORM规范主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。</p>
<blockquote>
<p>注意:Jpa 是一套规范，不是一套产品，那么像 Hibernate,TopLink,JDO 他们是一套产品，如果说这些产品实现了这个 Jpa 规范，那么我们就可以叫他们为 Jpa 的实现产品。</p>
</blockquote>
<h4 id="2-2-Spring-Boot-Jpa"><a href="#2-2-Spring-Boot-Jpa" class="headerlink" title="2.2 Spring Boot Jpa"></a>2.2 Spring Boot Jpa</h4><p>Spring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。</p>
<blockquote>
<p>Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现</p>
</blockquote>
<p>在Spring中使用JPA访问数据库，需要使用Spring Data模块支持。<br>    - SpringData是对Spring框架一个扩展模块，包含对JPA、Redis、MongoDB等技术的访问支持。</p>
<p>Spring Boot Jpa的使用 </p>
<ol>
<li><p>引入spring-boot-starter-jdbc、spring-boot-starter-data-jpa、驱动包</p>
</li>
<li><p>在application.properties定义db连接池参数（同上）</p>
</li>
<li><p>定义RunBoot启动类，使用@SpringBootApplication标记（同上）</p>
</li>
<li><p>根据要操作的表定义实体类，使用@Entity、@Table、@Id、@Column定义该对象和表结构之间的映射关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"direction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义Dao接口，可以选择继承JpaRepository、PagingAndSortingRepository、CrudRepository等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionDao</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Direction</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-3-Dao扩展操作"><a href="#2-3-Dao扩展操作" class="headerlink" title="2.3 Dao扩展操作"></a>2.3 Dao扩展操作</h4><p>分页查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pageable pageable = PageRequest.of(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//of(页数从0开始,记录条数)</span></span><br><span class="line">Page&lt;Direction&gt; page = dao.findAll(pageable);</span><br><span class="line">List&lt;Direction&gt; list = page.getContent();</span><br><span class="line">list.forEach(d-&gt;&#123;System.out.println(d.getId()+<span class="string">" "</span>+d.getName());&#125;);</span><br><span class="line">System.out.println(<span class="string">"总记录数:"</span>+page.getTotalElements()</span><br><span class="line">+<span class="string">" 页数:"</span>+(page.getNumber()+<span class="number">1</span>)+<span class="string">"/"</span>+page.getTotalPages());</span><br><span class="line">List&lt;Direction&gt; list1 = dao.findByIdGreaterThan2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>按方法名规则扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//where id&gt;?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义SQL语句扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(nativeQuery=<span class="keyword">true</span>,value=<span class="string">"select * from direction where id&gt;:id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan1</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<p>定义JPQL面向查询语句扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"from Direction where id&gt;:id"</span>) <span class="comment">//使用类型名和属性名替代表名和字段名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan2</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<p>按名称模糊查询，带分页支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(nativeQuery=<span class="keyword">true</span>,value=<span class="string">"select * from direction where name like :name"</span></span><br><span class="line">    ,countQuery=<span class="string">"select count(*) from direction where name like :name"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Direction&gt; <span class="title">findByNameLike1</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String name,Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二十一、SpringBoot入门]]></title>
      <url>http://chaooo.github.io/2019/08/27/21-SpringBoot%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h3 id="1-项目管理工具Maven的基本使用"><a href="#1-项目管理工具Maven的基本使用" class="headerlink" title="1. 项目管理工具Maven的基本使用"></a>1. 项目管理工具Maven的基本使用</h3><p>Maven是一个使用java编写的开源的项目管理工具，可以方便灵活的控制项目，不必浪费时间去在不同的环境中配置依赖的jar包，而专心于业务逻辑。</p>
<h4 id="1-1-配置Maven的系统环境变量"><a href="#1-1-配置Maven的系统环境变量" class="headerlink" title="1.1 配置Maven的系统环境变量"></a>1.1 配置Maven的系统环境变量</h4><ol>
<li>下载并解压到目录，如<code>D:\apache-maven-3.6.1</code></li>
<li>添加新的系统环境变量MAVEN_HOME=安装的目录：<code>MAVEN_HOME=D:\apache-maven-3.6.1</code></li>
<li>添加<code>%MAVEN_HOME%\bin</code>到系统PATH变量.</li>
<li>测试Maven配置是否成功，打开命令行窗口，输入<code>mvn -v</code>，如果有maven 版本信息输出则证明配置成功，否则请查看自己配置路径等是否正确。</li>
</ol>
<blockquote>
<p>注意：安装Maven前请确保已安装JDK并成功配置其环境变量。</p>
</blockquote>
<h4 id="1-2-maven中的术语"><a href="#1-2-maven中的术语" class="headerlink" title="1.2 maven中的术语"></a>1.2 maven中的术语</h4><ul>
<li><strong>maven插件</strong>：maven主要定义了项目对象模型的生命周期。实际上每个任务都是交由插件完成的。maven的生命周期与插件目标相互绑定，来完成每个具体的任务。</li>
<li><strong>maven坐标</strong>：就是对项目的定位。groupId：组id，机构名。artifactId：构建id ，产品名或者产品的id。version ：版本号。</li>
<li><strong>坐标形式</strong>：groupId + artifactId+ version</li>
<li><strong>maven仓库</strong>：存放maven共享构建的位置。<ol>
<li>本地仓库：localRepository（使用<code>conf/settings.xml</code>设置）</li>
<li>私服仓库：部署在局域网中的仓库，方便整个团队的开发使用。</li>
<li>中央仓库：远程仓库下载地址：<a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a></li>
</ol>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- conf/settings.xml设置本地仓库路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">...</span></span></span><br><span class="line">    &lt;localRepository&gt;D:/apache-maven-3.6.1/.m2/repository&lt;/localRepository&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="1-3-maven构建的生命周期"><a href="#1-3-maven构建的生命周期" class="headerlink" title="1.3 maven构建的生命周期"></a>1.3 maven构建的生命周期</h4><p>清除–&gt; 编译–&gt; 测试–&gt; 报告–&gt; 打包(jar\war)–&gt; 安装–&gt; 部署</p>
<ol>
<li>清除：<code>mvn clean</code></li>
<li>编译：<code>mvn compile</code></li>
<li>测试：<code>mvn test</code></li>
<li>打包：<code>mvn package</code></li>
<li>安装：<code>mvn install</code></li>
<li>部署：<code>mvn deploy</code></li>
</ol>
<h4 id="1-4-MAVEN优点"><a href="#1-4-MAVEN优点" class="headerlink" title="1.4 MAVEN优点"></a>1.4 MAVEN优点</h4><ol>
<li>模块化项目<ul>
<li>项目非常大时，可借助Maven将一个项目拆分成多个工程，最好是一个模块对应一个工程，利于分工协作。而且模块可以通信。</li>
</ul>
</li>
<li>实现Jar包共享<ul>
<li>借助Maven，可将jar包仅仅保存在“仓库”中，有需要该文件时，就引用该文件接口，不需要复制文件过来占用空间。</li>
</ul>
</li>
<li>jar包的依赖<ul>
<li>借助Maven可以以规范的方式下载jar包，因为所有的知名框架或第三方工具的jar包已经按照统一的规范存放到了Maven的中央仓库中。</li>
</ul>
</li>
<li>jar包的自动导入<ul>
<li>通过xml定义引入jar包，Maven会自动导入jar包及其依赖jar包进来。</li>
</ul>
</li>
</ol>
<h4 id="1-5-MAVEN工具"><a href="#1-5-MAVEN工具" class="headerlink" title="1.5 MAVEN工具"></a>1.5 MAVEN工具</h4><ul>
<li>可以命令行使用，也可以结合Eclipse和Idea使用</li>
<li>简化项目搭建、编译、打包、发布等工作</li>
</ul>
<h3 id="2-SpringBoot基础"><a href="#2-SpringBoot基础" class="headerlink" title="2. SpringBoot基础"></a>2. SpringBoot基础</h3><ul>
<li>SpringBoot是对<strong>Spring框架的封装</strong>，用于<strong>简化</strong>Spring应用搭建和开发过程。</li>
<li>SpringBoot是pivotal公司产品、SpringCloud也是。</li>
</ul>
<h4 id="2-1-SpringBoot典型特点："><a href="#2-1-SpringBoot典型特点：" class="headerlink" title="2.1 SpringBoot典型特点："></a>2.1 SpringBoot典型特点：</h4><ul>
<li>去除XML配置，完全采用Java配置方式</li>
<li>内置tomcat服务器</li>
<li>利用自动配置创建很多对象（DataSource、JdbcTemplate、DispatcherServlet等）</li>
<li>提供一系列启动器（jar包集合）</li>
<li>采用properties或yml做配置文件</li>
<li>应用采用jar包发布</li>
</ul>
<h4 id="2-2-SpringBoot程序构成"><a href="#2-2-SpringBoot程序构成" class="headerlink" title="2.2 SpringBoot程序构成"></a>2.2 SpringBoot程序构成</h4><ul>
<li>创建工程，导入boot启动器（jar包）</li>
<li><code>spring-boot-starter</code> (核心、包含ioc、yml、自动配置、Log日志)</li>
<li><code>spring-boot-starter-parent</code>（包含参数设置、文件编码、jdk版本等）</li>
<li><code>spring-boot-starter-jdbc</code>（包含连接池、jdbcTemplate等）</li>
<li><code>spring-boot-starter-web</code>（包含mvc、restful、tomcat等）</li>
<li><code>spring-boot-starter-test</code>（包含junit、spring-test等）</li>
<li>添加配置文件<code>application.properties</code>或<code>application.yml</code></li>
</ul>
<h4 id="2-3-SpringBoot配置文件"><a href="#2-3-SpringBoot配置文件" class="headerlink" title="2.3 SpringBoot配置文件"></a>2.3 SpringBoot配置文件</h4><p>application.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">server.port=8888</span><br></pre></td></tr></table></figure>

<p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr"> datasource:</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr"> port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-SpringBoot启动类"><a href="#2-4-SpringBoot启动类" class="headerlink" title="2.4 SpringBoot启动类"></a>2.4 SpringBoot启动类</h4><p>定义启动类，通过main方法启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xxxx</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(Xxxx.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-SpringBoot数据库访问"><a href="#2-5-SpringBoot数据库访问" class="headerlink" title="2.5 SpringBoot数据库访问"></a>2.5 SpringBoot数据库访问</h4><p>在pom.xml定义spring-boot-starter-jdbc、mysql驱动包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在application.properties定义数据库连接参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/ydma</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>定义启动类，内部会根据自动配置机制生成DataSource和JdbcTemplate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");</span></span><br><span class="line">        ApplicationContext ctx = </span><br><span class="line">                SpringApplication.run(RunBoot.class, args);</span><br><span class="line">        DataSource ds = ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(ds.getConnection());</span><br><span class="line">        JdbcTemplate template = ctx.getBean(JdbcTemplate.class);</span><br><span class="line">        System.out.println(template);</span><br><span class="line">        String sql = <span class="string">"insert into paper_score (total_score,my_score,user_id) values (?,?,?)"</span>;</span><br><span class="line">        Object[] params = &#123;<span class="number">100</span>,<span class="number">90</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        template.update(sql,params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提示：DataSource和JdbcTemplate都是基于自动配置机制产生，直接注入使用即可。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-打包发布SpringBoot程序："><a href="#2-6-打包发布SpringBoot程序：" class="headerlink" title="2.6 打包发布SpringBoot程序："></a>2.6 打包发布SpringBoot程序：</h4><ol>
<li><p>在pom.xml定义spring-boot-maven-plugin插件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>点击工程右键选择run as- maven build …</p>
</li>
<li><p>执行完毕后会在项目target目录下生成一个jar包，该包就是发布包</p>
<ul>
<li>可以采用java -jar xxxx.jar命令启动</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：eclipse设置jdk必须指向到JDK路径，不要JRE路径。</p>
</blockquote>
<h3 id="3-SpringBoot启动过程"><a href="#3-SpringBoot启动过程" class="headerlink" title="3. SpringBoot启动过程"></a>3. SpringBoot启动过程</h3><ol>
<li>调用SpringApplication的静态的run方法启动</li>
<li>静态的run方法调用SpringApplication对象的run方法<ul>
<li>(SpringApplication对象创建时加载spring.factories文件中Initializer和Application Listeners组件，判断程序类型servlet、reactive、default)</li>
</ul>
</li>
<li>对象的run方法会创建Spring的ApplicationContext容器对象<ul>
<li>获取启动Listener组件</li>
<li>获取environment环境参数</li>
<li>获取启动Logo信息Banner</li>
<li>根据程序类型不同创建不同类型的ApplicationContext对象</li>
<li>将Listener、environment、banner设置到ApplicationContext容器对象中</li>
<li>为ApplicationContext容器对象加载程序中各种Bean组件</li>
<li>开始执行启动任务ApplicationRunner、CommandLineRunner等</li>
<li>返回ApplicationContext容器对象</li>
</ul>
</li>
</ol>
<h3 id="4-SpringBootApplication作用"><a href="#4-SpringBootApplication作用" class="headerlink" title="4. @SpringBootApplication作用"></a>4. @SpringBootApplication作用</h3><p>SpringApplication.run方法在启动中，加载一个带有@SpringBootApplication标记的参数，该标记具有以下几种功能。</p>
<h4 id="4-1-SpringBootConfiguration（SpringBoot-Bean定义）"><a href="#4-1-SpringBootConfiguration（SpringBoot-Bean定义）" class="headerlink" title="4.1 @SpringBootConfiguration（SpringBoot Bean定义）"></a>4.1 @SpringBootConfiguration（SpringBoot Bean定义）</h4><ul>
<li>spring中bean定义<code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</code></li>
<li>SpringBoot通过<code>@Bean、@Primary</code>标记定义。</li>
</ul>
<p>案例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span><span class="comment">//开启Bean定义功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将返回的UserDao对象放入Spring容器，默认方法名为id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userdao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dao2"</span>)<span class="comment">//将返回的UserDao对象放入Spring容器，指定id为dao2</span></span><br><span class="line">    <span class="meta">@Primary</span><span class="comment">//默认注入该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userdao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"userService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@SpringBootConfiguration标记是对Spring的@Configuration封装，所以直接用@Configuration也可以。</p>
</blockquote>
<h4 id="4-2-ComponentScan（SpringBoot组件扫描）"><a href="#4-2-ComponentScan（SpringBoot组件扫描）" class="headerlink" title="4.2 @ComponentScan（SpringBoot组件扫描）"></a>4.2 @ComponentScan（SpringBoot组件扫描）</h4><ul>
<li>spring中组件扫描<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></li>
<li>SpringBoot通过@ComponentScan<ol>
<li>扫描指定包路径组件，带@Controller、@Service、@Repository、@Component注解标记组件<ul>
<li><code>@ComponentScan(basePackages= {&quot;cn.xdl.dao&quot;,&quot;cn.xdl.service&quot;})</code></li>
</ul>
</li>
<li>扫描cn.xdl包及子包下的组件<ul>
<li><code>@ComponentScan(basePackages=&quot;cn.xdl&quot;)</code></li>
</ul>
</li>
<li>扫描当前包及子包下的组件<ul>
<li><code>@ComponentScan</code></li>
</ul>
</li>
<li>扫描当前包及子包组件，并且将DeptService组件纳入<ul>
<li><code>@ComponentScan(includeFilters= {@Filter(type=FilterType.ASSIGNABLE_TYPE,classes=DeptService.class)})</code></li>
</ul>
</li>
<li>扫描当前包及子包组件，带有@Controller、@Service…、@MyComponent注解有效<ul>
<li><code>@ComponentScan(includeFilters= {@Filter(type=FilterType.ANNOTATION,classes=MyComponent.class)})</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="4-3-EnableAutoConfiguration（SpringBoot自动配置）"><a href="#4-3-EnableAutoConfiguration（SpringBoot自动配置）" class="headerlink" title="4.3 @EnableAutoConfiguration（SpringBoot自动配置）"></a>4.3 @EnableAutoConfiguration（SpringBoot自动配置）</h4><p>自动配置机制是SpringBoot框架特有功能，能在启动后自动创建一些常用对象，例如DataSource、JdbcTemplate等。</p>
<ul>
<li>自动配置原理：<ol>
<li>在xxx-autoconfigure.jar包中META-INF目录下有一个spring.factories文件，其中定义了大量的XxxAutoConfiguration配置组件。当开启@EnableAutoConfiguration标记时，标记内部会触发AutoConfigurationImportSelector组件调用SpringFactoriesLoader加载spring.factories文件。</li>
<li>自动配置组件就是采用@Configuration+@Bean+@Primary标记事先定义好的配置组件，通过Boot启动自动去spring.factories文件加载，然后在Spring容器中创建出约定对象。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataSourceAutoConfiguration<span class="comment">//创建dataSource对象</span></span><br><span class="line">JdbcTemplateAutoConfiguration<span class="comment">//创建jdbcTemplate</span></span><br><span class="line">DispatcherServletAutoConfiguration<span class="comment">//创建DispatcherServlet对象</span></span><br><span class="line">RedisAutoConfiguration<span class="comment">//创建RedisTemplate对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过自动配置机制创建DataSource对象<ol>
<li>引入spring-boot-starter-jdbc（hikari）、驱动包</li>
<li>在application.properties文件追加db参数</li>
<li>在启动类使用@EnableAutoConfiguration标记<ul>
<li>DataSourceAutoConfiguration默认会创建Hikari、tomcat、dbcp2连接池对象，优先级hikari最高，依次tomcat、dbcp2.</li>
<li>如果通过spring.datasource.type属性指定其他类型连接池组件，SpringBoot可以按指定类型创建连接池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="4-4-MAVEN如何排除某个jar包（扩展）"><a href="#4-4-MAVEN如何排除某个jar包（扩展）" class="headerlink" title="4.4 MAVEN如何排除某个jar包（扩展）"></a>4.4 MAVEN如何排除某个jar包（扩展）</h4><p>在引入spring-boot-starter-jdbc启动器时，由于jar包依赖会自动引入HikariCP，可以通过&lt; exclusion&gt;标记排除依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二十、SSM框架整合(Spring+SpringMVC+MyBatis)]]></title>
      <url>http://chaooo.github.io/2019/08/27/20-SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html</url>
      <content type="html"><![CDATA[<p>SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。<a id="more"></a></p>
<ul>
<li>使用spring MVC负责请求的转发和视图管理</li>
<li>spring实现业务对象管理</li>
<li>mybatis作为数据对象的持久化引擎</li>
</ul>
<h3 id="1-搭建SSM架构步骤："><a href="#1-搭建SSM架构步骤：" class="headerlink" title="1.搭建SSM架构步骤："></a>1.搭建SSM架构步骤：</h3><ol>
<li>设计数据库</li>
<li>先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。</li>
<li>编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li>
<li>编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。</li>
<li>配置spring和mybatis框架的整合(applicationContext.xml)</li>
<li>编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li>
<li>配置SpringMVC(web.xml)</li>
<li>编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li>
<li>编写JSP页面调用，请求哪些参数，需要获取什么数据。</li>
</ol>
<blockquote>
<p>DataBase –&gt; Entity –&gt; Mapper.xml –&gt; Mapper.Java(DAO) –&gt; Service.java –&gt; Controller.java –&gt; Jsp</p>
</blockquote>
<h3 id="2-搭建SSM架构实例（管理员登录）"><a href="#2-搭建SSM架构实例（管理员登录）" class="headerlink" title="2.搭建SSM架构实例（管理员登录）"></a>2.搭建SSM架构实例（管理员登录）</h3><h4 id="1-设计数据库-以MySql为例"><a href="#1-设计数据库-以MySql为例" class="headerlink" title="1. 设计数据库(以MySql为例)"></a>1. 设计数据库(以MySql为例)</h4><p>建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> exam_sys;</span><br><span class="line"><span class="comment">/** 管理员表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">admin</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'管理员ID'</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'管理员账号'</span>,</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">COMMENT</span> <span class="string">'管理员密码'</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_id_pk PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_name_uk <span class="keyword">UNIQUE</span>(<span class="keyword">NAME</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/** 插入数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span> (<span class="keyword">name</span>, <span class="keyword">password</span>) <span class="keyword">VALUES</span>(<span class="string">'admin'</span>, <span class="string">'123456'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-先写实体类entity，定义对象的属性"><a href="#2-先写实体类entity，定义对象的属性" class="headerlink" title="2. 先写实体类entity，定义对象的属性"></a>2. 先写实体类entity，定义对象的属性</h4><p>参照数据库中表的字段来设置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.entity;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    private <span class="built_in">String</span> password;</span><br><span class="line">    <span class="comment">/** 添加 getter/setter方法</span></span><br><span class="line"><span class="comment">     *  添加 无参，有参构造</span></span><br><span class="line"><span class="comment">     *  重写toString()以便于测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-编写AdminMapper-xml（Mybatis），定义功能"><a href="#3-编写AdminMapper-xml（Mybatis），定义功能" class="headerlink" title="3. 编写AdminMapper.xml（Mybatis），定义功能"></a>3. 编写AdminMapper.xml（Mybatis），定义功能</h4><p>对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace指定和哪个Mapper映射器接口对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.exam.mapper.AdminDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span>	</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByNameAndPassword"</span> <span class="attr">resultType</span>=<span class="string">"com.exam.entity.Admin"</span>&gt;</span></span><br><span class="line">        select * from admin where name=#&#123;name, jdbcType=VARCHAR&#125; and password=#&#123;password, jdbcType=VARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。"><a href="#4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。" class="headerlink" title="4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。"></a>4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。</h4><p>导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> com.exam.entity.Admin;</span><br><span class="line"></span><br><span class="line">public interface AdminDao &#123;</span><br><span class="line">    public Admin findByNameAndPassword(@Param(<span class="string">"name"</span>) <span class="built_in">String</span> name, @Param(<span class="string">"password"</span>) <span class="built_in">String</span> password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-配置spring和mybatis框架的整合"><a href="#5-配置spring和mybatis框架的整合" class="headerlink" title="5. 配置spring和mybatis框架的整合"></a>5. 配置spring和mybatis框架的整合</h4><p>导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/exam_sys"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory</span></span><br><span class="line"><span class="comment">        属性dataSource：注入连接池对象</span></span><br><span class="line"><span class="comment">        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置</span></span><br><span class="line"><span class="comment">        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/exam/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="typeAliasesPackage" value="com.exam.entity"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.exam.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="annotationClass" value="com.annotation.MyAnnotation"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启服务层组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.exam.service"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-编写Service-java，为控制层提供服务"><a href="#6-编写Service-java，为控制层提供服务" class="headerlink" title="6. 编写Service.java，为控制层提供服务"></a>6. 编写Service.java，为控制层提供服务</h4><p>接受控制层的参数，完成相应的功能，并返回给控制层。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> com.exam.mapper.AdminDao;</span><br><span class="line"></span><br><span class="line">@Service(<span class="string">"adminService"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdminService</span> </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminDao dao;</span><br><span class="line">    </span><br><span class="line">    public boolean Login(<span class="built_in">String</span> name, <span class="built_in">String</span> password) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dao.findByNameAndPassword(name, password)!=<span class="literal">null</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-配置SpringMVC"><a href="#7-配置SpringMVC" class="headerlink" title="7. 配置SpringMVC"></a>7. 配置SpringMVC</h4><p>导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet分发请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler--&gt;</span></span><br></pre></td></tr></table></figure>

<p>在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启控制器组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.exam.controller"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启标注形式mvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="8-编写Controller-java，连接页面请求和服务层"><a href="#8-编写Controller-java，连接页面请求和服务层" class="headerlink" title="8. 编写Controller.java，连接页面请求和服务层"></a>8. 编写Controller.java，连接页面请求和服务层</h4><p>获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> com.exam.entity.Admin;</span><br><span class="line"><span class="keyword">import</span> com.exam.service.AdminService;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/admin"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdminController</span> </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminService <span class="keyword">as</span>;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(<span class="string">"/tologin"</span>)</span><br><span class="line">    public <span class="built_in">String</span> toLogin() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"admin/login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(value=<span class="string">"/login"</span>,method=RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public boolean addUser(Admin admin, HttpServletRequest request) &#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+admin);</span><br><span class="line">        System.out.println(admin.getName()+<span class="string">"---"</span>+admin.getPassword());</span><br><span class="line">        boolean bl = <span class="keyword">as</span>.Login(admin.getName(), admin.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(bl) &#123;</span><br><span class="line">            <span class="comment">//登录成功的逻辑</span></span><br><span class="line">            request.getSession().setAttribute(<span class="string">"admin"</span>, admin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//登录失败的逻辑</span></span><br><span class="line">        request.setAttribute(<span class="string">"msg"</span>, <span class="string">"登录失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-编写JSP页面调用"><a href="#9-编写JSP页面调用" class="headerlink" title="9. 编写JSP页面调用"></a>9. 编写JSP页面调用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    管理员: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aName"</span>  <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aPassword"</span>  <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"loginBtn"</span>  <span class="attr">type</span>=<span class="string">"button"</span>  <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="string">"#loginBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"admin/login"</span>,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"post"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: $(<span class="string">"#aName"</span>).val(),</span></span><br><span class="line"><span class="javascript">            password: $(<span class="string">"#aPassword"</span>).val()</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十九、Java持久层框架Mybatis]]></title>
      <url>http://chaooo.github.io/2019/08/27/19-Java%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6Mybatis.html</url>
      <content type="html"><![CDATA[<p>Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。</p>
<a id="more"></a>
<p>MyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。</p>
<ol>
<li><a href="#id1">Mybatis框架的构成</a></li>
<li><a href="#id2">使用Mybatis访问数据库</a></li>
<li><a href="#id3">Mybatis的CRUD操作</a></li>
<li><a href="#id4">Mapper映射器</a></li>
<li><a href="#id5">向mapper传多个参数</a></li>
<li><a href="#id6">结果集列名和属性名不一致的解决方法</a></li>
<li><a href="#id7">类型的别名和日志输出</a></li>
<li><a href="#id8">JdbcType</a></li>
</ol>
<p><span id="id1"><span> </span></span></p>
<h3 id="1-Mybatis框架的构成"><a href="#1-Mybatis框架的构成" class="headerlink" title="1. Mybatis框架的构成"></a>1. Mybatis框架的构成</h3><ul>
<li>实体类 ： 封装记录信息（JavaBean）</li>
<li>SQL定义文件 ：定义sql语句（编写SQL语句的XML）</li>
<li>主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML</li>
<li>框架API ：用于实现数据库增删改查操作（主要通过SqlSession）</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-使用Mybatis访问数据库"><a href="#2-使用Mybatis访问数据库" class="headerlink" title="2. 使用Mybatis访问数据库"></a>2. 使用Mybatis访问数据库</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p>
<ol>
<li><p>准备数据库及创建项目（需要mybatis的jar包和数据库驱动包）</p>
</li>
<li><p>根据表建立对应的实体类：<code>Emp(id,name,salary)</code></p>
</li>
<li><p>在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"environment"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"environment"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/mapper/EmpMapper.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在【src】包路径下创建配置文件（com/mapper/EmpMapper.xml）,然后根据需求定义sql</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mapper.EmpMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span>	</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">         select * from emp32 where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">         select * from emp32 where name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<ul>
<li>parameterType：要求输入参数的类型</li>
<li>resultType：输出的类型</li>
</ul>
</blockquote>
<ol start="5">
<li><p>封装工具类获取SQLSession</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory ssf;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 先构建SQLSession工厂构建器</span></span><br><span class="line">        SqlSessionFactoryBuilder ssfb = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        <span class="comment">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class="line">        InputStream inputStream = SqlSessionUtil.class.getClassLoader().getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        ssf = ssfb.build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 获取SQLSession</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class="line">        <span class="keyword">return</span> ssf.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SqlSession ss =SqlSessionUtil.getSqlSession();</span><br><span class="line">        Emp emp = ss.selectOne(<span class="string">"findById"</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>基本原理</p>
<ul>
<li>应用程序找 MyBatis 要数据</li>
<li>MyBatis 从数据库中找来数据</li>
<li>通过 mybatis-config.xml 定位哪个数据库</li>
<li>通过 EmpMapper.xml 执行对应的 sql 语句</li>
<li>基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中</li>
<li>返回一个 Emp 对象</li>
</ul>
</blockquote>
<p><span id="id3"><span></span></span></p>
<h3 id="3-Mybatis的CRUD操作"><a href="#3-Mybatis的CRUD操作" class="headerlink" title="3. Mybatis的CRUD操作"></a>3. Mybatis的CRUD操作</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p>
<ol>
<li>第一步：配置EmpMapper.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertEmp"</span> <span class="attr">parameterType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    insert into emp32(name, salary) values(#&#123;name&#125;, #&#123;salary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    delete from emp32 where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    update emp32 set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">     select * from emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>parameterType：要求输入参数的类型</li>
<li>resultType：输出的类型</li>
</ul>
</blockquote>
<ol start="2">
<li>第二步：SQLSession实现增删改查</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先构建SQLSession工厂构建器</span></span><br><span class="line">SqlSessionFactoryBuilder ssfb = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line"><span class="comment">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class="line">InputStream inputStream = EmpTest.class.getClassLoader().getResourceAsStream(<span class="string">"sqlmap-config.xml"</span>);</span><br><span class="line">SqlSessionFactory ssf = ssfb.build(inputStream);</span><br><span class="line"><span class="comment">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class="line">SqlSession ss = ssf.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">Emp emp = <span class="keyword">new</span> Emp(<span class="number">0</span>,<span class="string">"ef2"</span>,<span class="number">50000</span>);</span><br><span class="line"><span class="keyword">int</span> addRows = ss.insert(<span class="string">"insertEmp"</span>, emp);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">int</span> delRows = ss.delete(<span class="string">"deleteEmpById"</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">Emp emp2 = <span class="keyword">new</span> Emp(<span class="number">1</span>,<span class="string">"hello"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> updateRows = ss.update(<span class="string">"updateEmpById"</span>, emp2);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">Emp emp3 = ss.selectOne(<span class="string">"findById"</span>, <span class="number">6</span>);</span><br><span class="line">List&lt;Emp&gt; empList = ss.selectList(<span class="string">"findAll"</span>);</span><br><span class="line"></span><br><span class="line">ss.commit();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SqlSession对象的操作方法如下：</p>
<ul>
<li>insert(..) 插入操作</li>
<li>update(..) 更新操作</li>
<li>delete(..) 删除操作</li>
<li>selectOne(..) 单行查询操作</li>
<li>selectList(..) 多行查询操作</li>
<li>通过 session.commit() 来提交事务，也可以简单理解为更新到数据库</li>
</ul>
</blockquote>
<p><span id="id4"><span></span></span></p>
<h3 id="4-Mapper映射器"><a href="#4-Mapper映射器" class="headerlink" title="4. Mapper映射器"></a>4. Mapper映射器</h3><p>使用规则：</p>
<ol>
<li>接口的方法名和SQL定义文件中的id保持一致</li>
<li>接口方法的返回值类型 要和resultType 保持一致<ul>
<li>单行：<code>resultType</code></li>
<li>多行：<code>List&lt;resultType&gt;</code></li>
<li>增删改返回值，推荐int，也可以是void</li>
</ul>
</li>
<li>接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意</li>
<li>SQL定义文件中的namespace必须包名.接口名</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-向mapper传多个参数"><a href="#5-向mapper传多个参数" class="headerlink" title="5. 向mapper传多个参数"></a>5. 向mapper传多个参数</h3><h4 id="5-1-第一种方案：-0-，-1-param1-和-param2"><a href="#5-1-第一种方案：-0-，-1-param1-和-param2" class="headerlink" title="5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}"></a>5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}</h4><p>DAO层的函数方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对应的Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;0&#125; and name = #&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。<br>也可以用#{param1} 和 #{param2}实现同意效果。</p>
<h4 id="5-2-第二种方案-param"><a href="#5-2-第二种方案-param" class="headerlink" title="5.2 第二种方案@param"></a>5.2 第二种方案@param</h4><p>Dao层的函数方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(@param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id, @<span class="title">param</span><span class="params">(<span class="string">"name"</span>)</span>String name)</span>;</span><br></pre></td></tr></table></figure>

<p>对应的Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-第三种方案：采用对象或Map传多参数"><a href="#5-3-第三种方案：采用对象或Map传多参数" class="headerlink" title="5.3 第三种方案：采用对象或Map传多参数"></a>5.3 第三种方案：采用对象或Map传多参数</h4><p>Dao层的函数方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(Emp emp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName2</span><span class="params">(Map&lt;String, Object&gt; params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对应的Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">parameterType</span>=<span class="string">"com.bean.Emp"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName2"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span id="id6"><span></span></span></p>
<h3 id="6-结果集列名和属性名不一致的解决方法"><a href="#6-结果集列名和属性名不一致的解决方法" class="headerlink" title="6. 结果集列名和属性名不一致的解决方法"></a>6. 结果集列名和属性名不一致的解决方法</h3><p>在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。<br>解决方法：</p>
<ol>
<li>使用别名，select语句使用与属性一致的别名</li>
<li>使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系</span></span><br><span class="line"><span class="comment">    type:resultMap最终所映射的Java对象类型，可以使用别名</span></span><br><span class="line"><span class="comment">    id:对resultMap的唯一标识 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.bean.Emp"</span> <span class="attr">id</span>=<span class="string">"empMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id表示查询结果集中唯一标识 </span></span><br><span class="line"><span class="comment">        column:查询出的列名</span></span><br><span class="line"><span class="comment">        property:type所指定的类中的属性名 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"e_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对普通列的映射定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>  <span class="attr">column</span>=<span class="string">"salary"</span>  <span class="attr">property</span>=<span class="string">"sal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"empMap"</span>&gt;</span></span><br><span class="line">         select * from  emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span id="id7"><span></span></span></p>
<h3 id="7-类型的别名和日志输出"><a href="#7-类型的别名和日志输出" class="headerlink" title="7. 类型的别名和日志输出"></a>7. 类型的别名和日志输出</h3><p>在mybatis-config.xml中自定义类型的别名</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"emp"</span> <span class="attr">type</span>=<span class="string">"com.bean.Emp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在EmpMapper.xml中使用别名 resultType=”emp”</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"emp"</span>&gt;</span></span><br><span class="line">    select id,name,salary sal from emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置MyBatis的日志输出到控制台</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置是否允许缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置日志输出的目标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span id="id8"><span></span></span></p>
<h3 id="8-JdbcType"><a href="#8-JdbcType" class="headerlink" title="8. JdbcType"></a>8. JdbcType</h3><p>在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。</p>
<ul>
<li>所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。</li>
<li>一般情况下，我们没有必要按个字段去识别/判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。</li>
<li>MyBatis包含的JdbcType类型，主要有下面这些：<ul>
<li>BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where name = #&#123;name, jdbcType=VARCHAR&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span id="id9"><span></span></span></p>
<h3 id="9-Mabatis中-和-的区别"><a href="#9-Mabatis中-和-的区别" class="headerlink" title="9. Mabatis中#{}和${}的区别"></a>9. Mabatis中#{}和${}的区别</h3><ol>
<li><code>${}</code>是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂）<ul>
<li>支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号</li>
</ul>
</li>
<li><code>#{}</code>是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入）<ul>
<li>不支持表名、排序方式等的占位，默认会将其当成字符串</li>
</ul>
</li>
</ol>
<h3 id="10-分页"><a href="#10-分页" class="headerlink" title="10. 分页"></a>10. 分页</h3><ol>
<li>在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置分页拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询前使用分页API</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(2, 2);</span><br><span class="line">List<span class="tag">&lt;<span class="name">Emp</span>&gt;</span> emps = dao.orderBySalary();</span><br><span class="line">for(Emp emp: emps) &#123;</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-Spring-MyBatis整合"><a href="#11-Spring-MyBatis整合" class="headerlink" title="11. Spring+MyBatis整合"></a>11. Spring+MyBatis整合</h3><p>Spring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API:</p>
<ol>
<li>SqlSessionFactoryBean<ul>
<li>创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源</li>
<li>依赖于dataSource 和加载SQL定义文件</li>
</ul>
</li>
<li>MapperFactoryBean<ul>
<li>根据指定的某一个Mapper接口生成Bean实例</li>
<li>依赖于SqlSessionFactory 和 MApper接口</li>
</ul>
</li>
<li>MapperScannerConfigurer<ul>
<li>根据指定包批量扫描Mapper接口并生成实例</li>
</ul>
</li>
<li>SqlSessionTemplate<ul>
<li>类似于JdbcTemplate，便于程序员自己编写Mapper实现类</li>
</ul>
</li>
</ol>
<h3 id="12-Spring-MyBatis完成sql操作"><a href="#12-Spring-MyBatis完成sql操作" class="headerlink" title="12. Spring+MyBatis完成sql操作"></a>12. Spring+MyBatis完成sql操作</h3><p><strong>第一步</strong>：使用Mybatis（同上）</p>
<ul>
<li>导jar包(mybatis包/数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口</li>
</ul>
<p><strong>第二步</strong>：配置SqlSessionFactoryBean</p>
<ul>
<li>导入jar包（mabatis-spring/ioc/aop/dao/连接池）</li>
<li>配置SqlSessionFactoryBean注入dataSource和指定sql定义文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>：</p>
<ol>
<li>方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory<ul>
<li>最终产生Mapper接口的 实现类，注意这是实现类</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置SqlSessionFactoryBean 产生Mapper接口的 实现类  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"empDao"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"com.dao.EmpDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"empDao2"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"com.dao.EmpDao2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方式二： MapperScannerConfigurer<ul>
<li>MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"annotationClass"</span> <span class="attr">value</span>=<span class="string">"com.annotation.MyAnnotation"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="13-使用SqlSessionTemplate模板来完成DAO接口的实现类"><a href="#13-使用SqlSessionTemplate模板来完成DAO接口的实现类" class="headerlink" title="13. 使用SqlSessionTemplate模板来完成DAO接口的实现类"></a>13. 使用SqlSessionTemplate模板来完成DAO接口的实现类</h3><ol>
<li>使用Mybatis（同上）</li>
<li>配置SqlSessionFactoryBean（同上）</li>
<li>编写DAO接口的实现类<ul>
<li>开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory</li>
<li>使用SqlSessionTemplate对应API完成增删改查</li>
</ul>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建SqlSessionTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionTemplate.selectOne(<span class="string">"findById"</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十八、Spring MVC框架]]></title>
      <url>http://chaooo.github.io/2019/08/27/18-SpringMVC%E6%A1%86%E6%9E%B6.html</url>
      <content type="html"><![CDATA[<p>Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">Spring MVC基本概念</a></li>
<li><a href="#id2">Spring MVC的编写步骤</a></li>
<li><a href="#id3">标注(注解)形式的MVC</a></li>
<li><a href="#id4">mvc控制器接收页面参数</a></li>
<li><a href="#id5">mvc控制器把数据传递给页面</a></li>
<li><a href="#id6">Spring MVC实现重定向</a></li>
<li><a href="#id7">Spring MVC 中文参数的乱码问题</a></li>
<li><a href="#id8">Spring MVC 拦截器</a></li>
<li><a href="#id9">Spring MVC 拦截器的使用步骤</a></li>
<li><a href="#id10">Spring MVC异常处理</a></li>
<li><a href="#id11">Spring MVC文件上传</a></li>
<li><a href="#id12">文件上传与异常处理的结合</a></li>
<li><a href="#id13">Spring MVC响应JSON</a></li>
<li><a href="#id14">REST</a></li>
<li><a href="#id15">REST实例</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-Spring-MVC基本概念"><a href="#1-Spring-MVC基本概念" class="headerlink" title="1. Spring MVC基本概念"></a>1. Spring MVC基本概念</h3><h4 id="1-1-Spring-MVC-五大核心组件"><a href="#1-1-Spring-MVC-五大核心组件" class="headerlink" title="1.1 Spring MVC 五大核心组件"></a>1.1 Spring MVC 五大核心组件</h4><p>Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</p>
<ol>
<li>DispatcherServlet：控制器，请求入口</li>
<li>HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系</li>
<li>Controller：控制器，处理请求</li>
<li>ModelAndView：封装了 数据信息和视图信息</li>
<li>ViewResolver：视图处理器</li>
</ol>
<p>他的两个核心是两个核心：</p>
<ul>
<li>处理器映射：选择使用哪个控制器来处理请求 </li>
<li>视图解析器：选择结果应该如何渲染<blockquote>
<p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。</p>
</blockquote>
</li>
</ul>
<h4 id="1-2-SpringMVC运行原理"><a href="#1-2-SpringMVC运行原理" class="headerlink" title="1.2 SpringMVC运行原理"></a>1.2 SpringMVC运行原理</h4><ol>
<li>Http请求：客户端请求提交到DispatcherServlet。 </li>
<li>寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 </li>
<li>调用处理器：DispatcherServlet将请求提交到Controller。 </li>
<li>调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 </li>
<li>处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 </li>
<li>Http响应：视图负责将结果显示到客户端。</li>
</ol>
<h4 id="1-3-SpringMVC接口解释"><a href="#1-3-SpringMVC接口解释" class="headerlink" title="1.3 SpringMVC接口解释"></a>1.3 SpringMVC接口解释</h4><ol>
<li><strong>DispatcherServlet接口</strong>：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： <ol>
<li>截获符合特定格式的URL请求。 </li>
<li>初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 </li>
<li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li>
</ol>
</li>
<li><strong>HandlerMapping接口</strong>：能够完成客户请求到Controller映射。 </li>
<li><strong>Controller接口</strong>： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 <ul>
<li>Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 </li>
<li>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 </li>
</ul>
</li>
<li><strong>ViewResolver接口</strong>：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</li>
</ol>
<h4 id="1-4-SpringMVC配置"><a href="#1-4-SpringMVC配置" class="headerlink" title="1.4 SpringMVC配置"></a>1.4 SpringMVC配置</h4><ol>
<li><p>在web.xml文件中进行配置applicationContext.xml路径</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置applicationContext.xml，开启注解功能、配置试图解析器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/toHello.do"</span>&gt;</span>helloController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloController"</span> <span class="attr">class</span>=<span class="string">"com.controller.MyHelleController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id2"><span></span></span></p>
<h3 id="2-Spring-MVC的编写步骤"><a href="#2-Spring-MVC的编写步骤" class="headerlink" title="2. Spring MVC的编写步骤"></a>2. Spring MVC的编写步骤</h3><ol>
<li>建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</li>
<li>在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。</li>
<li>在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。</li>
<li>编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象</li>
<li>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</li>
</ol>
<p><span id="id3"><span></span></span></p>
<h3 id="3-标注-注解-形式的MVC"><a href="#3-标注-注解-形式的MVC" class="headerlink" title="3. 标注(注解)形式的MVC"></a>3. 标注(注解)形式的MVC</h3><ol>
<li><p>建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</p>
</li>
<li><p>在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。</p>
</li>
<li><p>开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"包名"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了）</p>
<ul>
<li>使用<code>@Controller</code> 可以把普通Java类转换成控制器，同时在容器中创建对象</li>
<li>使用<code>@RequestMapping(&quot;/路径&quot;)</code> 设置方法上</li>
</ul>
</li>
<li><p>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</p>
</li>
</ol>
<p><span id="id4"><span></span></span></p>
<h3 id="4-mvc控制器接收页面参数"><a href="#4-mvc控制器接收页面参数" class="headerlink" title="4. mvc控制器接收页面参数"></a>4. mvc控制器接收页面参数</h3><ol>
<li><p>使用HttpServletRequest类型的参数来接收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String acc_no = request.getParameter(<span class="string">"acc_no"</span>);</span><br><span class="line">    String acc_pwd = request.getParameter(<span class="string">"acc_password"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接定义和页面请求参数同名的控制器参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login2.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login2</span><span class="params">(String acc_no,String acc_password, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当页面参数和控制器参数名字不一致，@RequestParam(“acc_no”) 让请求参数和控制器参数对应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login3.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login3</span><span class="params">(@RequestParam(<span class="string">"acc_no"</span>)</span> String a,String acc_password, ModelAndView mav) </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制器中 直接定义对象类型的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login4.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login4</span><span class="params">(Account acc, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-mvc控制器把数据传递给页面"><a href="#5-mvc控制器把数据传递给页面" class="headerlink" title="5. mvc控制器把数据传递给页面"></a>5. mvc控制器把数据传递给页面</h3><p>使用EL表达式在jsp页面接收数据<code>&lt;h1&gt;欢迎 ${acc_no} &lt;/h1&gt;</code></p>
<ol>
<li><p>使用域对象 进行传输 (request session ServletContext )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login6.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login6</span><span class="params">(String acc_no, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    req.setAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ModelAndView进行数据传输 </p>
<ul>
<li><code>mav.getModel().put(&quot;acc_no&quot;, acc_no);</code></li>
<li><code>mav.getModelMap().put(key, value);</code></li>
<li><code>mav.getModelMap().addAttribute(&quot;acc_no&quot;, acc_no);</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login7.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login7</span><span class="params">(String acc_no, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="comment">//mav.getModel().put("acc_no", acc_no);</span></span><br><span class="line">    <span class="comment">//mav.getModelMap().put(key, value)</span></span><br><span class="line">    mav.getModelMap().addAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用Model进行数据传输</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login8.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login8</span><span class="params">(String acc_no, Model m)</span> </span>&#123;</span><br><span class="line">    m.addAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ModelMap进行数据传输</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login9.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login9</span><span class="params">(String acc_no, ModelMap m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//m.addAttribute("acc_no", acc_no);</span></span><br><span class="line">    m.put(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(“新名”)修改）</p>
<ul>
<li>默认名：<code>&lt;h1&gt;欢迎 ${ account.acc_no } &lt;/h1&gt;</code></li>
<li>@ModelAttribute(“acc”)：<code>&lt;h1&gt;欢迎 ${ acc.acc_no } &lt;/h1&gt;</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login10.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login10</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id6"><span></span></span></p>
<h3 id="6-Spring-MVC实现重定向"><a href="#6-Spring-MVC实现重定向" class="headerlink" title="6. Spring MVC实现重定向"></a>6. Spring MVC实现重定向</h3><ol>
<li>控制器方法返回String <ul>
<li>redirect:请求路径</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login11.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login11</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    <span class="comment">//return "forward:toMain.do";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:toMain.do"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/toMain.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 干其它的事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>控制器方法返回ModelAndView <ul>
<li>使用RedirectView  完成</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login12.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login12</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    RedirectView rv = <span class="keyword">new</span> RedirectView(<span class="string">"toMain.do"</span>);</span><br><span class="line">    mav.setView(rv);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id7"><span></span></span></p>
<h3 id="7-Spring-MVC-中文参数的乱码问题"><a href="#7-Spring-MVC-中文参数的乱码问题" class="headerlink" title="7. Spring MVC 中文参数的乱码问题"></a>7. Spring MVC 中文参数的乱码问题</h3><p>tomcat8中 get 没有乱码问题，post 请求有乱码问题 </p>
<ol>
<li><p>参数为页面(HttpServletRequest request)与(HttpServletResponse response)时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入参数为<code>@RequestParam</code>时，可以通过字符串重新编码来解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> String(string.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法名前出现<code>@RequestMapping(value=&quot;XXX&quot;)</code>时可以在value属性后再加一个属性<code>produces=&quot;text/html;charset=UTF-8&quot;</code>来解决</p>
</li>
<li><p>在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">utf</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">encodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id8"><span></span></span></p>
<h3 id="8-Spring-MVC-拦截器"><a href="#8-Spring-MVC-拦截器" class="headerlink" title="8. Spring MVC 拦截器"></a>8. Spring MVC 拦截器</h3><ol>
<li>拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置）</li>
<li>HandlerMapping接口<ul>
<li>preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。</li>
<li>postHandle：处理器执行后、视图处理前调用。</li>
<li>afterCompletion：整个请求处理完毕后调用。</li>
</ul>
</li>
</ol>
<p><span id="id9"><span></span></span></p>
<h3 id="9-Spring-MVC-拦截器的使用步骤"><a href="#9-Spring-MVC-拦截器的使用步骤" class="headerlink" title="9. Spring MVC 拦截器的使用步骤"></a>9. Spring MVC 拦截器的使用步骤</h3><ol>
<li>搭建一个基于标注的mvc</li>
<li>编写一个类实现HandlerInterceptor接口</li>
<li>在Spring配置文件中配置拦截器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/login.do"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xdl.interceptor.SomeInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id10"><span></span></span></p>
<h3 id="10-Spring-MVC异常处理"><a href="#10-Spring-MVC异常处理" class="headerlink" title="10. Spring MVC异常处理"></a>10. Spring MVC异常处理</h3><ol>
<li><p>配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleExceptionResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"exceptionMappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.RuntimeException"</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.Exception"</span>&gt;</span>error2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e)</span> </span>&#123;</span><br><span class="line">		ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">			mav.setViewName(<span class="string">"error"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">			mav.setViewName(<span class="string">"error2"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Controller</span></span><br><span class="line"><span class="comment">//public class MyController &#123;</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error3"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id11"><span></span></span></p>
<h3 id="11-Spring-MVC文件上传"><a href="#11-Spring-MVC文件上传" class="headerlink" title="11. Spring MVC文件上传"></a>11. Spring MVC文件上传</h3><ol>
<li><p>jsp页面（method=”POST” enctype=”multipart/form-data type=”file”）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload.do"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"head_img"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id12"><span></span></span></p>
<h3 id="12-文件上传与异常处理的结合"><a href="#12-文件上传与异常处理的结合" class="headerlink" title="12. 文件上传与异常处理的结合"></a>12. 文件上传与异常处理的结合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/toFile.do"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">tofile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"file"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/upload.do"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(String acc_no, MultipartFile head_img)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"acc_no:"</span> + acc_no );</span><br><span class="line">		<span class="keyword">if</span>(head_img.getSize()&gt;<span class="number">1024</span>*<span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件过大！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 把文件写入磁盘</span></span><br><span class="line">		String uniqueStr = UUID.randomUUID().toString();</span><br><span class="line">		String oriFilename = head_img.getOriginalFilename();</span><br><span class="line">		String suffix = oriFilename.substring(oriFilename.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"F:/Eclipse/datas/"</span>+uniqueStr+suffix);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			head_img.transferTo(file);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(oriFilename);</span><br><span class="line">		System.out.println(file);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"file"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/** 局部异常 */</span></span><br><span class="line">	<span class="meta">@ExceptionHandler</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">processError</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"error4"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id13"><span></span></span></p>
<h3 id="13-Spring-MVC响应JSON"><a href="#13-Spring-MVC响应JSON" class="headerlink" title="13. Spring MVC响应JSON"></a>13. Spring MVC响应JSON</h3><ol>
<li>搭建基于标注的mvc</li>
<li>在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON</li>
<li>给方法加@RequestMapping(“/请求路径”)、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包</li>
</ol>
<p><span id="id14"><span></span></span></p>
<h3 id="14-REST"><a href="#14-REST" class="headerlink" title="14. REST"></a>14. REST</h3><p>REST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。</p>
<ol>
<li>REST两个核心规范<ul>
<li>url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:<a href="http://test/source/1234）" target="_blank" rel="noopener">http://test/source/1234）</a></li>
<li>对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新</li>
</ul>
</li>
<li>restful<ul>
<li>符合REST设计规范和风格的应用程序或设计 就是RESTful</li>
</ul>
</li>
<li>Spring MVC对REST的支持<ul>
<li>@RequestMapping支持URI的模板，以及http请求方式设定的支持<ul>
<li><code>@RequestMapping(value=&quot;/account/{id}&quot;,method=RequestMethod.POST)</code></li>
</ul>
</li>
<li>对URI上路径变量的处理的支持，@PathVariable<ul>
<li><code>@PathVariable(&quot;id&quot;) int id</code></li>
</ul>
</li>
<li>rest请求路径是没有后缀的，需要把url-parttern修改成<code>/</code></li>
<li><code>&lt;servlet-mapping&gt;&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></li>
<li>需要对静态资源进行放行<code>&lt;mvc:default-servlet-handler/&gt;</code></li>
</ul>
</li>
</ol>
<p><span id="id15"><span></span></span></p>
<h3 id="15-REST实例"><a href="#15-REST实例" class="headerlink" title="15. REST实例"></a>15. REST实例</h3><ol>
<li>配置web.xml与applicationContext.xml(部分配置)</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改rest请求路径 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- web.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写控制类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/toLogin.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id查询账户 GET */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        Random rm = <span class="keyword">new</span> Random();</span><br><span class="line">        Account acc = <span class="keyword">new</span> Account(id, <span class="string">"test"</span>+rm.nextInt(<span class="number">100</span>),<span class="string">"123"</span>, rm.nextInt(<span class="number">999</span>)+<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 新增账户 POST */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAccount</span><span class="params">(Account acc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+acc);</span><br><span class="line">        <span class="keyword">if</span>(acc.getId()&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id删除帐户对象 DELETE */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.DELETE)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteAccountById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delete:"</span>+id);</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id更新帐户 PUT */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.PUT)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putAccount</span><span class="params">(@RequestBody Account acc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//@RequestBody将接收的ajax请求的json字符串写入Account对象中</span></span><br><span class="line">        System.out.println(<span class="string">"update:"</span>+acc);</span><br><span class="line">        <span class="keyword">if</span>(acc.getId()&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写jsp页面</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountId"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountNo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountPassword"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>金额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountMoney"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"findBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"addBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"updateBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"delBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="string">"#findBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    findAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#addBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    addAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#updateBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    updateAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#delBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    delAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getDatas</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> accountId = $(<span class="string">"#accountId"</span>).val();</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> accountNo = $(<span class="string">"#accountNo"</span>).val();</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> accountPassword = $(<span class="string">"#accountPassword"</span>).val();</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> accountMoney = $(<span class="string">"#accountMoney"</span>).val();</span></span><br><span class="line"><span class="javascript">	<span class="keyword">return</span> &#123;</span></span><br><span class="line">	    id: accountId,</span><br><span class="line">	    acc_no: accountNo,</span><br><span class="line">	    acc_password: accountPassword,</span><br><span class="line">	    acc_money: accountMoney</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">findAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"get"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountNo"</span>).val(res.acc_no);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountPassword"</span>).val(res.acc_password);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountMoney"</span>).val(res.acc_money);</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">addAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"post"</span>,</span></span><br><span class="line">        data: datas,</span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">delAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"delete"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updateAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url:<span class="string">"account/"</span>+ datas.id,</span></span><br><span class="line"><span class="javascript">        type:<span class="string">"put"</span>,</span></span><br><span class="line"><span class="javascript">        data:<span class="built_in">JSON</span>.stringify(datas),</span></span><br><span class="line"><span class="javascript">        contentType:<span class="string">"application/json"</span>,<span class="comment">//以json字符串提交数据</span></span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<ul>
<li>PUT需要以json字符串提交数据<code>contentType:&quot;application/json&quot;</code></li>
<li>@RequestBody将接收的ajax请求的json字符串写入Account对象中</li>
<li>JSON.stringify()：将json对象转换为json字符串</li>
<li>JSON.parse()：将json字符串转换为json对象</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十七、Spring面向切面编程(AOP模块)]]></title>
      <url>http://chaooo.github.io/2019/08/27/17-Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP.html</url>
      <content type="html"><![CDATA[<p>AOP（Aspect Oriented Programming）：面向切面编程，<br>它是面向对象基础上发展来的技术，是面向对象更高层次的应用，<br>它可以在不修改原有代码的情况给组件增强功能。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">AOP涉及到的概念</a></li>
<li><a href="#id2">编写AOP程序步骤</a></li>
<li><a href="#id3">切点表达式</a></li>
<li><a href="#id4">通知的五种类型</a></li>
<li><a href="#id5">标注形式AOP步骤</a></li>
<li><a href="#id6">AOP 通知对应的标注</a></li>
<li><a href="#id7">@Around具体用法</a></li>
<li><a href="#id8">异常通知</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-AOP涉及到的概念"><a href="#1-AOP涉及到的概念" class="headerlink" title="1. AOP涉及到的概念"></a>1. AOP涉及到的概念</h3><ul>
<li>Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。</li>
<li>JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息）</li>
<li>Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点</li>
<li>Target：目标，要被切入共通业务逻辑的对象</li>
<li>Proxy：代理，被增强之后的目标对象就是代理</li>
<li>Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-编写AOP程序步骤"><a href="#2-编写AOP程序步骤" class="headerlink" title="2. 编写AOP程序步骤"></a>2. 编写AOP程序步骤</h3><ol>
<li>编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法</li>
<li>在不修改登录和注册原有代码的情况下，让两个方法调用前输出<code>******</code><ol>
<li>添加aop的jar包到lib</li>
<li>编写一个类，定义共同业务逻辑</li>
<li>配置aplicationContext.xml，创建切面对象</li>
<li>配置aop:config，切面–&gt;通知–&gt;切点</li>
</ol>
</li>
</ol>
<p><span id="id3"><span></span></span></p>
<h3 id="3-切点表达式"><a href="#3-切点表达式" class="headerlink" title="3. 切点表达式"></a>3. 切点表达式</h3><ol>
<li>Bean限定表达式<ul>
<li><code>bean(&quot;容器内组件id&quot;)</code>，支持通配符<em>，如：<code>bean(&quot;*Dao&quot;)</code>，`bean(“acc</em>“)`</li>
</ul>
</li>
<li>类型限定表达式<ul>
<li><code>within(&quot;包名.类型&quot;)</code>，要求表达式最后一部分必须是类型，如：<code>com.dao.impl.类型</code>，<code>com.dao.impl.*</code>，<code>com.dao..*</code></li>
</ul>
</li>
<li>方法限定表达式<ul>
<li><code>execution(&quot;表达式&quot;)</code>，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:<code>返回值类型 方法名()</code></li>
</ul>
</li>
</ol>
<p><span id="id4"><span></span></span></p>
<h3 id="4-通知的五种类型"><a href="#4-通知的五种类型" class="headerlink" title="4. 通知的五种类型"></a>4. 通知的五种类型</h3><ol>
<li><code>&lt;aop:before</code>：前置通知，目标方法执行之前调用</li>
<li><code>&lt;aop:after-returning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li>
<li><code>&lt;aop:after-throwing</code>：异常通知，目标方法出异常才调用</li>
<li><code>&lt;aop:after</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li>
<li><code>&lt;aop:around</code>：环绕通知，目标方法执行前后都调用</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-标注形式AOP步骤"><a href="#5-标注形式AOP步骤" class="headerlink" title="5. 标注形式AOP步骤"></a>5. 标注形式AOP步骤</h3><ol>
<li>建项目，添加jar包(ioc,aop)，src下添加配置文件</li>
<li>编写一个Sevice类，里面有登录和注册两个方法</li>
<li>开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑</li>
<li>定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象</li>
<li>开启标注形式aop：<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true|false&quot; /&gt;</code></li>
<li>使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： <code>@Aspect，@Before...</code></li>
</ol>
<p><span id="id6"><span></span></span></p>
<h3 id="6-AOP-通知对应的标注"><a href="#6-AOP-通知对应的标注" class="headerlink" title="6. AOP 通知对应的标注"></a>6. AOP 通知对应的标注</h3><ol>
<li><code>@Before</code>：前置通知，目标方法执行之前调用</li>
<li><code>@AfterReturning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li>
<li><code>@AfterThrowing</code>：异常通知，目标方法出异常才调用</li>
<li><code>@After</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li>
<li><code>@Around</code>：环绕通知，目标方法执行前后都调用</li>
</ol>
<p><span id="id7"><span></span></span></p>
<h3 id="7-Around具体用法"><a href="#7-Around具体用法" class="headerlink" title="7. @Around具体用法"></a>7. @Around具体用法</h3><p>@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"within(com..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">showAfterDate</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"开始时间："</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">    Object obj = pjp.proceed();</span><br><span class="line">    System.out.println(<span class="string">"结束时间："</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">    System.out.println(<span class="string">"执行时间："</span>date2.getTime() - date.getTime());</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p>
</blockquote>
<p><span id="id8"><span></span></span></p>
<h3 id="8-异常通知"><a href="#8-异常通知" class="headerlink" title="8. 异常通知"></a>8. 异常通知</h3><p>JoinPoint可以获取出异常的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"within(com..*)"</span>, throwing=<span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processException</span><span class="params">(JoinPoint jp, Exception e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"捕获到异常"</span> + jp.getSignature() + <span class="string">":\n【"</span> + e +<span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十六、Spring事务管理]]></title>
      <url>http://chaooo.github.io/2019/08/27/16-Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.html</url>
      <content type="html"><![CDATA[<p>事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">事务的特性(ACID)</a></li>
<li><a href="#id2">Spring提供事务管理的3个接口</a></li>
<li><a href="#id3">TransactionDefinition接口</a></li>
<li><a href="#id4">TransactionStatus接口</a></li>
<li><a href="#id5">PlatformTransactionManager接口（事务管理器）</a></li>
<li><a href="#id6">基于AspectJ的xml方式的声明式事务管理</a></li>
<li><a href="#id7">基于注解的声明式事务管理</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-事务的特性-ACID"><a href="#1-事务的特性-ACID" class="headerlink" title="1. 事务的特性(ACID)"></a>1. 事务的特性(ACID)</h3><ul>
<li>事务的特性：<strong>原子性、一致性、隔离性、持久性</strong>。</li>
<li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>
<li>一致性（Consistency）：事务前后数据的完整性必须保持一致。</li>
<li>隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。</li>
<li>持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-Spring提供事务管理的3个接口："><a href="#2-Spring提供事务管理的3个接口：" class="headerlink" title="2. Spring提供事务管理的3个接口："></a>2. Spring提供事务管理的3个接口：</h3><ol>
<li><strong>PlatformTransactionManager</strong>：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。</li>
<li><strong>TransactionDefinition</strong>：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。</li>
<li><strong>TransactionStatus</strong>：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。</li>
</ol>
<blockquote>
<p>Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。</p>
</blockquote>
<p><span id="id3"><span></span></span></p>
<h3 id="3-TransactionDefinition接口"><a href="#3-TransactionDefinition接口" class="headerlink" title="3. TransactionDefinition接口"></a>3. TransactionDefinition接口</h3><p>TransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation)</p>
<ul>
<li>如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。</li>
<li>事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。</li>
</ul>
<h4 id="3-1-安全问题"><a href="#3-1-安全问题" class="headerlink" title="3.1 安全问题"></a>3.1 安全问题</h4><ol>
<li>脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。</li>
<li>不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。</li>
<li>幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。</li>
</ol>
<h4 id="3-2-事务的隔离级别-Isolation-："><a href="#3-2-事务的隔离级别-Isolation-：" class="headerlink" title="3.2 事务的隔离级别(Isolation)："></a>3.2 事务的隔离级别(Isolation)：</h4><ol>
<li><strong><code>READ_UNCOMMITED</code></strong>(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。</li>
<li><strong><code>READ_COMMITED</code></strong>(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。</li>
<li><strong><code>REPEATABLE_READ</code></strong>(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。</li>
<li><strong><code>SERIALIZABLE</code></strong>(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。</li>
<li><code>DEFAULT</code>(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别）。</li>
</ol>
<h4 id="3-3-事务的传播特性-Propagation-："><a href="#3-3-事务的传播特性-Propagation-：" class="headerlink" title="3.3 事务的传播特性(Propagation)："></a>3.3 事务的传播特性(Propagation)：</h4><ol>
<li>第一类：运行在同一个事务<ul>
<li><strong><code>REQUIRED</code></strong>：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li>
<li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li>
<li><code>MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常</li>
</ul>
</li>
<li>第二类：运行在不同事务<ul>
<li><strong><code>REQUIRES_NEW</code></strong>：新建事务，如果当前存在事务，把当前事务挂起</li>
<li><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>
<li><code>NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常</li>
</ul>
</li>
<li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul>
<li><strong><code>NESTED</code></strong>：如果当前事务存在，则嵌套事务执行</li>
</ul>
</li>
</ol>
<p><span id="id4"><span></span></span></p>
<h3 id="4-TransactionStatus接口"><a href="#4-TransactionStatus接口" class="headerlink" title="4. TransactionStatus接口"></a>4. TransactionStatus接口</h3><p>平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。</p>
<p><span id="id5"><span></span></span></p>
<h3 id="5-PlatformTransactionManager接口（事务管理器）"><a href="#5-PlatformTransactionManager接口（事务管理器）" class="headerlink" title="5. PlatformTransactionManager接口（事务管理器）"></a>5. PlatformTransactionManager接口（事务管理器）</h3><p>该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。</p>
<h4 id="5-1-Spring支持两种方式事务管理："><a href="#5-1-Spring支持两种方式事务管理：" class="headerlink" title="5.1 Spring支持两种方式事务管理："></a>5.1 Spring支持两种方式事务管理：</h4><ol>
<li>编程式事务管理<ul>
<li>手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用）</li>
</ul>
</li>
<li>声明式事务管理<ul>
<li>基于TransactionProxyFactoryBean的方式（很少使用）</li>
<li>基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用）</li>
<li>基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加<code>@Transactional</code>注解（经常使用）</li>
</ul>
</li>
</ol>
<p><span id="id6"><span></span></span></p>
<h3 id="6-基于AspectJ的xml方式的声明式事务管理"><a href="#6-基于AspectJ的xml方式的声明式事务管理" class="headerlink" title="6. 基于AspectJ的xml方式的声明式事务管理"></a>6. 基于AspectJ的xml方式的声明式事务管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"jdbc连接池对象id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务的通知（事务的增强） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- propagation:事务传播行为</span></span><br><span class="line"><span class="comment">            isolation:事务的隔离级别</span></span><br><span class="line"><span class="comment">            read-only:只读</span></span><br><span class="line"><span class="comment">            rollback-for:发生哪些异常回滚</span></span><br><span class="line"><span class="comment">            no-rollback-for:发生哪些异常不回滚</span></span><br><span class="line"><span class="comment">            timeout:过期信息    --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"transfer"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">rollback-for</span>=<span class="string">""</span> <span class="attr">timeout</span>=<span class="string">""</span> <span class="attr">no-rollback-for</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut1"</span> <span class="attr">expression</span>=<span class="string">"execution(*cn.muke.spring.demo3.AccountService+.*(.))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span id="id7"><span></span></span></p>
<h3 id="7-基于注解的声明式事务管理"><a href="#7-基于注解的声明式事务管理" class="headerlink" title="7. 基于注解的声明式事务管理"></a>7. 基于注解的声明式事务管理</h3><ol>
<li><p>配置事务管理器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.创建一个事务管理器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"事务管理器id"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"jdbc连接池对象id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.开启声明式事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"事务管理器id"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true|false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>transaction-manager</strong>：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource)</li>
<li><strong>proxy-target-class</strong>：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>使用，在类上或者方法上标注<code>@Transactional</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(</span><br><span class="line">        rollbackFor=&#123;Exception.class&#125;, </span><br><span class="line">        readOnly=<span class="keyword">false</span>, </span><br><span class="line">        isolation=Isolation.DEFAULT,</span><br><span class="line">        propagation=Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Transactional的属性<ul>
<li><strong>rollbackFor</strong>：设置检查异常也回滚</li>
<li><strong>noRollbackFor</strong>：指定运行时异常不回滚</li>
<li><strong>readOnly</strong>： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。</li>
<li><strong>isolation</strong>：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE)</li>
<li><strong>propagation</strong>：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER)</li>
</ul>
</li>
<li>Spring中事务管理器默认值针对<strong>运行时异常</strong>回滚，对<strong>检查异常</strong>不回滚。</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十五、SpringJDBC详解]]></title>
      <url>http://chaooo.github.io/2019/08/27/15-SpringJDBC%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的<strong>声明式</strong>事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">数据源配置</a></li>
<li><a href="#id2">JdbcTemplate的使用</a></li>
<li><a href="#id3">通过实现RowMapper接口把查询结果映射到Java对象</a></li>
<li><a href="#id4">JdbcTemplate对象的主要方法</a></li>
<li><a href="#id5">异常转换</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-数据源配置"><a href="#1-数据源配置" class="headerlink" title="1. 数据源配置"></a>1. 数据源配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">mysqlDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/test"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(mysqlDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用XML配置来实现配置效果：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义jdbcTemplate对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.jdbc"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span id="id2"><span></span></span></p>
<h3 id="2-JdbcTemplate的使用"><a href="#2-JdbcTemplate的使用" class="headerlink" title="2. JdbcTemplate的使用"></a>2. JdbcTemplate的使用</h3><p>JdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。<br>JdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。</p>
<p>基本的查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAO实现类</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(*) from emp32"</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p><span id="id3"><span></span></span></p>
<h3 id="3-通过实现RowMapper接口把查询结果映射到Java对象"><a href="#3-通过实现RowMapper接口把查询结果映射到Java对象" class="headerlink" title="3. 通过实现RowMapper接口把查询结果映射到Java对象"></a>3. 通过实现RowMapper接口把查询结果映射到Java对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Emp</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Emp(</span><br><span class="line">            rs.getInt(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getDouble(<span class="string">"salary"</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAO实现类</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">getEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp32 where id=?"</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> EmpRowMapper(), id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p><span id="id4"><span></span></span></p>
<h3 id="4-JdbcTemplate对象的主要方法"><a href="#4-JdbcTemplate对象的主要方法" class="headerlink" title="4. JdbcTemplate对象的主要方法"></a>4. JdbcTemplate对象的主要方法</h3><ol>
<li><p>queryForInt()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询一个整数类型</span></span><br><span class="line"><span class="keyword">int</span> count = jdbcTemplateObject.queryForInt(<span class="string">"select count(*) from emp32"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个使用绑定变量的简单查询</span></span><br><span class="line"><span class="keyword">int</span> age = jdbcTemplateObject.queryForInt(<span class="string">"select age from emp32 where id = ?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>queryForLong()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询一个 long类型</span></span><br><span class="line"><span class="keyword">long</span> count = jdbcTemplateObject.queryForLong(<span class="string">"select count(*) from emp32"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>queryForObject()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询字符串</span></span><br><span class="line">String SQL = <span class="string">"select name from emp32 where id = ?"</span>;</span><br><span class="line">String name = jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询并返回一个对象：</span></span><br><span class="line">String SQL = <span class="string">"select * from emp32 where id = ?"</span>;</span><br><span class="line">emp32 student = jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;, <span class="keyword">new</span> EmpRowMapper());</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询并返回多个对象：</span></span><br><span class="line">String SQL = <span class="string">"select * from emp32"</span>;</span><br><span class="line">List&lt;emp32&gt; students = jdbcTemplateObject.query(SQL, <span class="keyword">new</span> EmpRowMapper());</span><br></pre></td></tr></table></figure>
</li>
<li><p>update()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表中插入一行：</span></span><br><span class="line">String SQL = <span class="string">"insert into emp32 (name, age) values (?, ?)"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="string">"Zara"</span>, <span class="number">11</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新表中的一行：</span></span><br><span class="line">String SQL = <span class="string">"update emp32 set name = ? where id = ?"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="string">"Zara"</span>, <span class="number">10</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//从表中删除一行：</span></span><br><span class="line">String SQL = <span class="string">"delete emp32 where id = ?"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">20</span>&#125; );</span><br></pre></td></tr></table></figure>
</li>
<li><p>execute()：执行DDL语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">"CREATE TABLE emp32(</span></span><br><span class="line"><span class="string">	id		INT AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">	NAME	VARCHAR(30),</span></span><br><span class="line"><span class="string">	salary	DOUBLE DEFAULT 5000,</span></span><br><span class="line"><span class="string">	CONSTRAINT student_id_pk PRIMARY KEY(id),</span></span><br><span class="line"><span class="string">	CONSTRAINT student_name_uk UNIQUE(NAME)</span></span><br><span class="line"><span class="string">)"</span>;</span><br><span class="line">jdbcTemplateObject.execute( SQL );</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-异常转换"><a href="#5-异常转换" class="headerlink" title="5. 异常转换"></a>5. 异常转换</h3><ul>
<li>Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。</li>
<li>所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。</li>
<li>这样可以使异常处理机制独立于当前使用的具体数据库。</li>
<li>除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。</li>
</ul>
<p>例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSQLErrorCodeTranslator</span> <span class="keyword">extends</span> <span class="title">SQLErrorCodeSQLExceptionTranslator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DataAccessException customTranslate</span><br><span class="line">      (String task, String sql, SQLException sqlException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlException.getErrorCode() == -<span class="number">104</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DuplicateKeyException(<span class="string">"完整性约束冲突"</span>, sqlException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十四、Spring IoC注解实现]]></title>
      <url>http://chaooo.github.io/2019/08/27/14-SpringIoC%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0.html</url>
      <content type="html"><![CDATA[<ol>
<li><a href="#id1">回顾xml方式管理Java Bean</a></li>
<li><a href="#id2">注解方式管理Java Bean</a></li>
<li><a href="#id3">注解方式Bean的注入</a></li>
<li><a href="#id4">注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-回顾xml方式管理Java-Bean"><a href="#1-回顾xml方式管理Java-Bean" class="headerlink" title="1. 回顾xml方式管理Java Bean"></a>1. 回顾xml方式管理Java Bean</h3><ol>
<li>将一个Bean交由Spring创建并管理<ul>
<li><code>&lt;baen id=&quot;bean&quot; class=&quot;包名.Bean&quot;&gt;&lt;/baen&gt;</code></li>
</ul>
</li>
<li>获取Spring上下文<ul>
<li><code>ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></li>
</ul>
</li>
<li>获取Bean<ul>
<li><code>Bean bean = app.getBean(&quot;bean&quot;, Bean.class);</code></li>
</ul>
</li>
</ol>
<p><span id="id2"><span></span></span></p>
<h3 id="2-注解方式管理Java-Bean"><a href="#2-注解方式管理Java-Bean" class="headerlink" title="2. 注解方式管理Java Bean"></a>2. 注解方式管理Java Bean</h3><p>一、创建一个class配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="comment">//将一个Bean交由Spring创建并管理</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean <span class="title">bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean = <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、获取Spring上下文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = </span><br><span class="line">    <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfiguration.class);</span><br></pre></td></tr></table></figure>

<p>三、获取Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bean1 bean1 = context.getBean(<span class="string">"bean1"</span>, Bean1.class);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-简化注解方式的步骤1"><a href="#2-1-简化注解方式的步骤1" class="headerlink" title="2.1 简化注解方式的步骤1"></a>2.1 简化注解方式的步骤1</h4><p>一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//该注解可理解当前class等同于一个xml文件</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>) <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在applicationContext.xml中开启组件扫描方式<code>&lt;context:component-scan base-package=&quot;包路径&quot;/&gt;</code>。</p>
</blockquote>
<p>二、 将交由Spring管理的类加上<code>@Component</code>注解，或（<code>@Repository</code>，<code>@Controller</code>，<code>@Service</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"bean1"</span>)<span class="comment">//通过构造方法实例化Bean1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 </p>
<ul>
<li>@Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 </li>
<li>@Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 </li>
<li>@Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 </li>
</ul>
</blockquote>
<h4 id="2-2-Bean别名"><a href="#2-2-Bean别名" class="headerlink" title="2.2 Bean别名"></a>2.2 Bean别名</h4><p>一、 xml形式：通过name属性或alias标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">name</span>=<span class="string">"bean2,bean3"</span> <span class="attr">class</span>=<span class="string">"com...Bean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"bean1"</span> <span class="attr">alias</span>=<span class="string">"bean4"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>二、 注解形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=&#123;<span class="string">"bean1"</span>,<span class="string">"bean2"</span>,<span class="string">"bean3"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：@Component只能指定一个名字，@Component默认值为<strong>类名首字母小写</strong>，也可以自定义，如:<code>@Component(&quot;bean1&quot;)</code>； 默认@scope为singleton单例，也可以进行指定</p>
</blockquote>
<p><span id="id3"><span></span></span></p>
<h3 id="3-注解方式Bean的注入"><a href="#3-注解方式Bean的注入" class="headerlink" title="3. 注解方式Bean的注入"></a>3. 注解方式Bean的注入</h3><p>一、 <strong><code>@Value(&quot;值&quot;)</code></strong>：常用于基本数据类型值注入，<code>值</code>可用EL表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、 <strong><code>@Autowired</code></strong>：常用于复杂类型值的注入<br>    + <code>@Autowired</code>：可以用在<strong>成员变量</strong>，<strong>setter方法</strong>，<strong>构造方法</strong>上；优先按照类型进行匹配，匹配不上启用名字进行匹配。<br>    + <code>@Qualifier(&quot;名字&quot;)</code> 根据名字匹配，配合@Autowired，<strong>不能用在构造方法上</strong>；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，<code>@Autowired(required=false)</code>:尽量去找，组件不存在也不报错。<br>    + @Autowired的<strong>原理</strong>：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于成员变量 */</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//@Qualifier("card1")</span></span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于构造方法 */</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于setter方法 */</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCard</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、 <strong><code>@Resource</code></strong>：常用于复杂类型值的注入<br>    + @Resource：用在<strong>成员变量</strong>和<strong>setter方法</strong>上，是<strong>JDK</strong>1.6支持的注解，优先按照名字匹配，可以通过<code>@Resource(name=&quot;名&quot;)</code>指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"card"</span>)</span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合类型值注入实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"aaa"</span>);</span><br><span class="line">        list.add(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id4"><span></span></span></p>
<h3 id="4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等"><a href="#4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等" class="headerlink" title="4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)"></a>4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</h3><h4 id="4-1-注解方式Bean的作用域"><a href="#4-1-注解方式Bean的作用域" class="headerlink" title="4.1 注解方式Bean的作用域"></a>4.1 注解方式Bean的作用域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-注解方式Bean的懒加载"><a href="#4-2-注解方式Bean的懒加载" class="headerlink" title="4.2 注解方式Bean的懒加载"></a>4.2 注解方式Bean的懒加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="meta">@Lazy</span> <span class="comment">//相当于xml中default-lazy-init="true"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="meta">@Lazy</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-Bean初始化和销毁"><a href="#4-3-Bean初始化和销毁" class="headerlink" title="4.3 Bean初始化和销毁"></a>4.3 Bean初始化和销毁</h4><p>一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、xml形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"example.Bean"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">init-method</span>=<span class="string">"init"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>三、注解形式1，@Bean(initMethod=”init”, destroyMethod=”cleanup”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"cleanup"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean <span class="title">bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、注解形式2，添加@PostConstruct，@PreDestroy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十三、Spring基础和IoC控制反转]]></title>
      <url>http://chaooo.github.io/2019/08/27/13-Spring%E5%9F%BA%E7%A1%80%E5%92%8CIoC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC.html</url>
      <content type="html"><![CDATA[<p>Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。</p>
<ul>
<li>IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础<a id="more"></a></li>
<li>DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装</li>
<li>WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持</li>
<li>AOP：是在面向对象的基础上发展来的更高级的技术</li>
<li>ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库</li>
<li>JEE：Java的消息服务，远程调用，邮件服务等</li>
</ul>
<ol>
<li><a href="#id1">IoC（控制反转）</a></li>
<li><a href="#id2">Spring容器初始化</a></li>
<li><a href="#id3">spring容器创建对象(实例化)</a></li>
<li><a href="#id4">Spring DI注入的实现</a></li>
<li><a href="#id5">DI的参数的注入</a></li>
<li><a href="#id6">Bean的常用配置项(作用域,生命周期,懒加载等)</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-IoC（控制反转）"><a href="#1-IoC（控制反转）" class="headerlink" title="1. IoC（控制反转）"></a>1. IoC（控制反转）</h3><p><strong>IoC</strong>：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。</p>
<ol>
<li>控制：控制对象的创建及销毁（生命周期）</li>
<li>反转：将对象的控制权交给IoC容器</li>
</ol>
<p><strong>DI</strong>：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。</p>
<ul>
<li>简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入</li>
</ul>
<blockquote>
<p>IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。</p>
</blockquote>
<p><span id="id2"><span></span></span></p>
<h3 id="2-Spring容器初始化"><a href="#2-Spring容器初始化" class="headerlink" title="2. Spring容器初始化"></a>2. Spring容器初始化</h3><p>任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext</p>
<ul>
<li>BeanFactory提供配置结构和基本功能，加载并初始化Bean</li>
<li>ApplicationContext保存了Bean对象并在Spring中被广泛使用</li>
</ul>
<h4 id="2-1-初始化ApplicationContext的几种方式："><a href="#2-1-初始化ApplicationContext的几种方式：" class="headerlink" title="2.1 初始化ApplicationContext的几种方式："></a>2.1 初始化ApplicationContext的几种方式：</h4><ol>
<li><p>本地文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileSystemXmlApplicationContext app = </span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"F:/workspace/appcontext.xml"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Classpath</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext app = </span><br><span class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classath:applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Web应用中依赖Servlet或Listener</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-2-Spring容器完成IOC的步骤"><a href="#2-2-Spring容器完成IOC的步骤" class="headerlink" title="2.2 Spring容器完成IOC的步骤"></a>2.2 Spring容器完成IOC的步骤</h4><ol>
<li>建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下</li>
<li>在spring容器配置文件中配置文件中配置一个对象的创建<ul>
<li><code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li>
</ul>
</li>
<li>写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件<ul>
<li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code></li>
</ul>
</li>
</ol>
<p><span id="id3"><span></span></span></p>
<h3 id="3-spring容器创建对象-实例化"><a href="#3-spring容器创建对象-实例化" class="headerlink" title="3. spring容器创建对象(实例化)"></a>3. spring容器创建对象(实例化)</h3><h4 id="3-1-构造器方式实例化"><a href="#3-1-构造器方式实例化" class="headerlink" title="3.1 构造器方式实例化"></a>3.1 构造器方式实例化</h4><ul>
<li>配置文件：<code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li>
<li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code>默认调用类型对应的无参构造方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Date date = app.getBean(<span class="string">"date"</span>, Date.class);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-静态工厂方法实例化"><a href="#3-2-静态工厂方法实例化" class="headerlink" title="3.2 静态工厂方法实例化"></a>3.2 静态工厂方法实例化</h4><ul>
<li>使用一个类型对应的静态方法来获取这个类型的对象</li>
<li><code>&lt;bean id=&quot;对象引用名&quot; class=&quot;包名.工厂类名&quot; factory-method=&quot;静态方法名&quot;&gt;&lt;/bean&gt;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cal"</span> <span class="attr">class</span>=<span class="string">"java.util.Calendar"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Calendar cal = app.getBean(<span class="string">"cal"</span>, Calendar.class);</span><br></pre></td></tr></table></figure>

<h4 id="3-3-实例工厂方法实例化"><a href="#3-3-实例工厂方法实例化" class="headerlink" title="3.3 实例工厂方法实例化"></a>3.3 实例工厂方法实例化</h4><ul>
<li>使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象</li>
<li><code>&lt;bean id=&quot;对象的引用名&quot; factory-bean=&quot;工厂方法的id&quot; factory-method=&quot;成员方法名&quot;&gt;&lt;/bean&gt;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cal"</span> <span class="attr">class</span>=<span class="string">"java.util.Calendar"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"time"</span> <span class="attr">factory-bean</span>=<span class="string">"cal"</span> <span class="attr">factory-method</span>=<span class="string">"getTime"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Date time = app.getBean(<span class="string">"time"</span>, Date.class);</span><br></pre></td></tr></table></figure>

<p><span id="id4"><span></span></span></p>
<h3 id="4-Spring-DI注入的实现"><a href="#4-Spring-DI注入的实现" class="headerlink" title="4. Spring DI注入的实现"></a>4. Spring DI注入的实现</h3><p>Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。<br>Bean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。<br>DI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配)</p>
<ul>
<li>实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。</li>
</ul>
<h4 id="4-1-设值注入"><a href="#4-1-设值注入" class="headerlink" title="4.1 设值注入"></a>4.1 设值注入</h4><p>property(属性)的name参考对象set方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"黑桃"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"A"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player参考其setCard方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"玩家1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span> <span class="attr">ref</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-构造注入（Constructor-arguments）"><a href="#4-2-构造注入（Constructor-arguments）" class="headerlink" title="4.2 构造注入（Constructor arguments）"></a>4.2 构造注入（Constructor arguments）</h4><p>构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card2"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"红桃"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"K"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player参考其构造方法Player(name,card) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player2"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"玩家2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"card"</span> <span class="attr">ref</span>=<span class="string">"card2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-自动化注入（Autowiring-mode）"><a href="#4-3-自动化注入（Autowiring-mode）" class="headerlink" title="4.3 自动化注入（Autowiring mode）"></a>4.3 自动化注入（Autowiring mode）</h4><p>一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire=”byName/byType/constructor”)指定对应的自动化的注入方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">autowire</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>自动装配autowire</strong>属性 有五种自动装配的方式：</p>
<ul>
<li><p>No：默认，需要通过<code>ref</code>属性来连接bean。</p>
</li>
<li><p><strong>byName</strong>： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card3"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应)</span></span><br><span class="line"><span class="comment">    否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player3"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>byType</strong>：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player4"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>constructor</strong>：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card5"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player5"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"constructor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>autodetect</strong>：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</p>
</li>
</ul>
<p><span id="id5"><span></span></span></p>
<h3 id="5-DI的参数的注入"><a href="#5-DI的参数的注入" class="headerlink" title="5. DI的参数的注入"></a>5. DI的参数的注入</h3><p>Bean对象 注入类型 可以是 字符串、集合、bean对象。</p>
<h4 id="5-1-注入字符串"><a href="#5-1-注入字符串" class="headerlink" title="5.1 注入字符串"></a>5.1 注入字符串</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"msg"</span> <span class="attr">class</span>=<span class="string">"com.xdl.bean.OracleDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"scott"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>tiger<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-注入集合"><a href="#5-2-注入集合" class="headerlink" title="5.2 注入集合"></a>5.2 注入集合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"friends"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"friends2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546454"</span> <span class="attr">value</span>=<span class="string">"值1"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546464"</span> <span class="attr">value</span>=<span class="string">"值2"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. props集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164545564"</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164546756"</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-集合参数的单独定义"><a href="#5-3-集合参数的单独定义" class="headerlink" title="5.3 集合参数的单独定义"></a>5.3 集合参数的单独定义</h4><p>注入集合–引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"ref_friends"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:set</span> <span class="attr">id</span>=<span class="string">"ref_buddys"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:set</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">"ref_phones"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"159454644"</span> <span class="attr">value</span>=<span class="string">"值1"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546454"</span> <span class="attr">value</span>=<span class="string">"值2"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. props集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"ref_phonePro"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164545564"</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"16454675665564"</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"ref_db"</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones"</span> <span class="attr">ref</span>=<span class="string">"ref_phones"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones2"</span> <span class="attr">ref</span>=<span class="string">"ref_phonePro"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-Spring的’EL’表达式"><a href="#5-3-Spring的’EL’表达式" class="headerlink" title="5.3 Spring的’EL’表达式"></a>5.3 Spring的’EL’表达式</h4><p>它和EL在语法上很 相似，可以读取一个bean对象/集合中的数据。<br>Spring EL 采用 #{Sp Expression Language} 即 <code>#{spring表达式}</code>，可在xml配置和注解中使用。</p>
<ul>
<li>Spring EL配置连接池对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"db"</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.xdl.bean.OracleDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.name&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><span id="id6"><span></span></span></p>
<h3 id="6-Bean的常用配置项-作用域-生命周期-懒加载等"><a href="#6-Bean的常用配置项-作用域-生命周期-懒加载等" class="headerlink" title="6. Bean的常用配置项(作用域,生命周期,懒加载等)"></a>6. Bean的常用配置项(作用域,生命周期,懒加载等)</h3><p>Bean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization/destruction method</p>
<h4 id="6-1-Bean作用域（Scope）"><a href="#6-1-Bean作用域（Scope）" class="headerlink" title="6.1 Bean作用域（Scope）"></a>6.1 Bean作用域（Scope）</h4><ol>
<li>Singleton作用域<ul>
<li>单例，指一个Bean容器只存在一份</li>
</ul>
</li>
<li>prototype作用域<ul>
<li>每次请求(使用)创建新的实例，destroy方式不生效</li>
</ul>
</li>
<li>Web环境作用域：<ul>
<li>request作用域：每个request请求都会创建一个单独的实例。</li>
<li>session作用域：每个session都会创建一个单独的实例。</li>
<li>application作用域：每个servletContext都会创建一个单独的实例。</li>
<li>websocket作用域：每个websocket连接都会创建一个单独的实例。</li>
</ul>
</li>
<li>自定义作用域<ul>
<li>SimpleThreadScope作用域：每个线程都会创建一个单独的实例。</li>
</ul>
</li>
</ol>
<h4 id="6-2-Bean的生命周期（Initialization-destruction-method）"><a href="#6-2-Bean的生命周期（Initialization-destruction-method）" class="headerlink" title="6.2 Bean的生命周期（Initialization/destruction method）"></a>6.2 Bean的生命周期（Initialization/destruction method）</h4><p>Bean的生命周期：定义 –&gt; 初始化 –&gt; 使用 –&gt; 销毁</p>
<h5 id="6-2-1-Bean初始化"><a href="#6-2-1-Bean初始化" class="headerlink" title="6.2.1 Bean初始化"></a>6.2.1 Bean初始化</h5><p>如果需要在Bean实例化之后执行一些逻辑，有两种方法：</p>
<ul>
<li>实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。</li>
<li><strong>配置init-method</strong><ul>
<li>配置<strong><code>beans</code></strong>的<code>default-init-method</code>属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。</li>
<li>配置<strong><code>bean</code></strong>的<code>init-method</code>来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleId"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-2-Bean销毁"><a href="#6-2-2-Bean销毁" class="headerlink" title="6.2.2 Bean销毁"></a>6.2.2 Bean销毁</h5><p>如果需要在Bean销毁之前执行一些逻辑，有两种方法：</p>
<ul>
<li>实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。</li>
<li><strong>配置destroy-method</strong><ul>
<li>配置<strong><code>beans</code></strong>的<code>default-destroy-method</code>属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。</li>
<li>配置<strong><code>bean</code></strong>的<code>destroy-method</code>来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleId"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：销毁方法只针对单例模式的对象</p>
</blockquote>
<h4 id="6-3-Bean的懒加载（Lazy-initialization-mode）"><a href="#6-3-Bean的懒加载（Lazy-initialization-mode）" class="headerlink" title="6.3 Bean的懒加载（Lazy-initialization mode）"></a>6.3 Bean的懒加载（Lazy-initialization mode）</h4><p>Spring容器会在创建容器时提前初始化<code>Singleton作用域</code>的bean，可以通过bean标记<code>lazy-init=&quot;true&quot;</code>延迟实例化(对象被使用时才创建)。</p>
<ul>
<li><p><strong>配置lazy-init</strong></p>
<ul>
<li>配置<strong><code>beans</code></strong>的<code>default-lazy-init=&quot;true&quot;</code>为所有Bean设定懒加载。</li>
<li>配置<strong><code>bean</code></strong>的<code>lazy-init=&quot;true&quot;</code>为单独的某个Bean设定懒加载。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载</p>
<ul>
<li>优点：尽可能的节约了资源</li>
<li>缺点：可能导致某个操作响应时间增加</li>
</ul>
</li>
</ul>
<h4 id="6-4-Bean装配的Aware接口"><a href="#6-4-Bean装配的Aware接口" class="headerlink" title="6.4 Bean装配的Aware接口"></a>6.4 Bean装配的Aware接口</h4><p>实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。</p>
<ol>
<li>ApplicationContextAware<ul>
<li>接口方法：setApplicationContext</li>
<li>作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li>
<li>实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li>
</ul>
</li>
<li>BeanNameAware<ul>
<li>接口方法：setBeanName</li>
<li>作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li>
<li>实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li>
</ul>
</li>
</ol>
<h4 id="6-4-Bean装配之Resource"><a href="#6-4-Bean装配之Resource" class="headerlink" title="6.4 Bean装配之Resource"></a>6.4 Bean装配之Resource</h4><p><strong>Resources</strong>（针对于资源文件的统一接口）</p>
<ol>
<li>UrlResource：URL 对应的资源，根据一个 URL 地址即可获取</li>
<li>ClassPathResource：获取类路径下的资源</li>
<li>FileSystemResource：获取文件系统里面的资源</li>
<li>ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源</li>
<li>InputStreamResource：获取输入流封装的资源</li>
<li>ByteArrayResource：获取字节数组封装的资源</li>
</ol>
<p>ResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。</p>
<ul>
<li>getResource()参数：<ul>
<li>classPath方式：”classPath:class路径下文件”</li>
<li>file方式： “file:本地磁盘文件绝对地址”</li>
<li>url方式： “url:URL地址下文件”</li>
<li>没有前缀时依赖applicationContext的配置文件路径: “文件全名”</li>
</ul>
</li>
<li>eg:<code>applicationContext.getResource(&quot;classpath:config.txt&quot;)</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库系统基础]]></title>
      <url>http://chaooo.github.io/2019/07/22/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.html</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>数据库 是 电子化信息的集合<ul>
<li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li>
</ul>
</li>
<li>表(Table)：以按行按列形式组织及展现的数据<a id="more"></a>
<ul>
<li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li>
</ul>
</li>
<li>数据库系统的构成（概念层次）:<ol>
<li>数据库(DB):Database：相互之间有关联关系的数据的集合</li>
<li>数据库管理系统(DBMS):Database Management System</li>
<li>数据库应用(DBAP):Database Application</li>
<li>数据库管理员(DBA):Database Asministrator</li>
<li>计算机基本系统</li>
</ol>
</li>
</ol>
<h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol>
<li><a href="#id1">数据库管理系统(DBMS)</a></li>
<li><a href="#id2">数据库系统的标准结构</a></li>
<li><a href="#id3">三级模式两层映像</a></li>
<li><a href="#id4">数据模型</a></li>
<li><a href="#id5">关系模型</a></li>
<li><a href="#id6">关系模型中的完整性</a></li>
<li><a href="#id7">关系代数</a></li>
<li><a href="#id8">关系演算</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-数据库管理系统-DBMS"><a href="#1-数据库管理系统-DBMS" class="headerlink" title="1. 数据库管理系统(DBMS)"></a>1. 数据库管理系统(DBMS)</h3><h4 id="1-1-从用户角度看DBMS-数据库管理系统"><a href="#1-1-从用户角度看DBMS-数据库管理系统" class="headerlink" title="1.1 从用户角度看DBMS(数据库管理系统)"></a>1.1 从用户角度看DBMS(数据库管理系统)</h4><ol>
<li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等<ul>
<li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li>
<li>用户使用DDL描述其所要建立的表的格式</li>
<li>DBMS依照用户的定义，创建数据库及其中的表</li>
</ul>
</li>
<li>数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等<ul>
<li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li>
<li>用户使用DML描述其所要进行的增、删、改、查等操作</li>
<li>DBMS依照用户的操作描述，实际执行这些操作</li>
</ul>
</li>
<li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)<ul>
<li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li>
<li>用户使用DCL描述其对数据库所要实施的控制</li>
<li>DBMS依照用户描述，实际ijnx控制</li>
</ul>
</li>
<li>数据库维护：转储/恢复/重组/性能监测/分析…<ul>
<li>DBMS提供了一系列程序(实用程序/例行程序)给用户</li>
<li>在这些程序中提供了对数据库维护的各种功能</li>
<li>用户使用这些程序进行各种数据库维护操作</li>
<li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li>
</ul>
</li>
</ol>
<h4 id="1-2-数据库语言"><a href="#1-2-数据库语言" class="headerlink" title="1.2 数据库语言"></a>1.2 数据库语言</h4><ul>
<li>使用者使用数据库语言，利用DBMS操纵数据库</li>
<li>SQL语言：结构化的数据库语言</li>
<li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li>
</ul>
<h4 id="1-3-从系统实现角度看DBMS的功能"><a href="#1-3-从系统实现角度看DBMS的功能" class="headerlink" title="1.3 从系统实现角度看DBMS的功能"></a>1.3 从系统实现角度看DBMS的功能</h4><ol>
<li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li>
<li>DBMS为完成DB管理，在后台运行着一系列程序…<ul>
<li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li>
<li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li>
<li><strong>数据存取与索引</strong>：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等</li>
<li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li>
<li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li>
<li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li>
<li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li>
<li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li>
<li><strong>数据字典管理</strong>：管理用户已经定义的信息</li>
<li><strong>应用程序接口(API)</strong>：提供应用程序使用DBMS特定功能的二首段</li>
<li><strong>数据库数据装载、重组等实用程序</strong></li>
<li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li>
</ul>
</li>
</ol>
<blockquote>
<p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p>
</blockquote>
<p><span id="id2"><span></span></span></p>
<h3 id="2-数据库系统的标准结构"><a href="#2-数据库系统的标准结构" class="headerlink" title="2. 数据库系统的标准结构"></a>2. 数据库系统的标准结构</h3><p>DBMS管理数据的三个层次：</p>
<ol>
<li>External Level = User Level（外部级别 = 用户级别）<ul>
<li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li>
</ul>
</li>
<li>Conceptual Level = Logic level（概念级别 = 逻辑级别）<ul>
<li>从全局角度理解/管理的数据, 含相应的关联约束</li>
</ul>
</li>
<li>Internal Level = Physical level（内部级别 = 物理级别）<ul>
<li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li>
</ul>
</li>
</ol>
<p><span id="id3"><span></span></span></p>
<h3 id="3-三级模式两层映像"><a href="#3-三级模式两层映像" class="headerlink" title="3. 三级模式两层映像"></a>3. 三级模式两层映像</h3><p>数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成</p>
<ul>
<li>应用–&gt; 外模式(多个) –&gt; 模式(一个) –&gt; 内模式(一个) –&gt; 数据库</li>
</ul>
<h4 id="3-1-数据-视图-与模式-数据的结构"><a href="#3-1-数据-视图-与模式-数据的结构" class="headerlink" title="3.1 数据(视图)与模式(数据的结构)"></a>3.1 数据(视图)与模式(数据的结构)</h4><ul>
<li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li>
<li>视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据</li>
</ul>
<h4 id="3-2-三级模式-三级视图"><a href="#3-2-三级模式-三级视图" class="headerlink" title="3.2 三级模式(三级视图)"></a>3.2 三级模式(三级视图)</h4><ol>
<li>External Schema —-(External) View<ul>
<li>外模式：某一用户能够看到与处理的数据的结构描述</li>
</ul>
</li>
<li>(Conceptual) Schema —- Conceptual View<ul>
<li>模式(概念模式)：从全局角度理解/管理的数据的结构描述, 含相应的关联约束</li>
<li>体现在数据之间的内在本质联系</li>
</ul>
</li>
<li>Internal Schema —- Internal  View<ul>
<li>内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li>
</ul>
</li>
</ol>
<h4 id="3-3-两层映像"><a href="#3-3-两层映像" class="headerlink" title="3.3 两层映像"></a>3.3 两层映像</h4><ol>
<li>E-C Mapping：External Schema-Conceptual Schema Mapping <ul>
<li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li>
<li>便于用户观察和使用</li>
</ul>
</li>
<li>C-I Mapping：Conceptual Schema-Internal Schema Mapping <ul>
<li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li>
<li>便于计算机进行存储和处理</li>
</ul>
</li>
</ol>
<h4 id="3-4-标准结构的两个独立性"><a href="#3-4-标准结构的两个独立性" class="headerlink" title="3.4 标准结构的两个独立性"></a>3.4 标准结构的两个独立性</h4><ol>
<li>逻辑数据独立性<ul>
<li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li>
</ul>
</li>
<li>物理数据独立性<ul>
<li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li>
</ul>
</li>
</ol>
<p><span id="id4"><span></span></span></p>
<h3 id="4-数据模型"><a href="#4-数据模型" class="headerlink" title="4. 数据模型"></a>4. 数据模型</h3><ol>
<li>数据模型：模式 与 模式的结构<ul>
<li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li>
<li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li>
<li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li>
</ul>
</li>
<li>三大经典数据模型<ul>
<li>关系模型：<strong>表</strong>的形式组织数据</li>
<li>层次模型：<strong>树</strong>的形式组织数据</li>
<li>网状模型：<strong>图</strong>的形式组织数据</li>
</ul>
</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-关系模型"><a href="#5-关系模型" class="headerlink" title="5. 关系模型"></a>5. 关系模型</h3><ol>
<li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：<ul>
<li>描述DB各种数据的基本结构形式(Table/Relation)</li>
<li>描述Table与Table之间所可能发生的各种操作(关系运算)</li>
<li>描述这些操作所应遵循的约束条件(完整性约束)</li>
</ul>
</li>
<li>关系模型的三个要素：<ul>
<li>基本结构：Relation/Table</li>
<li>基本操作：Relation Operator<ul>
<li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li>
<li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li>
</ul>
</li>
<li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li>
</ul>
</li>
<li>表(Table)的基本构成要素<ul>
<li>列/字段/属性/数据项：列名，列值</li>
<li>行/元组/记录</li>
<li>标题/模式</li>
</ul>
</li>
</ol>
<h4 id="5-1-“表”的严格定义"><a href="#5-1-“表”的严格定义" class="headerlink" title="5.1 “表”的严格定义"></a>5.1 “表”的严格定义</h4><ul>
<li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li>
<li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li>
<li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li>
</ul>
<h4 id="5-2-关系模式与关系"><a href="#5-2-关系模式与关系" class="headerlink" title="5.2 关系模式与关系"></a>5.2 关系模式与关系</h4><ul>
<li>同一关系模式下，可有很多的关系</li>
<li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li>
<li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li>
</ul>
<h4 id="5-3-关系的特性"><a href="#5-3-关系的特性" class="headerlink" title="5.3 关系的特性"></a>5.3 关系的特性</h4><ul>
<li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li>
<li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li>
<li>列位置互换性：区分哪一列是靠列名</li>
<li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)</li>
<li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li>
<li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li>
<li>属性不可再分特性:又被称为关系第一范式</li>
</ul>
<h4 id="5-4-关系的一些重要概念"><a href="#5-4-关系的一些重要概念" class="headerlink" title="5.4 关系的一些重要概念"></a>5.4 关系的一些重要概念</h4><ol>
<li>候选码(Candidate Key)/候选键<ul>
<li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li>
</ul>
</li>
<li>主码(Primary Key)/主键<ul>
<li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li>
</ul>
</li>
<li>主属性与非主属性<ul>
<li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li>
<li>最简单的，候选码只包含一个属性；</li>
<li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li>
</ul>
</li>
<li>外码(Foreign Key)/外键<ul>
<li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li>
<li>两个关系通常是靠外码连接起来的。</li>
</ul>
</li>
</ol>
<p><span id="id6"><span></span></span></p>
<h3 id="6-关系模型中的完整性"><a href="#6-关系模型中的完整性" class="headerlink" title="6. 关系模型中的完整性"></a>6. 关系模型中的完整性</h3><h4 id="6-1-实体完整性"><a href="#6-1-实体完整性" class="headerlink" title="6.1 实体完整性"></a>6.1 实体完整性</h4><ul>
<li>关系的主码中的属性值不能为空值；</li>
<li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li>
</ul>
<h4 id="6-2-参照完整性"><a href="#6-2-参照完整性" class="headerlink" title="6.2 参照完整性"></a>6.2 参照完整性</h4><ul>
<li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li>
<li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li>
</ul>
<h4 id="6-3-用户自定义完整性"><a href="#6-3-用户自定义完整性" class="headerlink" title="6.3 用户自定义完整性"></a>6.3 用户自定义完整性</h4><ul>
<li>用户针对具体的应用环境定义的完整性约束条件</li>
</ul>
<h4 id="6-4-DBMS对关系完整性的支持"><a href="#6-4-DBMS对关系完整性的支持" class="headerlink" title="6.4 DBMS对关系完整性的支持"></a>6.4 DBMS对关系完整性的支持</h4><ul>
<li>实体完整性和参照完整性由DBMS系统自动支持</li>
<li>DBMS系统通常提供了如下机制：<ol>
<li>它使用户可以自行定义有关的完整性约束条件</li>
<li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li>
</ol>
</li>
</ul>
<p><span id="id7"><span></span></span></p>
<h3 id="7-关系代数"><a href="#7-关系代数" class="headerlink" title="7. 关系代数"></a>7. 关系代数</h3><h4 id="7-1-关系代数的特点"><a href="#7-1-关系代数的特点" class="headerlink" title="7.1 关系代数的特点"></a>7.1 关系代数的特点</h4><ul>
<li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li>
<li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li>
<li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li>
<li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li>
<li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li>
</ul>
<h4 id="7-2-关系代数的约束"><a href="#7-2-关系代数的约束" class="headerlink" title="7.2 关系代数的约束"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p>
<ul>
<li>并相容性：<ol>
<li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li>
<li>定义：关系R与关系S存在相容性，当且仅当：<ul>
<li>(1) 关系R和关系S的属性数目必须相同；</li>
<li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li>
</ul>
</li>
</ol>
<ul>
<li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>
<li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>
</ul>
</li>
</ul>
<h4 id="7-3-关系代数的基本操作"><a href="#7-3-关系代数的基本操作" class="headerlink" title="7.3 关系代数的基本操作"></a>7.3 关系代数的基本操作</h4><ol>
<li>集合操作<ul>
<li>并（UNIO）：R∪S</li>
<li>交（INTERSECTION）：R∩S</li>
<li>差（DIFFERENCE）：R-S</li>
<li>笛卡儿积（Cartesian PRODUCT）：R×S</li>
</ul>
</li>
<li>纯关系操作<ul>
<li>选择（SELECT）：σF(R)</li>
<li>投影（PROJECT）：ΠA(R)</li>
<li>连接（JOIN）：R⋈S</li>
<li>除（DIVISION）：R÷S</li>
</ul>
</li>
</ol>
<h5 id="7-3-1-并-Union-操作"><a href="#7-3-1-并-Union-操作" class="headerlink" title="7.3.1 并(Union) 操作"></a>7.3.1 并(Union) 操作</h5><ul>
<li>定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：<strong><code>R∪S</code></strong>, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li>
<li>数学描述：<code>R∪S={t|t∈R∨t∈S}</code>，其中t是元组</li>
<li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li>
<li>汉语中的“或者…或者…”通常意义是并运算的要求。</li>
<li><code>R∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li>
</ul>
<h5 id="7-3-2-差-Difference-操作"><a href="#7-3-2-差-Difference-操作" class="headerlink" title="7.3.2 差(Difference) 操作"></a>7.3.2 差(Difference) 操作</h5><ul>
<li>定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：<strong><code>R-S</code></strong>, 它由出现在关系R中但不出现在关系S中的元组构成。</li>
<li>数学描述：<code>R－S={t|t∈R∧t∉S}</code>，其中t是元组</li>
<li>汉语中的“是…但不含…”通常意义是差运算的要求。</li>
<li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li>
</ul>
<h5 id="7-3-3-交（Intersection-Referential-integrity）-操作"><a href="#7-3-3-交（Intersection-Referential-integrity）-操作" class="headerlink" title="7.3.3  交（Intersection Referential integrity） 操作"></a>7.3.3  交（Intersection Referential integrity） 操作</h5><ul>
<li>定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。</li>
<li>数学描述：<code>R∩S={t|t∈R∧t∈S}</code>，其中t是元组</li>
</ul>
<h5 id="7-3-4-广义笛卡尔积-Extended-cartesian-product-操作"><a href="#7-3-4-广义笛卡尔积-Extended-cartesian-product-操作" class="headerlink" title="7.3.4 广义笛卡尔积(Extended cartesian product) 操作"></a>7.3.4 广义笛卡尔积(Extended cartesian product) 操作</h5><ul>
<li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：<strong><code>RxS</code></strong>；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。</li>
<li>数学描述：<code>RxS = {&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S}</code></li>
<li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li>
<li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li>
<li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).</li>
</ul>
<h5 id="7-3-5-选择-Select"><a href="#7-3-5-选择-Select" class="headerlink" title="7.3.5 选择(Select)"></a>7.3.5 选择(Select)</h5><ul>
<li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作<strong><code>σF(R)</code></strong>, 它从关系R中选择出满足给定条件condition的元组构成。</li>
<li>数学描述：<code>σF(R) = {t|t∈R ∧ F(t)=&#39;真&#39;}</code>,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。</li>
<li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；¬；∧；∨</code> }</li>
</ul>
<h5 id="7-3-6-投影-Project"><a href="#7-3-6-投影-Project" class="headerlink" title="7.3.6 投影(Project)"></a>7.3.6 投影(Project)</h5><ul>
<li>定义：给定一个关系R, 投影运算结果也是一个关系，记作<strong><code>A(R)</code></strong>, 它从关系R中选出属性包含在A中的列构成。</li>
<li>数学描述：<code>ΠA(R) = {t[A] | t∈R}</code>,其中A为R中的属性列</li>
<li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li>
</ul>
<h4 id="7-4-关系代数的扩展操作"><a href="#7-4-关系代数的扩展操作" class="headerlink" title="7.4 关系代数的扩展操作"></a>7.4 关系代数的扩展操作</h4><h5 id="7-4-1-交-Intersection"><a href="#7-4-1-交-Intersection" class="headerlink" title="7.4.1 交(Intersection)"></a>7.4.1 交(Intersection)</h5><ul>
<li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：<strong><code>R∩S</code></strong>, 它由同时出现在关系R和关系S中的元组构成。</li>
<li>数学描述：<code>R∩S = {t|t∈R ∧ t∈S}</code>，其中t是元组</li>
<li>R∩S 和 S∩R 运算的结果是同一个关系</li>
<li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li>
<li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li>
</ul>
<h5 id="7-4-2-θ-连接-θ-Join-theta-Join"><a href="#7-4-2-θ-连接-θ-Join-theta-Join" class="headerlink" title="7.4.2 θ-连接(θ-Join, theta-Join)"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul>
<li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li>
<li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 <strong><code>R⋈S[AθB]</code></strong>：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li>
<li>数学描述：<code>R⋈S[AθB] = σ t[A]θs[B] (R×S)</code>，σF(RxS)其中t是R中的元组，s是S中的元组</li>
<li>在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用</li>
<li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li>
</ul>
<h5 id="7-4-3-等值连接-Equi-Join"><a href="#7-4-3-等值连接-Equi-Join" class="headerlink" title="7.4.3 等值连接(Equi-Join)"></a>7.4.3 等值连接(Equi-Join)</h5><ul>
<li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作<strong><code>R⋈S[A=B]</code></strong>：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li>
<li>数学描述：<code>R⋈S[A=B] = σ t[A]=s[B] (R×S)</code></li>
<li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li>
<li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接/等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li>
</ul>
<h5 id="7-4-4-自然连接-Natural-Join"><a href="#7-4-4-自然连接-Natural-Join" class="headerlink" title="7.4.4 自然连接(Natural-Join)"></a>7.4.4 自然连接(Natural-Join)</h5><ul>
<li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li>
<li>数学描述：<code>R⋈S = σ t[B]=s[B] (R×S)</code></li>
<li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li>
</ul>
<h4 id="7-5-关系代数的基本书写思路"><a href="#7-5-关系代数的基本书写思路" class="headerlink" title="7.5 关系代数的基本书写思路"></a>7.5 关系代数的基本书写思路</h4><ol>
<li>选出将用到的关系/表</li>
<li>做”积”运算（可用连接运算替换）</li>
<li>做选择运算保留所需的行/元组</li>
<li>做投影运算保留所需的列/属性</li>
</ol>
<ul>
<li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li>
<li>如涉及多个表，则检查：<ul>
<li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li>
<li>如不能，能否使用等值或不等值连接(θ-连接)</li>
<li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li>
</ul>
</li>
<li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li>
</ul>
<h4 id="7-6-关系代数之复杂扩展操作"><a href="#7-6-关系代数之复杂扩展操作" class="headerlink" title="7.6 关系代数之复杂扩展操作"></a>7.6 关系代数之复杂扩展操作</h4><h5 id="7-6-1-除-Division"><a href="#7-6-1-除-Division" class="headerlink" title="7.6.1 除(Division)"></a>7.6.1 除(Division)</h5><ul>
<li>除法运算经常用于求解“查询… 全部的/所有的…”问题</li>
<li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li>
<li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li>
<li>数学描述：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R÷S = &#123;t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) &#125;</span><br><span class="line">    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>其中[R-S]为投影Π的下标(属性)</p>
</blockquote>
<h5 id="7-6-2-外连接-Outer-Join"><a href="#7-6-2-外连接-Outer-Join" class="headerlink" title="7.6.2 外连接(Outer-Join)"></a>7.6.2 外连接(Outer-Join)</h5><ul>
<li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li>
<li>外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li>
<li>外连接的形式：左外连接、右外连接、全外连接<ul>
<li>左外连接 = 自然连接(或连接) + 左侧表中失配的元组</li>
<li>右外连接 = 自然连接(或连接) + 右侧表中失配的元组</li>
<li>全外连接 = 自然连接(或连接) + 两侧表中失配的元组</li>
<li>左外连接(Left Outer Join)记为：⋊</li>
<li>右外连接(Right Outer Join)记为：⋉</li>
<li>全外连接(Full Outer Join)记为：⋊⋉</li>
</ul>
</li>
</ul>
<p><span id="id8"><span></span></span></p>
<h3 id="8-关系演算"><a href="#8-关系演算" class="headerlink" title="8. 关系演算"></a>8. 关系演算</h3><p>关系演算是<strong>描述关系运算</strong>的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</p>
<ul>
<li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ol>
<li>关系元组演算是以<strong>元组变量</strong>作为谓词变量的基本对象</li>
<li>关系域演算是以<strong>域变量</strong>作为谓词变量的基本对象</li>
</ol>
</li>
</ul>
<h4 id="8-1-关系元组演算"><a href="#8-1-关系元组演算" class="headerlink" title="8.1 关系元组演算"></a>8.1 关系元组演算</h4><ol>
<li>关系元组演算公式：{ t | P(t) }<ul>
<li>表示：所有使谓词 P 为真的元组 t 的集合</li>
<li>t 是元组变量</li>
<li>t ∈ r 表示元组 t 在关系 r 中</li>
<li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li>
<li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li>
</ul>
</li>
<li>关系元组演算公式的基本形式：{ t | P(t) }</li>
<li>P(t)可以是如下三种形式之一的原子公式：<ul>
<li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li>
<li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=</li>
<li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li>
</ul>
</li>
<li>P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造<ul>
<li>如果F是一个公式，则 ¬F 也是公式</li>
<li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li>
</ul>
</li>
<li>P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例</li>
<li>构造P(t)还有两个运算符：∃(存在)、∀(任意)<ul>
<li>如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式</li>
<li>如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式</li>
<li>运算符∃和∀，又称为量词，前者称“<strong>存在量词</strong>”，后者称“<strong>全称量词</strong>”</li>
<li>而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“<strong>约束变量</strong>”，否则被称为“<strong>自由变量</strong>”。</li>
</ul>
</li>
<li>元组演算的等价性变换<ul>
<li>符号<code>&lt;=&gt;</code>表示表示等价于,如：<code>¬(A&gt;B) &lt;=&gt; A&lt;=B  &lt;=&gt; A&lt;B∨A=B</code></li>
</ul>
</li>
</ol>
<h4 id="8-2-关系域演算"><a href="#8-2-关系域演算" class="headerlink" title="8.2 关系域演算"></a>8.2 关系域演算</h4><ol>
<li>关系域演算公式的基本形式：<code>{&lt;x1,x2, …,xn&gt; | P(x1,x2, …,xn)}</code>,其中 xi 代表域变量或常量, P为以xi为变量的公式。</li>
<li>元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；</li>
<li>域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。</li>
<li>公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。</li>
<li>元组演算和域演算可以等价互换。</li>
</ol>
<h5 id="8-2-1-基于关系域演算的QBE语言"><a href="#8-2-1-基于关系域演算的QBE语言" class="headerlink" title="8.2.1 基于关系域演算的QBE语言"></a>8.2.1 基于关系域演算的QBE语言</h5><p>QBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。</p>
<ol>
<li>特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可</li>
<li>QBE操作框架由四个部分构成<ul>
<li>关系名区：用于书写欲待查询的关系名</li>
<li>属性名区：用于显示对应关系名区关系的所有属性名</li>
<li>操作命令区：用于书写查询操作的命令</li>
<li>查询条件区：用于书写查询条件</li>
</ul>
</li>
<li>QBE的操作命令<ul>
<li>Print 或 P.   —- 显示输出操作</li>
<li>Delete或D.   —- 删除操作</li>
<li>Insert或I.     —- 插入操作</li>
<li>Update或U. —- 更新操作</li>
</ul>
</li>
<li>构造查询的几个要素 <ul>
<li>示例元素: 即域变量， 一定要加下划线 </li>
<li>示例元素是这个域中可能的一个值， 它不必是查询结果中的元素</li>
<li>打印操作符P.: 指定查询结果所含属性列 </li>
<li>查询条件: 不用加下划线</li>
<li>可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略</li>
<li>排序要求 <ul>
<li>升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="8-3-安全性"><a href="#8-3-安全性" class="headerlink" title="8.3 安全性"></a>8.3 安全性</h4><p>关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的</p>
<ol>
<li>关系代数是一种集合运算，是安全的<ul>
<li>集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。</li>
</ul>
</li>
<li>关系演算不一定是安全的<ul>
<li>如：{t|¬(R(t))}, {t R(t)∨t[2]&gt;3}可能表示无限关系</li>
</ul>
</li>
<li>需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。</li>
</ol>
<h5 id="8-3-1-安全约束有限集合DOM"><a href="#8-3-1-安全约束有限集合DOM" class="headerlink" title="8.3.1 安全约束有限集合DOM"></a>8.3.1 安全约束有限集合DOM</h5><ol>
<li>DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。</li>
<li>DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。</li>
<li>安全元组演算表达式，满足三个条件：<ul>
<li>只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。<ul>
<li>{ t|ψ(t) }中t的取值只能是DOM中的值，有限的。</li>
</ul>
</li>
<li>对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。<ul>
<li>{ t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。</li>
</ul>
</li>
<li>对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。<ul>
<li>{ t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="8-4-关于三种关系运算的一些观点"><a href="#8-4-关于三种关系运算的一些观点" class="headerlink" title="8.4 关于三种关系运算的一些观点"></a>8.4 关于三种关系运算的一些观点</h4><ol>
<li>关系运算有三种：关系代数、关系元组演算和关系域演算</li>
<li>三种关系运算都是抽象的数学运算，体现了三种不同的思维<ul>
<li>关系代数—以集合为对象的操作思维，由集合到集合的变换</li>
<li>元组演算—以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环</li>
<li>域演算—以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件</li>
</ul>
</li>
<li>三种运算之间是等价的<ul>
<li>关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等<br>价的。即一种形式的表达式可以被等价地转换为另一种形式</li>
</ul>
</li>
<li>三种关系运算都可说是非过程性的<ul>
<li>相比之下：域演算的非过程性最好，元组演算次之，关系代数最差</li>
</ul>
</li>
<li>三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础<ul>
<li>一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的</li>
<li>目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等</li>
</ul>
</li>
<li>数据库语言可以基于这三种抽象运算来设计<ul>
<li>用“键盘符号”来替换抽象的数学符号</li>
<li>用易于理解的符号组合来表达抽象的数学符号</li>
<li>例如：ISBL语言—基于关系代数的数据库语言</li>
<li>再例如：Ingres系统的QUEL语言</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数据库系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十二、JavaWeb编程基础]]></title>
      <url>http://chaooo.github.io/2019/07/20/12_JavaWeb%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html</url>
      <content type="html"><![CDATA[<p>JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">http协议</a></li>
<li><a href="#id2">Servlet</a></li>
<li><a href="#id3">请求的转发与重定向</a></li>
<li><a href="#id4">上下文对象ServletContext</a></li>
<li><a href="#id5">会话跟踪（状态管理）</a></li>
<li><a href="#id6">JSP</a></li>
<li><a href="#id7">内置对象(隐含对象)</a></li>
<li><a href="#id8">taglib指令</a></li>
<li><a href="#id9">JavaWeb三大组件</a></li>
<li><a href="#id10">JSON在Java中的使用</a></li>
<li><a href="#id11">AJAX</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-http协议"><a href="#1-http协议" class="headerlink" title="1. http协议"></a>1. http协议</h3><p>超文本传输协议，是一种应用层的网络传输协议</p>
<ul>
<li>http协议的特点：<ol>
<li>简单，快速：支持多种不同的的数据提交方式，如get/post</li>
<li>数据传输灵活，支持任意类型数据的传输</li>
<li>无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。</li>
<li>无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。</li>
</ol>
</li>
<li>http协议的组成部分：<ol>
<li>请求：浏览器连接服务器的过程</li>
<li>响应：服务器回复浏览器的过程</li>
</ol>
</li>
<li>http协议的请求：<ol>
<li>请求头：描述客户端的信息</li>
<li>请求体：GET没有请求体，请求体用于存储POST请求发送的数据。</li>
<li>请求空行：请求头与请求体之间的一行空白</li>
<li>请求行：描述请求方式，服务器地址，协议版本等</li>
</ol>
</li>
<li>http协议的响应：<ol>
<li>响应头：描述服务器的信息</li>
<li>响应体：响应的内容，文本，json数据等。</li>
<li>响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。</li>
</ol>
</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-Servlet"><a href="#2-Servlet" class="headerlink" title="2. Servlet"></a>2. Servlet</h3><p>servlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。</p>
<h4 id="2-1-Servlet编写步骤："><a href="#2-1-Servlet编写步骤：" class="headerlink" title="2.1 Servlet编写步骤："></a>2.1 Servlet编写步骤：</h4><ol>
<li>编写一个Java类，继承HttpServlet类</li>
<li>重新service方法</li>
<li>在service方法中，对用户请求进行响应。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解：添加访问的网址</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1.设置响应体的编码，以及内容类型</span></span><br><span class="line">		res.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">		<span class="comment">//2.得到响应体输出的打印流</span></span><br><span class="line">		PrintWriter out = res.getWriter();</span><br><span class="line">		<span class="comment">//3.打印文字</span></span><br><span class="line">		out.println(<span class="string">"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-配置ervlet类的访问网址"><a href="#2-2-配置ervlet类的访问网址" class="headerlink" title="2.2 配置ervlet类的访问网址"></a>2.2 配置ervlet类的访问网址</h4><ul>
<li>web3.0版本之后使用注解的方式配置ervlet类的访问网址</li>
<li>web3.0版本之前配置Servlet访问网址的方式：<ul>
<li>将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 </li>
<li>配置Servlet类的别名，并给指定别名的Servlet添加映射网址。</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Servlet类别名，用于后续添加映射网址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Servlet类全名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>day01_Servlet.demo1.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 给指定别名的Servlet添加映射网址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-Servlet生命周期"><a href="#2-3-Servlet生命周期" class="headerlink" title="2.3 Servlet生命周期"></a>2.3 Servlet生命周期</h4><ul>
<li>实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用</li>
<li>创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。</li>
<li>销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。</li>
<li>tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：<ul>
<li>init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。</li>
<li>service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。</li>
<li>destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。</li>
</ul>
</li>
</ul>
<h4 id="2-4-get和post区别"><a href="#2-4-get和post区别" class="headerlink" title="2.4 get和post区别"></a>2.4 get和post区别</h4><ul>
<li>GET请求：<ul>
<li>没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&amp;连接键值对。</li>
<li>只能传输字符串类型参数</li>
<li>浏览器url地址最大长度4kb</li>
<li>数据传输时，参数在url中明文显示，不安全。</li>
</ul>
</li>
<li>POST请求：<ul>
<li>有请求体，是一个单独的数据包，用于存储请求中的多个参数</li>
<li>可传输任意类型的数据，进行文件上传必须POST请求</li>
<li>可以传递的数据大小，理论上没有上限</li>
<li>数据传输时在单独的数据包，较为安全。</li>
</ul>
</li>
</ul>
<h4 id="2-5-接收请求中的参数"><a href="#2-5-接收请求中的参数" class="headerlink" title="2.5 接收请求中的参数"></a>2.5 接收请求中的参数</h4><ol>
<li>根据参数的名称，接收参数的单个值<ul>
<li>String value = <strong>request.getParameter(String name)</strong>;</li>
</ul>
</li>
<li>根据参数的名称，接收一组参数的值<ul>
<li>String[] values = <strong>request.getParameterValues(String name)</strong>;</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">  response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">  <span class="comment">//1.接收</span></span><br><span class="line">  String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">  String[] password = request.getParameterValues(<span class="string">"password"</span>);</span><br><span class="line">  <span class="comment">//2.打印</span></span><br><span class="line">  System.out.println(<span class="string">"username:"</span> + username);</span><br><span class="line">  System.out.println(<span class="string">"password:"</span> + password[<span class="number">0</span>]);</span><br><span class="line">  System.out.println(<span class="string">"password2:"</span> + password[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">//3.浏览器输出</span></span><br><span class="line">  response.getWriter().append(<span class="string">"&lt;div&gt;很遗憾注册失败，点击&lt;a href=\"demo1.html\"&gt;重新注册&lt;/a&gt;&lt;/div&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-乱码处理"><a href="#2-6-乱码处理" class="headerlink" title="2.6 乱码处理"></a>2.6 乱码处理</h4><h4 id="2-6-1-乱码情况："><a href="#2-6-1-乱码情况：" class="headerlink" title="2.6.1 乱码情况："></a>2.6.1 乱码情况：</h4><ul>
<li>浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。</li>
<li>tomcat8版本之前(不包含tomcat8版本), GET请求乱码</li>
<li>任何版本, POST请求乱码</li>
</ul>
<h4 id="2-6-2-请求乱码处理："><a href="#2-6-2-请求乱码处理：" class="headerlink" title="2.6.2 请求乱码处理："></a>2.6.2 请求乱码处理：</h4><ul>
<li>适用于所有乱码问题：(Tomcat8之后get无乱码)<ol>
<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>
<li>将接收到的中文乱码重新编码：</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">String userName = <span class="keyword">new</span> String( name.getByte(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>仅适用于POST请求：<ol>
<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>
<li>Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li>
</ol>
</li>
</ul>
<h4 id="2-6-3-响应乱码的处理："><a href="#2-6-3-响应乱码的处理：" class="headerlink" title="2.6.3 响应乱码的处理："></a>2.6.3 响应乱码的处理：</h4><ul>
<li>方式一：设置响应的内容类型, 以及编码格式:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>;</li>
<li>方式二：进设置编码格式, 不设置响应内容类型:<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code>(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);</li>
</ul>
<h4 id="2-7-Servlet的创建时机"><a href="#2-7-Servlet的创建时机" class="headerlink" title="2.7 Servlet的创建时机"></a>2.7 Servlet的创建时机</h4><ul>
<li>通过web.xml配置Servlet, 可以修改Servlet加载的时机。</li>
<li>可以给Servlet节点，添加<code>&lt;load-on-startup&gt;</code>节点来制定servlet启动顺序。</li>
<li>节点中的值为数字：<ul>
<li><code>-1</code>：默认-1，表示当用户第一次请求时，创建对象</li>
<li><code>&gt;=0</code>：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>demo.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span id="id3"><span></span></span></p>
<h3 id="3-请求的转发与重定向"><a href="#3-请求的转发与重定向" class="headerlink" title="3. 请求的转发与重定向"></a>3. 请求的转发与重定向</h3><h4 id="3-1-请求对象request的常用操作"><a href="#3-1-请求对象request的常用操作" class="headerlink" title="3.1 请求对象request的常用操作"></a>3.1 请求对象request的常用操作</h4><ol>
<li>getMethod() : 得到请求的方式</li>
<li>getRequestURI() : 获取浏览器请求地址</li>
<li>getRemoteAddr() : 获取客户端ip地址</li>
<li>getRemoteHost() : 获取客户端名称</li>
<li>getServerName() : 获取服务器名称</li>
<li>getServerPort() : 获取服务器端口号</li>
<li>getQueryString() : 获取get请求参数字符串，其他请求返回null</li>
</ol>
<h4 id="3-1-请求的转发与重定向注意事项"><a href="#3-1-请求的转发与重定向注意事项" class="headerlink" title="3.1 请求的转发与重定向注意事项"></a>3.1 请求的转发与重定向注意事项</h4><ul>
<li>请求转发与重定向操作，必须要有出口。</li>
<li>当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了</li>
</ul>
<h4 id="3-2-转发"><a href="#3-2-转发" class="headerlink" title="3.2 转发*"></a>3.2 转发*</h4><ul>
<li>一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理</li>
<li>步骤：<ol>
<li>获取请求转发器：<code>RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;);</code></li>
<li>进行转发操作：<code>rd.forward(request, response);</code></li>
</ol>
</li>
<li>因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:<ul>
<li><code>request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response);</code></li>
</ul>
</li>
<li>特点：<ul>
<li>转发过程中，多个web组件之间共享一个请求对象request与响应对象response</li>
<li>在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变</li>
<li>转发不能跨项目实现</li>
<li>比重定向效率更高</li>
</ul>
</li>
</ul>
<h4 id="3-3-重定向"><a href="#3-3-重定向" class="headerlink" title="3.3 重定向*"></a>3.3 重定向*</h4><ul>
<li>一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址</li>
<li>格式：<code>response.sendRedirect(&quot;重定向地址&quot;)</code>；</li>
<li>原理：当客户端请求服务器时，发起重定向流程：<ol>
<li>给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.</li>
<li>当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.</li>
<li>浏览器自动发起新的请求 , 跳转到新地址.</li>
</ol>
</li>
<li>特点：<ol>
<li>重定向会产生两个请求对象，多个请求对象中数据不互通</li>
<li>浏览器地址发生了改变</li>
<li>重定向可以跨域实现</li>
<li>比转发效率低</li>
</ol>
</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-上下文对象ServletContext"><a href="#4-上下文对象ServletContext" class="headerlink" title="4. 上下文对象ServletContext"></a>4. 上下文对象ServletContext</h3><ul>
<li>用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享</li>
<li>每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。</li>
</ul>
<p>获取ServletContext对象：<code>ServletContext context = getServletContext();</code></p>
<ul>
<li>常用方法<ul>
<li>context.setAttributes(String key, Objexct value); //设置替换数据</li>
<li>context.getAttributes(String key); //获取数据</li>
<li>context.removeAttributes(String key); //删除数据</li>
<li>context.getRealPath(“/“); //获取项目运行时所在文件路径</li>
</ul>
</li>
</ul>
<p><span id="id5"><span></span></span></p>
<h3 id="5-会话跟踪（状态管理）"><a href="#5-会话跟踪（状态管理）" class="headerlink" title="5. 会话跟踪（状态管理）"></a>5. 会话跟踪（状态管理）</h3><ul>
<li><p>存在两种实现：</p>
<ol>
<li>cookie: 将浏览器产生的状态存储在浏览器中</li>
<li>Session: 将浏览器产生的状态存储在服务器中</li>
</ol>
</li>
<li><p>cookie技术原理：</p>
<ul>
<li>服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，</li>
<li>浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来</li>
<li>当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器</li>
</ul>
</li>
<li><p>Session技术原理：</p>
<ul>
<li>当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，</li>
<li>该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器</li>
<li>浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。</li>
</ul>
</li>
</ul>
<h4 id="5-1-Cookie"><a href="#5-1-Cookie" class="headerlink" title="5.1 Cookie"></a>5.1 Cookie</h4><ul>
<li>创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对<ul>
<li><code>Cookie cookie = new Cookie(String key, String value);</code></li>
<li>注意：tomcat8.5版本之前，cookie无法出场中文</li>
</ul>
</li>
<li>通过响应对象，将cookie添加到响应头,可添加多个<ul>
<li><strong>response.addCookie(Cookie cookie)</strong>;</li>
</ul>
</li>
<li>通过请求头得到cookie数组，没有则返回null<ul>
<li><strong>Cookie[] cookies = request.getCookies()</strong>;</li>
<li>取键：cookie.getName();</li>
<li>取值：cookie.getValue()</li>
</ul>
</li>
<li>Cookie的存储时长：<ul>
<li>cookie.setMaxAge(int 秒)；<ul>
<li>正数：倒计时秒数</li>
<li>0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它</li>
<li>负数：默认-1，表示会话结束时自动删除（关闭浏览器）</li>
</ul>
</li>
</ul>
</li>
<li>Cookie的存储路径问题<ul>
<li>存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同</li>
<li>为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“/“);</li>
</ul>
</li>
</ul>
<h4 id="5-2-Cookie的优缺点"><a href="#5-2-Cookie的优缺点" class="headerlink" title="5.2 Cookie的优缺点"></a>5.2 Cookie的优缺点</h4><ul>
<li>缺点：<ol>
<li>Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。</li>
<li>数据存储在客户的计算机中，不安全，不建议存储安全敏感数据</li>
<li>保存数据量有限制，大约4kb左右</li>
<li>依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除</li>
</ol>
</li>
<li>优点：<ol>
<li>分散服务器的压力</li>
</ol>
</li>
</ul>
<h4 id="5-3-Session"><a href="#5-3-Session" class="headerlink" title="5.3 Session"></a>5.3 Session</h4><ul>
<li>获取Session<ul>
<li>格式1：<strong>request.getSession()</strong>;//等价参数传true</li>
<li>格式2：request.getSession(boolean isNew);<ul>
<li>true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回</li>
<li>false，根据浏览器的SessionId查找一个session，若没有就返回null</li>
</ul>
</li>
</ul>
</li>
<li>Session常用方法<ul>
<li><strong>session.setAttribute(String key, object value)</strong>;//设置/替换值</li>
<li><strong>session.getAttribute(String key)</strong>;//获取值</li>
<li>session.invalidate();//销毁</li>
</ul>
</li>
<li>设置session存活时长<ul>
<li>默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。</li>
<li>可以通过修改配置文件，修改所有的session时长<ul>
<li>修改<code>conf/web.xml</code>的<code>&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt;</code></li>
</ul>
</li>
<li>可以通过session对象，修改单个对象的session时长<ul>
<li>void session.setMaxInactiveInterval(int seconds)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-4-Session的优缺点"><a href="#5-4-Session的优缺点" class="headerlink" title="5.4 Session的优缺点"></a>5.4 Session的优缺点</h4><ul>
<li>缺点：<ul>
<li>数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源</li>
</ul>
</li>
<li>优点：<ol>
<li>数据存储在服务器中，安全</li>
<li>数据类型为Object，在Java中表示可以存储所有类型的数据</li>
<li>session存储的数据大小，理论上无限的。</li>
</ol>
</li>
</ul>
<h4 id="5-5-Cookie和Session的使用"><a href="#5-5-Cookie和Session的使用" class="headerlink" title="5.5 Cookie和Session的使用"></a>5.5 Cookie和Session的使用</h4><ul>
<li>Cookie和Session不是互斥的，是相辅相成的</li>
<li>在项目开发时：<ul>
<li>对安全敏感的数据，存储在session中</li>
<li>对安全不敏感的字符串数据，可以选择存储在Cookie中</li>
<li>对于大的数据，应该存在数据库和文件中</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：cookie和session是为了管理状态而非存储数据。</p>
</blockquote>
<p><span id="id6"><span></span></span></p>
<h3 id="6-JSP"><a href="#6-JSP" class="headerlink" title="6.JSP"></a>6.JSP</h3><h4 id="6-1-JSP语法基础"><a href="#6-1-JSP语法基础" class="headerlink" title="6.1 JSP语法基础"></a>6.1 JSP语法基础</h4><ul>
<li><p>Java Server Pages：java动态网页技术</p>
</li>
<li><p>JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应</p>
</li>
<li><p>注意：</p>
<ol>
<li>JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet</li>
<li>执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html</li>
</ol>
</li>
<li><p>JSP语法结构</p>
<ol>
<li>html代码</li>
<li>Java代码</li>
<li>Jsp特有的语法结构</li>
</ol>
</li>
<li><p>Java代码声明区：指的是类的成员位置</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">  <span class="comment">// Java代码声明区</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  <span class="comment">// Java代码执行区</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>JSP输出表达式<ul>
<li>用于快速的将Java中的数据，输出到网页中..</li>
<li>语法格式：<code>&lt;%=数据 %&gt;</code>，编译后被转换成out.print(数据)</li>
</ul>
</li>
<li>JSP注释：<ul>
<li>html中可以用<code>&lt;!-- --&gt;</code></li>
<li>java中可以用<code>//，/**/，/** */</code></li>
<li>jsp注释<code>&lt;%-- --%&gt;</code><ul>
<li>html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-2-JSP三大指令"><a href="#6-2-JSP三大指令" class="headerlink" title="6.2 JSP三大指令"></a>6.2 JSP三大指令</h4><ul>
<li>page指令</li>
<li>include指令</li>
<li>taglib指令</li>
</ul>
<ul>
<li>指令使用格式：&lt;%@ 指令名称 属性1=值 属性2=值 属性n=值 %&gt;<br>*语法上，JSP允许在单个页面出现多个相同的JSP指令</li>
</ul>
<h5 id="6-2-1-page指令"><a href="#6-2-1-page指令" class="headerlink" title="6.2.1 page指令"></a>6.2.1 page指令</h5><ul>
<li>用于配置页面信息</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page</span><br><span class="line">  language=<span class="string">"java"</span>：语言</span><br><span class="line">  contentType=<span class="string">"text/html;charset=utf-8"</span>：响应的内容类型，以及响应的编码格式</span><br><span class="line">  pageEncoding=<span class="string">"UTF-8"</span>：文件存储的编码格式</span><br><span class="line">  extends=<span class="string">"继承的父类"</span></span><br><span class="line">  buffer=<span class="string">"数字/none"</span>：是否允许缓存，默认值<span class="number">8</span>kb</span><br><span class="line">  autoFlush=<span class="string">"true/false"</span>：是否自动清除缓存，默认<span class="keyword">true</span></span><br><span class="line">  session=<span class="string">"true/false"</span>：是否提前准备session对象，默认<span class="keyword">true</span></span><br><span class="line">  isThreadSafe=<span class="string">"true/false"</span>：是否线程安全的</span><br><span class="line">  <span class="keyword">import</span>=<span class="string">"java.util.List"</span>：用于导包，多个包使用<span class="string">","</span>隔开</span><br><span class="line">  errorPage=<span class="string">"网址"</span>：当页面发生BUG后，显示哪个页面</span><br><span class="line">  isErrorPage=<span class="string">"true/false"</span>：当前页面是否是一个错误处理页面，如果结果为<span class="keyword">true</span>，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-项目发生错误时，统一的处理方式"><a href="#6-3-项目发生错误时，统一的处理方式" class="headerlink" title="6.3 项目发生错误时，统一的处理方式"></a>6.3 项目发生错误时，统一的处理方式</h4><ol>
<li>打开项目的web.xml</li>
<li>加入子节点<code>&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt;</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>include指令：用于将jsp或html引入到另一个jsp中<ul>
<li>语法格式：<code>&lt;%@ include file=&quot;地址&quot; %&gt;</code></li>
</ul>
</li>
<li>include动作：用于将jsp或html引入到另一个jsp中<ul>
<li>语法格式：<code>&lt;jsp:include page=&quot;地址&quot;&gt;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>include指令 与 include动作区别：</p>
<ul>
<li>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp =&gt; 一个Servlet）</li>
<li>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp =&gt; 多个Servlet）</li>
</ul>
</blockquote>
<p><span id="id7"><span></span></span></p>
<h3 id="7-内置对象-隐含对象"><a href="#7-内置对象-隐含对象" class="headerlink" title="7.内置对象(隐含对象)"></a>7.内置对象(隐含对象)</h3><ul>
<li>在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。</li>
<li>内置对象通常是我们会主动创建的对象</li>
</ul>
<h4 id="7-1-九大内置对象"><a href="#7-1-九大内置对象" class="headerlink" title="7.1 九大内置对象"></a>7.1 九大内置对象</h4><ol>
<li>request<ul>
<li>对象类型：java.servlet.<strong>HttpServletRequest</strong></li>
<li>request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。</li>
</ul>
</li>
<li>response<ul>
<li>对象类型：javax.servlet.<strong>HttpServletResponse</strong></li>
<li>response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。</li>
</ul>
</li>
<li>config<ul>
<li>对象类型：javax.servlet.<strong>ServletConfig</strong></li>
<li>在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。</li>
</ul>
</li>
<li>out<ul>
<li>对象类型：javax.servlet.jsp.<strong>JspWriter</strong></li>
<li>在JSP开发过程中使用得最为频繁的对象</li>
</ul>
</li>
<li>page<ul>
<li>对象类型：java.lang.<strong>Object</strong></li>
<li>page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。</li>
</ul>
</li>
<li>pageContext<ul>
<li>对象类型：<strong>pageContext</strong></li>
<li>pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</li>
</ul>
</li>
<li>session<ul>
<li>对象类型：java.servlet.http.<strong>HttpSession</strong></li>
<li>session是与请求有关的会话期，用来表示和存储当前页面的请求信息。</li>
</ul>
</li>
<li>application<ul>
<li>对象类型：javax.servlet.<strong>ServletContext</strong></li>
<li>用于实现用户之间的数据共享（多使用于网络聊天系统）。</li>
</ul>
</li>
<li>exception<ul>
<li>对象类型：java.lang.<strong>Throwable</strong></li>
<li>作用 exception内置对象是用来处理页面出现的异常错误。</li>
</ul>
</li>
</ol>
<h4 id="7-2-JSP四大域对象"><a href="#7-2-JSP四大域对象" class="headerlink" title="7.2 JSP四大域对象"></a>7.2 JSP四大域对象</h4><ul>
<li>九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据</li>
<li>域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法：<ol>
<li>存储数据：setAttribute(String key, Object value);</li>
<li>获取数据：Object value = getAttribute(String);</li>
<li>删除数据： removeAttribute(String key);</li>
</ol>
</li>
<li>四大内置对象，分别指的是：<ol>
<li>pageContext: (作用域：1个页面)<ul>
<li>页面上下文，存储在pageContext中的数据, 作用域是最小的,  pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁.</li>
</ul>
</li>
<li>request: (作用域：一次请求，如果请求被转发，可能跨越多个页面)<ul>
<li>请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁.</li>
</ul>
</li>
<li>session: (作用域：一次会话，一次会话可能包含多个请求)<ul>
<li>会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。</li>
</ul>
</li>
<li>application: (域范围：一次服务，应用从启动到关闭application一直都在)<ul>
<li>Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="7-3-EL表达式"><a href="#7-3-EL表达式" class="headerlink" title="7.3 EL表达式"></a>7.3 EL表达式</h4><ul>
<li>用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。</li>
<li>格式：<code>${表达式}</code></li>
<li>EL表达式用于运算<ul>
<li>在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是:   246 </li>
</ul>
</li>
<li>用于取出域对象中的数据<ul>
<li>取出数据直接输出：<code>${域对象中存储的键}</code></li>
<li>如果取出的数据不存在, 则不输出 (不可能显示null)</li>
</ul>
</li>
<li>取出对象数据的属性值:<ul>
<li>格式1： ${对象存储的键.属性名}</li>
<li>格式2： ${对象存储的键[“属性名”]}</li>
<li>格式3(动态取值)： ${对象存储的键[属性存储的键]}</li>
</ul>
</li>
<li>取出集合中的数据<ul>
<li>格式: ${集合存储时的key[下标]}</li>
</ul>
</li>
</ul>
<h4 id="7-4-EL表达式取出数据的流程"><a href="#7-4-EL表达式取出数据的流程" class="headerlink" title="7.4 EL表达式取出数据的流程"></a>7.4 EL表达式取出数据的流程</h4><ul>
<li>四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据.</li>
<li>步骤:<ol>
<li>先从pageContext中, 寻找数据是否存在.</li>
<li>如果pageContext中数据不存在, 则去request中寻找数据是否存在</li>
<li>如果request 中数据不存在, 则去session中寻找数据是否存在</li>
<li>如果session中数据不存在, 则去application中寻找数据是否存在</li>
<li>如果application中数据不存在,则不输出任何数据.</li>
</ol>
</li>
</ul>
<p><span id="id8"><span></span></span></p>
<h3 id="8-taglib指令"><a href="#8-taglib指令" class="headerlink" title="8. taglib指令"></a>8. taglib指令</h3><p>用于在JSP文件中，引入标签库文件。</p>
<ul>
<li>格式： <code>&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt;</code><ul>
<li>prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：<code>&lt;标签库名称:标签名&gt;</code></li>
<li>uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性</li>
</ul>
</li>
<li>JSTL(JSP Standard Tag Library): JSP标准标签库<ul>
<li>使用时，需要引入jar文件</li>
<li>if 标签，格式：&lt;库名称:if text=”${ booble }”&gt;</li>
<li>forEach 标签，格式：&lt;库名称:forEach items=”${ List }” var=”item”&gt;</li>
</ul>
</li>
<li>自定义标签库:<ol>
<li>编写一个Java类, 继承SimpleTagSupport类.</li>
<li>重写父类的doTag方法.</li>
<li>在doTag方法中, 通过getJspContext方法,  的到JSP页面的上下文</li>
<li>通过上下文对象, 得到JSP中的out对象, </li>
<li>通过out对象,  向网页中输出内容</li>
<li>编写tld文件 , 描述标签库 以及 标签.</li>
</ol>
</li>
</ul>
<p>自定义标签库案例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTag1</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ArrayList&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        data.add(<span class="string">"流水在碰到底处时才会释放活力。——歌德"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">        JspContext context = getJspContext();</span><br><span class="line">        JspWriter out = context.getOut();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> index = r.nextInt(data.size());</span><br><span class="line">        out.println(<span class="string">"&lt;span&gt;"</span>+data.get(index)+<span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述标签库 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是对于标签库的介绍 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>我们这个标签库, 是闲的慌 , 所以写的.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述标签库的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>xdl<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签库的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>11.88<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 建议的短命名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>xdl<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签库的表示, 用于引入时匹配标签库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://shuidianshuisg.com<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开始描述标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对于标签的介绍 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>这个标签用于随机向网页中, 输出一句名言<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>heiheihei<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签所对应的的Java类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.xdl.tag.MyTag1<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签的内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span id="id9"><span></span></span></p>
<h3 id="9-JavaWeb三大组件-Servlet-filter-Lister"><a href="#9-JavaWeb三大组件-Servlet-filter-Lister" class="headerlink" title="9. JavaWeb三大组件(Servlet,filter,Lister)"></a>9. JavaWeb三大组件(Servlet,filter,Lister)</h3><h4 id="9-1-Filter过滤器"><a href="#9-1-Filter过滤器" class="headerlink" title="9.1 Filter过滤器"></a>9.1 Filter过滤器</h4><ul>
<li>请求的过滤器，面向切面编程思想（AOP）</li>
<li>使用步骤：<ol>
<li>编写一个类，实现Filter接口</li>
<li>通过注解或web.xml配置过滤器规则</li>
</ol>
</li>
<li>过滤器链：<ul>
<li>当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求</li>
</ul>
</li>
<li>过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml）<ul>
<li>注解方式：按照类名的自然顺序先后</li>
<li>web.xml配置方式：按照web.xml配置顺序，先后执行</li>
</ul>
</li>
<li>案例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/home.jsp"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Filter即将销毁时执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有新的请求, 满足了过滤器的过滤规则,  正在过滤</span></span><br><span class="line"><span class="comment">     * 参数1.   请求对象</span></span><br><span class="line"><span class="comment">     * 参数2. 响应对象</span></span><br><span class="line"><span class="comment">     * 参数3.  过滤器链对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"过滤管理员登录的过滤器 正在执行"</span>);</span><br><span class="line">        <span class="comment">//1.    从请求中, 得到session</span></span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="comment">//2.    判断session中是否存在username</span></span><br><span class="line">        Object username = session.getAttribute(<span class="string">"username"</span>);</span><br><span class="line">        <span class="comment">//3.    如果存在, 且值为admin , 则放行 </span></span><br><span class="line">        <span class="keyword">if</span>(username !=<span class="keyword">null</span> &amp;&amp; username.equals(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4.    否则拦截, 并响应, 提示请先以管理员身份登录</span></span><br><span class="line">            response.getWriter().append(<span class="string">"&lt;script&gt;alert('请先以管理员身份登录, 再访问管理页面');window.location.href='login.jsp'&lt;/script&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Filter初始化时 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>web.xml配置方式</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.xdl.demo1.EnCodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/home.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="9-2-Listener监听器"><a href="#9-2-Listener监听器" class="headerlink" title="9.2 Listener监听器"></a>9.2 Listener监听器</h4><ul>
<li>监听服务器的一些状态事件，事件驱动机制。</li>
<li>分为两类状态事件：<ul>
<li>服务器中组件的生命周期</li>
<li>一些域对象中数据变化的事件</li>
</ul>
</li>
<li>监听服务器的启动与关闭：ServletContextListener</li>
<li>监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener</li>
<li>监听Session会话的开启与关闭：HttpSessionListener </li>
<li>监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener </li>
</ul>
<p><span id="id10"><span></span></span></p>
<h3 id="10-JSON在Java中的使用"><a href="#10-JSON在Java中的使用" class="headerlink" title="10. JSON在Java中的使用"></a>10. JSON在Java中的使用</h3><ul>
<li>JSON：JavaScript Object Notation</li>
<li>GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入jar文件</span></span><br><span class="line">Gson g = <span class="keyword">new</span> Gson();</span><br><span class="line">String str = g.toJson(Java对象);<span class="comment">//转换JSON字符串</span></span><br><span class="line">类型 对象名 = g.fromJson(Json字符串, 类型.class);<span class="comment">//转换为Java对象</span></span><br></pre></td></tr></table></figure>

<p><span id="id11"><span></span></span></p>
<h3 id="11-AJAX"><a href="#11-AJAX" class="headerlink" title="11. AJAX"></a>11. AJAX</h3><ul>
<li>一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作</li>
<li>Ajax请求的状态（readyState）<ul>
<li>0：正在初始化</li>
<li>1：请求正在发送</li>
<li>2：请求发送完毕</li>
<li>3：服务器开始响应</li>
<li>4：响应接收完毕，连接断开</li>
</ul>
</li>
<li>Ajax响应的状态（status）<ul>
<li>200：成功</li>
<li>404：找不到资源</li>
<li>500：服务器错误</li>
</ul>
</li>
</ul>
<h4 id="11-1-GET请求AJAX"><a href="#11-1-GET请求AJAX" class="headerlink" title="11.1 GET请求AJAX"></a>11.1 GET请求AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"地址?参数列表"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//通过xhr.responseText接收响应体</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//失败处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<h4 id="11-2-POST请求AJAX"><a href="#11-2-POST请求AJAX" class="headerlink" title="11.2 POST请求AJAX"></a>11.2 POST请求AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"地址"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//通过xhr.responseText接收响应体</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//失败处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//POST请求设置请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>); </span><br><span class="line">xhr.send(参数列表); <span class="comment">//发送请求参数</span></span><br></pre></td></tr></table></figure>

<h4 id="11-2-Jquery中的AJAX"><a href="#11-2-Jquery中的AJAX" class="headerlink" title="11.2 Jquery中的AJAX"></a>11.2 Jquery中的AJAX</h4><ol>
<li><code>$.ajax({url,[settings]})</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"请求的网址"</span>,</span><br><span class="line">    type:<span class="string">"请求方式GET/POST..."</span>,</span><br><span class="line">    <span class="keyword">async</span>:<span class="string">"请求是否异步, 默认true"</span>,</span><br><span class="line">    data:<span class="string">"请求的参数列表, 格式与GET请求?后的格式一致"</span>,</span><br><span class="line">    dataType:<span class="string">"TEXT或JSON"</span>,<span class="comment">//服务器返回的数据类型</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="comment">//当服务器响应状态码在200-299之间时, 这里执行</span></span><br><span class="line">        <span class="comment">//参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//当服务器响应状态码不再200-299之间时, 这里执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>$.get(url, [data], [callback], [type])</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>("请求的网址", &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>$.post(url, [data], [callback], [type])</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;, <span class="string">"json"</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>$.getJSON(url, [data], [callback])</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>jquery对象.load(url, [data], [callback])</code></li>
</ol>
<ul>
<li>载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#dom"</span>).load(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//加载成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="11-3-Vue中的AJAX"><a href="#11-3-Vue中的AJAX" class="headerlink" title="11.3 Vue中的AJAX"></a>11.3 Vue中的AJAX</h4><ul>
<li>使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js</li>
<li>不创建Vue对象的情况下, 使用的ajax:<ul>
<li><code>Vue.http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li>
<li><code>Vue.http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li>
</ul>
</li>
<li>创建Vue实例, 使用ajax<ul>
<li><code>this.$http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li>
<li><code>this.$http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GET请求: 传递参数列表: </span></span><br><span class="line">&#123;</span><br><span class="line">    params:&#123;</span><br><span class="line">        参数名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">        参数名<span class="number">2</span>:值<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">POST请求: 传递参数列表:</span><br><span class="line">&#123;</span><br><span class="line">    参数名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">    参数名<span class="number">2</span>:值<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>success函数 与 error函数<ul>
<li>格式: function(res){} //res , 就是响应对象, 包含了响应的相关信息</li>
<li>响应对象的常用属性:<ol>
<li>url : 响应的网址</li>
<li>body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string</li>
<li>ok  : boolean值, 响应码在200-299之间时  为 true</li>
<li>status : 响应码, 例如: 200,302,404,500</li>
<li>statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok</li>
</ol>
</li>
<li>响应对象的常用函数:<ol>
<li>text() : 以字符串的形式, 返回响应体</li>
<li>json() : 以对象的形式, 返回响应体</li>
<li>blob() : 以二进制的形式 , 返回响应体.</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="11-4-AJAX缓存问题"><a href="#11-4-AJAX缓存问题" class="headerlink" title="11.4 AJAX缓存问题"></a>11.4 AJAX缓存问题</h4><ul>
<li>浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。</li>
<li>缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。</li>
<li>在请求地址加上随机参数可以比避免缓存，如:<code>&quot;s1.do?time=&quot;+new Date().getTime();</code></li>
</ul>
<h4 id="11-5-AJAX跨域问题"><a href="#11-5-AJAX跨域问题" class="headerlink" title="11.5 AJAX跨域问题"></a>11.5 AJAX跨域问题</h4><ul>
<li>默认编写的Servlet . 不允许其他网站的ajax跨域请求.</li>
<li>我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域:<ul>
<li><code>response.addHeader(&quot;Access-Control-allow-Origin&quot;,&quot;*&quot;)</code>;</li>
<li><code>response.addHeader(&quot;Access-Control-allow-Methods&quot;,&quot;GET,POST&quot;)</code>;</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> JavaWeb编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> javaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十一、JavaSE数据结构与算法入门]]></title>
      <url>http://chaooo.github.io/2019/07/15/11_JavaSE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<p>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">Java数据结构</a></li>
<li><a href="#id2">时间复杂度与空间复杂度</a></li>
<li><a href="#id3">算法的基本概念</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-Java数据结构-Data-Structure"><a href="#1-Java数据结构-Data-Structure" class="headerlink" title="1.Java数据结构(Data Structure)"></a>1.Java数据结构(Data Structure)</h3><h4 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h4><ol>
<li>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</li>
<li>而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。</li>
<li>而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</li>
</ol>
<h4 id="1-2-Java数据结构"><a href="#1-2-Java数据结构" class="headerlink" title="1.2 Java数据结构"></a>1.2 Java数据结构</h4><ul>
<li>数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。<ol>
<li>线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。</li>
<li>非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。</li>
</ol>
</li>
<li>按数据的存储结构分为：顺序存储结构和链式存储结构<ol>
<li>顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 </li>
<li>链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。</li>
</ol>
</li>
</ul>
<h4 id="1-2-1-线性数据结构"><a href="#1-2-1-线性数据结构" class="headerlink" title="1.2.1 线性数据结构"></a>1.2.1 线性数据结构</h4><p>常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。</p>
<ol>
<li>一维数组<ul>
<li>在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。</li>
<li>ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。</li>
<li>数组的插入/更新/删除效率比较低，而<strong>查询效率非常高</strong>,查询效率时间复杂度是1。</li>
</ul>
</li>
<li>线性表<ul>
<li>线性表是有序的储存结构、链式的储存结构。</li>
<li>链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。</li>
<li>常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。</li>
<li>线性表<strong>插入效率比较高</strong>，而查询效率就比较低（add(),get()）。</li>
</ul>
</li>
<li>栈Stack<ul>
<li>栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。</li>
</ul>
</li>
<li>队列<ul>
<li>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。</li>
<li>Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</li>
<li>使用场景也非常多，如线程池，mq，连接池等。</li>
</ul>
</li>
<li>串<ul>
<li>串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）</li>
</ul>
</li>
</ol>
<h4 id="1-2-2-非线性数据结构"><a href="#1-2-2-非线性数据结构" class="headerlink" title="1.2.2 非线性数据结构"></a>1.2.2 非线性数据结构</h4><p>常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。</p>
<ol>
<li>多维数组<ul>
<li>Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</li>
</ul>
</li>
<li>集合<ul>
<li>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</li>
</ul>
</li>
<li>树<ul>
<li>在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。</li>
<li>除了根节点，其他结点有且只有一个直接父节点</li>
<li>每个结点可以有任意多个直接子节点。</li>
<li>树的数据结构又分为：<ol>
<li>自由树/普通树：对子节点没有任何约束。</li>
<li>二叉树：每个节点最多含有两个子节点的树称为二叉树。</li>
<li>二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）</li>
<li>B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。</li>
<li>B+tree：又称B+。是B-树的变体，也是一种多路搜索树。</li>
</ol>
</li>
</ul>
</li>
<li>Hash<ul>
<li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）</li>
<li>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>
<li>Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。</li>
<li>Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</li>
<li>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</li>
</ul>
</li>
<li>图<ul>
<li>图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</li>
</ul>
</li>
</ol>
<h3 id="2-时间复杂度与空间复杂度"><a href="#2-时间复杂度与空间复杂度" class="headerlink" title="2. 时间复杂度与空间复杂度"></a>2. 时间复杂度与空间复杂度</h3><h4 id="2-1-时间复杂度"><a href="#2-1-时间复杂度" class="headerlink" title="2.1 时间复杂度"></a>2.1 时间复杂度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为<strong>T(n)</strong></p>
<p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p>
<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。</p>
<p>有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。</p>
<p>常见的算法的时间 复杂度之间的关系为：<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</code></p>
<h4 id="2-2-空间复杂度"><a href="#2-2-空间复杂度" class="headerlink" title="2.2 空间复杂度"></a>2.2 空间复杂度</h4><p>空间复杂度：算法所需存储空间的度量，记作：<code>S(n)=O( f(n) )</code>，其中 n 为问题的规模。</p>
<p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p>
<p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p>
<blockquote>
<ul>
<li>空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。</li>
<li>时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。</li>
<li>稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。</li>
</ul>
</blockquote>
<h3 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h3><ul>
<li>算法: 简单来说就是解决问题的步骤。</li>
<li>算法的五个特征:有穷性，确定性，可行性，有输入，有输出<ol>
<li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li>
<li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li>
<li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li>
<li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li>
<li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li>
</ol>
</li>
<li>算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求<ul>
<li>描述算法的速度必须要和数据项的个数联系起来。</li>
<li>算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；</li>
<li>一个算法的效率越高越好，而存储量是越低越好。</li>
</ul>
</li>
</ul>
<h3 id="4-常用的查找算法"><a href="#4-常用的查找算法" class="headerlink" title="4. 常用的查找算法"></a>4. 常用的查找算法</h3><h4 id="4-1-线性（顺序）查找算法"><a href="#4-1-线性（顺序）查找算法" class="headerlink" title="4.1 线性（顺序）查找算法"></a>4.1 线性（顺序）查找算法</h4><ol>
<li>使用目标元素与样本数列中第一个元素起依次进行比较</li>
<li>若目标元素等于样本元素，则表示查找成功</li>
<li>若目标元素与样本元素比较完毕也不相等，则表示查找失败</li>
</ol>
<h4 id="4-2-二分查找算法"><a href="#4-2-二分查找算法" class="headerlink" title="4.2 二分查找算法"></a>4.2 二分查找算法</h4><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。</p>
<ul>
<li>普通循环实现二分查找算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(srcArray, <span class="number">28</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找普通循环实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcArray 有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 查找元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span> srcArray[], <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = srcArray.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == srcArray[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = srcArray.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p>
</blockquote>
<ul>
<li>递归实现二分查找递归实现算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(srcArray, <span class="number">0</span>,<span class="number">15</span>,<span class="number">28</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcArray  有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 数组低地址下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end   数组高地址下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  查找元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 查找元素不存在返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span> srcArray[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">    <span class="keyword">if</span> (srcArray[mid] == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(srcArray, mid + <span class="number">1</span>, end, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(srcArray, start, mid - <span class="number">1</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p>
</blockquote>
<h3 id="4-常用的排序算法"><a href="#4-常用的排序算法" class="headerlink" title="4. 常用的排序算法"></a>4. 常用的排序算法</h3><ul>
<li>八大排序算法<ul>
<li>一、直接插入排序（Insertion Sort）</li>
<li>二、希尔排序（Shell Sort）</li>
<li>三、选择排序（Selection Sort）</li>
<li>四、堆排序（Heap Sort）</li>
<li>五、冒泡排序（Bubble Sort）</li>
<li>六、快速排序（Quick Sort）</li>
<li>七、归并排序（Merging Sort）</li>
<li>八、基数排序（Radix Sort）</li>
</ul>
</li>
</ul>
<h4 id="4-1-冒泡排序算法"><a href="#4-1-冒泡排序算法" class="headerlink" title="4.1 冒泡排序算法"></a>4.1 冒泡排序算法</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<ul>
<li><p>算法描述：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</li>
</ol>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//声明标志位</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="keyword">int</span> temp = arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j++<span class="number">1</span>] = temp;</span><br><span class="line">          flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//若此轮结束flag还是为true,则证明已经有序</span></span><br><span class="line">      <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>冒泡排序算法复杂度:</p>
<ul>
<li>平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)</li>
<li>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十、JavaSE常用设计模式]]></title>
      <url>http://chaooo.github.io/2019/07/15/10_JavaSE%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">常用的设计原则</a></li>
<li><a href="#id2">设计模式分类</a></li>
<li><a href="#id3">单例模式</a></li>
<li><a href="#id4">模板模式</a></li>
<li><a href="#id5">工厂模式</a></li>
<li><a href="#id6">适配器模式</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-常用的设计原则"><a href="#1-常用的设计原则" class="headerlink" title="1.常用的设计原则"></a>1.常用的设计原则</h3><ul>
<li><strong>开闭原则</strong>：对扩展开发，对修改方便</li>
<li><strong>里氏代换原则</strong>：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）</li>
<li><strong>依赖倒转原则</strong>：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li>
<li><strong>接口隔离原则</strong>：尽量多依赖小接口而不是大接口</li>
<li><strong>迪米特法则</strong>（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。</li>
<li><strong>合成复用原则</strong>：尽量多使用合成/聚合的方式，而不是继承的方式。</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2.设计模式分类"></a>2.设计模式分类</h3><h4 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><ul>
<li>设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。</li>
<li>设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。</li>
<li>设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性</li>
</ul>
<h4 id="2-2-具体分类"><a href="#2-2-具体分类" class="headerlink" title="2.2 具体分类"></a>2.2 具体分类</h4><ol>
<li><strong>创建型模式</strong>：<em>用于对象创建的过程</em><ul>
<li><strong>单例模式</strong>、<strong>工厂方法模式</strong>、抽象工厂模式、建造者模式(生成器模式)、原型模式</li>
</ul>
</li>
<li><strong>结构型模式</strong>：<em>用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构</em><ul>
<li>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)</li>
</ul>
</li>
<li><strong>行为型模式</strong>：<em>用于解决类或对象之间的交互，更合理的优化类或对象之间的关系</em><ul>
<li>责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、<strong>模板模式</strong>、访问者模式、备忘录模式、</li>
</ul>
</li>
<li>JEE 设计模式<ul>
<li>数据访问对象模式 </li>
</ul>
</li>
</ol>
<p><span id="id3"><span></span></span></p>
<h3 id="3-单例模式（Singleton）"><a href="#3-单例模式（Singleton）" class="headerlink" title="3.单例模式（Singleton）"></a>3.单例模式（Singleton）</h3><h4 id="3-1-实现流程："><a href="#3-1-实现流程：" class="headerlink" title="3.1 实现流程："></a>3.1 实现流程：</h4><ol>
<li>私有的构造方法</li>
<li>私有的静态的当前类的对象作为属性</li>
<li>共有的静态方法返回当前对象<h4 id="3-1-实现方式："><a href="#3-1-实现方式：" class="headerlink" title="3.1 实现方式："></a>3.1 实现方式：</h4></li>
<li>饿汉式：立即加载，对象启动时就加载</li>
<li>懒汉式：延迟加载，对象什么时候用到时才会加载</li>
<li>生命周期托管：单例对象交给别人处理</li>
</ol>
<p><span id="id4"><span></span></span></p>
<h3 id="4-模板模式"><a href="#4-模板模式" class="headerlink" title="4.模板模式"></a>4.模板模式</h3><p>在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。</p>
<ul>
<li>eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">      initialize();</span><br><span class="line">      start();</span><br><span class="line">      end();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 不同子类以不同方法实现抽象类的的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span> <span class="keyword">extends</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Initialized!."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Started."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> <span class="keyword">extends</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Initialized!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Started!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Software s1 = <span class="keyword">new</span> Browser();</span><br><span class="line">      s1.play();</span><br><span class="line">      s1 = <span class="keyword">new</span> Editor();</span><br><span class="line">      s1.play();    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-模式模式优缺点："><a href="#4-1-模式模式优缺点：" class="headerlink" title="4.1 模式模式优缺点："></a>4.1 模式模式优缺点：</h4><ol>
<li>优点<ul>
<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li>
</ul>
</li>
<li>缺点<ul>
<li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li>
</ul>
</li>
<li>适用场景<ul>
<li>在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。</li>
</ul>
</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5. 工厂模式"></a>5. 工厂模式</h3><ol>
<li>简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；</li>
<li>工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；</li>
<li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。</li>
</ol>
<h4 id="5-1-简单工厂模式的实现："><a href="#5-1-简单工厂模式的实现：" class="headerlink" title="5.1 简单工厂模式的实现："></a>5.1 简单工厂模式的实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span></span>; &#125;</span><br><span class="line">  <span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span> </span>&#123; <span class="comment">/*苹果*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pear</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span> </span>&#123; <span class="comment">/* 梨 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"apple"</span>)) &#123;<span class="comment">//生产苹果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pear"</span>)) &#123;<span class="comment">//生产梨</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">FruitFactory mFactory = <span class="keyword">new</span> FruitFactory();</span><br><span class="line">Apple apple = (Apple) mFactory.createFruit(<span class="string">"apple"</span>);<span class="comment">//获得苹果</span></span><br><span class="line">Pear pear = (Pear) mFactory.createFruit(<span class="string">"pear"</span>);<span class="comment">//获得梨</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单工厂只适合于产品对象较少，且产品固定的需求</p>
</blockquote>
<h4 id="5-2-工厂方法模式实现："><a href="#5-2-工厂方法模式实现：" class="headerlink" title="5.2 工厂方法模式实现："></a>5.2 工厂方法模式实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Fruit <span class="title">createFruit</span><span class="params">()</span></span>;<span class="comment">//生产水果</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PearFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">AppleFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">PearFactory pearFactory = <span class="keyword">new</span> PearFactory();</span><br><span class="line">Apple apple = (Apple) appleFactory.createFruit();<span class="comment">//获得苹果</span></span><br><span class="line">Pear pear = (Pear) pearFactory.createFruit();<span class="comment">//获得梨</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂</p>
</blockquote>
<h4 id="5-3-抽象工厂模式实现："><a href="#5-3-抽象工厂模式实现：" class="headerlink" title="5.3 抽象工厂模式实现："></a>5.3 抽象工厂模式实现：</h4><ul>
<li>抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；</li>
<li>eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// cpu接口和实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cpu650</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">/* 625 也厉害 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cpu825</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* 825 处理更强劲 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 屏幕接口和实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Screen5</span> <span class="keyword">implements</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="comment">/* 5寸 */</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Screen6</span> <span class="keyword">implements</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">/* 6寸 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Cpu <span class="title">getCpu</span><span class="params">()</span></span>;<span class="comment">//使用的cpu</span></span><br><span class="line">    <span class="function">Screen <span class="title">getScreen</span><span class="params">()</span></span>;<span class="comment">//使用的屏幕</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 具体工厂实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cpu.Cpu825();<span class="comment">//高性能处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Screen <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Screen.Screen6();<span class="comment">//6寸大屏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HongMiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cpu.Cpu650();<span class="comment">//高效处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Screen <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Screen.Screen5();<span class="comment">//小屏手机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；</p>
</blockquote>
<h4 id="5-4-三种工厂方式总结："><a href="#5-4-三种工厂方式总结：" class="headerlink" title="5.4 三种工厂方式总结："></a>5.4 三种工厂方式总结：</h4><ol>
<li>对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；</li>
<li>抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；</li>
</ol>
<p><span id="id6"><span></span></span></p>
<h3 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6.适配器模式（Adapter）"></a>6.适配器模式（Adapter）</h3><ul>
<li>适配器模式Adapter是结构型模式的一种，分为<strong>类适配器模式</strong>，<strong>对象适配器模式</strong>，<strong>缺省适配器模式</strong>。<ul>
<li>类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；</li>
<li>对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。</li>
</ul>
</li>
</ul>
<blockquote>
<p>适配器模式的缺点<br><br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
</blockquote>
<h4 id="6-1-缺省适配器模式"><a href="#6-1-缺省适配器模式" class="headerlink" title="6.1 缺省适配器模式"></a>6.1 缺省适配器模式</h4><ul>
<li>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</li>
<li>缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)</li>
<li>适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九、JavaSE网络编程]]></title>
      <url>http://chaooo.github.io/2019/07/12/09_JavaSE%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br>java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">网络编程常识</a></li>
<li><a href="#id2">基于tcp协议的编程模型</a></li>
<li><a href="#id3">基于udp协议的编程模型</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-网络编程常识"><a href="#1-网络编程常识" class="headerlink" title="1. 网络编程常识"></a>1. 网络编程常识</h3><h4 id="1-1-七层网络模型"><a href="#1-1-七层网络模型" class="headerlink" title="1.1 七层网络模型"></a>1.1 七层网络模型</h4><p>为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：<br><br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<ul>
<li>当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；</li>
<li>当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；</li>
</ul>
<h4 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h4><ul>
<li>IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。</li>
<li>日常生活中采用<strong>点分十进制</strong>表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1</li>
</ul>
<h4 id="1-3-端口号"><a href="#1-3-端口号" class="headerlink" title="1.3 端口号"></a>1.3 端口号</h4><ul>
<li>根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。</li>
<li>网络编程需要提供：IP地址 和 端口号</li>
<li>端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。</li>
</ul>
<h4 id="1-4-tcp协议与udp协议"><a href="#1-4-tcp协议与udp协议" class="headerlink" title="1.4 tcp协议与udp协议"></a>1.4 tcp协议与udp协议</h4><ul>
<li>TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。</li>
<li>UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li>
<li>tcp协议与udp协议比较：</li>
</ul>
<table>
<thead>
<tr>
<th>tcp协议</th>
<th>udp协议</th>
</tr>
</thead>
<tbody><tr>
<td>传输控制协议，面向连接</td>
<td>用户数据报协议，非面向连接</td>
</tr>
<tr>
<td>通信过程全程保持连接</td>
<td>通信过程不需要全程连接</td>
</tr>
<tr>
<td>保证了数据传输的可靠性和有序性</td>
<td>不保证数据传输的可靠性和有序性</td>
</tr>
<tr>
<td>全双工的字节流的通信方式</td>
<td>全双工的数据报的通信方式</td>
</tr>
<tr>
<td>服务器的资源消耗多，压力大，效率低</td>
<td>服务器资源消耗少，压力小，效率高</td>
</tr>
</tbody></table>
<p><span id="id2"><span></span></span></p>
<h3 id="2-基于tcp协议的编程模型"><a href="#2-基于tcp协议的编程模型" class="headerlink" title="2. 基于tcp协议的编程模型"></a>2. 基于tcp协议的编程模型</h3><h4 id="2-1-编程模型"><a href="#2-1-编程模型" class="headerlink" title="2.1 编程模型"></a>2.1 编程模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器端                         客户端</span><br><span class="line"></span><br><span class="line">创建监听服务</span><br><span class="line">等待连接    &lt;----建立连接------  连接服务器           </span><br><span class="line">进行通讯    &lt;----进行通讯-----&gt;  进行通讯</span><br><span class="line">关闭连接                        关闭连接</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器：<ol>
<li>创建ServerSocket类型的对象并提供端口号；</li>
<li>等待客户端的连接请求，调用accept方法；</li>
<li>使用输入输出流进行通信；</li>
<li>关闭Socket；</li>
</ol>
</li>
<li>客户端：<ol>
<li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li>
<li>使用输入输出流进行通信；</li>
<li>关闭Socket；</li>
</ol>
</li>
</ul>
<h4 id="2-2-ServerSocket类和Socket类"><a href="#2-2-ServerSocket类和Socket类" class="headerlink" title="2.2 ServerSocket类和Socket类"></a>2.2 ServerSocket类和Socket类</h4><ul>
<li>java.net.ServerSocket类主要用于描述服务器套接字信息。</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ServerSocket(int port)</td>
<td>根据参数指定的端口号来构造对象</td>
</tr>
<tr>
<td>Socket accept()</td>
<td>监听并接收到此套接字的连接请求</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭套接字</td>
</tr>
</tbody></table>
<ul>
<li>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Socket(String host, int port)</td>
<td>根据指定主机名和端口号来构造对象</td>
</tr>
<tr>
<td>InputStream getInputStream()</td>
<td>用于获取当前套接字的输入流</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>用于获取当前套接字的输出流</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭套接字</td>
</tr>
</tbody></table>
<p><span id="id3"><span></span></span></p>
<h3 id="3-客户端与服务端通信演示："><a href="#3-客户端与服务端通信演示：" class="headerlink" title="3.客户端与服务端通信演示："></a>3.客户端与服务端通信演示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Socket s;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 3.使用输入输出流进行通信</span></span><br><span class="line">      BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">          <span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">      PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 实现服务器接收到字符串内容后打印出来</span></span><br><span class="line">        <span class="comment">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class="line">        String str = br.readLine();</span><br><span class="line">        <span class="comment">//System.out.println("服务器接收到的数据是：" + str);</span></span><br><span class="line">        <span class="comment">// 当服务器接收到"bye"后，则聊天结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"bye"</span>.equalsIgnoreCase(str)) &#123;</span><br><span class="line">          System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() + <span class="string">"已下线！"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() </span><br><span class="line">          + <span class="string">"发来的消息是："</span> + str);  </span><br><span class="line">        <span class="comment">// 当服务器接收到客户端发来的消息后，向客户端回发消息"I received!"</span></span><br><span class="line">        ps.println(<span class="string">"I received!"</span>);</span><br><span class="line">        <span class="comment">//System.out.println("服务器发送数据成功！");</span></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 4.关闭Socket</span></span><br><span class="line">      ps.close();</span><br><span class="line">      br.close();</span><br><span class="line">      s.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStringTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建ServerSocket类型的对象并提供端口号</span></span><br><span class="line">      ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">      <span class="comment">// 2.等待客户端的连接请求，调用accept方法</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"等待客户端的连接请求..."</span>);</span><br><span class="line">        <span class="comment">// 当没有客户端连接时，阻塞在accept方法的调用这里</span></span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        <span class="comment">// 获取连接成功的客户端通信地址</span></span><br><span class="line">        System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() + <span class="string">"连接成功！"</span>);</span><br><span class="line">        <span class="comment">// 当有客户端连接成功后，则启动一个新的线程为之服务</span></span><br><span class="line">        <span class="keyword">new</span> ServerThread(s).start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//ss.close();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientStringTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建Socket类型的对象并提供服务器的通信地址和端口号</span></span><br><span class="line">      Socket s = <span class="keyword">new</span> Socket(<span class="string">"XDL-20170621QCO"</span>, <span class="number">8888</span>);</span><br><span class="line">      System.out.println(<span class="string">"连接服务器成功！"</span>);</span><br><span class="line">      <span class="comment">// 2.使用输入输出流进行通信</span></span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">      BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">          <span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞</span></span><br><span class="line">        <span class="comment">//Thread.sleep(10000);</span></span><br><span class="line">        <span class="comment">// 练习：实现客户端向服务器发送的内容由用户从键盘输入</span></span><br><span class="line">        System.out.println(<span class="string">"请输入要发送的内容："</span>);</span><br><span class="line">        <span class="comment">//String msg = sc.next(); // 读取字符串内容时，遇到空格停止</span></span><br><span class="line">        String msg = sc.nextLine();</span><br><span class="line">        <span class="comment">// 实现客户端向服务器发送字符串内容"hello"</span></span><br><span class="line">        <span class="comment">//ps.println("hello");</span></span><br><span class="line">        ps.println(msg);</span><br><span class="line">        System.out.println(<span class="string">"客户端发送数据成功！"</span>);</span><br><span class="line">        <span class="comment">// 判断客户端发送的内容是否为"bye"，若是则聊天结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"bye"</span>.equalsIgnoreCase(msg)) &#123;</span><br><span class="line">          System.out.println(<span class="string">"聊天结束！"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现服务器回发消息的接收</span></span><br><span class="line">        <span class="comment">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class="line">        String str = br.readLine();</span><br><span class="line">        System.out.println(<span class="string">"客户端接收到的数据是："</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.关闭Socket</span></span><br><span class="line">      br.close();</span><br><span class="line">      sc.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      s.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id4"><span></span></span></p>
<h3 id="4-基于udp协议的编程模型"><a href="#4-基于udp协议的编程模型" class="headerlink" title="4. 基于udp协议的编程模型"></a>4. 基于udp协议的编程模型</h3><h4 id="4-1-编程模型"><a href="#4-1-编程模型" class="headerlink" title="4.1 编程模型"></a>4.1 编程模型</h4><ul>
<li>主机A(接收方):<ol>
<li>创建DatagramSocket类型的对象，并提供端口号；</li>
<li>创建DatagramPacket类型的对象，用于接收发来的数据；</li>
<li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li>
<li>关闭Socket并释放有关的资源；</li>
</ol>
</li>
<li>主机B(发送方)<ol>
<li>创建DatagramSocket类型的对象；</li>
<li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li>
<li>通过Socket发送数据，调用<strong>send()</strong>方法；</li>
<li>关闭Socket并释放有关的资源；</li>
</ol>
</li>
</ul>
<h4 id="4-2-DatagramSocket类"><a href="#4-2-DatagramSocket类" class="headerlink" title="4.2 DatagramSocket类"></a>4.2 DatagramSocket类</h4><ul>
<li>java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>DatagramSocket()</td>
<td>无参的方式构造对象。</td>
</tr>
<tr>
<td>DatagramSocket(int port)</td>
<td>根据参数指定的端口号来构造对象。</td>
</tr>
<tr>
<td>void receive(DatagramPacket p)</td>
<td>用于接收数据并存放到参数指定的变量中。</td>
</tr>
<tr>
<td>void send(DatagramPacket p)</td>
<td>用于将参数指定的数据发送出去。</td>
</tr>
<tr>
<td>void close()</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-3-DatagramPacket类"><a href="#4-3-DatagramPacket类" class="headerlink" title="4.3 DatagramPacket类"></a>4.3 DatagramPacket类</h4><ul>
<li>java.net.DatagramPacket类用于描述数据报信息(信件)；</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>DatagramPacket(byte[] buf, int length)</td>
<td>用于接收数据包并记录到参数变量中；</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td>
<td>用于将参数指定的数据发送到参数指定的位置</td>
</tr>
<tr>
<td>InetAddress getAddress()</td>
<td>用于获取发送方或接收方的通信地址信息。</td>
</tr>
<tr>
<td>int getPort()</td>
<td>用于获取发送方或接收方的端口信息。</td>
</tr>
<tr>
<td>int getLength()</td>
<td>用于获取发送或接收数据的长度。</td>
</tr>
</tbody></table>
<h4 id="4-4-InetAddress类"><a href="#4-4-InetAddress类" class="headerlink" title="4.4 InetAddress类"></a>4.4 InetAddress类</h4><ul>
<li>java.net.InetAddress类用于描述互联网协议地址。</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>static InetAddress getLocalHost()</td>
<td>用于获取本地主机的通信地址信息。</td>
</tr>
<tr>
<td>static InetAddress getByName(String host)</td>
<td>根据参数指定的主机名来获取通信地址。</td>
</tr>
<tr>
<td>String getHostName()</td>
<td>用于获取通信地址中的主机名信息。</td>
</tr>
<tr>
<td>String getHostAddress()</td>
<td>用于获取通信地址中的IP地址信息。</td>
</tr>
</tbody></table>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈开源]]></title>
      <url>http://chaooo.github.io/2019/07/11/%E8%B0%88%E8%B0%88%E5%BC%80%E6%BA%90.html</url>
      <content type="html"><![CDATA[<h3 id="什么是开源"><a href="#什么是开源" class="headerlink" title="什么是开源"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p>
<p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p>
<a id="more"></a>
<p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p>
<h3 id="开源是否等于免费"><a href="#开源是否等于免费" class="headerlink" title="开源是否等于免费"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p>
<p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p>
<p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p>
<p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p>
<p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p>
<h3 id="为什么要选择开源软件"><a href="#为什么要选择开源软件" class="headerlink" title="为什么要选择开源软件"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p>
<p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p>
<p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p>
<p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p>
<p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p>
<blockquote>
<p>参考连接：</p>
<ul>
<li><a href="https://blog.csdn.net/happmaoo/article/details/83201544" target="_blank" rel="noopener">https://blog.csdn.net/happmaoo/article/details/83201544</a></li>
<li><a href="https://www.oschina.net/news/58921/what-is-open-source" target="_blank" rel="noopener">https://www.oschina.net/news/58921/what-is-open-source</a></li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[八、JavaSE反射机制]]></title>
      <url>http://chaooo.github.io/2019/07/10/08_JavaSE%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html</url>
      <content type="html"><![CDATA[<p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">基本概念</a></li>
<li><a href="#id2">Class类</a></li>
<li><a href="#id3">Constructor类</a></li>
<li><a href="#id4">Field类</a></li>
<li><a href="#id5">Method类</a></li>
<li><a href="#id6">原始方式与反射方式构造对象实例</a></li>
<li><a href="#id7">注解(Annotation)</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<p>反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；<br>类是用来描述一组对象，反射机制可以理解为是用来描述一组类</p>
<p>通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。</p>
<h4 id="1-1-相关类及描述"><a href="#1-1-相关类及描述" class="headerlink" title="1.1 相关类及描述"></a>1.1 相关类及描述</h4><ul>
<li>Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</li>
<li>Package：用来描述类所属的包</li>
<li>Field：用来描述类中的属性</li>
<li>Method：用来描述类中的方法</li>
<li>Constructor：用来描述类中的构造方法</li>
<li>Annotation：用来描述类中的注解</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-Class类"><a href="#2-Class类" class="headerlink" title="2. Class类"></a>2. Class类</h3><p>java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</p>
<h4 id="2-1-获取Class类型对象的三种方式"><a href="#2-1-获取Class类型对象的三种方式" class="headerlink" title="2.1 获取Class类型对象的三种方式"></a>2.1 获取Class类型对象的三种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"包名.类名"</span>);<span class="comment">//用的最多，但可能抛出ClassNotFoundException异常</span></span><br><span class="line">Class clazz = 类名.class;<span class="comment">//任何类都有一个隐含的静态成员变量class</span></span><br><span class="line">Class clazz = 对象.getClass();<span class="comment">//Object类中的方法</span></span><br><span class="line">Class clazz = 包装类.TYPE;<span class="comment">//获取对应基本数据类型的class对象</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-常用方法"><a href="#2-2-常用方法" class="headerlink" title="2.2 常用方法"></a>2.2 常用方法</h4><ul>
<li>static Class&lt;?&gt; forName(String className)<ul>
<li>用于获取参数指定对应的Class对象并返回</li>
</ul>
</li>
<li>T newInstance()<ul>
<li>默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>
</ul>
</li>
<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<ul>
<li>用于获取此Class对象所表示类型中参数指定的公共构造方法。</li>
</ul>
</t></li>
<li>Constructor&lt;?&gt;[] getConstructors()<ul>
<li>用于获取此Class对象所表示类型中所有的公共构造方法</li>
</ul>
</li>
<li>Field getDeclaredField(String name)<ul>
<li>用于获取此Class对象所表示类中参数指定的单个成员变量信息</li>
</ul>
</li>
<li>Field[] fs = getDeclaredFields()<ul>
<li>用于获取此Class对象所表示类中所有成员变量信息</li>
</ul>
</li>
<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<ul>
<li>用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法</li>
</ul>
</li>
<li>Method[] getMethods()<ul>
<li>用于获取该Class对象表示类中所有公共成员方法。</li>
</ul>
</li>
<li>获取私有相关方法<ul>
<li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)</li>
<li>getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)</li>
<li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有)</li>
<li>getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)</li>
</ul>
</li>
</ul>
<h4 id="2-3-其他方法"><a href="#2-3-其他方法" class="headerlink" title="2.3 其他方法"></a>2.3 其他方法</h4><ol>
<li>int result = getModifiers(); 获取类的修饰符(权限+特征)<ul>
<li>每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract</li>
</ul>
</li>
<li>String name = getName(); 获取类的全名(包名.类名)</li>
<li>String name = getSimpleName(); 获取类简单名(只有类名 缺少包)</li>
<li>Package p = getPackage(); 获取当前类所属的包<ul>
<li>p.getName(); 获取包名(Package类中的方法)</li>
</ul>
</li>
<li>Class sclazz = getSuperClass(); 获取超类(父类)对应Class</li>
<li>Class[] classes = getInterface(); 获取当前类父亲接口</li>
<li>Class[] classes = getClasses(); 获取类中的内部类</li>
<li>Object obj = <strong>newInstance()</strong>; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>
<li>Field f = getField(“属性名”); 获取类中的属性(公有的 自己类+父类)</li>
<li>Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)</li>
<li>getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类)</li>
<li>Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)</li>
</ol>
<p><span id="id3"><span></span></span></p>
<h3 id="3-Constructor类"><a href="#3-Constructor类" class="headerlink" title="3. Constructor类"></a>3. Constructor类</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>
<h4 id="3-1-Constructor类中的常用方法"><a href="#3-1-Constructor类中的常用方法" class="headerlink" title="3.1 Constructor类中的常用方法"></a>3.1 Constructor类中的常用方法</h4><ul>
<li>T newInstance(Object… initargs)<ul>
<li>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。</li>
</ul>
</li>
</ul>
<h4 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2 其他方法"></a>3.2 其他方法</h4><ul>
<li>con.getModifiers();</li>
<li>con.getName();</li>
<li>con.getParameterTypes();</li>
<li>con.getExceptionTypes();</li>
<li>如何操作构造方法<ul>
<li>执行一次,创建对象</li>
<li>Object = newInstance(执行构造方法时的所有参数);</li>
<li>con.setAccessible(true);</li>
</ul>
</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-Field类"><a href="#4-Field类" class="headerlink" title="4. Field类"></a>4. Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>
<h4 id="4-1-Field类中的常用方法"><a href="#4-1-Field类中的常用方法" class="headerlink" title="4.1 Field类中的常用方法"></a>4.1 Field类中的常用方法</h4><ul>
<li>Object get(Object obj)<ul>
<li>调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。</li>
</ul>
</li>
<li>Object set(Object obj, Object value)<ul>
<li>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。</li>
</ul>
</li>
<li>void setAccessible(boolean flag)<ul>
<li>当实参传递true时，则反射的对象在使用时应该取消java语言访问检查</li>
</ul>
</li>
</ul>
<h4 id="4-2-其他方法"><a href="#4-2-其他方法" class="headerlink" title="4.2 其他方法"></a>4.2 其他方法</h4><ol>
<li>int = getModifiers(); 获取属性修饰符(权限+特征)</li>
<li>Class = getType(); 获取属性的类型对应的那个class</li>
<li>String = getName(); 获取属性的名字</li>
<li>操作属性: set(对象,值); Object = get(对象);<ul>
<li>如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入</li>
</ul>
</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-Method类"><a href="#5-Method类" class="headerlink" title="5. Method类"></a>5. Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>
<h4 id="5-1-Method类中的常用方法"><a href="#5-1-Method类中的常用方法" class="headerlink" title="5.1 Method类中的常用方法"></a>5.1 Method类中的常用方法</h4><ul>
<li>Object invoke(Object obj, Object… args)<ul>
<li>使用对象obj来调用此Method对象所表示的成员方法，实参传递args。</li>
</ul>
</li>
</ul>
<h4 id="5-2-其他方法"><a href="#5-2-其他方法" class="headerlink" title="5.2 其他方法"></a>5.2 其他方法</h4><ul>
<li>int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)</li>
<li>Class mrt = m.getReturnType(); 获取返回值数据类型</li>
<li>String mn = m.getName(); 获取方法的名字</li>
<li>Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型</li>
<li>Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型</li>
<li>如何操作方法</li>
<li>调用方法   让他执行一次</li>
<li>Object result = invoke(对象,执行方法需要传递的所有参数…);</li>
<li>若方法是私有的方法  不允许操作</li>
<li>可以设置setAccessable(true)   设置方法使用权  准入</li>
</ul>
<p><span id="id6"><span></span></span></p>
<h3 id="6-原始方式与反射方式构造对象实例"><a href="#6-原始方式与反射方式构造对象实例" class="headerlink" title="6. 原始方式与反射方式构造对象实例"></a>6. 原始方式与反射方式构造对象实例</h3><ol>
<li>使用原始方式来构造对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//1.采用无参的方式构造Person对象并打印</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p); <span class="comment">//null 0</span></span><br><span class="line">  <span class="comment">//2.使用有参方式来构造Person对象</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"zhangfei"</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(p2); <span class="comment">//zhangfei 30</span></span><br><span class="line">  <span class="comment">//3.修改与获取属性(成员变量)，调用get,set方法</span></span><br><span class="line">p2.setName(<span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + p2.getName()); <span class="comment">//guanyu</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用反射机制来构造对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//1.使用获取到的Class对象来构造Person对象并打印</span></span><br><span class="line">Class c1 = Class.forName(<span class="string">"myproject.Person"</span>);<span class="comment">//不可省略包名</span></span><br><span class="line">System.out.println(c1.newInstance());<span class="comment">//null 0</span></span><br><span class="line">    <span class="comment">//2.使用有参方式来构造对象</span></span><br><span class="line">Class c2 = Class.forName(<span class="string">"myproject.Person"</span>);</span><br><span class="line">Constructor ct2 = c2.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">Object obj = ct2.newInstance(<span class="string">"zhangfei"</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(obj);<span class="comment">//zhangfei 30</span></span><br><span class="line">    <span class="comment">//3.修改与获取属性(成员变量)</span></span><br><span class="line">Field f2 = c2.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，设置使用权</span></span><br><span class="line">f2.set(obj, <span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + f2.get(obj)); <span class="comment">//guanyu</span></span><br><span class="line">    <span class="comment">//4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来</span></span><br><span class="line">Method m1 = c2.getMethod(<span class="string">"getName"</span>);</span><br><span class="line">System.out.println(<span class="string">"获取到的姓名是："</span> + m1.invoke(obj)); <span class="comment">//zhangfei</span></span><br><span class="line">    <span class="comment">//5.成员方法setName，调用getMethod方法来修改姓名并打印出来</span></span><br><span class="line">Method m2 = c2.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">Object res = m2.invoke(obj, <span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"方法调用的返回值是："</span> + res); <span class="comment">//null</span></span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + m1.invoke(obj)); <span class="comment">//guanyu</span></span><br></pre></td></tr></table></figure>

<p><span id="id7"><span></span></span></p>
<h3 id="7-注解-Annotation"><a href="#7-注解-Annotation" class="headerlink" title="7. 注解(Annotation)"></a>7. 注解(Annotation)</h3><h4 id="7-1-注解相关概念"><a href="#7-1-注解相关概念" class="headerlink" title="7.1 注解相关概念"></a>7.1 注解相关概念</h4><ul>
<li>注释<ul>
<li>单行注释：<code>//</code></li>
<li>多行注释：<code>/*   */</code></li>
<li>文档注释：<code>/**   */</code></li>
</ul>
</li>
<li>注解的写法<ul>
<li><code>@XXX [(一些信息)]</code></li>
</ul>
</li>
<li>注解位置<ul>
<li>类的上面，属性上面，方法上面，构造方法上面，参数前面</li>
</ul>
</li>
<li>注解的作用<ol>
<li>用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated</li>
<li>用来做代码的检测(验证)，@Override</li>
<li>*可以携带一些信息(内容)，文件.properties/.xml，注解</li>
</ol>
</li>
<li>常用的注解<ul>
<li>@Deprecated：用来说明方法是废弃的</li>
<li>@Override：用来做代码检测   检测此方法是否是一个重写</li>
<li>@SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{}<ul>
<li>unused：变量定义后未被使用</li>
<li>serial：类实现了序列化接口  不添加序列化ID号</li>
<li>rawtypes：集合没有定义泛型</li>
<li>deprecation：方法以废弃    </li>
<li>*unchecked：出现了泛型的问题  可以不检测</li>
<li>all：包含了以上所有(不推荐)</li>
</ul>
</li>
</ul>
</li>
<li>注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：<ol>
<li>基本数据类型</li>
<li>String类型</li>
<li>枚举类型enum</li>
<li>注解类型@</li>
<li>数组类型[]，数组的内部需要是如上的四种类型</li>
</ol>
</li>
<li>注解的分类<ol>
<li>按运行机制分：源码注解，编译时注解，运行时注解</li>
<li>按照来源分：来自JDK的注解，来自第三方的注解，自定义注解</li>
</ol>
</li>
</ul>
<h4 id="7-2-自定义注解类型的语法要求："><a href="#7-2-自定义注解类型的语法要求：" class="headerlink" title="7.2 自定义注解类型的语法要求："></a>7.2 自定义注解类型的语法要求：</h4><ol>
<li>使用@interface关键字定义注解</li>
<li>成员以<strong>无参无异常</strong>方式声明</li>
<li>可以用default为成员指定一个默认值</li>
<li>成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration</li>
<li>如果注解只有一个成员，则成员名必须取名<strong>value()</strong>,在使用时可以忽略成员名和赋值号(=)</li>
<li>注解类可以没有成员，没有成员的注解称为标识注解</li>
<li>需要元注解来描述说明<ul>
<li>@Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)</li>
<li>@Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME)</li>
<li>@Inherited：允许子类继承</li>
<li>@Document：当前注解是否能被文档(javadoc)所记录</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description&#123;</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-使用自定义注解："><a href="#7-3-使用自定义注解：" class="headerlink" title="7.3 使用自定义注解："></a>7.3 使用自定义注解：</h4><ul>
<li>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Description</span>(desc=<span class="string">"I am eyeColor"</span>, author=<span class="string">"Chao"</span>, age=<span class="number">18</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">eyeColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Description</span>(<span class="string">"I am class annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Description</span>(<span class="string">"I am method annotation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-解析注解"><a href="#7-4-解析注解" class="headerlink" title="7.4 解析注解"></a>7.4 解析注解</h4><p>通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。</p>
<ol>
<li>使用类加载器加载类<ul>
<li><code>Class c=Class.forName（&quot;com.ann.test.Child&quot;)</code></li>
</ul>
</li>
<li>找到类上面的注解<ul>
<li><code>isAnnotationPresent（类类型）</code>：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。</li>
</ul>
</li>
<li>拿到注解实例，需要强制类型转换。<ul>
<li><code>Description d=（Description）c.getAnnotation(Description.class);</code></li>
</ul>
</li>
<li>找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseAnn</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//1. 使用类加载器加载类</span></span><br><span class="line">      Class c=Class.forName（<span class="string">"com.ann.test.Child"</span>)</span><br><span class="line">      <span class="comment">//2. 找到类上面的注解</span></span><br><span class="line">      <span class="keyword">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class="line">      <span class="keyword">if</span>(isExist)&#123;</span><br><span class="line">        <span class="comment">//3. 拿到注解实例</span></span><br><span class="line">        Description d=（Description）c.getAnnotation(Description.class);</span><br><span class="line">        System.out.println(d.value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.找到方法上的注解</span></span><br><span class="line">      Method[] ms = c.getMethods();</span><br><span class="line">      <span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isMExist = m.isAnnotationPresent(Description.class);</span><br><span class="line">        <span class="keyword">if</span>(isMExist)&#123;</span><br><span class="line">          Description md=（Description）c.getAnnotation(Description.class);</span><br><span class="line">          System.out.println(md.value());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一种解析方法上的注解:<ul>
<li>获取这个方法的所有注解，<code>Annotation [] as=m.getAnnotations();</code>然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">  Annotation [] as=m.getAnnotations();</span><br><span class="line">  <span class="keyword">for</span>(Annotation a:as)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Description)&#123;</span><br><span class="line">      Description md = (Description)a;</span><br><span class="line">      System.out.println(md.value());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[七、JavaSE多线程]]></title>
      <url>http://chaooo.github.io/2019/07/09/07_JavaSE%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<p>多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>程序的执行其实都是在抢CPU的资源，CPU的执行权。<br>多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">基本概念</a></li>
<li><a href="#id2">实现线程的过程</a></li>
<li><a href="#id3">线程常用方法</a></li>
<li><a href="#id4">线程池</a></li>
<li><a href="#id5">线程的主要状态</a></li>
<li><a href="#id6">线程的同步机制</a></li>
<li><a href="#id7">线程的死锁</a></li>
<li><a href="#id8">内存可见性</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li>程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  </li>
<li>进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个<strong>进程包含n个线程</strong>；(进程是系统进行资源分配和调度的一个独立单位)。</li>
<li>线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。</li>
<li>多进程是指操作系统能同时运行多个任务（程序）。</li>
<li>多线程是指在同一程序(一个进程)中有多个顺序流在执行。</li>
<li>并行与并发：<ul>
<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>
<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li>
</ul>
</li>
<li>线程和进程一样分为五个阶段：<strong>创建</strong>、<strong>就绪状态</strong>、<strong>执行状态</strong>、<strong>等待/挂起/阻塞</strong>、<strong>终止/异常/消亡</strong>。</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-实现线程的过程"><a href="#2-实现线程的过程" class="headerlink" title="2. 实现线程的过程"></a>2. 实现线程的过程</h3><p>java.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。</p>
<ul>
<li>自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  </li>
<li>自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 </li>
</ul>
<h4 id="2-1-实现方式一：继承Thread类"><a href="#2-1-实现方式一：继承Thread类" class="headerlink" title="2.1 实现方式一：继承Thread类"></a>2.1 实现方式一：继承Thread类</h4><ol>
<li>自己描述一个类</li>
<li>继承父类Thread</li>
<li>重写run方法</li>
<li>new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="comment">//这里编写该线程的执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">mt.start();</span><br></pre></td></tr></table></figure>

<h4 id="2-2-实现方式二：实现Runnable接口"><a href="#2-2-实现方式二：实现Runnable接口" class="headerlink" title="2.2 实现方式二：实现Runnable接口"></a>2.2 实现方式二：实现Runnable接口</h4><ol>
<li>自己描述一个类</li>
<li>实现一个父接口Runnable</li>
<li>重写run方法</li>
<li>new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="comment">//这里编写该线程的执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread td = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">td.start();</span><br></pre></td></tr></table></figure>

<h4 id="2-3-两种方式优缺点："><a href="#2-3-两种方式优缺点：" class="headerlink" title="2.3 两种方式优缺点："></a>2.3 两种方式优缺点：</h4><ul>
<li>使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类</li>
<li>使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。</li>
</ul>
<p><span id="id3"><span></span></span></p>
<h3 id="3-线程常用方法"><a href="#3-线程常用方法" class="headerlink" title="3. 线程常用方法"></a>3. 线程常用方法</h3><p><img src="http://cdn.chaooo.top/java/thread.jpg" alt="Thread常用方法"></p>
<h4 id="3-1-相关方法的解析："><a href="#3-1-相关方法的解析：" class="headerlink" title="3.1 相关方法的解析："></a>3.1 相关方法的解析：</h4><ul>
<li>Thread()：使用无参方式构造对象  </li>
<li>Thread(String name)：根据参数指定的名称来构造对象。  </li>
<li>Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   </li>
<li>Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。</li>
<li>void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  </li>
<li>void <strong>start()</strong>：用于<strong>启动线程</strong>，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。</li>
</ul>
<ul>
<li>int getPriority()：用于获取线程的优先级，优先级1-10</li>
<li>void setPriority(int)：更改线程的优先级</li>
</ul>
<h4 id="3-2-多线程原理分析"><a href="#3-2-多线程原理分析" class="headerlink" title="3.2 多线程原理分析"></a>3.2 多线程原理分析</h4><ol>
<li>执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  </li>
<li>对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  </li>
<li>当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  </li>
<li>两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  </li>
</ol>
<h4 id="3-3-线程的编号和名称"><a href="#3-3-线程的编号和名称" class="headerlink" title="3.3 线程的编号和名称"></a>3.3 线程的编号和名称</h4><ul>
<li>long getId()：用于获取调用对象所表示线程的编号</li>
<li>String getName()：用于获取调用对象所表示线程的名称</li>
<li>void setName()：用于设置线程的名称为参数指定的数值</li>
<li>static Thread currentThread()：获取当前正在执行线程的引用</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h3><ul>
<li>为了避免重复的创建线程，线程池的出现可以<strong>让线程进行复用</strong>。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。</li>
<li>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。</li>
<li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务<ul>
<li>接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService</li>
<li>抽象类：AbstractExecutorService</li>
<li>实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor</li>
</ul>
</li>
<li>创建线程的第三种方式是实现Callable接口，主要用于线程池</li>
</ul>
<p><span id="id5"><span></span></span></p>
<h3 id="5-线程的主要状态"><a href="#5-线程的主要状态" class="headerlink" title="5. 线程的主要状态"></a>5. 线程的主要状态</h3><p><img src="http://cdn.chaooo.top/java/threadLife.jpg" alt="线程的生命周期"></p>
<ol>
<li>新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行</li>
<li>就绪状态：调用start()进入的状态，此时线程还是没有开始执行</li>
<li>运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态</li>
<li>消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止</li>
<li>阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态</li>
</ol>
<h4 id="5-1-线程的休眠"><a href="#5-1-线程的休眠" class="headerlink" title="5.1 线程的休眠"></a>5.1 线程的休眠</h4><ul>
<li><strong>终止线程</strong>：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。</li>
<li>static void <strong>yield()</strong>：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。</li>
<li>static void <strong>sleep(times)</strong>：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。</li>
</ul>
<h4 id="5-1-线程的等待"><a href="#5-1-线程的等待" class="headerlink" title="5.1 线程的等待"></a>5.1 线程的等待</h4><ul>
<li>void <strong>join()</strong>：等待该线程终止，让多个线程同步执行，变成单个线程</li>
<li>void <strong>join(long millis)</strong>：表示等待参数指定的毫秒数</li>
<li><strong>对象.wait()</strong> 和 <strong>对象.notify()/notifyAll()</strong>可以让线程的状态来回切换</li>
<li>sleep()和wait()的区别：</li>
</ul>
<table>
<thead>
<tr>
<th>sleep()和wait()的区别</th>
<th>sleep()</th>
<th>wait()</th>
</tr>
</thead>
<tbody><tr>
<td>1.类</td>
<td>Thread类</td>
<td>Object类</td>
</tr>
<tr>
<td>2.调用</td>
<td>静态 类名.</td>
<td>对象.</td>
</tr>
<tr>
<td>3.理解</td>
<td>调用位置的线程等待</td>
<td>对象调用，访问对象的其他线程等待</td>
</tr>
<tr>
<td>4.唤醒</td>
<td>不需要唤醒</td>
<td>需要其他对象调用notify唤醒</td>
</tr>
<tr>
<td>5.锁</td>
<td>不会释放锁</td>
<td>等待后会释放锁</td>
</tr>
</tbody></table>
<h4 id="5-2-守护线程"><a href="#5-2-守护线程" class="headerlink" title="5.2 守护线程"></a>5.2 守护线程</h4><ul>
<li>boolean <strong>isDeamon()</strong>：用于判断是否为守护线程</li>
<li>void <strong>setDeamon(boolean on)</strong>：用于设置线程为守护线程</li>
<li>Java线程有两类：<ul>
<li>用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程</li>
<li>守护线程：运行在后台，为其他前台线程服务</li>
</ul>
</li>
<li>守护线程特点：<ul>
<li><strong>一旦所有线程都结束运行，守护线程会随JVM一起结束工作</strong></li>
</ul>
</li>
<li>守护线程应用：<ul>
<li>数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。</li>
</ul>
</li>
<li>设置守护线程：<ul>
<li>可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程</li>
</ul>
</li>
</ul>
<p><span id="id6"><span></span></span></p>
<h3 id="6-线程的同步机制"><a href="#6-线程的同步机制" class="headerlink" title="6. 线程的同步机制"></a>6. 线程的同步机制</h3><ul>
<li><p>条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。</p>
</li>
<li><p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做<strong>线程的同步机制</strong>。</p>
</li>
<li><p>Java提供了一种<strong>内置的锁机制</strong>来支持<strong>原子性</strong>，使用<strong>synchronized</strong>关键字来保证线程执行操作的原子性，叫做<strong>对象/同步锁机制</strong>。</p>
</li>
<li><p>特征修饰符synchronized：表示同步，一个时间点只有一个线程访问</p>
</li>
<li><p>线程安全锁：两种形式是（锁定的永远是对象）</p>
<ol>
<li><p>使用同步代码块的方式，将synchronized关键字放在方法体内部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="comment">//需同步执行(锁定)的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用synchronized保证线程同步时应当注意：</p>
<ol>
<li>多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用</li>
<li>在使用同步块时应当尽量减少同步范围以提高并发的执行效率</li>
</ol>
</li>
</ul>
<blockquote>
<ol>
<li>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li>
<li>每个对象只有一个锁（lock）与之相关联。</li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>
</ol>
</blockquote>
<p><span id="id7"><span></span></span></p>
<h3 id="7-线程的死锁"><a href="#7-线程的死锁" class="headerlink" title="7. 线程的死锁"></a>7. 线程的死锁</h3><p>Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**当两个线程或多个线程之间相互锁定时就形成了死锁**/</span></span><br><span class="line"><span class="comment">//线程一：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">synchronized</span>(a) &#123; <span class="comment">//表示:持有对象锁a,等待对象锁b</span></span><br><span class="line">        <span class="keyword">synchronized</span>(b) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程二：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">synchronized</span>(b) &#123; <span class="comment">//表示:持有对象锁b,等待对象锁a</span></span><br><span class="line">        <span class="keyword">synchronized</span>(a) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。</li>
<li>隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。</li>
<li>两种导致隐性死锁的情况：加锁次序和占有并等待。<ul>
<li>加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。</li>
<li>占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。</li>
</ul>
</li>
</ul>
<h4 id="7-1-死锁的避免"><a href="#7-1-死锁的避免" class="headerlink" title="7.1 死锁的避免"></a>7.1 死锁的避免</h4><ul>
<li>避免死锁的原则：顺序上锁，反向解锁，不要回头</li>
<li>静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。</li>
<li>动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：<strong>安全序列</strong>和<strong>银行家算法</strong>。</li>
</ul>
<p><span id="id8"><span></span></span></p>
<h3 id="8-内存可见性"><a href="#8-内存可见性" class="headerlink" title="8.内存可见性"></a>8.内存可见性</h3><h4 id="8-1-基本概念"><a href="#8-1-基本概念" class="headerlink" title="8.1 基本概念"></a>8.1 基本概念</h4><ul>
<li>可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到</li>
<li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量</li>
<li>Java内存模型(JMM)：<ul>
<li>Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。</li>
<li>所有的变量都存储在主内存中</li>
<li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li>
</ul>
</li>
<li>Java内存模型规定：<ul>
<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li>
<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>
</ul>
</li>
<li>要实现共享变量的可见性，必须保证两点：<ul>
<li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li>
<li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。</li>
</ul>
</li>
<li>Java<strong>语言层面</strong>支持的可见性实现方式：Synchronized，volatile</li>
</ul>
<h4 id="8-2-Synchronized实现可见性"><a href="#8-2-Synchronized实现可见性" class="headerlink" title="8.2 Synchronized实现可见性"></a>8.2 Synchronized实现可见性</h4><ul>
<li>Synchronized能够实现：原子性(同步)、可见性</li>
<li>JMM关于synchronized的两条规定：<ul>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li>
<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li>
</ul>
</li>
<li>线程执行互斥代码的过程：<ol>
<li>获得互斥锁</li>
<li>清空工作内存</li>
<li>从主内存拷贝变量的最新副本到工作内存</li>
<li>执行代码</li>
<li>将更改后的共享变量的值刷新到主内存</li>
<li>释放互斥锁</li>
</ol>
</li>
<li>重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化<ol>
<li>编译器优化重排序（编译器处理）</li>
<li>指令级并行重排序（处理器优化）</li>
<li>内存系统的重排序（处理器读写缓存的优化）</li>
</ol>
</li>
<li>as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致</li>
<li>单线程中重排序不会带来内存可见性问题</li>
<li>多线程中程序交错执行时，重排序可能造成内存可见性问题</li>
</ul>
<table>
<thead>
<tr>
<th>不可见的原因</th>
<th>syschronized解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>1.线程的交叉执行</td>
<td>原子性</td>
</tr>
<tr>
<td>2.重排序结合线程交叉执行</td>
<td>原子性</td>
</tr>
<tr>
<td>3.共享变量未及时更新</td>
<td>可见性</td>
</tr>
</tbody></table>
<h4 id="8-3-volatile实现可见性"><a href="#8-3-volatile实现可见性" class="headerlink" title="8.3 volatile实现可见性"></a>8.3 volatile实现可见性</h4><ul>
<li>深入来说：通过加入内存屏障和禁止重排序优化来实现的。<ul>
<li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li>
<li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li>
</ul>
</li>
<li>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</li>
<li>线程<strong>写</strong>volatile变量的过程：<ol>
<li>改变线程工作内存中volatile变量副本的值</li>
<li>将改变后的副本的值从工作内存刷新到主内存</li>
</ol>
</li>
<li>线程<strong>读</strong>volatile变量的过程：<ol>
<li>从主内存中读取volatile变量的最新值到线程的工作内存中</li>
<li>从工作内存中读取volatile变量的副本</li>
</ol>
</li>
<li>volatile不能保证volatile变量复合操作的原子性</li>
<li>volatile适用场景：<ol>
<li>对变量的写操作不依赖其当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ol>
</li>
</ul>
<h4 id="8-4-Synchronized和volatile比较"><a href="#8-4-Synchronized和volatile比较" class="headerlink" title="8.4 Synchronized和volatile比较"></a>8.4 Synchronized和volatile比较</h4><ul>
<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li>
<li>从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁</li>
<li>synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性</li>
<li>volatile没有synchronized使用广泛。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[六、JavaSE输入输出(IO)]]></title>
      <url>http://chaooo.github.io/2019/07/09/06_JavaSE%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-IO.html</url>
      <content type="html"><![CDATA[<p>输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">File类</a></li>
<li><a href="#id2">IO流</a></li>
<li><a href="#id3">文件流</a></li>
<li><a href="#id4">字节型文件流</a></li>
<li><a href="#id5">字符型文件流</a></li>
<li><a href="#id6">*缓冲流</a></li>
<li><a href="#id7">转换流</a></li>
<li><a href="#id8">对象流</a></li>
<li><a href="#id9">打印流(PrintStream类)</a></li>
<li><a href="#id10">Properties类的使用</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h3><ul>
<li>File与真实硬盘中的文件或文件夹  不是一个东西<ul>
<li>File是在内存中的一个对象&lt;—映射—&gt;硬盘上的文件或文件夹</li>
</ul>
</li>
<li>java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。</li>
<li>File类中的常用的方法<ul>
<li>canRead()，canWrite()，isHidden()，isFile()，isDirectory()</li>
<li>length()，获取文件中字节的个数</li>
<li>lastModified()，获取文件最后的修改时间—&gt;毫秒值</li>
<li>*String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt<ul>
<li>绝对路径&lt;—-&gt;相对路径</li>
<li>绝对路径可以通过完整的字符串，定位盘符，文件夹，文件</li>
<li>相对路径没有盘符的写法，当前工程(项目)所在的位置找寻</li>
</ul>
</li>
<li>String name = getName()，获取文件的名字    Test.txt</li>
<li><em>boolean = *</em>createNewFile()**，创建新的文件</li>
<li><em>boolean = *</em>mkdir** ，创建新的文件夹  外层没有 不能创建</li>
<li><em>boolean = *</em>mkdirs**，创建新的文件夹  外层没有 可以自动创建</li>
<li>String pname = getParent()，获取当前file的父亲file名字</li>
<li>*File file = getParentFile()，获取当前file的父亲file对象</li>
<li>String[] names = list()，获取当前file的所有儿子名字</li>
<li>*File[] files = listFiles()，获取当前file的所有儿子对象</li>
<li>*boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹</li>
</ul>
</li>
<li>文件夹的路径(找父目录)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找当前file的所有父目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"D:\\test\\bbb\\inner\\InnerTest.txt"</span>);</span><br><span class="line">File pfile = file.getParentFile();</span><br><span class="line"><span class="keyword">while</span>(pfile!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(pfile.getAbsolutePath());</span><br><span class="line">    pfile = pfile.getParentFile();<span class="comment">//再找一遍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件夹的遍历—-需要一个递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法  用来展示(遍历)文件夹,参数--&gt;file(代表文件或文件夹)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFile</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取file的子元素</span></span><br><span class="line">    <span class="comment">//files==null是个文件</span></span><br><span class="line">    <span class="comment">//files!=null是个文件夹</span></span><br><span class="line">    <span class="comment">//files.length!=0是一个带元素的文件夹</span></span><br><span class="line">    File[] files = file.listFiles();<span class="comment">//test文件夹所有子元素</span></span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span> &amp;&amp; files.length!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">            <span class="keyword">this</span>.showFile(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做自己的显示(file是文件或file是一个空的文件夹)</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件夹的删除—-需要一个递归</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法 删除文件夹,参数 file</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断file不是空文件夹</span></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span> &amp;&amp; files.length!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">            <span class="keyword">this</span>.deleteFile(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除file (file是个文件或file是一个空文件夹)</span></span><br><span class="line">    file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id2"><span></span></span></p>
<h3 id="2-IO流"><a href="#2-IO流" class="headerlink" title="2. IO流"></a>2. IO流</h3><ul>
<li>流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </li>
<li>流的分类:<ul>
<li>根据处理数据类型的不同分为：字符流和字节流</li>
<li>根据数据流向不同分为：输入流in(读取)和输出流out(写入)</li>
<li>操作的目标来区分:<ul>
<li>文件流，数组流，字符串流，数据流，对象流，网络流…</li>
</ul>
</li>
</ul>
</li>
<li>IO流的框架结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|——IO流</span><br><span class="line">    |————字节流</span><br><span class="line">        |————InputStream</span><br><span class="line">            |————FileInputStream</span><br><span class="line">            |————DataInputStream</span><br><span class="line">            |————ObjectInputStream</span><br><span class="line">        |————OutputStream</span><br><span class="line">            |————FileOutputStream</span><br><span class="line">            |————DataOutputStream</span><br><span class="line">            |————ObjectOutputStream</span><br><span class="line">            |————PrintStream</span><br><span class="line">    |————字符流</span><br><span class="line">        |————Reader</span><br><span class="line">            |————BufferedReader</span><br><span class="line">            |————InputStreamReader</span><br><span class="line">        |————Writer</span><br><span class="line">            |————BufferedWriter</span><br><span class="line">            |————OutputStreamWriter</span><br></pre></td></tr></table></figure>

<p><span id="id3"><span></span></span></p>
<h3 id="3-文件流"><a href="#3-文件流" class="headerlink" title="3. 文件流"></a>3. 文件流</h3><p>读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分</p>
<ul>
<li>字节型文件流(1字节)：FileInputStream/FileOutputStream</li>
<li>字符型文件流(2字节–1字符)：FileReader/FileWriter</li>
<li>字节流和字符流的区别：<ul>
<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>
</ul>
</li>
<li>结论：只要是处理<strong>纯文本</strong>数据，就优先考虑使用<strong>字符流</strong>。 除此之外都使用<strong>字节流</strong>。</li>
<li>输入流和输出流<ul>
<li>对输入流只能进行<strong>读</strong>操作，对输出流只能进行<strong>写</strong>操作。 </li>
</ul>
</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-字节型文件流"><a href="#4-字节型文件流" class="headerlink" title="4. 字节型文件流"></a>4. 字节型文件流</h3><h4 id="4-1-字节型文件输入流FileInputStream-读"><a href="#4-1-字节型文件输入流FileInputStream-读" class="headerlink" title="4.1 字节型文件输入流FileInputStream(读)"></a>4.1 字节型文件输入流FileInputStream(读)</h4><ul>
<li>FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。</li>
<li>创建对象<ul>
<li>调用一个带File类型的构造方法</li>
<li>调用一个带String类型的构造方法</li>
</ul>
</li>
<li>常用方法<ul>
<li>int code = read();    每次从流管道中读取一个字节，返回字节的code码</li>
<li>*int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数</li>
<li>int count = available();   返回流管道中还有多少缓存的字节数</li>
<li>skip(long n);跳过几个字节  读取<ul>
<li>多线程—&gt;利用几个线程同时读取文件</li>
</ul>
</li>
<li>*close()    将流管道关闭—必须要做,最好放在finally里<ul>
<li>注意代码的健壮性，判断严谨（eg:非空判断）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-字节型文件输出流FileOutputStream-写"><a href="#4-2-字节型文件输出流FileOutputStream-写" class="headerlink" title="4.2 字节型文件输出流FileOutputStream(写)"></a>4.2 字节型文件输出流FileOutputStream(写)</h4><ul>
<li>FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。</li>
<li>创建对象<ul>
<li>调用一个带File参数，还有File boolean重载</li>
<li>调用一个带String参数，还有String boolean重载</li>
<li>eg: new FileOutputStream(“D://test//bbb.txt”, true)//第二个参控制每次写入追加还是重载</li>
</ul>
</li>
<li>常用方法<ul>
<li>write(int code);  将给定code对应的字符写入文件   ‘=’</li>
<li>write(byte[]);  将数组中的全部字节写入文件   getByte()</li>
<li>write(byte[] b, int off, int len);</li>
<li>flush();    将管道内的字节推入(刷新)文件</li>
<li>close();    注意在finally中关闭</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException</li>
<li>创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件</li>
</ul>
</blockquote>
<ul>
<li>设计一个文件复制的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File file, String path)</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建输入流读取信息</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">//创建一个新的File对象</span></span><br><span class="line">        File newFile = <span class="keyword">new</span> File(path +<span class="string">"\\"</span>+ file.getName());<span class="comment">//"E:\\test\\test.txt"</span></span><br><span class="line">        <span class="comment">//创建一个输出流</span></span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(newFile);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//通常1kb-8kb之间</span></span><br><span class="line">        <span class="keyword">int</span> count = fis.read(b);</span><br><span class="line">        <span class="keyword">while</span>(count != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(b, <span class="number">0</span>, count);<span class="comment">//将读取到的有效字节写入</span></span><br><span class="line">            fos.flush();</span><br><span class="line">            count = fis.read(b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"复制完毕！"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fis!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; fis.close(); &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fos!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;fos.close();&#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id5"><span></span></span></p>
<h3 id="5-字符型文件流"><a href="#5-字符型文件流" class="headerlink" title="5. 字符型文件流"></a>5. 字符型文件流</h3><p>FileReader/FileWriter：只能操作纯文本的文件 .txt / .properties</p>
<h4 id="5-1-字符型文件输入流FileReader-读"><a href="#5-1-字符型文件输入流FileReader-读" class="headerlink" title="5.1 字符型文件输入流FileReader(读)"></a>5.1 字符型文件输入流FileReader(读)</h4><ul>
<li>FileReader类在java.io包，继承自InputStreamReader，Reader</li>
<li>创建对象<ul>
<li>调用一个带File类型的构造方法</li>
<li>调用一个带String类型的构造方法</li>
</ul>
</li>
<li>常用方法<ul>
<li>read()</li>
<li>read(char[])</li>
<li>close()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"F://test//Test.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="comment">// int code = fr.read();</span></span><br><span class="line">    <span class="comment">// System.out.println(code);</span></span><br><span class="line">    <span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> count = fr.read(c);</span><br><span class="line">    <span class="keyword">while</span>(count!=-<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(c, <span class="number">0</span>, count));</span><br><span class="line">        count = fr.read(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-字符型文件输出流FileWriter-写"><a href="#5-2-字符型文件输出流FileWriter-写" class="headerlink" title="5.2 字符型文件输出流FileWriter(写)"></a>5.2 字符型文件输出流FileWriter(写)</h4><ul>
<li>FileWriter类在java.io包，继承自OutputStreamWriter，Writer</li>
<li>构造方法<ul>
<li>带file参数，带file,boolean参数</li>
<li>带String参数，带String,boolean参数</li>
</ul>
</li>
<li>常用方法<ul>
<li>write(int)</li>
<li>write(char[])</li>
<li>write(string)</li>
<li>flush()，close()</li>
</ul>
</li>
</ul>
<p><span id="id6"><span></span></span></p>
<h3 id="6-缓冲流"><a href="#6-缓冲流" class="headerlink" title="6. *缓冲流"></a>6. *缓冲流</h3><ul>
<li>缓冲流,也叫高效流，是对4个基本的File…流的增强，所以也是4个流，按照数据类型分类：<ul>
<li>字节缓冲流：BufferedInputStream，BufferedOutputStream </li>
<li>字符缓冲流：BufferedReader，BufferedWriter</li>
</ul>
</li>
<li>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li>
<li>缓冲流读写方法与基本的流是一致</li>
</ul>
<h4 id="6-1-字节缓冲流"><a href="#6-1-字节缓冲流" class="headerlink" title="6.1 字节缓冲流"></a>6.1 字节缓冲流</h4><ul>
<li>BufferedInputStream，BufferedOutputStream</li>
<li>构造方法<ul>
<li>public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 </li>
<li>public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"bis.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"bos.txt"</span>));</span><br></pre></td></tr></table></figure>

<h4 id="6-2-字符缓冲流"><a href="#6-2-字符缓冲流" class="headerlink" title="6.2 字符缓冲流"></a>6.2 字符缓冲流</h4><ul>
<li>BufferedReader，BufferedWriter</li>
<li>构造方法<ul>
<li>public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 </li>
<li>public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"br.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw.txt"</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</li>
<li>特有方法: <ul>
<li>BufferedReader：public String readLine(): 读一行文字。 </li>
<li>BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法，用来用户登录认证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://test//User.txt"</span>));</span><br><span class="line">        <span class="comment">//User.txt每行存储格式：张三-123</span></span><br><span class="line">        String user = br.readLine();<span class="comment">//user表示一行记录，记录账号密码</span></span><br><span class="line">        <span class="keyword">while</span>(user!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将user信息拆分，分别与参数比较</span></span><br><span class="line">            String[] value = user.split(<span class="string">"-"</span>);<span class="comment">//value[0]账号，value[1]密码</span></span><br><span class="line">            System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(value[<span class="number">0</span>].equals(username)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(value[<span class="number">1</span>].equals(password)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"登录成功"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            user = br.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"账号或密码错误！"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>readLine方法演示:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;F://test//User.txt&quot;, true));</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.write(&quot;java-888&quot;);</span><br><span class="line">    bw.flush();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id7"><span></span></span></p>
<h3 id="7-转换流"><a href="#7-转换流" class="headerlink" title="7. 转换流"></a>7. 转换流</h3><h4 id="7-1-字符编码"><a href="#7-1-字符编码" class="headerlink" title="7.1 字符编码"></a>7.1 字符编码</h4><ul>
<li>字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。</li>
<li>字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
<li>常见字符集:<ul>
<li>ASCII字符集 ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）</li>
</ul>
</li>
<li>ISO-8859-1字符集：<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li>GBxxx字符集：<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li>GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）</li>
</ul>
</li>
<li>Unicode字符集 ：<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。</li>
</ul>
</li>
</ul>
</li>
<li>编码引出的问题<ul>
<li>在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</li>
</ul>
</li>
</ul>
<h4 id="7-2-InputStreamReader类"><a href="#7-2-InputStreamReader类" class="headerlink" title="7.2 InputStreamReader类"></a>7.2 InputStreamReader类</h4><p>转换流java.io.InputStreamReader，是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<ul>
<li>构造方法<ul>
<li>InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </li>
<li>InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>指定编码读取:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">       String FileName = <span class="string">"E:\\file_gbk.txt"</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">       InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">    <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">       InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">"GBK"</span>);</span><br><span class="line"><span class="comment">// 定义变量,保存字符</span></span><br><span class="line">       <span class="keyword">int</span> read;</span><br><span class="line">    <span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">       <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.print((<span class="keyword">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">      &#125;</span><br><span class="line">       isr.close();</span><br><span class="line">    <span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">       <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">      &#125;</span><br><span class="line">       isr2.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-OutputStreamWriter类"><a href="#7-3-OutputStreamWriter类" class="headerlink" title="7.3 OutputStreamWriter类"></a>7.3 OutputStreamWriter类</h4><p>转换流java.io.OutputStreamWriter ，是Writer的子类，是从<strong>字符流到字节流</strong>的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<ul>
<li>构造方法<ul>
<li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </li>
<li>OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>指定编码写出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 定义文件路径</span></span><br><span class="line">       String FileName = <span class="string">"E:\\out.txt"</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">       OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">       <span class="comment">// 写出数据</span></span><br><span class="line">    osw.write(<span class="string">"你好"</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">       osw.close();</span><br><span class="line"><span class="comment">// 定义文件路径</span></span><br><span class="line">String FileName2 = <span class="string">"E:\\out2.txt"</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">       OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">"GBK"</span>);</span><br><span class="line">       <span class="comment">// 写出数据</span></span><br><span class="line">    osw2.write(<span class="string">"你好"</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">       osw2.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id8"><span></span></span></p>
<h3 id="8-对象流"><a href="#8-对象流" class="headerlink" title="8. 对象流"></a>8. 对象流</h3><ul>
<li>对象序列化和反序列化<ul>
<li>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 </li>
<li>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象</li>
<li>简单来讲<ul>
<li>对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中</li>
<li>对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象</li>
<li>如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口；<br>如果想要将对象反序列化：需要给对象提供一个序列化的版本号，<code>private long serialVersionUID = 任意L</code>;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-1-ObjectOutputStream类"><a href="#8-1-ObjectOutputStream类" class="headerlink" title="8.1 ObjectOutputStream类"></a>8.1 ObjectOutputStream类</h3><ul>
<li>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</li>
<li>构造方法<ul>
<li>public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>

<ul>
<li>序列化操作<ol>
<li>一个对象要想序列化，必须满足两个条件:<ul>
<li>该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</li>
</ul>
</li>
<li>写出对象方法<ul>
<li>public final void writeObject (Object obj) : 将指定的对象写出。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//满足两个条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> String address;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Address check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写出对象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">  Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">  e.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">  e.address = <span class="string">"beiqinglu"</span>;</span><br><span class="line">  e.age = <span class="number">20</span>; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建序列化流对象</span></span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>));</span><br><span class="line">      <span class="comment">// 写出对象</span></span><br><span class="line">      out.writeObject(e);</span><br><span class="line">      <span class="comment">// 释放资源</span></span><br><span class="line">      out.close();</span><br><span class="line">      fileOut.close();</span><br><span class="line">      System.out.println(<span class="string">"Serialized data is saved"</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">           i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//Serialized data is saved</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="8-1-ObjectInputStream类"><a href="#8-1-ObjectInputStream类" class="headerlink" title="8.1 ObjectInputStream类"></a>8.1 ObjectInputStream类</h4><ul>
<li>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </li>
<li>构造方法<ul>
<li>public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
</li>
<li>反序列化操作1<ul>
<li>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。</li>
<li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。</li>
<li>public final Object readObject () : 读取一个对象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">       Employee e = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建反序列化流</span></span><br><span class="line">            FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">            <span class="comment">// 读取一个对象</span></span><br><span class="line">            e = (Employee) in.readObject();</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">            <span class="comment">// 捕获其他异常</span></span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassNotFoundException c) &#123;</span><br><span class="line">      <span class="comment">// 捕获类找不到异常</span></span><br><span class="line">            System.out.println(<span class="string">"Employee class not found"</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">       System.out.println(<span class="string">"Name: "</span> + e.name);<span class="comment">// zhangsan</span></span><br><span class="line">       System.out.println(<span class="string">"Address: "</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">       System.out.println(<span class="string">"age: "</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反序列化操作2<ul>
<li>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法 </li>
</ul>
</li>
<li>Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Address check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id9"><span></span></span></p>
<h3 id="9-打印流-PrintStream类"><a href="#9-打印流-PrintStream类" class="headerlink" title="9. 打印流(PrintStream类)"></a>9. 打印流(PrintStream类)</h3><ul>
<li>平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</li>
<li>构造方法<ul>
<li><code>public PrintStream(String fileName);</code>  使用指定的文件名创建一个新的打印流。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>)；</span><br></pre></td></tr></table></figure>

<ul>
<li>改变打印流向<ul>
<li>System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">        <span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line">        <span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        <span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id10"><span></span></span></p>
<h3 id="10-Properties类的使用"><a href="#10-Properties类的使用" class="headerlink" title="10. Properties类的使用"></a>10. Properties类的使用</h3><ul>
<li>Java.util.Properties，主要用于读取Java的配置文件。</li>
<li>Properties类继承自Hashtable</li>
<li>配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用”#”来注释。</li>
<li>Properties类的主要方法：<ol>
<li>getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</li>
<li>load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</li>
<li>setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</li>
<li>store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</li>
<li>clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[五、JavaSE异常处理机制]]></title>
      <url>http://chaooo.github.io/2019/07/09/05_JavaSE%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html</url>
      <content type="html"><![CDATA[<p>Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">基本概念</a></li>
<li><a href="#id2">异常的分支结构</a></li>
<li><a href="#id3">添加处理异常的手段</a></li>
<li><a href="#id4">异常的捕获</a></li>
<li><a href="#id5">异常的抛出</a></li>
<li><a href="#id6">自定义异常</a></li>
<li><a href="#id7">总结</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li>异常用于在Java语言中描述运行阶段发生的错误。</li>
<li>在Java中有一个定义好的规则Throwable（可以抛出的）</li>
<li>java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。<ul>
<li>Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。</li>
<li>Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。</li>
</ul>
</li>
<li>java.lang.Exception类是所有异常的超类，主要分为两大类：<ul>
<li>RuntimeException - 运行时异常，也叫非检测性异常</li>
<li>IOException和其他异常 - 其他异常也叫做检测性异常</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Throwable类</span><br><span class="line">    |————Exception类</span><br><span class="line">        |————RuntimeException异常</span><br><span class="line">            |————ArithmeticException类</span><br><span class="line">            |————ArrayIndexOutOfBoundsException类</span><br><span class="line">            |————NullPointerException类</span><br><span class="line">            |————ClassCastException类</span><br><span class="line">            |————NumberFormatException类</span><br><span class="line">        |————IOException和其他异常</span><br><span class="line">    |————Error类</span><br></pre></td></tr></table></figure>

<p><span id="id2"><span></span></span></p>
<h3 id="2-异常的分支结构"><a href="#2-异常的分支结构" class="headerlink" title="2. 异常的分支结构"></a>2. 异常的分支结构</h3><h4 id="2-1-运行时异常（非检查异常）"><a href="#2-1-运行时异常（非检查异常）" class="headerlink" title="2.1 运行时异常（非检查异常）"></a>2.1 运行时异常（非检查异常）</h4><ol>
<li>Error和RuntimeException都算作运行时异常</li>
<li>javac编译的时候，不会提示和发现的，</li>
<li>在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)</li>
<li>要求大家出现这样异常的时候 知道怎么产生及如何修改<ul>
<li>InputMisMatchException 输入不匹配<ul>
<li>int value = input.nextInt();//   abc</li>
</ul>
</li>
<li>*NumberFormatException 数字格式化<ul>
<li>int value = Integer.parseInt(“123.45”);</li>
</ul>
</li>
<li>NegativeArraySizeException 数组长度负数<ul>
<li>int[] array = new int[-2];</li>
</ul>
</li>
<li>*ArrayIndexOutOfBoundsException 数组索引越界<ul>
<li>int[] array = {1,2,3};</li>
<li>array[5];</li>
</ul>
</li>
<li>*5NullPointerException 空指针异常<ul>
<li>int[][] array = new int[3][];</li>
<li>array[0][0] =10;</li>
<li>Person p = null;</li>
<li>p.getName();</li>
</ul>
</li>
<li>ArithmeticException 数字异常<ul>
<li>10/0    整数不允许除以0    Infinity小数除以0会产生无穷</li>
</ul>
</li>
<li>*ClassCastException 造型异常<ul>
<li>Person p = new Teacher();</li>
<li>Student s = (Student)p;</li>
</ul>
</li>
<li>*StringIndexOutOfBoundsException 字符串越界<ul>
<li>String str = “abc”;</li>
<li>str.charAt(5);</li>
</ul>
</li>
<li>*IndexOutOfBoundsException 集合越界<ul>
<li>List家族</li>
<li>ArrayList  list = new ArrayList();</li>
<li>list.add(); list.add(); list.add();</li>
<li>list.get(5);</li>
</ul>
</li>
<li>IllegalArgumentException 非法参数异常<ul>
<li>ArrayList  list = new ArrayList(-1);</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-编译时异常-检查异常"><a href="#2-2-编译时异常-检查异常" class="headerlink" title="2.2 编译时异常(检查异常)"></a>2.2 编译时异常(检查异常)</h4><ul>
<li>除了Error和RuntimeException以外其他的异常</li>
<li>javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)</li>
<li>因为这样的异常在程序运行过程中极有可能产生问题的</li>
<li>异常产生后后续的所有执行就停止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg: InterruptException</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id3"><span></span></span></p>
<h3 id="3-添加处理异常的手段"><a href="#3-添加处理异常的手段" class="headerlink" title="3. 添加处理异常的手段"></a>3. 添加处理异常的手段</h3><ul>
<li>处理异常不是 异常消失了</li>
<li>处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行</li>
<li>两种手段：<ul>
<li>异常的捕获：try{}catch(){}[ finally{} ]</li>
<li>throws抛出</li>
</ul>
</li>
<li>final，finally，finalize区别<ul>
<li>final：特征修饰符，修饰变量，属性，方法，类<ul>
<li>修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)</li>
<li>修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)</li>
<li>修饰方法：不能被子类重写</li>
<li>修饰类：不能被其他的子类继承</li>
</ul>
</li>
<li>finally：处理异常手段的一部分<ul>
<li>try{}catch(){}后面的一个部分</li>
<li>这个部分可有可无，如果有只能含有一份，且必须执行</li>
</ul>
</li>
<li>finalize：是Object类中的一个protected方法<ul>
<li>对象没有任何引用指向的时候 – 会被GC回收</li>
<li>当对象回收的时候 默认调用finalize方法</li>
<li>若想要看到对象回收的效果，可以重写 public void finalize(){}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-异常的捕获"><a href="#4-异常的捕获" class="headerlink" title="4. 异常的捕获"></a>4. 异常的捕获</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 引用变量)&#123;</span><br><span class="line">    针对该异常的处理代码;</span><br><span class="line">&#125;<span class="keyword">catch</span> ...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论是否发生异常都要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>处理异常放在方法内部 可能会出现的小问题<ul>
<li>如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String test() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //...可能产生异常的的代码</span><br><span class="line">        return &quot;值1&quot;;//事先约定好 返回值</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();//打印输出异常的名字</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        System.out.println(&quot;finally块执行啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;值2&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述执行结果：若try中代码块产生异常return返回 <strong>值2</strong>，若try中无异常则return返回 <strong>值1</strong>，无论return在哪finally都会执行。</li>
</ul>
<blockquote>
<p>异常捕获的注意事项：</p>
<ul>
<li>当需要多分catch分子时，切记小类型应该放在大类型的前面；</li>
<li>懒人写法：catch(Exception e){…}</li>
<li>finally通常用于善后处理，如：关闭已经打开的文件等。</li>
</ul>
</blockquote>
<p><span id="id5"><span></span></span></p>
<h3 id="5-异常的抛出"><a href="#5-异常的抛出" class="headerlink" title="5. 异常的抛出"></a>5. 异常的抛出</h3><ul>
<li>当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。</li>
<li>语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{} ，<br><br>如：<code>public void show() throw Exception {}</code></li>
<li>重写方法的抛出规则：<ul>
<li>不抛出异常</li>
<li>抛出父类异常中的子类异常</li>
<li>抛出和父类一样的异常</li>
<li>不能抛出同级不一样的异常</li>
<li>不能抛出更大的异常</li>
</ul>
</li>
</ul>
<p><span id="id6"><span></span></span></p>
<h3 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="6. 自定义异常"></a>6. 自定义异常</h3><ul>
<li>可以根据需要自定义异常类。</li>
<li>自定义异常的方式：<ul>
<li>继承Exception或者异常的子类。</li>
<li>提供两个构造，无参构造和String做参数的构造。 </li>
</ul>
</li>
<li>异常的手段<ul>
<li>如果继承是RuntimeException—-&gt;运行时异常(不需要必须添加处理手段)</li>
<li>如果继承是Exception—–&gt;编译时异常(必须添加处理手段)</li>
</ul>
</li>
<li>类中可以写带String参数的构造方法，可以做细致的说明</li>
<li>通过throw关键字，new一个异常的对象</li>
<li>主动产生异常：<code>throw new 异常类型();</code></li>
</ul>
<p><span id="id7"><span></span></span></p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul>
<li>1.在开发中尽量使用条件判断避免异常的发生;</li>
<li>2.若实在避免不了，则进行异常捕获；</li>
<li>3.若实在捕获不了，则进行异常抛出；</li>
<li>4.若需要使用针对性异常，则自定义异常。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[四、JavaSE集合框架]]></title>
      <url>http://chaooo.github.io/2019/07/08/04_JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html</url>
      <content type="html"><![CDATA[<p>为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">Collection集合</a></li>
<li><a href="#id2">List集合</a></li>
<li><a href="#id3">泛型机制</a></li>
<li><a href="#id4">Queue集合</a></li>
<li><a href="#id5">*ArrayList类</a></li>
<li><a href="#id6">Vector类</a></li>
<li><a href="#id7">Stack类</a></li>
<li><a href="#id8">*LinkedList类</a></li>
<li><a href="#id9">Set集合</a></li>
<li><a href="#id10">HashSet类</a></li>
<li><a href="#id11">TreeSet类</a></li>
<li><a href="#id12">Map集合</a></li>
<li><a href="#id13">HashMap类</a></li>
<li><a href="#id14">TreeMap类</a></li>
<li><a href="#id15">Lambda表达式</a></li>
<li><a href="#id16">Stream API</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1. Collection集合"></a>1. Collection集合</h3><ul>
<li>Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。</li>
</ul>
<blockquote>
<p>数组与集合的比较</p>
<ul>
<li>数组的特点：<ol>
<li>数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；</li>
<li>支持下标访问，实现随机访问非常方便；</li>
<li>增删操作不方便，可能会移动大量元素；</li>
<li>数组一旦声明长度固定无法更改；</li>
<li>数组支持基本数据类型，也支持引用数据类型；</li>
</ol>
</li>
<li>集合的特点：<ol>
<li>集合的存储单元可以不连续，数据类容可以不相同；</li>
<li>集合部分支持下标访问，部分不支持；</li>
<li>集合中增删元素可以不移动大量元素；</li>
<li>集合大小可以随时动态调整；</li>
<li>集合中的元素必须是引用数据类型（基本数据类型可用包装类）；</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-Collection接口</span><br><span class="line">    |————List接口</span><br><span class="line">        |————ArrayList类</span><br><span class="line">        |————LinkedList类</span><br><span class="line">        |————Stack类</span><br><span class="line">        |————Vector类</span><br><span class="line">    |————Queue接口</span><br><span class="line">        |————LinkedList类</span><br><span class="line">    |————Set接口</span><br><span class="line">        |————HashSet类</span><br><span class="line">        |————TreeSet类</span><br><span class="line">-Map接口</span><br><span class="line">    |————HashMap类</span><br><span class="line">    |————TreeMap类</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Collection存储的都是value,其中List有序可重复，Set无序无重复</li>
<li>Map存储的是以key-value形式,key无序无重复 value无序可重复</li>
<li>序 : 顺序–添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>Collection集合的常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e);</td>
<td>向集合中添加对象</td>
</tr>
<tr>
<td>boolean contains(Object o);</td>
<td>判断是否包含指定对象</td>
</tr>
<tr>
<td>boolean remove(Object o);</td>
<td>从集合中删除对象</td>
</tr>
<tr>
<td>void clear();</td>
<td>清空集合</td>
</tr>
<tr>
<td>int size();</td>
<td>返回包含对象的个数</td>
</tr>
<tr>
<td>boolean isEmpty();</td>
<td>判断是否为空</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection c2 = <span class="keyword">new</span> ArrayList(); <span class="comment">//多态</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = c2.add(<span class="keyword">new</span> String(<span class="string">"one"</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = c2.add(<span class="keyword">new</span> Integer(<span class="number">2</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">"c2 = "</span> + c2); <span class="comment">//[one, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = c2.contains(<span class="keyword">new</span> Integer(<span class="number">2</span>));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//contains方法工作原理：(o==null ? e==null : o.equals(e));</span></span><br></pre></td></tr></table></figure>

<p><span id="id2"><span></span></span></p>
<h3 id="2-List集合"><a href="#2-List集合" class="headerlink" title="2. List集合"></a>2. List集合</h3><ul>
<li>java.util.List集合是Collection集合的子集合。</li>
<li>List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。<ul>
<li>ArrayList类的底层使用<strong>数组</strong>进行数据管理，访问元素方便，增删不方便。</li>
<li>LinkedList类的底层使用<strong>链表</strong>进行数据管理，访问不方便，增删方便。</li>
<li>Stark类的底层使用数组进行数据管理，该类主要描述具有<strong>后进先出</strong>的特征的数据结构，叫做<strong>栈</strong>。</li>
<li>Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。</li>
</ul>
</li>
<li>List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。</li>
</ul>
<table>
<thead>
<tr>
<th>List类常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, E element)</td>
<td>向集合指定位置添加元素</td>
</tr>
<tr>
<td>boolean addAll(int index, Collection&lt;?extends E&gt; c)</td>
<td>向集合中添加所有元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>从集合中获取指定位置的元素</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>修改指定位置的元素</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定位置的元素</td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td>在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td>将集合中的对象序列化以对象数组的形式返回。</td>
</tr>
<tr>
<td>List<e> subList(int fromIndex, int toIndex)</e></td>
<td>获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图</td>
</tr>
</tbody></table>
<p><span id="id3"><span></span></span></p>
<h3 id="3-泛型机制"><a href="#3-泛型机制" class="headerlink" title="3. 泛型机制"></a>3. 泛型机制</h3><ul>
<li>集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。</li>
<li>从jdk1.5开始推出泛型机制，在集合名称后面使用&lt;数据类型&gt;的方式明确要求该集合中可以存放的数据类型。如：<code>List&lt;String&gt; lt = new LinkedList&lt;String&gt;();</code>。</li>
<li>从jdk1.7开始可省略后面&lt;&gt;的数据类型，叫做<code>菱形特性</code>，如：<code>List&lt;String&gt; lt = new ArrayList&lt;&gt;();</code>。</li>
<li>泛型本质就是参数化类型，让数据类型作为参数传递，<code>public interface List&lt;E&gt;{}</code>其中<code>E</code>是占位形参，由于实参可以支持各种广泛的类型，因此得名<code>泛型</code>。</li>
<li>泛型可以用在哪里：<ol>
<li>泛型类：类定义的时候描述某种数据类型，集合的使用就是这样</li>
<li>泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型</li>
<li>泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中</li>
<li>方法参数泛型限制，高级泛型，规范边界，extends，super</li>
</ol>
</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-Queue集合"><a href="#4-Queue集合" class="headerlink" title="4. Queue集合"></a>4. Queue集合</h3><ul>
<li>java.util.Queue集合是Collection集合的子集合。</li>
<li>Queue集合主要描述具有<strong>先进先出</strong>特性的数据结构，叫做<strong>队列</strong>(FIFO:First Input First Output)。</li>
<li>Queue集合主要实现类是<code>LinkedList类</code>，因为该类在增删方面有一定优势。</li>
</ul>
<table>
<thead>
<tr>
<th>Queue接口中主要方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>boolean offer(E e)</td>
<td>将一个对象添加至队尾，若添加成功则返回true</td>
</tr>
<tr>
<td>E poll()</td>
<td>从队首删除并返回一个元素</td>
</tr>
<tr>
<td>E peek()</td>
<td>返回队首的元素（但并不删除）</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//将数据11、22、33、44、55依次入队</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    q1.offer(i*<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id5"><span></span></span></p>
<h3 id="5-ArrayList类"><a href="#5-ArrayList类" class="headerlink" title="5. *ArrayList类"></a>5. *ArrayList类</h3><ol>
<li>底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util</li>
<li>ArrayList特点适合遍历轮询，不适合插入删除</li>
<li>如何构建一个ArrayList对象<ul>
<li>无参数构造方法，带默认容量构造方法，带collection参数的构造方法</li>
</ul>
</li>
<li>ArrayList中常用的方法<ul>
<li>增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()</li>
</ul>
</li>
<li>类中其他常用的方法<ul>
<li>addAll并集，removeAll差集，ratainAll交集;</li>
<li>indexOf()，lastIndexOf()，contains()，List=subList();</li>
<li>isEmpty()，clear()，ensureCapacity()，iterator();迭代器</li>
<li>toArray(T[] x)，trimToSize();</li>
</ul>
</li>
</ol>
<p><span id="id6"><span></span></span></p>
<h3 id="6-Vector类"><a href="#6-Vector类" class="headerlink" title="6. Vector类"></a>6. Vector类</h3><ol>
<li>是ArrayList集合的早期版本，所属的包 java.util<ul>
<li>Vector底层也是利用(动态)数组的形式存储</li>
<li>Vector是线程同步的(synchronized)，安全性高，效率较低</li>
</ul>
</li>
<li>扩容方式与ArrayList不同<ul>
<li>默认是扩容2倍，可以通过构造方法创建对象时修改这一机制</li>
</ul>
</li>
<li>构造方法和常用方法与ArrayList类似</li>
</ol>
<p><span id="id7"><span></span></span></p>
<h3 id="7-Stack类"><a href="#7-Stack类" class="headerlink" title="7. Stack类"></a>7. Stack类</h3><ol>
<li>Stack类，栈，java.util包</li>
<li>构造方法只有一个无参数</li>
<li>除了继承自Vacton类的方法外还有特殊的方法<ul>
<li>push(E e)将某一个元素压入栈顶(add())</li>
<li>E = pop()将某一个元素从栈顶取出并删掉(E = remove())</li>
<li>E = peek()查看栈顶的一个元素 不删除(get())</li>
<li>boolean = empty()判断栈内元素是否为空(isEmpty())</li>
<li>int = search()查找给定的元素在占中的位置(indexOf())</li>
</ul>
</li>
<li>应用场景<ul>
<li>中国象棋，悔棋</li>
<li>栈中存储每一次操作的步骤</li>
<li>撤销功能</li>
</ul>
</li>
</ol>
<p><span id="id8"><span></span></span></p>
<h3 id="8-LinkedList类"><a href="#8-LinkedList类" class="headerlink" title="8. *LinkedList类"></a>8. *LinkedList类</h3><ol>
<li>LinkedList类，java.util包</li>
<li>底层使用<strong>双向链表</strong>的数据结构形式来存储<ul>
<li>适合于插入或删除  不适合遍历轮询</li>
</ul>
</li>
<li>构建对象<ul>
<li>无参数构造方法，带参数的构造方法(collection)</li>
</ul>
</li>
<li>常用的方法<ul>
<li>增删改查：add()，remove()，set()，get()，size()，offer，poll，peek</li>
<li>手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()</li>
</ul>
</li>
<li>插入删除的特性是否像想的那样<ul>
<li>对比ArrayList  Linked</li>
</ul>
</li>
</ol>
<p><span id="id9"><span></span></span></p>
<h3 id="9-Set集合"><a href="#9-Set集合" class="headerlink" title="9. Set集合"></a>9. Set集合</h3><ul>
<li>java.util.Set集合是Collection集合的子集合。</li>
<li>Set集合没有先后放入次序，并且不允许有重复关系，实现类有<code>HashSet类</code>和<code>TreeSet</code>类。</li>
<li>其中<code>HashSet类</code>底层是采用哈希表进行数据管理的。</li>
<li>其中<code>TreeSet类</code>的底层是采用二叉树进行数据管理的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法和Collection集合基本一样</span></span><br><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">set1.add(<span class="string">"one"</span>);</span><br><span class="line">System.out.println(<span class="string">"s1="</span>+s1);</span><br></pre></td></tr></table></figure>

<ul>
<li>set集合的无重复特性<ul>
<li>HashSet，无重复原则有两个方法同时起作用<ul>
<li>equals    hashCode</li>
<li>默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入</li>
<li>如果想要改变其比较的规则  可以重写上述两个方法</li>
</ul>
</li>
<li>TreeSet，无重复原则有一个方法起作用<ul>
<li>compareTo</li>
<li>上述这个方法不是每一个对象都有的</li>
<li>若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable</li>
<li>实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-1-Set集合的遍历"><a href="#9-1-Set集合的遍历" class="headerlink" title="9.1 Set集合的遍历"></a>9.1 Set集合的遍历</h4><ul>
<li>所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。</li>
</ul>
<table>
<thead>
<tr>
<th>迭代器<code>Iterator&lt;E&gt; iterator()</code>，主要方法有</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>判断集合中是否有可以迭代/访问的元素</td>
</tr>
<tr>
<td>E next()</td>
<td>用于取出一个元素并指向下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>用于删除访问到的最后一个元素</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = set1.iterator();<span class="comment">//获取当前集合的迭代器对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;<span class="comment">//判断是否有可以访问的元素</span></span><br><span class="line">    String temp = it.next();<span class="comment">//取出一个并指向下一个</span></span><br><span class="line">    System.out.println( temp );</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"two"</span>.equals(temp))&#123;</span><br><span class="line">        it.remove();<span class="comment">//删除set1中该元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>增强for循环(for each结构)</li>
<li>语法格式：<code>for(元素类型 变量名:集合/数组){ 循环体; }</code>。</li>
<li>执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(String ts : s1) &#123;</span><br><span class="line">    System.out.println(ts);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ti : arr) &#123;</span><br><span class="line">    System.out.println(ti);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id10"><span></span></span></p>
<h3 id="10-HashSet类"><a href="#10-HashSet类" class="headerlink" title="10. HashSet类"></a>10. HashSet类</h3><ol>
<li>HashSet集合底层采用HashMap（数组+链表–&gt;散列表），java.util包。</li>
<li>它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 </li>
<li>创建对象：无参数，有参数</li>
<li>集合容器的基本使用<ul>
<li>增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)</li>
<li>没有修改方法</li>
<li>iterator()  获取一个迭代器对象</li>
<li>size()</li>
</ul>
</li>
<li>无重复的原则<ul>
<li>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li>
</ul>
</li>
</ol>
<p><span id="id11"><span></span></span></p>
<h3 id="11-TreeSet类"><a href="#11-TreeSet类" class="headerlink" title="11. TreeSet类"></a>11. TreeSet类</h3><ol>
<li><p>TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))</p>
</li>
<li><p>创建对象： 无参数构造方法 ，带Collection构造方法</p>
</li>
<li><p>基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()</p>
</li>
<li><p>二叉树主要指每个节点最多只有两个子节点的树形结构。</p>
</li>
<li><p>满足以下三个特征的二叉树叫做<strong>有序二叉树</strong>：</p>
<ul>
<li>左子树中的任意节点元素都小于根节点元素；</li>
<li>右子树中的任意节点元素都大于根节点元素；</li>
<li>左子树和右子树内部也遵守上述规则；</li>
</ul>
</li>
<li><p>无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。</p>
</li>
<li><p>元素放入TreeSet集合过程：<br>由于TreeSet集合底层采用<strong>有序二叉树</strong>进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：</p>
<ol>
<li>使用元素的<strong>自然排序</strong>规则进行比较并排序，让元素类型实现java.lang.Comparable接口；</li>
<li>使用<strong>比较器规则</strong>进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；</li>
</ol>
</li>
</ol>
<blockquote>
<p>注意：<br>    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；<br>    2. 可以使用Collections工具类对集合中的元素进行操作；</p>
</blockquote>
<p><span id="id12"><span></span></span></p>
<h3 id="12-Map集合"><a href="#12-Map集合" class="headerlink" title="12. Map集合"></a>12. Map集合</h3><ul>
<li>java.util.Map&lt;K, V&gt;集合存取元素的基本单位是：单对元素（键值对key-value）。</li>
<li>Map：映射，通过某一个key可以直接定位到一个value值</li>
<li>key无序无重复   value无序可重复<ul>
<li>key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致</li>
</ul>
</li>
<li>主要有两个实现类：<code>HashMap类</code>和<code>TreeMap类</code>。</li>
<li>Map基本使用：HashMap，TreeMap，Properties</li>
<li>Map集合常用方法：<ul>
<li>增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)</li>
</ul>
</li>
<li>Map集合的遍历方式：a.迭代Key，b.迭代Entry</li>
<li>Map集合的性能调优：<ul>
<li>加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）</li>
</ul>
</li>
</ul>
<p><span id="id13"><span></span></span></p>
<h3 id="13-HashMap类"><a href="#13-HashMap类" class="headerlink" title="13. HashMap类"></a>13. HashMap类</h3><ol>
<li>包:java.util，底层散列表的形式（数组+链表）</li>
<li>构造方法创建对象   无参数  带默认容量的  带map参数的构造方法</li>
<li>特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复<ul>
<li>找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry</li>
</ul>
</li>
<li>基本方法：<ul>
<li>增 put(key,value)，存放一组映射关系key-value<ol>
<li>key存储的顺序与取得顺序不同</li>
<li>不同的key可以存储相同的value</li>
<li>key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)</li>
</ol>
</li>
<li>删 E = remove(key);</li>
<li>改 replace(key,newValue)，put(key,value2)</li>
<li>查 E = get(key)；</li>
<li>Set<key> = keySet()获取全部的key</key></li>
<li>Set<entry> = entrySet();</entry></li>
<li>size();</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();<span class="comment">//获取集合中全部的entry对象</span></span><br><span class="line">Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = entrys.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Entry&lt;Integer,String&gt; entry = it.next();<span class="comment">//entry  key value</span></span><br><span class="line">    Integer key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">"--"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>除了上述几个常用的方法外  其他API中提供的方法<ul>
<li>clear，containsKey(key)，containsValue(value)</li>
<li>getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值</li>
<li>isEmpty()</li>
<li>putAll(map)</li>
<li>putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦</li>
</ul>
</li>
<li>map集合在什么情形下用?<ol>
<li>想要存储一组元素<ul>
<li>数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合</li>
</ul>
</li>
<li>如果发现长度以后不确定—&gt;集合</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">list</th>
<th align="center">Set</th>
<th align="center">Map</th>
</tr>
</thead>
<tbody><tr>
<td align="center">List家族有序的</td>
<td align="center">Set家族无重复</td>
<td align="center">Map家族k-v</td>
</tr>
<tr>
<td align="center">存储有顺序用这个</td>
<td align="center">存储元素希望自动去掉重复元素用这个</td>
<td align="center">通过唯一的k快速找寻v用这个</td>
</tr>
<tr>
<td align="center">ArrayList:更适合遍历轮询</td>
<td align="center">HashSet:性能更高</td>
<td align="center">HashMap:性能更高</td>
</tr>
<tr>
<td align="center">LinkedList:更适合插入和删除</td>
<td align="center">TreeSet:希望存进去的元素自动去重复,同时还能自动排序</td>
<td align="center">Tree:希望存进去的元素key自动排序</td>
</tr>
<tr>
<td align="center">Stack:LIFO</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p><span id="id14"><span></span></span></p>
<h3 id="14-TreeMap类"><a href="#14-TreeMap类" class="headerlink" title="14. TreeMap类"></a>14. TreeMap类</h3><ol>
<li>java.util包</li>
<li>构造方法：无参数，带map参数</li>
<li>常用方法：put， get，remove，replace，size</li>
<li>底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）</li>
<li>自然有序，按照Unicode编码自然有序<ul>
<li>ap集合中的key需要可比较的   key的对象需要实现Comparable接口</li>
</ul>
</li>
</ol>
<p><span id="id15"><span></span></span></p>
<h3 id="15-Lambda表达式"><a href="#15-Lambda表达式" class="headerlink" title="15. Lambda表达式"></a>15. Lambda表达式</h3><ul>
<li>java8支持的新的语法格式，Lambda允许<code>把函数作为一个方法的参数</code>(函数作为参数传递进方法中)，使用lambda表达式可以<code>使代码变得更加简洁紧凑</code>。</li>
<li>函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。</li>
<li>lambda表达式语法由<strong>参数列表</strong>、<strong>箭头函数<code>-&gt;</code></strong>和<strong>函数体</strong>组成，函数体即可以是一个表达式，也可以是一个语句块。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int a, int b) -&gt; a+b</span><br><span class="line">() -&gt; 42</span><br><span class="line">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。</li>
<li>jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。</li>
</ul>
<h4 id="15-1-Lambda表达式-方法引用"><a href="#15-1-Lambda表达式-方法引用" class="headerlink" title="15.1 Lambda表达式-方法引用"></a>15.1 Lambda表达式-方法引用</h4><ul>
<li>方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</li>
<li>方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。</li>
</ul>
<p><span id="id16"><span></span></span></p>
<h3 id="16-Stream-API"><a href="#16-Stream-API" class="headerlink" title="16. Stream API"></a>16. Stream API</h3><ul>
<li><p>Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。</p>
</li>
<li><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p>
<ul>
<li><strong>无存储</strong>。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li><strong>为函数式编程而生</strong>。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li>
<li><strong>惰式执行</strong>。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li><strong>可消费性</strong>。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
</li>
<li><p>对stream的操作分为为两类，中间操作和结束操作，二者特点是：</p>
<ul>
<li><strong>中间操作</strong>总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li>
<li><strong>结束操作</strong>会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>
</ul>
</li>
</ul>
<h4 id="16-1-stream方法使用"><a href="#16-1-stream方法使用" class="headerlink" title="16.1 stream方法使用"></a>16.1 stream方法使用</h4><ul>
<li>stream跟<strong>函数接口</strong>关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三、JavaSE核心工具类]]></title>
      <url>http://chaooo.github.io/2019/07/08/03_JavaSE%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%B1%BB.html</url>
      <content type="html"><![CDATA[<p>API (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">Object类与其常用方法</a></li>
<li><a href="#id2">包装类</a></li>
<li><a href="#id3">数学处理类</a></li>
<li><a href="#id4">Scanner类和System类</a></li>
<li><a href="#id5">日期类</a></li>
<li><a href="#id6">String类</a></li>
<li><a href="#id7">StringBuilder类/StringBuffer类</a></li>
<li><a href="#id8">Optional类</a></li>
</ol>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ul>
<li>java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类…</li>
<li>java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类…</li>
<li>java.io包：是输入输出包，包括读写各种设备。</li>
<li>java.net包：是网络编程的包，包括各种网络编程。</li>
<li>java.sql包：是操作数据库的所有类和接口。</li>
</ul>
<p><span id="id1"><span></span></span></p>
<h3 id="1-Object类与其常用方法"><a href="#1-Object类与其常用方法" class="headerlink" title="1. Object类与其常用方法"></a>1. Object类与其常用方法</h3><h4 id="1-1-Object类"><a href="#1-1-Object类" class="headerlink" title="1.1 Object类"></a>1.1 Object类</h4><ul>
<li>java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。</li>
<li>Object定义了“对象”的基本行为，被子类默认继承。</li>
</ul>
<h4 id="1-2-equals-和-hashCode"><a href="#1-2-equals-和-hashCode" class="headerlink" title="1.2 equals() 和 hashCode()"></a>1.2 equals() 和 hashCode()</h4><ul>
<li>boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。</li>
<li>equals()方法要求：自反性/对称性/传递性/一致性/非空性。</li>
<li>Java类可以根据需要重写继承自Object的equals()方法。</li>
</ul>
<blockquote>
<p>注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
</blockquote>
<ul>
<li><p>int hashCode():返回对象的哈希码值，对应一个内存。</p>
</li>
<li><p>hashCode规范要求：</p>
<ul>
<li>一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的</li>
<li>如果两个对象判定相等，它们的hashCode应该时同一个值</li>
<li>如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。</li>
</ul>
</li>
<li><p>hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。</p>
</li>
</ul>
<h4 id="1-3-toString"><a href="#1-3-toString" class="headerlink" title="1.3 toString()"></a>1.3 toString()</h4><ul>
<li>String toString()：用于获取调用对象的字符串形式，返回”包名.类名@hashCode值的16进制”。</li>
<li>Java类可以根据需要重写toString方法返回更有意义的信息。</li>
<li>Java在使用System.out.println()打印对象时或者<code>+</code>连接字符串时，默认调用toString()方法。</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2. 包装类"></a>2. 包装类</h3><h4 id="2-1-包装类"><a href="#2-1-包装类" class="headerlink" title="2.1 包装类"></a>2.1 包装类</h4><ul>
<li>由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。</li>
<li>Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。</li>
</ul>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>java.lang.Byte</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character</td>
</tr>
</tbody></table>
<ol>
<li>八个包装类都在同一个包下（java.lang包），不需要import导包直接使用</li>
<li>八个包装类中有六个是与数字相关，都默认继承父类Number</li>
<li>八个包装类都实现了Serializable, Comparable</li>
<li>八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型</li>
<li>八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型</li>
</ol>
<h4 id="2-2-Integer类"><a href="#2-2-Integer类" class="headerlink" title="2.2 Integer类"></a>2.2 Integer类</h4><ul>
<li>java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。</li>
<li>Integer类重写了<strong>equals()</strong>方法（重写后比较的是数值）、hashCode()以及toString()方法。</li>
</ul>
<table>
<thead>
<tr>
<th>Integer类的常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Integer(int i)</td>
<td>根据参数指定整数来构造对象</td>
</tr>
<tr>
<td>Integer(String s)</td>
<td>根据参数指定的字符串来构造对象</td>
</tr>
<tr>
<td>int intValue()</td>
<td>获取调用对象中整数值并返回</td>
</tr>
<tr>
<td>static Integer valueOf(int i)</td>
<td>根据参数指定整数值得到Integer类型对象</td>
</tr>
<tr>
<td>static int parseInt(String s)</td>
<td>将字符串类型转换为int类型并返回</td>
</tr>
</tbody></table>
<h4 id="2-3-装箱和拆箱"><a href="#2-3-装箱和拆箱" class="headerlink" title="2.3 装箱和拆箱"></a>2.3 装箱和拆箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer it = Integer.valueOf(i); <span class="comment">//实现了int类型到Integer类型的转换，这个过程叫做装箱</span></span><br><span class="line"><span class="keyword">int</span> ia = it.intValue();<span class="comment">//实现了Integer类型到int类型的转换，这个过程叫做拆箱</span></span><br><span class="line"><span class="comment">//jdk5增加了自动拆箱和装箱功能（编译器预处理）:</span></span><br><span class="line">Integer i = <span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> ia = i;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>

<ul>
<li>笔试考点：<blockquote>
<ul>
<li>在Integer类部提供了自动装箱池技术，将<strong>-128~127间的整数已经装箱完毕</strong>，当使用该范围整数时直接取池中的对象即可，从而提高效率。</li>
<li>Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Integer it1 = <span class="number">128</span>;</span><br><span class="line">Integer it2 = <span class="number">128</span>;</span><br><span class="line">Integer it3 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">Integer it4 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">System.out.println(it1.equals(it2));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(it1 == it2);<span class="comment">//比较地址 false</span></span><br><span class="line">System.out.println(it3.equals(it4));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(it3 == it4);<span class="comment">//比较地址 false</span></span><br><span class="line"></span><br><span class="line">Integer it5 = <span class="number">127</span>;</span><br><span class="line">Integer it6 = <span class="number">127</span>;</span><br><span class="line">Integer it7 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer it8 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">System.out.println(it5.equals(it6));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(it5 == it6);<span class="comment">//比较地址 true, 自动装箱池范围-128~127。</span></span><br><span class="line">System.out.println(it7.equals(it8));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(it7 == it8);<span class="comment">//比较地址 false</span></span><br></pre></td></tr></table></figure>

<p><span id="id3"><span></span></span></p>
<h3 id="3-数学处理类"><a href="#3-数学处理类" class="headerlink" title="3. 数学处理类"></a>3. 数学处理类</h3><ul>
<li>java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。</li>
</ul>
<table>
<thead>
<tr>
<th>常用的方法</th>
<th>返回值类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Math.abs()</td>
<td></td>
<td>返回给定数字的绝对值(参数 int long float double)</td>
</tr>
<tr>
<td>Math.ceil()</td>
<td>double</td>
<td>向上取整</td>
</tr>
<tr>
<td>Math.floor()</td>
<td>double</td>
<td>向下取整</td>
</tr>
<tr>
<td>Math.rint()</td>
<td>double</td>
<td>临近的整数 如果两边距离一样 则返回偶数</td>
</tr>
<tr>
<td>Math.round()</td>
<td>int</td>
<td>四舍五入的整数</td>
</tr>
<tr>
<td>Math.max(a,b)/min(a,b)</td>
<td></td>
<td>(参数int  long  float  double)</td>
</tr>
<tr>
<td>Math.pow(a,b)</td>
<td>double</td>
<td>a的b次方  (参数double 返回值double)</td>
</tr>
<tr>
<td>Math.sqrt(double a)</td>
<td></td>
<td>获取给定参数的平方根</td>
</tr>
<tr>
<td>Math.random()</td>
<td>double</td>
<td>随机产生一个[0.0–1.0)</td>
</tr>
</tbody></table>
<ul>
<li>0-9之间的随机整数：int value = (int)<strong>(Math.random()*10</strong>);</li>
<li>Math.random()计算小数的时候精确程度可能有些损失</li>
</ul>
<h4 id="3-1-Random类"><a href="#3-1-Random类" class="headerlink" title="3.1 Random类"></a>3.1 Random类</h4><ul>
<li>java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>
</ul>
<table>
<thead>
<tr>
<th>常用的方法</th>
<th>Random r = new Random();</th>
</tr>
</thead>
<tbody><tr>
<td>r.nextInt();</td>
<td>随机产生 int取值范围的整数 有正有负(<code>-2^31</code>~<code>2^31-1</code>即<code>正负21亿</code>之间)</td>
</tr>
<tr>
<td>r.nextInt(int bound);</td>
<td>随机产生一个[0–bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException</td>
</tr>
<tr>
<td>r.nextFloat()</td>
<td>随机产生一个 [0.0—1.0)</td>
</tr>
<tr>
<td>r.nextBoolean()</td>
<td>随机产生一个boolean值   true  false</td>
</tr>
</tbody></table>
<h4 id="3-2-UUID类"><a href="#3-2-UUID类" class="headerlink" title="3.2 UUID类"></a>3.2 UUID类</h4><ul>
<li>java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>
<li>只有有参构造方法，我们通常不会创建对象</li>
<li>UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key</li>
<li>产生一个32位的随机元素 每一个位置是一个16进制的数字</li>
</ul>
<h4 id="3-3-BigDecimal"><a href="#3-3-BigDecimal" class="headerlink" title="3.3 BigDecimal"></a>3.3 BigDecimal</h4><ul>
<li>java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number</li>
<li>Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。</li>
<li>提供的构造方法全部都是带参数的<ul>
<li>通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(“1.23”);</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>BigDecimal类的常用方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>BigDecimal(String val)</td>
<td>根据参数指定的字符串来构造对象</td>
</tr>
<tr>
<td>BigDecimal    setScale(int newScale, RoundingMode roundingMode)</td>
<td>两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)</td>
</tr>
<tr>
<td>BigDecimal <strong>add</strong>(BigDecimal augend)</td>
<td>用于实现<strong>加法</strong>运算</td>
</tr>
<tr>
<td>BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)</td>
<td>用于实现<strong>减法</strong>运算</td>
</tr>
<tr>
<td>BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)</td>
<td>用于实现<strong>乘法</strong>运算</td>
</tr>
<tr>
<td>BigDecimal <strong>divide</strong>(BigDecimal divisor)</td>
<td>用于实现<strong>除法</strong>运算，也可传入更多参数设置保留小数点位数和取值模式</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">"3.0"</span>);</span><br><span class="line">BigDecimal d4 = <span class="keyword">new</span> BigDecimal(<span class="string">"2.9"</span>);</span><br><span class="line">System.out.println(d3.add(d4));<span class="comment">//加：5.9</span></span><br><span class="line">System.out.println(d3.subtract(d4));<span class="comment">//减：0.1</span></span><br><span class="line">System.out.println(d3.multiply(d4));<span class="comment">//乘：8.70</span></span><br><span class="line">System.out.println(d3.divide(d4, <span class="number">8</span>, BigDecimal.ROUND_HALF_UP));<span class="comment">//除：1.03448276</span></span><br></pre></td></tr></table></figure>

<p>对于divide方法，通常需要制定<strong>精度和舍入模式</strong>，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。</p>
<h4 id="3-4-BigInteger"><a href="#3-4-BigInteger" class="headerlink" title="3.4 BigInteger"></a>3.4 BigInteger</h4><ul>
<li>java.math.BigInteger类处理大整数，需要import导入，继承自Number</li>
<li>java提供的整数类型(int\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 </li>
<li>如何创建对象，提供的构造方法全部都是带参数的<ul>
<li>通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(“123”);</li>
</ul>
</li>
<li>和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。</li>
</ul>
<h4 id="3-5-DecimalFormat类"><a href="#3-5-DecimalFormat类" class="headerlink" title="3.5 DecimalFormat类"></a>3.5 DecimalFormat类</h4><ul>
<li>所属的包 java.text，import导入才能使用</li>
<li>通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//调用format方法将一个小数格式化成一个字符串</span></span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"000.000"</span>);</span><br><span class="line">System.out.println(df.format(<span class="number">12.45</span>)); <span class="comment">//012.450</span></span><br><span class="line">System.out.println(df.format(<span class="number">12345.6789</span>)); <span class="comment">//12345.679</span></span><br><span class="line"></span><br><span class="line">DecimalFormat df2 = <span class="keyword">new</span> DecimalFormat(<span class="string">"###.###"</span>);</span><br><span class="line">System.out.println(df2.format(<span class="number">12.45</span>)); <span class="comment">//12.45</span></span><br><span class="line">System.out.println(df2.format(<span class="number">12345.6789</span>)); <span class="comment">//12345.679</span></span><br><span class="line"></span><br><span class="line">DecimalFormat df3 = <span class="keyword">new</span> DecimalFormat(<span class="string">"000.###"</span>);</span><br><span class="line">System.out.println(df3.format(<span class="number">12.45</span>)); <span class="comment">//012.45</span></span><br><span class="line">System.out.println(df3.format(<span class="number">12345.6789</span>)); <span class="comment">//12345.679</span></span><br></pre></td></tr></table></figure>

<p><span id="id4"><span></span></span></p>
<h3 id="4-Scanner类和System类"><a href="#4-Scanner类和System类" class="headerlink" title="4. Scanner类和System类"></a>4. Scanner类和System类</h3><h4 id="4-1-Scanner类"><a href="#4-1-Scanner类" class="headerlink" title="4.1 Scanner类"></a>4.1 Scanner类</h4><ol>
<li>所属的包java.util包  需要import导包</li>
<li>通过一个带输入流的构造方法创建对象</li>
<li>常用方法    nextInt()  nextFloat()   next()   nextLine()</li>
</ol>
<h4 id="4-1-System类"><a href="#4-1-System类" class="headerlink" title="4.1 System类"></a>4.1 System类</h4><ol>
<li>所属的包java.lang包 不需要导入</li>
<li>不需要创建对象  通过类名就可以访问</li>
<li>有三个属性及若干的方法<ul>
<li>三个属性out   in   err</li>
<li>方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;</li>
</ul>
</li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-日期类"><a href="#5-日期类" class="headerlink" title="5. 日期类"></a>5. 日期类</h3><h4 id="5-1-Date类"><a href="#5-1-Date类" class="headerlink" title="5.1 Date类"></a>5.1 Date类</h4><ul>
<li>java.util.Date类表示特定的瞬间，精确到毫秒。</li>
<li>通常使用无参数的构造方法，或者带long构造方法</li>
<li>Date类中常用的方法<ul>
<li>before();  after();</li>
<li>setTime()  getTime();—–&gt;long</li>
<li>compareTo();   //-1  1  0</li>
</ul>
</li>
<li>Date类大多数用于进行时间分量计算的方法已经被Calender取代。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();<span class="comment">//当前日期信息</span></span><br><span class="line">    <span class="comment">//Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019</span></span><br><span class="line"><span class="keyword">long</span> time = date.getTime();<span class="comment">//1970年1月1日距今毫秒数。</span></span><br><span class="line">date.setTime(time + <span class="number">24</span>\*<span class="number">60</span>\*<span class="number">60</span>\*<span class="number">1000</span>);<span class="comment">//通过毫秒数设置时间</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-SimpleDateFormat类"><a href="#5-2-SimpleDateFormat类" class="headerlink" title="5.2 SimpleDateFormat类"></a>5.2 SimpleDateFormat类</h4><ul>
<li>java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类</li>
<li>其构造方法 SimpleDateFormat(String pattern)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日"</span>);</span><br><span class="line">String dateStr = sdf.format(date);</span><br><span class="line"><span class="comment">// format用于将日期按指定格式转换为字符串</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">"2013-01-06"</span>;</span><br><span class="line">SimpleDateFormat sdf2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">Date date2 = sdf2.parse(str);<span class="comment">//如果字符串格式不匹配将抛出异常</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用格式字符串</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
<td>yyyy年——2013年；yy——13年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
<td>MM月——01月；M月——1月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
<td>dd日——01日；d日——1日</td>
</tr>
<tr>
<td>H</td>
<td>小时(24)</td>
<td>HH:mm:ss—12:46:33</td>
</tr>
<tr>
<td>h</td>
<td>小时(12)</td>
<td>hh(a):mm:ss—12(下午):47:48</td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
<td>–</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
<td>–</td>
</tr>
</tbody></table>
<h4 id="5-3-Calendar类"><a href="#5-3-Calendar类" class="headerlink" title="5.3 Calendar类"></a>5.3 Calendar类</h4><ul>
<li>java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。</li>
<li>有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();</li>
<li>通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">c1.set(<span class="number">2008</span>,<span class="number">9</span>-<span class="number">1</span>,<span class="number">20</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">System.out.println(c1.getTime());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>常用方法</p>
<ul>
<li>after()  before()</li>
<li>setTime()  getTime()—-&gt;Date</li>
<li>getTimeInMillis()—-time</li>
<li>getTimeZone()—TimeZone</li>
<li>Calendar里面包含一个date属性  可以操作date的某一个局部信息</li>
<li>set   get<ul>
<li>calendar.set(Calendar.YEAR,2015);</li>
<li>int year = calendar.get(Calendar.YEAR);</li>
</ul>
</li>
</ul>
</li>
<li><p>TimeZone</p>
<ol>
<li>java.util包</li>
<li>可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();</li>
<li>常用方法<ul>
<li>tz.getID()       —-&gt;    Asia/Shanghai</li>
<li>tz.getDisplayName()    —-&gt;  中国标准时间</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><span id="id6"><span></span></span></p>
<h3 id="6-String类"><a href="#6-String类" class="headerlink" title="6. String类"></a>6. String类</h3><h4 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h4><ul>
<li>String类 —&gt; 引用类型  —&gt; java.lang包</li>
<li>没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<string></string></li>
<li>java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如”abc”等，任何一个字符对应2字节定长编码。</li>
<li>String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何构建对象</span></span><br><span class="line">String str1 = <span class="string">"abc"</span>; <span class="comment">//直接将字符串常量赋值给str   (字符串常量池)</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String();<span class="comment">//无参数构造方法创建空的对象</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);<span class="comment">//带string参数的构造方法创建对象</span></span><br><span class="line"><span class="keyword">byte</span>[] bArr = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>&#125;;<span class="comment">//a:97，b:98，c:99，d:100</span></span><br><span class="line">String str4 = <span class="keyword">new</span> String(bArr);<span class="comment">//将数组中的每一个元素转化成对应的char 组合成String</span></span><br><span class="line"><span class="keyword">char</span>[] cArr = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line">String str5 = <span class="keyword">new</span> String(cArr);<span class="comment">//将数组中的每一个char元素拼接成最终的String</span></span><br><span class="line">String str6 = String(<span class="keyword">char</span>[], index, count);<span class="comment">//使用char数组中下标从index位置开始的count个字符来构造对象</span></span><br><span class="line">String str7 = String(<span class="keyword">byte</span>[], index, length);<span class="comment">//使用byte数组下标从index位置开始length个字节来构造对象</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-字符串常量池"><a href="#6-2-字符串常量池" class="headerlink" title="6.2 字符串常量池"></a>6.2 字符串常量池</h4><ul>
<li>由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。</li>
<li>出于性能考虑，Java虚拟机(JVM)将<strong>字符串字面量对象</strong>缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">String str2 = <span class="string">"Hello"</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//比较地址 true，不会重新创建</span></span><br><span class="line">System.out.println(str1.equals(str3));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//比较地址 false，使用new会重新创建新的String对象</span></span><br><span class="line">    <span class="comment">//1.下面的代码中创建了几个对象并分别存放在什么位置？</span></span><br><span class="line">String s1 = <span class="string">"hello"</span>; <span class="comment">//1个对象，常量池。</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"world"</span>); <span class="comment">//2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-String类常用方法"><a href="#6-3-String类常用方法" class="headerlink" title="6.3 String类常用方法"></a>6.3 String类常用方法</h4><ol>
<li>第一梯队(重写): equals  hashCode  compareTo  toString</li>
<li>第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。</li>
<li>第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。</li>
</ol>
<ul>
<li>重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口<ol>
<li>boolean = equals(Object obj);<ul>
<li>继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;</li>
</ul>
</li>
<li>int = hashCode();<ul>
<li>继承自Object类中的方法，重写了：31*h+和…</li>
</ul>
</li>
<li>int = compareTo();<ul>
<li>实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差</li>
</ul>
</li>
<li>String = toString()<ul>
<li>Object类中返回类名@hashCode(16进制形式)</li>
<li>String类重写后返回的是String对象的字面值</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();</p>
</blockquote>
<table>
<thead>
<tr>
<th>String类的成员方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>char charAt(int index)</td>
<td>返回字符串指定位置</td>
</tr>
<tr>
<td>int codePointAt(int index)</td>
<td>“abc”0–&gt;97，返回给定index对应位置的那个char所对应的code码</td>
</tr>
<tr>
<td>String concat(String)</td>
<td>将给定的字符串拼接在当前字符串之后</td>
</tr>
<tr>
<td>int length()</td>
<td>返回字符串序列的长度</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：区别数组的length是属性，String的length()是方法，集合是size()方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String str6 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(<span class="string">"下标为0的字符是："</span>+str6.charAt(<span class="number">0</span>));<span class="comment">// h</span></span><br><span class="line">System.out.println(<span class="string">"字符串长度是："</span>+str6.length());<span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串"12345"转换为整数类型</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//方式一：Integer类中的pareseInt方法</span></span><br><span class="line"><span class="keyword">int</span> ia = Integer.parseInt(str);</span><br><span class="line">System.out.println(<span class="string">"转换出来结果是："</span>+ ia);<span class="comment">//123456</span></span><br><span class="line">    <span class="comment">//方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">    res = res*<span class="number">10</span> + (str.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"转换出来结果是："</span>+ res);<span class="comment">//123456</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>String类的常用基本方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>boolean contains(CharSequence s)</td>
<td>判断当前字符串是否包含参数指定的内容</td>
</tr>
<tr>
<td>String toLowerCase()</td>
<td>返回小写形式</td>
</tr>
<tr>
<td>String toUpperCase()</td>
<td>返回大写形式</td>
</tr>
<tr>
<td>String trim()</td>
<td>返回去掉前后空格的字符串</td>
</tr>
<tr>
<td>boolean startsWith(String prefix)</td>
<td>判断是否以参数字符开头</td>
</tr>
<tr>
<td>boolean endsWith(String suffix)</td>
<td>判断是否以参数字符结尾</td>
</tr>
<tr>
<td>boolean equals(Object anObject)</td>
<td>比较字符串内容是否相等，String类已重写</td>
</tr>
<tr>
<td>boolean equalsIgnoreCase(String anotherString)</td>
<td>同上，并且忽略大小写</td>
</tr>
<tr>
<td>int indexOf(String str)</td>
<td>返回第一次出现str位置，找不到返回-1</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)</td>
<td>同上，从fromIndex开始检索</td>
</tr>
<tr>
<td>String substring(int beginIndex, int endIndex)</td>
<td>截取字符串，beginIndex开始，endIndex结束</td>
</tr>
<tr>
<td>String substring(int beginIndex)</td>
<td>截取字符串，beginIndex开始到结尾</td>
</tr>
</tbody></table>
<h4 id="6-4-正则相关方法"><a href="#6-4-正则相关方法" class="headerlink" title="6.4 正则相关方法"></a>6.4 正则相关方法</h4><ul>
<li>正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。</li>
</ul>
<table>
<thead>
<tr>
<th>正则相关方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>boolean matches(String regex)</td>
<td>用于判断是否匹配正则表达式规则。</td>
</tr>
<tr>
<td>String[] split(String regx)</td>
<td>以正则为分割符，将字符串拆分成字符串数组</td>
</tr>
<tr>
<td>String replaceAll(String regex, String replacement)</td>
<td>正则替换</td>
</tr>
</tbody></table>
<p><span id="id7"><span></span></span></p>
<h3 id="7-StringBuilder类-StringBuffer类"><a href="#7-StringBuilder类-StringBuffer类" class="headerlink" title="7. StringBuilder类/StringBuffer类"></a>7. StringBuilder类/StringBuffer类</h3><h4 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h4><ol>
<li>java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。</li>
<li>StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable<ul>
<li>StringBuffer/StringBuilder没有compareTo方法</li>
<li>StringBuffer/StringBuilder含有一个String没有的方法 append();拼接</li>
</ul>
</li>
</ol>
<h4 id="7-2-特性"><a href="#7-2-特性" class="headerlink" title="7.2 特性"></a>7.2 特性</h4><p>可变字符串，char[] value;  动态扩容</p>
<h4 id="7-3-对象的构建"><a href="#7-3-对象的构建" class="headerlink" title="7.3 对象的构建"></a>7.3 对象的构建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//无参数构造方法  构建一个默认长度16个空间的对象  char[]</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//利用给定的参数 构建一个自定义长度空间的对象 char[]</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//利用带String参数的构造方法  默认数组长度字符串长度+16个</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="7-4-StringBuilder中常用的方法"><a href="#7-4-StringBuilder中常用的方法" class="headerlink" title="7.4 StringBuilder中常用的方法"></a>7.4 StringBuilder中常用的方法</h4><ul>
<li>最主要的方法 <strong>append()</strong> 频繁的拼接字符串的时候使用此方法 提高性能</li>
<li>ensureCapacity(int minimumCapacity)  确保底层数组容量够用</li>
<li>capacity();//字符串底层char[]的容量</li>
<li>length();//字符串有效元素个数(长度)</li>
<li>setLength();//设置字符串的有效元素个数</li>
<li>char = charAt(int index);</li>
<li>int = codePointAt(int index);</li>
<li>String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果</li>
<li>StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦</li>
<li>StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦</li>
<li>int = indexOf(String str [,int fromIndex]);</li>
<li>int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找</li>
<li>insert(int index,value);//将给定的value插入在index位置之上</li>
<li>replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,”zzt”);</li>
<li>setCharAt(int index,char value);//将index位置的字符改成给定的value</li>
<li>toString();//将StringBuilder对象 构建成一个string对象 返回</li>
<li>trimToSize();//将数组中无用的容量去掉  变成length长度的数组</li>
</ul>
<h4 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h4><ol>
<li>StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；</li>
<li>常用方法<ul>
<li>与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；</li>
<li>与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致</li>
<li>不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();</li>
</ul>
</li>
<li>String家族笔试中经常容易考察的知识点</li>
<li>String所属的包 继承关系 实现接口<ul>
<li>java.lang 继承Object 接口Serializable,CharSequence,Comparable</li>
</ul>
</li>
<li>String构建方式<ul>
<li>常量  构造方法  </li>
</ul>
</li>
<li>String对象内存结构<ul>
<li>字符串常量区  new堆内存对象</li>
<li>==  equals()区别</li>
<li>“a”+”b”+”c”</li>
</ul>
</li>
<li>String不可变特性<ul>
<li>长度及内容</li>
</ul>
</li>
<li>String中的常用方法<ul>
<li>concat();  toUpperCase();</li>
</ul>
</li>
<li>String和StringBuilder区别   |   String和StringBuffer区别<ul>
<li>String不可变字符串<ul>
<li>JDK1.0</li>
<li>有一个接口Comparable</li>
<li>不可变体现在长度及内容</li>
<li>有一些方法StringBuilder没有 concat  compareTo  toUpperCase</li>
</ul>
</li>
<li>StringBuilder可变字符串<ul>
<li>JDK1.5</li>
<li>有一个接口Appendable</li>
<li>可变字符串  没有final修饰  底层可以进行数组扩容</li>
<li>有一些方法String没有  append() insert() delete() reverse()</li>
</ul>
</li>
</ul>
</li>
<li>StringBuffer和StringBuilder的不同<ul>
<li>它们方法基本相同</li>
<li>StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低</li>
<li>StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高</li>
</ul>
</li>
</ol>
<p><span id="id8"><span></span></span></p>
<h3 id="8-Optional类"><a href="#8-Optional类" class="headerlink" title="8. Optional类"></a>8. Optional类</h3><ul>
<li>可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。</li>
<li>获取字符串长度：<ol>
<li>方式1：if(null==str){return 0;}else{return str.length();}</li>
<li>方式2：return Optional.ofNullable(str).map(String::length).orElse(0);</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取两个字符串长度和</span></span><br><span class="line">String str1 = <span class="string">"zhangsan"</span>;</span><br><span class="line">String str2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> str1Length = Optional.ofNullable(str1).map(String::length).orElse(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> str2Length = Optional.ofNullable(str2).map(String::length).orElse(<span class="number">0</span>);</span><br><span class="line">System.out.println(str1Length + str2Length);<span class="comment">//8，8+0</span></span><br><span class="line"><span class="comment">//步骤分解:</span></span><br><span class="line"><span class="comment">//构建Optional对象</span></span><br><span class="line">Optional&lt;String&gt; op1 = Optional.ofNullable(str1);</span><br><span class="line"><span class="comment">//将str1的长度的结果构建成Optional对象</span></span><br><span class="line">Optional&lt;Integer&gt; op2 = op1.map(String::length);</span><br><span class="line"><span class="comment">//如果长度不为空，则获取长度值，否则返回默认值</span></span><br><span class="line"><span class="keyword">int</span> len = op2.orElse(<span class="number">0</span>);</span><br><span class="line">System.out.println(len);<span class="comment">//8</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二、JavaSE面向对象]]></title>
      <url>http://chaooo.github.io/2019/07/07/02_JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
      <content type="html"><![CDATA[<p>面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。<br>Java中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">类与对象</a></li>
<li><a href="#id2">构造方法和方法重载</a></li>
<li><a href="#id3">this关键字</a></li>
<li><a href="#id4">方法的传递和递归</a></li>
<li><a href="#id5">封装</a></li>
<li><a href="#id6">static关键字</a></li>
<li><a href="#id7">单例设计模式</a></li>
<li><a href="#id8">继承（extends）</a></li>
<li><a href="#id9">方法的重写（Override）</a></li>
<li><a href="#id10">访问控制</a></li>
<li><a href="#id11">包（Package）</a></li>
<li><a href="#id12">final关键字</a></li>
<li><a href="#id13">对象的创建过程</a></li>
<li><a href="#id14">多态</a></li>
<li><a href="#id15">抽象类</a></li>
<li><a href="#id16">接口</a></li>
<li><a href="#id17">内部类</a></li>
<li><a href="#id18">回调模式</a></li>
<li><a href="#id19">抽象方法的笔试考点</a></li>
<li><a href="#id20">枚举类（enum）</a></li>
<li><a href="#id21">内存机制问题</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1. 类与对象"></a>1. 类与对象</h3><h4 id="1-1-类的定义"><a href="#1-1-类的定义" class="headerlink" title="1.1 类的定义"></a>1.1 类的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;类体&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类名由多个单词组成时，要求每个单词首字母大写</p>
</blockquote>
<h4 id="1-2-成员变量的定义"><a href="#1-2-成员变量的定义" class="headerlink" title="1.2 成员变量的定义"></a>1.2 成员变量的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123; 数据类型 成员变量名=初始值; ... &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>成员变量名由多个单词组成时，要求第二个起每个单词首字母大写</p>
</blockquote>
<h4 id="1-3-对象的创建"><a href="#1-3-对象的创建" class="headerlink" title="1.3 对象的创建"></a>1.3 对象的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。</p>
</blockquote>
<h4 id="1-4-引用"><a href="#1-4-引用" class="headerlink" title="1.4 引用"></a>1.4 引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名 引用变量名;</span><br><span class="line">Person p = <span class="keyword">new</span> Person(); <span class="comment">//声明person类型的引用p指向Person类型对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用变量名.成员变量名;</span><br><span class="line">p.name = <span class="string">'zhangsan'</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。</li>
<li>使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。</li>
</ul>
</blockquote>
<ul>
<li>除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。</li>
</ul>
<h4 id="1-5-成员方法"><a href="#1-5-成员方法" class="headerlink" title="1.5 成员方法"></a>1.5 成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    返回值类型 成员方法名(形参列表)&#123;方法体;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void</li>
<li>形参列表：数据类型 形参1, 数据类型 形参2, …</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-构造方法和方法重载"><a href="#2-构造方法和方法重载" class="headerlink" title="2. 构造方法和方法重载"></a>2. 构造方法和方法重载</h3><h4 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123; 构造方法名(形参列表)&#123;构造方法体;&#125; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造方法名与类名相同且没有返回值</li>
<li>当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。</li>
</ul>
<h4 id="2-2-默认构造方法"><a href="#2-2-默认构造方法" class="headerlink" title="2.2 默认构造方法"></a>2.2 默认构造方法</h4><ul>
<li>当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。</li>
<li>若类中出现自定义构造方法，则编译器不再提供构造方法。</li>
</ul>
<h4 id="2-3-方法重载（overload）"><a href="#2-3-方法重载（overload）" class="headerlink" title="2.3 方法重载（overload）"></a>2.3 方法重载（overload）</h4><p>在Java中，方法名相同，参数列表不同的方法构成重载关系。</p>
<ul>
<li>体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）</li>
<li>实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。</li>
</ul>
<p><span id="id3"><span></span></span></p>
<h3 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3. this关键字"></a>3. this关键字</h3><p>在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。</p>
<ul>
<li>使用方式：<ol>
<li>当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名</li>
<li>在构造方法的的第一行，可以调用本类中的其他构造方法。</li>
</ol>
</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-方法的传递和递归"><a href="#4-方法的传递和递归" class="headerlink" title="4. 方法的传递和递归"></a>4. 方法的传递和递归</h3><h4 id="4-1-传参"><a href="#4-1-传参" class="headerlink" title="4.1 传参"></a>4.1 传参</h4><ul>
<li>基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。</li>
<li>引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。</li>
<li>引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。</li>
</ul>
<h4 id="4-2-递归的调用"><a href="#4-2-递归的调用" class="headerlink" title="4.2 递归的调用"></a>4.2 递归的调用</h4><ul>
<li>递归是指方法体内部调用自身</li>
<li>必须有递归的规律和退出条件</li>
<li>使用递归必须使得问题简单化而不是复杂化</li>
<li>若递归影响到程序的执行性能时，则用递推取代之</li>
</ul>
<p><span id="id5"><span></span></span></p>
<h3 id="5-封装"><a href="#5-封装" class="headerlink" title="5. 封装"></a>5. 封装</h3><p>面向对象的三大特征：封装，继承，多态。</p>
<ul>
<li>封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断</li>
<li>封装基本流程：<ol>
<li>私有化成员变量(private)</li>
<li>提供公有的get、set方法，并在set方法体中进行合理性判断</li>
<li>在构方法中调用set方法进行合理值的判断</li>
</ol>
</li>
</ul>
<p><span id="id6"><span></span></span></p>
<h3 id="6-static关键字"><a href="#6-static关键字" class="headerlink" title="6. static关键字"></a>6. static关键字</h3><p>基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。</p>
<blockquote>
<p>为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。</p>
</blockquote>
<ul>
<li>static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)</li>
<li>特点<ul>
<li>静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问</li>
<li>静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突</li>
<li>静态元素只加载一次，全部类对象及类本身共享</li>
<li>静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存</li>
<li>非静态成员和静态成员都可以访问静态成员</li>
<li>静态成员不可以访问非静态成员</li>
<li>静态元素中不可出现this或super关键字，静态元素属于类的</li>
</ul>
</li>
</ul>
<p><span id="id7"><span></span></span></p>
<h3 id="7-单例设计模式"><a href="#7-单例设计模式" class="headerlink" title="7. 单例设计模式"></a>7. 单例设计模式</h3><p>基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编程实现Singleton类的封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sin = <span class="keyword">new</span> Singleton();<span class="comment">//2.提供本类的引用指向本类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//1.私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//3.提供公有的get方法将上述成员变量的数值返回出去</span></span><br><span class="line">        <span class="keyword">return</span> sin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现流程：<ol>
<li>私有化构造方法（private）</li>
<li>提供本类类型的引用指向本类类型对象（private static）</li>
<li>提供公有的get方法将上述对象return出去（public static）</li>
<li>实现方式：饿汉式和懒汉式，开发中推荐饿汉式。</li>
</ol>
</li>
</ul>
<p><span id="id8"><span></span></span></p>
<h3 id="8-继承（extends）"><a href="#8-继承（extends）" class="headerlink" title="8. 继承（extends）"></a>8. 继承（extends）</h3><ul>
<li>继承就是子类复用父类的代码，关键字extends表示类和类的继承关系</li>
<li>使用继承可以提高代码复用性、扩展性、以及可维护性。<ol>
<li>子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。</li>
<li>无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。</li>
<li>使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。</li>
<li>在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cricle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    Cricle()&#123;&#125;   <span class="comment">//编译器会加入无参的调用 super()。</span></span><br><span class="line">    Cricle(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> r)&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);  <span class="comment">//通过super关键字调用父类的构造方法。</span></span><br><span class="line">        setR(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id9"><span></span></span></p>
<h3 id="9-方法的重写（Override）"><a href="#9-方法的重写（Override）" class="headerlink" title="9. 方法的重写（Override）"></a>9. 方法的重写（Override）</h3><p>概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。<br><br>原则：</p>
<ol>
<li>要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。</li>
<li>要求访问权限不能变小，可以相同或变大</li>
<li>重写的方法不能抛出更大的异常</li>
</ol>
<p><span id="id10"><span></span></span></p>
<h3 id="10-访问控制"><a href="#10-访问控制" class="headerlink" title="10. 访问控制"></a>10. 访问控制</h3><ul>
<li>public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，</li>
<li>通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰</li>
</ul>
<table>
<thead>
<tr>
<th>访问控制符</th>
<th align="center">访问权限</th>
<th align="right">本类内部</th>
<th align="right">本类中的包</th>
<th align="right">子类</th>
<th align="right">其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td align="center">共有的</td>
<td align="right">Y</td>
<td align="right">Y</td>
<td align="right">Y</td>
<td align="right">Y</td>
</tr>
<tr>
<td>protected</td>
<td align="center">保护的</td>
<td align="right">Y</td>
<td align="right">Y</td>
<td align="right">Y</td>
<td align="right">N</td>
</tr>
<tr>
<td>不写</td>
<td align="center">默认的</td>
<td align="right">Y</td>
<td align="right">Y</td>
<td align="right">N</td>
<td align="right">N</td>
</tr>
<tr>
<td>private</td>
<td align="center">私有的</td>
<td align="right">Y</td>
<td align="right">N</td>
<td align="right">N</td>
<td align="right">N</td>
</tr>
</tbody></table>
<p><span id="id11"><span></span></span></p>
<h3 id="11-包（Package）"><a href="#11-包（Package）" class="headerlink" title="11. 包（Package）"></a>11. 包（Package）</h3><p>为了解决命名冲突问题，便于文件的管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名；</span><br><span class="line"><span class="keyword">package</span> 包名<span class="number">1</span>.包名<span class="number">2</span>.包名<span class="number">3</span>...包名n;</span><br><span class="line"><span class="comment">/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */</span></span><br><span class="line">org.apache.commons.lang.StringUtil;</span><br></pre></td></tr></table></figure>

<p><span id="id12"><span></span></span></p>
<h3 id="12-final关键字"><a href="#12-final关键字" class="headerlink" title="12. final关键字"></a>12. final关键字</h3><ol>
<li>final关键字修饰<strong>类</strong>体现该类<strong>不能被继承</strong>（防止滥用继承）。</li>
<li>final关键字修饰<strong>方法</strong>体现在该方法<strong>不能被重新，但可以被继承</strong>（防止不经意间造成的方法重写）。</li>
<li>final关键字修饰<strong>成员变量</strong>体现在改成员变量<strong>必须初始化且不能更改</strong>（防止不经意间造成的数据更改）。</li>
</ol>
<blockquote>
<p>扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用<strong><code>public static final</code></strong>共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。</p>
</blockquote>
<p><span id="id13"><span></span></span></p>
<h3 id="13-对象的创建过程"><a href="#13-对象的创建过程" class="headerlink" title="13. 对象的创建过程"></a>13. 对象的创建过程</h3><ul>
<li>单个对象的创建过程<ol>
<li>main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；</li>
<li>若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；</li>
<li>执行构造块中的代码可以对成员变量进行赋值；</li>
<li>执行构造方法体中的代码可以对成员变量进行再次赋值；</li>
<li>此时对象构造完毕，继续向下执行后续的代码；</li>
</ol>
</li>
<li>子类对象的创建过程<ol>
<li>main方法是程序的入口，先加载父类的的代码再加载子类的代码；</li>
<li>先执行父类静态代码块，再执行子类的静态代码块；</li>
<li>先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；</li>
<li>先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。</li>
</ol>
</li>
</ul>
<p><span id="id14"><span></span></span></p>
<h3 id="14-多态"><a href="#14-多态" class="headerlink" title="14. 多态"></a>14. 多态</h3><ol>
<li>语法：父类的引用指向子类的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类类型 引用变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">Person pw = <span class="keyword">new</span> Worker();</span><br><span class="line">pw.show();<span class="comment">//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多态的效果：<ol>
<li>父类的引用<strong>可以</strong>直接调用<strong>父类独有</strong>的方法。</li>
<li>父类的引用<strong>不可以</strong>直接调用<strong>子类独有</strong>的方法。</li>
<li>对于父类子类都有的<strong>非静态方法</strong>来说，编译阶段调用父类的，运行阶段调用子类重写后的。</li>
<li>对于父类子类都有的<strong>静态方法</strong>来说，只调用父类的。</li>
</ol>
</li>
<li>多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。</li>
<li>多态的表现形式<ol>
<li>多态的前提要有继承的关系</li>
<li>使用父类引用指向子类对象 Person p = new Teacher();//向上转型</li>
<li>该引用只能调用父类中定义的属性/方法</li>
<li>执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写</li>
<li>若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException</li>
</ol>
</li>
<li>引用数据类型之间的转换<ul>
<li>转换必须发生在父子类之间，否则编译报错。</li>
<li>自动类型转换：小到大，子类型向父类型的转换，eg:<code>Person pw = new Worker();</code>。</li>
<li>强制类型转换：大到小，父类型向子类型转换，eg:<code>((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法</code>。</li>
</ul>
</li>
<li>为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*语法格式：*/</span> 对象 <span class="keyword">instanceof</span> 类型  <span class="comment">//返回布尔值</span></span><br><span class="line"><span class="keyword">if</span>(pw <span class="keyword">instanceof</span> Teacher)&#123;</span><br><span class="line">    Teacher t = (Teacher) pw;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"转换会有异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>多态的使用场合：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过方法的参数传递形成多态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Shape s)</span></span>&#123;&#125;</span><br><span class="line">TestShape.draw(<span class="keyword">new</span> Rect(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在方法体中直接使用多态的语法格式。</span></span><br><span class="line">TestAbstrat ta = <span class="keyword">new</span> SubTestAbstract();</span><br><span class="line">ta.show();</span><br></pre></td></tr></table></figure>

<p><span id="id15"><span></span></span></p>
<h3 id="15-抽象类"><a href="#15-抽象类" class="headerlink" title="15. 抽象类"></a>15. 抽象类</h3><ol>
<li>基本概念<ul>
<li>用<strong>abstract</strong>关键字修饰的类称为抽象类。</li>
<li>抽象类不能实例化，抽象类的意义在于被继承。</li>
<li>抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。</li>
<li>抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123; <span class="comment">//一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;<span class="comment">//用abstract修饰的方法，称之为抽象方法，没有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注意：<ol>
<li>抽象类中可以有成员变量，成员方法，以及构造方法。</li>
<li>抽象类中可以没有抽象方法，也可以有抽象方法。</li>
<li>具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。</li>
<li>子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。</li>
<li>抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</li>
<li>推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。</li>
</ol>
</li>
</ol>
<blockquote>
<p>多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。</p>
</blockquote>
<p><span id="id16"><span></span></span></p>
<h3 id="16-接口"><a href="#16-接口" class="headerlink" title="16. 接口"></a>16. 接口</h3><ol>
<li>基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过<strong>interface</strong>关键字定义。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123; <span class="comment">//-通过interface关键字定义接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEF_SPEED=<span class="number">100</span>;<span class="comment">//-接口中不能定义成员变量，只能定义常量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//-接口中只可以定义没有实现的方法（可以省略public abstract）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一个类可以通过<strong>implements</strong>关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">implements</span> <span class="title">Runner</span>,... </span>&#123; <span class="comment">//与继承不同，可以实现多个接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">//该类需要实现接口中定义的所有方法</span></span><br><span class="line">        System.out.println(<span class="string">"run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runner ra = <span class="keyword">new</span> American();<span class="comment">//接口作为一种类型声明，并且声明的变量可以引用实现类的对象</span></span><br><span class="line">        ra.run();<span class="comment">//通过该变量可以调用该接口定义的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hunter</span> <span class="keyword">extends</span> <span class="title">Runner</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>类与接口的关系<ul>
<li>类和类使用<code>extends</code>继承，仅支持<strong>单继承</strong>。</li>
<li>接口和接口使用<code>extends</code>继承，支持多继承。</li>
<li>类使用<code>implements</code>实现接口，支持<strong>多实现</strong>。</li>
</ul>
</li>
<li>抽象类与接口的关系（笔试题）<ol>
<li>定义抽象类:<code>abstract class</code>，而定义接口:<code>interface</code>；</li>
<li>类继承抽象类:<code>extends</code>单继承，而类实现接口:<code>implements</code>多实现；</li>
<li>抽象类可以<code>有</code>构造方法，而接口<code>不能有</code>构造方法；</li>
<li>抽象类可以有<code>成员变量</code>，而接口只能有<code>常量</code>；</li>
<li>抽象类可以有<code>成员方法</code>，而接口只能有<code>抽象方法</code>；</li>
<li>抽象类中增加方法子类可以<code>不用重写</code>，而接口中增加方法子类<code>必须重写</code>；</li>
<li>从jdk1.8开始允许接口中有非抽象方法，但需要<code>default</code>关键字修饰。</li>
</ol>
</li>
</ol>
<p><span id="id17"><span></span></span></p>
<h3 id="17-内部类"><a href="#17-内部类" class="headerlink" title="17. 内部类"></a>17. 内部类</h3><ul>
<li>内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部</li>
<li>内部类定义在 类的内部 ，与类成员层次一致</li>
<li>内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）<ul>
<li>成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>
<li>局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>
<li>匿名内部类：成员匿名内部类，局部匿名内部类</li>
<li>静态内部类：成员静态内部类</li>
</ul>
</li>
</ul>
<h4 id="17-1-成员内部类"><a href="#17-1-成员内部类" class="headerlink" title="17.1 *成员内部类"></a>17.1 *成员内部类</h4><ul>
<li>将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>
<li>成员内部类可以与正常类一样 使用不同的修饰符来修饰</li>
<li>好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的</li>
<li>若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;</li>
<li>内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class</li>
</ul>
<h4 id="17-2-局部内部类"><a href="#17-2-局部内部类" class="headerlink" title="17.2 局部内部类"></a>17.2 局部内部类</h4><ul>
<li>将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>
<li>局部内部类像是一个局部的变量一样，不能用public protected private及static</li>
<li>只能用abstract或final</li>
<li>局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod</li>
<li>局部内部类使用的变量只能是final修饰</li>
</ul>
<h4 id="17-3-匿名内部类"><a href="#17-3-匿名内部类" class="headerlink" title="17.3 *匿名内部类"></a>17.3 *匿名内部类</h4><p>将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类<br><br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体<br><br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类<br><br>匿名类内部没有构造方法，也不能用任何修饰符来修饰</p>
<ul>
<li>当接口类型的引用作为方法的形参时，实参的传递方式有两种：<ol>
<li>自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。</li>
<li>直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubA</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这里自定义类实现接口并重写抽象方法！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        a.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ATest.test(new A());//报错，A是接口，不能new对象</span></span><br><span class="line">        <span class="comment">//-方式1：接口实现类的对象作为实参传递</span></span><br><span class="line">        ATest.test(<span class="keyword">new</span> ASub());<span class="comment">//接口类型引用指向实现类的对象，形成了多态。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//-方式2：匿名内部类</span></span><br><span class="line">        <span class="comment">// 接口/父类类型 引用变量名 = new 接口/父类类型() &#123;方法的重写&#125;;</span></span><br><span class="line">        A ta = <span class="keyword">new</span> A() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"这里是匿名内部类"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ATest.test(ta);<span class="comment">//得到接口类型的引用，再作为实参传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。</li>
<li>语法格式：<code>接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperType obj = <span class="keyword">new</span> SuperType(...)&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="17-4-静态内部类"><a href="#17-4-静态内部类" class="headerlink" title="17.4 静态内部类"></a>17.4 静态内部类</h4><ul>
<li>成员静态内部类</li>
<li>不需要外部类对象，通过正常的方式直接创建内部类</li>
<li>静态元素不能访问非静态成员(自己类和外部类)</li>
</ul>
<p><span id="id18"><span></span></span></p>
<h3 id="18-回调模式"><a href="#18-回调模式" class="headerlink" title="18. 回调模式"></a>18. 回调模式</h3><p>回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n, Action ac)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; ac.doSth();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    repeat(<span class="number">5</span>, <span class="keyword">new</span> Action()&#123;<span class="comment">//通过匿名内部类传递参数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id19"><span></span></span></p>
<h3 id="19-抽象方法的笔试考点"><a href="#19-抽象方法的笔试考点" class="headerlink" title="19. 抽象方法的笔试考点"></a>19. 抽象方法的笔试考点</h3><ul>
<li><code>abstract</code>与哪些关键字不能共存：<ol>
<li><code>final</code>关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。</li>
<li><code>static</code>关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。</li>
<li><code>private</code>关键字；因为private修饰的私有方法不能被继承，就不能重写，而<code>abstract</code>方法需要重写。</li>
</ol>
</li>
</ul>
<p><span id="id20"><span></span></span></p>
<h3 id="20-枚举类（enum）"><a href="#20-枚举类（enum）" class="headerlink" title="20. 枚举类（enum）"></a>20. 枚举类（enum）</h3><ul>
<li>一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来</li>
<li>创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum<e>&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</e></li>
<li>我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object</li>
<li>Enum类型，有两个属性<ul>
<li>name—–&gt;枚举对象的名字，name()获取name属性</li>
<li>ordinal—&gt;枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号</li>
</ul>
</li>
<li>一些常用的方法<ul>
<li>valueOf()   通过给定的name获取对应的枚举对象</li>
<li>values()     获取全部的枚举对象  —&gt; 返回一个数组  Day[]</li>
<li>compareTo()   可以比较两个枚举对象   int</li>
<li>toString()      由于这个方法没有final修饰  可以覆盖(重写)</li>
</ul>
</li>
<li>switch内部判断枚举的应用</li>
<li>我们也可以在enum中描述自己的一些属性或方法<ul>
<li>必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;</li>
<li>可以定义自己的属性</li>
<li>类创建的过程中  帮我们创建枚举类型的对象</li>
<li>需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day&#123;</span><br><span class="line">    <span class="comment">//描述了七个当前类的对象</span></span><br><span class="line">    monday(<span class="string">"星期一"</span>,<span class="number">1</span>),tuesday(<span class="string">"星期二"</span>,<span class="number">2</span>),wednesday,thursday,friday,saturday,sunday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String  name,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.index=index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span id="id21"><span></span></span></p>
<h3 id="21-内存机制问题"><a href="#21-内存机制问题" class="headerlink" title="21. 内存机制问题"></a>21. 内存机制问题</h3><ul>
<li>类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行</li>
<li>栈内存—&gt;Person p = new Person();—-&gt;堆内存    方法区—类模板<ul>
<li>栈内存—-变量空间,方法临时执行空间（从创建开始执行完毕,<strong>立即回收</strong>）</li>
<li>堆内存—-new申请对象空间（<strong>垃圾回收器GC</strong>,对象空间没有任何引用指向视为垃圾）</li>
<li>方法区—-常量  类模板  静态成员（有且只有一份,<strong>不回收</strong>）</li>
</ul>
</li>
<li>Runtime类(是单例模式)之中提供了几个管理内存的方法<ul>
<li>maxMemory</li>
<li>totalMemory</li>
<li>freeMemory</li>
<li>栈内存溢出错误StackOverflowError </li>
<li>堆内存溢出错误OutOfMemoryError</li>
</ul>
</li>
<li>Object类中有一个finalize方法  如果重写也能看见对象回收的效果</li>
<li>GC系统提供的一个线程    回收算法</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一、JavaSE语法基础]]></title>
      <url>http://chaooo.github.io/2019/07/07/01_JavaSE%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80.html</url>
      <content type="html"><![CDATA[<p>这是<strong>javaSE知识梳理</strong>的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。</p>
<a id="more"></a>

<ol>
<li><a href="#id1">数据类型</a></li>
<li><a href="#id2">变量与常量</a></li>
<li><a href="#id3">数据类型之间的转换</a></li>
<li><a href="#id4">运算符</a></li>
<li><a href="#id5">循环</a></li>
<li><a href="#id6">数组</a></li>
<li><a href="#id7">函数</a></li>
</ol>
<p><span id="id1"><span></span></span></p>
<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><h4 id="1-1-分为两大类："><a href="#1-1-分为两大类：" class="headerlink" title="1.1 分为两大类："></a>1.1 分为两大类：</h4><ol>
<li>基本数据类型：byte，short，int，long，float，double，boolean，char</li>
<li>引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface</li>
</ol>
<blockquote>
<p>注：<code>单个字节</code>表示<code>8位二进制</code>位，最左边表示符号位（0：正，1：负）。</p>
</blockquote>
<h4 id="1-2-整数类型（byte，short，int，long）"><a href="#1-2-整数类型（byte，short，int，long）" class="headerlink" title="1.2 整数类型（byte，short，int，long）"></a>1.2 整数类型（byte，short，int，long）</h4><ol>
<li><strong>byte</strong>： 1个字节，范围<code>-2^7~2^7-1</code>，即<code>-128~127</code>。</li>
<li><strong>short</strong>：2个字节，范围<code>-2^15~2^15-1</code>，即<code>-32768~32767</code>。</li>
<li><strong>int</strong>:   4个字节，范围<code>-2^31~2^31-1</code>，即<code>正负21亿</code>之间。</li>
<li><strong>long</strong>： 8个字节，范围<code>-2^63~2^63-1</code>，比int更大。如果要表示long直接量，需要<code>L</code>或<code>l</code>结尾。</li>
</ol>
<h4 id="1-3-浮点类型（float，double）"><a href="#1-3-浮点类型（float，double）" class="headerlink" title="1.3 浮点类型（float，double）"></a>1.3 浮点类型（float，double）</h4><ol>
<li><strong>float</strong>： 4个字节，单精度浮点数，取到<code>小数点后7</code>位有效数字。如果要表示float直接量，需要<code>F</code>或<code>f</code>结尾</li>
<li><strong>double</strong>：8个字节，双精度浮点数，取到<code>小数点后15</code>位有效数字。</li>
</ol>
<blockquote>
<p>扩展：浮点运算有时会有误差，为了实现精确运算可使用<code>java.math.BigDecimal</code>类型加以描述。</p>
</blockquote>
<h4 id="1-4-布尔类型（boolean）"><a href="#1-4-布尔类型（boolean）" class="headerlink" title="1.4 布尔类型（boolean）"></a>1.4 布尔类型（boolean）</h4><ol>
<li><strong>boolean</strong>：1个字节（未明确规定），值只有<code>true</code>和<code>false</code>。</li>
</ol>
<h4 id="1-5-字符类型（char）"><a href="#1-5-字符类型（char）" class="headerlink" title="1.5 字符类型（char）"></a>1.5 字符类型（char）</h4><ol>
<li><strong>char</strong>：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：’a’,’1’,’中’ 等。</li>
</ol>
<ul>
<li>开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号””引起来。</li>
<li>需记住的ASII码字符：’a’:97，’A’:65，’0’:48，空格:32，换行符:10</li>
<li>常用转义符(逃逸字符)：<code>\t</code>:制表符，<code>\n</code>:换行，<code>\&quot;</code>，<code>\&#39;</code>，<code>\\</code>:反斜杠本身，<code>\b</code>:回退一格，<code>\r</code>:回车</li>
<li>字符类型计算<ul>
<li>一个字符加一个数字，得到Unicode码表中那个数之后的字符</li>
<li>两个字符相减得到它们在表中的距离</li>
<li>char也可以和int之间相互赋值</li>
</ul>
</li>
</ul>
<p><span id="id2"><span></span></span></p>
<h3 id="2-变量与常量"><a href="#2-变量与常量" class="headerlink" title="2. 变量与常量"></a>2. 变量与常量</h3><h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><ul>
<li>常量是一个值，在程序运行的过程中不能再次发生改变</li>
<li>基本类型的值都可以认为是常量   4  3.4  ‘a’  true，String类(引用数据类型)值”abc”视为常量</li>
<li>常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit–int   64bit–double</li>
</ul>
<h4 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h4><ul>
<li>变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的</li>
<li>变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字</li>
<li>变量空间   里面只能存储一个内容(值/引用)</li>
<li>空间内的内容的类型与定义时一致 内容可以改变 </li>
<li>内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值</li>
</ul>
<h4 id="2-3-标识符（变量）命名规则"><a href="#2-3-标识符（变量）命名规则" class="headerlink" title="2.3 标识符（变量）命名规则"></a>2.3 标识符（变量）命名规则</h4><ol>
<li>必须字母，数字，下划线以及美元$等组成，且首位非数字。</li>
<li>不能使用Java语言中的关键字，如class，static，void，int等。</li>
<li>区分大小写，长度无限制，但不能过长，尽量见名知意。</li>
</ol>
<h4 id="2-3-命名的规约"><a href="#2-3-命名的规约" class="headerlink" title="2.3 命名的规约"></a>2.3 命名的规约</h4><ul>
<li>类名字：首字母大写，如果两个以上的单词，所有首字母都大写</li>
<li>变量名：首字母小写，如果两个以上的单词，之后的首字母大写</li>
<li>遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性</li>
</ul>
<p><span id="id3"><span></span></span></p>
<h3 id="3-数据类型之间的转换"><a href="#3-数据类型之间的转换" class="headerlink" title="3. 数据类型之间的转换"></a>3. 数据类型之间的转换</h3><h4 id="3-1-基本数据类型之间转换"><a href="#3-1-基本数据类型之间转换" class="headerlink" title="3.1 基本数据类型之间转换"></a>3.1 基本数据类型之间转换</h4><ol>
<li>自动类型转换：从小类型到大类型自动转换</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double</span><br><span class="line">          char -----^</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long big = 1024L\*1024\*1024;</span><br><span class="line">int i = (int)big;</span><br></pre></td></tr></table></figure>

<h4 id="3-2其他数据类型之间转换"><a href="#3-2其他数据类型之间转换" class="headerlink" title="3.2其他数据类型之间转换"></a>3.2其他数据类型之间转换</h4><ul>
<li>同种大数据类型之间才能发生转换</li>
<li>类型转换之前，保证大前提：同种大数据类型一致<ul>
<li>基本–基本   可以直接转换(自动 强制)</li>
<li>引用–引用   可以直接转化(自动 强制 – 上转型 下转型)</li>
<li>基本–引用   不可以直接进行转化(间接-桥梁-包装类)</li>
</ul>
</li>
<li>保证大数据类型一致的前提下(都是基本类型)</li>
</ul>
<ul>
<li><p>小数据类型一致:整型–&gt;整型 / 浮点–&gt;浮点</p>
<ul>
<li>比较内存空间的大小</li>
<li>大数据类型空间可以直接接受小数据类型的值(自动转换)</li>
<li>小数据类型空间不可以直接接受大数据类型的值(强制类型转换)</li>
<li>强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte a = 1;   int b = a;//自动直接转化就可以</span><br><span class="line">int a = 1;  byte b = (byte)a;//需要强制类型转换</span><br><span class="line">float x = 3.4F;   double y = x;//自动直接转化</span><br><span class="line">double x = 3.4; float y = (float)x;//强制转换</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>小数据类型不一致:整型–&gt;浮点</p>
<ul>
<li>比较精确程度</li>
<li>浮点型的精确程度更高</li>
<li>任何一个浮点型空间都可以直接接受一个整型的值</li>
<li>反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;  float b = a;//自动直接转化</span><br><span class="line">float a =1.0F;  int b = (int)a;//强制类型转换</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>整型–&gt;字符</p>
<ul>
<li>每一个字符都对应这一个Unicode码   a–97<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char x = &apos;a&apos;;  int y = x;//自动转化  y--97</span><br><span class="line">int x = 97; char y = (char)x;//强制的转化</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>布尔类型很特殊</p>
<ul>
<li>不能与其他基本类型之间发生转化</li>
</ul>
</li>
</ul>
<p><span id="id4"><span></span></span></p>
<h3 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h3><ol>
<li>算术运算符： <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></li>
<li>关系运算符： <code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li>
<li>自增减运算符： <code>++</code>，<code>--</code></li>
<li>逻辑运算符： <code>&amp;&amp;</code>，<code>||</code>，<code>！</code>（短路特性：逻辑与<code>&amp;&amp;</code>运算，若第一个条件为假,跳过第二个条件；逻辑或<code>||</code>运算，若第一个条件为真，跳过第二个条件）</li>
<li>三目运算符： 条件 ? 表达式1 ： 表达式2</li>
<li>赋值运算符：<code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>=</code> </li>
</ol>
<p><span id="id5"><span></span></span></p>
<h3 id="5-循环"><a href="#5-循环" class="headerlink" title="5. 循环"></a>5. 循环</h3><ol>
<li>while循环和for循环完全可以互换。</li>
<li>while循环主要用于明确循环条件，但不明确循环次数的场合</li>
<li>for循环主要用于明确次数或范围的场合</li>
<li>while(true) 等价于 for(;;)，表示无限循环。</li>
</ol>
<p><span id="id6"><span></span></span></p>
<h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h3><h4 id="6-1-一维数组"><a href="#6-1-一维数组" class="headerlink" title="6.1 一维数组"></a>6.1 一维数组</h4><ul>
<li><code>数组类型[] 数组名 = new 数据类型[长度]</code> ：动态方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组类型[] 数组名 = <span class="keyword">new</span> 数据类型[长度] <span class="comment">//动态方式</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组类型[] 数组名 = &#123;初始值<span class="number">1</span>, 初始值<span class="number">1</span>, 初始值<span class="number">1</span>, ...&#125; <span class="comment">//静态方式</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">/*特殊方式：*/</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-二维数组"><a href="#6-2-二维数组" class="headerlink" title="6.2 二维数组"></a>6.2 二维数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组类型[][] 数组名 = <span class="keyword">new</span> 数据类型[行数][列数]</span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组类型[][] 数组名 = &#123;&#123;初始值<span class="number">1</span>, 初始值<span class="number">1</span>, 初始值<span class="number">1</span>&#125;,&#123;值<span class="number">2</span>,...&#125; ...&#125;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;, &#123;<span class="number">01</span>, <span class="number">5</span>, <span class="number">3</span>&#125;, &#123;<span class="number">8</span>, <span class="number">20</span>, <span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二维数组arr.length表示行数，arr[0].length表示此行的长度</p>
</blockquote>
<p><span id="id7"><span></span></span></p>
<h3 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h3><ul>
<li>函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=a; i&lt;=b; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(a +<span class="string">"到"</span>+ b +<span class="string">"的和是"</span>+ sum);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序</li>
<li>函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javaSE知识梳理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaSE </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Win10下配置Nginx+PHP-7+MySQL-5.6]]></title>
      <url>http://chaooo.github.io/2019/02/22/Win10%E4%B8%8B%E9%85%8D%E7%BD%AENginx-php7-mysql-5-6.html</url>
      <content type="html"><![CDATA[<h3 id="1-软件下载"><a href="#1-软件下载" class="headerlink" title="1. 软件下载"></a>1. 软件下载</h3><ul>
<li>Windows操作系统。</li>
<li>Nginx，下载地址：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>。</li>
<li>PHP，下载地址：<a href="http://php.net/downloads.php" target="_blank" rel="noopener">http://php.net/downloads.php</a>（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。</li>
<li>MySQL，下载地址：<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">https://www.mysql.com/downloads/</a>。（选择社区版<code>Community</code>-&gt;<code>MySQL Community Server</code>-&gt;<code>MySQL Community Server 5.6</code>，根据Windows系统选择对应zip包）。<a id="more"></a>
<h3 id="2-软件安装"><a href="#2-软件安装" class="headerlink" title="2. 软件安装"></a>2. 软件安装</h3>在C盘新建安装目录<code>C:\PHP</code>。<h4 id="2-1-Nginx安装"><a href="#2-1-Nginx安装" class="headerlink" title="2.1 Nginx安装"></a>2.1 Nginx安装</h4>Nginx本身就是绿色软件，下载zip安装包解压到<code>C:\PHP</code>，打开目录<code>C:\PHP\nginx-1.15.8</code>双击nginx.exe就可以运行，然后在浏览器打开<a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>，出现欢迎界面表示NGINX正常工作。<br>确认NGINX正常工作后在任务管理器中结束nginx.exe任务。<h4 id="2-2-PHP安装"><a href="#2-2-PHP安装" class="headerlink" title="2.2 PHP安装"></a>2.2 PHP安装</h4>把PHP的zip安装包解压到<code>C:\PHP</code>，解压后PHP安装目录为：<code>C:\PHP\php-7.3.2</code>。<br>cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。<br>将<code>C:\PHP\php-7.3.2</code>加入系统环境变量。<h4 id="2-3-准备网站根目录"><a href="#2-3-准备网站根目录" class="headerlink" title="2.3 准备网站根目录"></a>2.3 准备网站根目录</h4>准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把<code>C:\PHP\web</code>作为我的网站根目录。<br>在根目录<code>C:\PHP\web</code>下新建一个info.php文件，输入如下内容：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-4-让nginx识别PHP"><a href="#2-4-让nginx识别PHP" class="headerlink" title="2.4 让nginx识别PHP"></a>2.4 让nginx识别PHP</h4><p>  配置PHP (<code>C:\PHP\php-7.3.2</code>)<br>  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:<br>  在PHP根目录下修改配置文件<code>C:\PHP\php-7.3.2\php.ini-development</code>并另存为<code>php.ini</code>,在其中修改或添加配置：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgi.fix_pathinfo=1</span><br></pre></td></tr></table></figure></p>
<p>  配置nginx conf(<code>C:\PHP\nginx-1.15.8\conf</code>)<br>  在Nginx根目录下找到conf目录，编辑器打开<code>C:\PHP\nginx-1.15.8\confnginx.conf</code>:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">error_log  logs/error.log; #打开error_log</span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        # ...</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root     C:\PHP\web; #配置根目录</span><br><span class="line">            index   index.html index.htm index.php;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # ...</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        # 打开下面几行注释</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            root             C:\PHP\web; #配置根目录</span><br><span class="line">            fastcgi_pass     127.0.0.1:9000;</span><br><span class="line">            fastcgi_index    index.php;</span><br><span class="line">            #重要: 把下面 /scripts 修改成 $document_root</span><br><span class="line">            fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; </span><br><span class="line">            include          fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-5-运行与测试"><a href="#2-5-运行与测试" class="headerlink" title="2.5 运行与测试"></a>2.5 运行与测试</h4><p>nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么<code>nginx.conf</code>中有这样一句<code>fastcgi_pass 127.0.0.1:9000;</code>。</p>
<ol>
<li><p>在任务管理器中结束nginx.exe任务，然后到<code>C:\PHP\nginx-1.15.8</code>目录双击nginx.exe开启服务。</p>
</li>
<li><p>在命令行中，cd到php的home目录<code>C:\PHP\php-7.3.2</code>，然后执行如下命令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php-cgi.exe -b <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9000</span> -c php.ini</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开浏览器，输入 <a href="http://127.0.0.1/info.php" target="_blank" rel="noopener">http://127.0.0.1/info.php</a>，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</p>
</li>
</ol>
<h4 id="2-6-MySQL安装"><a href="#2-6-MySQL安装" class="headerlink" title="2.6 MySQL安装"></a>2.6 MySQL安装</h4><p>  把MySQL的zip安装包解压到<code>C:\PHP</code>，解压后PHP安装目录为：<code>C:\PHP\mysql-5.6.43-winx64</code>。<br>  将<code>C:\PHP\mysql-5.6.43-winx64\bin</code>加入系统环境变量。<br>  修改配置文件<code>C:\PHP\mysql-5.6.43-winx64\my-default.ini</code>并另存为<code>my.ini</code>,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basedir=C:\PHP\mysql-5.6.43-winx64       #mysql所在目录</span><br><span class="line">datadir=C:\PHP\mysql-5.6.43-winx64\data  #mysql所在目录\data</span><br></pre></td></tr></table></figure></p>
<p>  以管理员身份运行cmd,到安装目录的bin下，输入<code>mysqld -install</code>：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\PHP\mysql-5.6.43-winx64\bin&gt; mysqld -install</span><br><span class="line">Service successfully installed.</span><br></pre></td></tr></table></figure></p>
<p>  输入命令:<code>mysql --version</code>,正常会显示版本信息。<br>  输入命令:<code>net start mysql</code>启动服务(停止命令：net stop mysql):<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\PHP\mysql-5.6.43-winx64\bin&gt;net start mysql</span><br><span class="line">MySQL 服务正在启动 ..</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure></p>
<p>  服务启动成功之后，输入命令：<code>mysql -u root -p</code>（第一次登录没有密码，直接按回车过）:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\PHP\mysql-5.6.43-winx64\bin&gt;mysql -u root -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 1</span><br><span class="line">Server version: 5.6.43 MySQL Community Server (GPL)</span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></p>
<p>  如出现<code>mysql&gt;</code>,即登录成功。<br>  输入命令<code>exit</code>,退出登录。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; exit</span><br><span class="line">Bye</span><br><span class="line">C:\PHP\mysql-5.6.43-winx64\bin&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-制作自动启动脚本"><a href="#3-制作自动启动脚本" class="headerlink" title="3. 制作自动启动脚本"></a>3. 制作自动启动脚本</h3><p>控制台就一直开着，很不方便。这个时候可以使用 <a href="https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip" target="_blank" rel="noopener">RunHiddenConsole.zip</a> 来得管理服务的启动与关闭。</p>
<h4 id="3-1-启动脚本"><a href="#3-1-启动脚本" class="headerlink" title="3.1 启动脚本"></a>3.1 启动脚本</h4><p>在目录<code>C:\PHP</code>下新建一个<code>start.bat</code>作为启动脚本文件：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">:启动脚本</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> php_home=./php-<span class="number">7</span>.<span class="number">3</span>.<span class="number">2</span></span><br><span class="line"><span class="built_in">set</span> nginx_home=./nginx-<span class="number">1</span>.<span class="number">15</span>.<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">REM Windows 下无效</span></span><br><span class="line"><span class="comment">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class="line"><span class="built_in">set</span> PHP_FCGI_MAX_REQUESTS=<span class="number">1000</span></span><br><span class="line"><span class="built_in">echo</span> Starting PHP FastCGI...</span><br><span class="line">RunHiddenConsole <span class="variable">%php_home%</span>/php-cgi.exe -b <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9000</span> -c <span class="variable">%php_home%</span>/php.ini</span><br><span class="line"><span class="built_in">echo</span> FastCGI 启动成功</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Starting nginx...</span><br><span class="line">RunHiddenConsole <span class="variable">%nginx_home%</span>/nginx.exe -p <span class="variable">%nginx_home%</span></span><br><span class="line"><span class="built_in">echo</span> nginx 启动成功</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">:<span class="built_in">echo</span> <span class="number">15</span>秒后自动退出</span><br><span class="line">:<span class="built_in">ping</span> <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>  -n <span class="number">15</span> &gt; null</span><br><span class="line">:请按任意键继续. . .</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-停止脚本"><a href="#3-2-停止脚本" class="headerlink" title="3.2 停止脚本"></a>3.2 停止脚本</h4><p>在目录<code>C:\PHP</code>下新建一个<code>stop.bat</code>作为停止脚本文件：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">:停止脚本</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> Stopping nginx...  </span><br><span class="line"><span class="built_in">taskkill</span> /F /IM nginx.exe &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span> nginx 已停止</span><br><span class="line">:换行</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Stopping PHP FastCGI...</span><br><span class="line"><span class="built_in">taskkill</span> /F /IM php-cgi.exe &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span> FastCGI 已停止</span><br><span class="line">:请按任意键继续. . .</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-重启脚本"><a href="#3-3-重启脚本" class="headerlink" title="3.3 重启脚本"></a>3.3 重启脚本</h4><p>在目录<code>C:\PHP</code>下新建一个<code>restart.bat</code>作为重启脚本文件：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">:停止脚本</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> Stopping nginx...  </span><br><span class="line"><span class="built_in">taskkill</span> /F /IM nginx.exe &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span> nginx 已停止</span><br><span class="line">:换行</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Stopping PHP FastCGI...</span><br><span class="line"><span class="built_in">taskkill</span> /F /IM php-cgi.exe &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span> FastCGI 已停止</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line">:启动脚本</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> php_home=./php-<span class="number">7</span>.<span class="number">3</span>.<span class="number">2</span></span><br><span class="line"><span class="built_in">set</span> nginx_home=./nginx-<span class="number">1</span>.<span class="number">15</span>.<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">REM Windows 下无效</span></span><br><span class="line"><span class="comment">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class="line"><span class="built_in">set</span> PHP_FCGI_MAX_REQUESTS=<span class="number">1000</span></span><br><span class="line"><span class="built_in">echo</span> Starting PHP FastCGI...</span><br><span class="line">RunHiddenConsole <span class="variable">%php_home%</span>/php-cgi.exe -b <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9000</span> -c <span class="variable">%php_home%</span>/php.ini</span><br><span class="line"><span class="built_in">echo</span> FastCGI 启动成功</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Starting nginx...</span><br><span class="line">RunHiddenConsole <span class="variable">%nginx_home%</span>/nginx.exe -p <span class="variable">%nginx_home%</span></span><br><span class="line"><span class="built_in">echo</span> nginx 启动成功</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">:<span class="built_in">echo</span> <span class="number">15</span>秒后自动退出</span><br><span class="line">:<span class="built_in">ping</span> <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>  -n <span class="number">15</span> &gt; null</span><br><span class="line">:请按任意键继续. . .</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<h3 id="4-最后"><a href="#4-最后" class="headerlink" title="4.最后"></a>4.最后</h3><p>我的根目录结构</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">PHP</span>&gt;<span class="title">dir</span></span></span><br><span class="line"><span class="function"> 驱动器 <span class="title">C</span> 中的卷是 系统</span></span><br><span class="line"><span class="function"> 卷的序列号是 09<span class="title">C1</span>-<span class="title">B27D</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="title">C</span>:\<span class="title">PHP</span> 的目录</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2019/02/22  15:46    &lt;<span class="title">DIR</span>&gt;          .</span></span><br><span class="line"><span class="function">2019/02/22  15:46    &lt;<span class="title">DIR</span>&gt;          ..</span></span><br><span class="line"><span class="function">2019/02/22  11:23    &lt;<span class="title">DIR</span>&gt;          <span class="title">mysql</span>-5.6.43-<span class="title">winx64</span></span></span><br><span class="line"><span class="function">2018/12/25  17:54    &lt;<span class="title">DIR</span>&gt;          <span class="title">nginx</span>-1.15.8</span></span><br><span class="line"><span class="function">2019/02/21  15:59    &lt;<span class="title">DIR</span>&gt;          <span class="title">php</span>-7.3.2</span></span><br><span class="line"><span class="function">2019/02/22  15:41               758 <span class="title">restart.bat</span></span></span><br><span class="line"><span class="function">2010/10/26  11:43             1,536 <span class="title">RunHiddenConsole.exe</span></span></span><br><span class="line"><span class="function">2019/02/22  15:41               549 <span class="title">start.bat</span></span></span><br><span class="line"><span class="function">2019/02/22  15:41               227 <span class="title">stop.bat</span></span></span><br><span class="line"><span class="function">2019/02/21  16:56    &lt;<span class="title">DIR</span>&gt;          <span class="title">web</span></span></span><br><span class="line"><span class="function">               4 个文件          3,070 字节</span></span><br><span class="line"><span class="function">               6 个目录 100,959,772,672 可用字节</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[BlueLake博客主题的详细配置]]></title>
      <url>http://chaooo.github.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.html</url>
      <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p><a href="https://github.com/chaooo/hexo-theme-BlueLake" target="_blank" rel="noopener">BlueLake主题</a>写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。</p>
<a id="more"></a>
<p>在阅读本文之前，假定您已经成功安装了<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<blockquote>
<p>需要特别注意的是Hexo有两个<code>_config.yml</code>配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为<strong><code>根_config.yml</code></strong>；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为<strong><code>主题_config.yml</code></strong>。</p>
</blockquote>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>您可以直接到<a href="https://github.com/chaooo/hexo-theme-BlueLake" target="_blank" rel="noopener">BlueLake发布页</a>下载，然后解压拷贝到<code>themes</code>目录下，修改配置即可。<br>不过我还是推荐使用<code>GIT</code>来checkout代码，之后也可以通过<code>git pull</code>来快速更新。</p>
<h4 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h4><p>在根目录下打开终端窗口：</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake</span><br></pre></td></tr></table></figure>

<h4 id="1-2-安装主题渲染器"><a href="#1-2-安装主题渲染器" class="headerlink" title="1.2 安装主题渲染器"></a>1.2 安装主题渲染器</h4><p>BlueLake是基于<code>jade</code>和<code>stylus</code>写的，所以需要安装<code>hexo-renderer-jade</code>和<code>hexo-renderer-stylus</code>来渲染。</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-jade@0.3.0 --save</span><br><span class="line">$ npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>

<h4 id="1-3-启用主题"><a href="#1-3-启用主题" class="headerlink" title="1.3 启用主题"></a>1.3 启用主题</h4><p>打开<code>根_config.yml</code>配置文件，找到theme字段，将其值改为<code>BlueLake</code>(先确认主题文件夹名称是否为BlueLake)。</p>
<figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">BlueLake</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-验证"><a href="#1-4-验证" class="headerlink" title="1.4 验证"></a>1.4 验证</h4><p>首先启动 Hexo 本地站点，并开启调试模式：</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s --debug</span><br></pre></td></tr></table></figure>

<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p>
<h4 id="1-5-更新主题"><a href="#1-5-更新主题" class="headerlink" title="1.5 更新主题"></a>1.5 更新主题</h4><p>今后若主题添加了新功能正是您需要的，您可以直接<code>git pull</code>来更新主题。</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/BlueLake</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><h4 id="2-1-配置网站头部显示文字"><a href="#2-1-配置网站头部显示文字" class="headerlink" title="2.1 配置网站头部显示文字"></a>2.1 配置网站头部显示文字</h4><p>打开<code>根_config.yml</code>，找到：</p>
<figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> </span><br><span class="line"><span class="attr">description:</span> </span><br><span class="line"><span class="attr">author:</span></span><br></pre></td></tr></table></figure>

<p><code>title</code>和<code>subtitle</code>分别是网站主标题和副标题，会显示在网站头部；<code>description</code>在网站界面不会显示，内容会加入网站源码的<code>meta</code>标签中，主要用于SEO；<code>author</code>就填写网站所有者的名字，会在网站底部的<code>Copyright</code>处有所显示。</p>
<h4 id="2-2-设置语言"><a href="#2-2-设置语言" class="headerlink" title="2.2 设置语言"></a>2.2 设置语言</h4><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在<code>根_config.yml</code>配置如下：</p>
<figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-设置菜单"><a href="#2-3-设置菜单" class="headerlink" title="2.3 设置菜单"></a>2.3 设置菜单</h4><p>打开<code>主题_config.yml</code>，找到：</p>
<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">home</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-home</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">archives/</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># - page: about</span></span><br><span class="line">  <span class="comment">#   directory: about/</span></span><br><span class="line">  <span class="comment">#   icon: fa-user</span></span><br><span class="line"><span class="attr">  - page:</span> <span class="string">rss</span></span><br><span class="line"><span class="attr">    directory:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure>

<p>主题默认是展示四个菜单，即<code>主页home</code>，<code>归档archive</code>，<code>关于about</code>，<code>订阅RSS</code>；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。<br>每个页面底部的<code>footer</code>中<code>联系博主</code>的三个图标分别是<code>邮箱</code>，<code>微博主页链接地址</code>，<code>GitHUb个人页链接地址</code>，直接使用<code>主题_config.yml</code>中<code>about页面</code>的配置，若不需要about页面，只需要如下配置就好：</p>
<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># About page </span></span><br><span class="line"><span class="attr">about:</span></span><br><span class="line"><span class="attr">  email:</span> <span class="comment">## 个人邮箱 </span></span><br><span class="line"><span class="attr">  weibo_url:</span> <span class="comment">## 微博主页链接地址</span></span><br><span class="line"><span class="attr">  github_url:</span> <span class="comment">## github主页链接地址</span></span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-添加about页"><a href="#2-3-1-添加about页" class="headerlink" title="2.3.1 添加about页"></a>2.3.1 添加about页</h5><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">'about'</span></span><br></pre></td></tr></table></figure>

<p>打开<code>主题_config.yml</code>，补全关于我页面的详细信息：</p>
<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># About page </span></span><br><span class="line"><span class="attr">about:</span></span><br><span class="line"><span class="attr">  photo_url:</span> <span class="comment">## 头像的链接地址</span></span><br><span class="line"><span class="attr">  email:</span> <span class="comment">## 个人邮箱 </span></span><br><span class="line"><span class="attr">  weibo_url:</span> <span class="comment">## 微博主页链接地址</span></span><br><span class="line"><span class="attr">  weibo_name:</span> <span class="comment">## 微博用户名 </span></span><br><span class="line"><span class="attr">  github_url:</span> <span class="comment">## github主页链接地址</span></span><br><span class="line"><span class="attr">  github_name:</span> <span class="comment">## github用户名</span></span><br></pre></td></tr></table></figure>

<p>当然您也可以自定义重新布局about页面，只需要修改<code>layout/page.jade</code>模板就好。</p>
<h5 id="2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件"><a href="#2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件" class="headerlink" title="2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件"></a>2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h5><p>在根目录下打开命令行窗口：</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br><span class="line">$ npm install hexo-generator-sitemap --save</span><br><span class="line">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<p>添加<code>主题_config.yml</code>配置：</p>
<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Plugins:</span></span><br><span class="line">  <span class="string">hexo-generator-feed</span></span><br><span class="line">  <span class="string">hexo-generator-sitemap</span></span><br><span class="line">  <span class="string">hexo-generator-baidu-sitemap</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-添加本地搜索"><a href="#2-4-添加本地搜索" class="headerlink" title="2.4 添加本地搜索"></a>2.4 添加本地搜索</h4><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件<a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">hexo-generator-json-content</a>来创建JSON数据文件：</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>

<p>然后在<code>根_config.yml</code>添加配置：</p>
<figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line"><span class="attr">  meta:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  pages:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    raw:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    content:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    slug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    updated:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    permalink:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    excerpt:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    categories:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>最后在<code>主题_config.yml</code>添加配置：</p>
<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-修改站点图标"><a href="#2-5-修改站点图标" class="headerlink" title="2.5 修改站点图标"></a>2.5 修改站点图标</h4><p>站点图标存放在主题的<code>Source</code>目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。<br>您需要准备一张ico格式并命名为** favicon.ico <strong>，请将其放入hexo目录的<code>source</code>文件夹，建议大小：32px X 32px。<br>您需要为苹果设备添加网站徽标，请命名为</strong> apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。<br>(有很多网站都可以在线生成ico格式的图片。)</p>
<h4 id="2-6-添加站点关键字"><a href="#2-6-添加站点关键字" class="headerlink" title="2.6 添加站点关键字"></a>2.6 添加站点关键字</h4><p>请在hexo目录的<code>根_config.yml</code>中添加keywords字段，如：</p>
<figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">网站简要描述,如：Charles·Zheng's</span> <span class="string">blog.</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">网站关键字,</span> <span class="string">key,</span> <span class="string">key1,</span> <span class="string">key2,</span> <span class="string">key3</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Charles</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-首页添加文章置顶"><a href="#2-7-首页添加文章置顶" class="headerlink" title="2.7 首页添加文章置顶"></a>2.7 首页添加文章置顶</h4><p>在根目录下打开命令行窗口安装：</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<p>然后在需要置顶的文章的Front-matter中加上top: true即可。</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: BlueLake博客主题的详细配置</span><br><span class="line">tags: [hexo,BlueLake]</span><br><span class="line">categories: hexo博客折腾</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="2-8-更换主题背景和添加文章版权信息"><a href="#2-8-更换主题背景和添加文章版权信息" class="headerlink" title="2.8 更换主题背景和添加文章版权信息"></a>2.8 更换主题背景和添加文章版权信息</h4><p>更换主题背景为深色</p>
<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Theme tone</span></span><br><span class="line"><span class="attr">dark:</span> <span class="literal">true</span> <span class="comment">#true/false</span></span><br></pre></td></tr></table></figure>

<p>添加文章版权信息</p>
<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Theme tone</span></span><br><span class="line"><span class="comment">#Copyright</span></span><br><span class="line"><span class="attr">copyright:</span> </span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span> <span class="comment">#true/false  </span></span><br><span class="line"><span class="attr">  describe:</span> <span class="string">转载请注明出处(必须保留原文作者署名原文链接)</span> <span class="comment">#自定义描述替换默认描述</span></span><br></pre></td></tr></table></figure>

<h4 id="2-9-其他配置"><a href="#2-9-其他配置" class="headerlink" title="2.9 其他配置"></a>2.9 其他配置</h4><p><code>主题_config.yml</code>的其他配置</p>
<ol>
<li><code>show_category_count</code>——是否显示分类下的文章数。</li>
<li><code>widgets_on_small_screens</code>——是否在小屏显示侧边栏，若<code>true</code>,则侧边栏挂件将显示在底部。<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">show_category_count:</span> <span class="literal">true</span> </span><br><span class="line"><span class="attr">widgets_on_small_screens:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-集成第三方服务"><a href="#3-集成第三方服务" class="headerlink" title="3.集成第三方服务"></a>3.集成第三方服务</h3><h4 id="3-1-添加评论"><a href="#3-1-添加评论" class="headerlink" title="3.1 添加评论"></a>3.1 添加评论</h4><p>目前主题集成六种第三方评论，分别是<a href="http://duoshuo.com" target="_blank" rel="noopener">多说评论</a>、<a href="https://disqus.com" target="_blank" rel="noopener">Disqus评论</a>、<a href="https://livere.com" target="_blank" rel="noopener">来必力评论</a>、<a href="http://www.uyan.cc/" target="_blank" rel="noopener">友言评论</a>、<a href="https://gentie.163.com/info.html" target="_blank" rel="noopener">网易云跟帖评论</a>、<a href="http://changyan.kuaizhan.com" target="_blank" rel="noopener">畅言评论</a>，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。</p>
<ol>
<li>注册并获得代码。<ul>
<li>若使用<a href="http://duoshuo.com" target="_blank" rel="noopener">多说评论</a>，注册多说后获得short_name。</li>
<li>若使用<a href="https://disqus.com" target="_blank" rel="noopener">Disqus评论</a>，注册Disqus后获得short_name。</li>
<li>若使用<a href="https://livere.com" target="_blank" rel="noopener">来必力评论</a>，注册来必力,获得data-uid。</li>
<li>若使用<a href="http://www.uyan.cc/" target="_blank" rel="noopener">友言评论</a>，注册友言,获得uid。</li>
<li>若使用<a href="https://gentie.163.com/info.html" target="_blank" rel="noopener">网易云跟帖评论</a>，注册网易云跟帖,获得productKey。</li>
<li>若使用<a href="http://changyan.kuaizhan.com" target="_blank" rel="noopener">畅言评论</a>，注册畅言，获得appid，appkey。</li>
</ul>
</li>
<li>配置<code>主题_config.yml</code>：<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Cmments</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line"><span class="attr">  duoshuo:</span> <span class="comment">## duoshuo_shortname</span></span><br><span class="line"><span class="attr">  disqus:</span> <span class="comment">## disqus_shortname</span></span><br><span class="line"><span class="attr">  livere:</span> <span class="comment">## 来必力(data-uid)</span></span><br><span class="line"><span class="attr">  uyan:</span> <span class="comment">## 友言(uid)</span></span><br><span class="line"><span class="attr">  cloudTie:</span> <span class="comment">## 网易云跟帖(productKey)</span></span><br><span class="line"><span class="attr">  changyan:</span> <span class="comment">## 畅言需在下方配置两个参数，此处不填。</span></span><br><span class="line"><span class="attr">    appid:</span> <span class="comment">## 畅言(appid)</span></span><br><span class="line"><span class="attr">    appkey:</span> <span class="comment">##畅言(appkey)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-2-百度统计"><a href="#3-2-百度统计" class="headerlink" title="3.2 百度统计"></a>3.2 百度统计</h4><ol>
<li>登录<a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>，定位到站点的代码获取页面。</li>
<li>复制<code>//hm.baidu.com/hm.js?</code>后面那串统计脚本id(假设为：8006843039519956000)</li>
<li>配置<code>主题_config.yml</code>:<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="number">8006843039519956000</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>注意： <code>baidu_analytics</code>不是你的百度<code>id</code>或者百度统计<code>id</code><br>如若使用谷歌统计，配置方法与百度统计类似。</p>
</blockquote>
<h4 id="3-3-卜算子阅读次数统计"><a href="#3-3-卜算子阅读次数统计" class="headerlink" title="3.3 卜算子阅读次数统计"></a>3.3 卜算子阅读次数统计</h4><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="noopener">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>若设置为<code>true</code>将计算文章的阅读量(Hits)，并显示在文章标题下的<code>小手图标</code>旁。</p>
<h4 id="3-4-微博秀"><a href="#3-4-微博秀" class="headerlink" title="3.4 微博秀"></a>3.4 微博秀</h4><p>微博秀挂件的代码放在<code>layout/_widget/weibo.jade</code>下，需要您去<a href="http://open.weibo.com/" target="_blank" rel="noopener">微博开放平台</a>获取您自己的微博秀代码来替换。</p>
<ol>
<li>登录<a href="http://open.weibo.com/" target="_blank" rel="noopener">微博开放平台</a>，选择微博秀。</li>
<li>为了与主题风格统一，作如下配置<ul>
<li>基础设置：高<code>400px</code>；勾选宽度自适应；颜色选择<code>白色</code>；</li>
<li>样式设置：主字色<code>#333</code>；链接色<code>#40759b</code>；鼠标悬停色<code>#f7f8f8</code>；</li>
<li>模块设置：去掉<code>标题</code>、<code>边框</code>、<code>粉丝</code>的勾选框，只留<code>微博</code>。</li>
</ul>
</li>
<li>复制代码里<code>src=&quot;&quot;</code>里引号包裹的内容，替换到<code>layout/_widget/weibo.jade</code><figure class="highlight stylus"><figcaption><span>weibo.jade</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade" target="_blank" rel="noopener">layout/_widget/weibo.jade</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line marked">.widget</span><br><span class="line">  .widget-title</span><br><span class="line">    i(class=<span class="string">'fa fa-weibo'</span>)= <span class="string">' '</span> + __(<span class="string">'新浪微博'</span>)</span><br><span class="line">  iframe(<span class="attribute">width</span>=<span class="string">"100%"</span>,height=<span class="string">"400"</span>,class=<span class="string">"share_self"</span>,frameborder=<span class="string">"0"</span>,scrolling=<span class="string">"no"</span>,src=<span class="string">"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1"</span>)</span><br></pre></td></tr></table></figure>
这只是为了和主题的风格统一，当然您也可以自由随意发挥。<blockquote>
<p>注意：最主要是是要把<code>src</code>里<code>uid=</code>和<code>verifier=</code>后面的字段替换为您自己代码里的就好。</p>
</blockquote>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> hexo博客折腾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> BlueLake </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义HEXO站内搜索Javascript+json]]></title>
      <url>http://chaooo.github.io/2016/11/09/%E8%87%AA%E5%AE%9A%E4%B9%89HEXO%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2Javascript-json.html</url>
      <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>目前很多<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：<br>    <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a>生成<code>xml</code>格式的数据文件。<br>    <a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">hexo-generator-json-content</a> 生成<code>json</code>格式的数据文件。<br>今天的主角是<a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">hexo-generator-json-content</a>，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。</p>
<a id="more"></a>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>

<p>然后执行<code>hexo generate</code>时会自动生成<code>content.json</code>文件，若使用默认设置，生成的数据结构如下 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">meta: &#123;</span><br><span class="line">    title: hexo.config.title,</span><br><span class="line">    subtitle: hexo.config.subtitle,</span><br><span class="line">    description: hexo.config.description,</span><br><span class="line">    author: hexo.config.author,</span><br><span class="line">    url: hexo.config.url</span><br><span class="line">&#125;,</span><br><span class="line">pages: [&#123; //-&gt; all pages</span><br><span class="line">    title: page.title,</span><br><span class="line">    slug: page.slug,</span><br><span class="line">    date: page.date,</span><br><span class="line">    updated: page.updated,</span><br><span class="line">    comments: page.comments,</span><br><span class="line">    permalink: page.permalink,</span><br><span class="line">    path: page.path,</span><br><span class="line">    excerpt: page.excerpt, //-&gt; only text ;)</span><br><span class="line">    keywords: null //-&gt; it needs settings</span><br><span class="line">    text: page.content, //-&gt; only text minified ;)</span><br><span class="line">    raw: page.raw, //-&gt; original MD content</span><br><span class="line">    content: page.content //-&gt; final HTML content</span><br><span class="line">&#125;],</span><br><span class="line">posts: [&#123; //-&gt; only published posts</span><br><span class="line">    title: post.title,</span><br><span class="line">    slug: post.slug,</span><br><span class="line">    date: post.date,</span><br><span class="line">    updated: post.updated,</span><br><span class="line">    comments: post.comments,</span><br><span class="line">    permalink: post.permalink,</span><br><span class="line">    path: post.path,</span><br><span class="line">    excerpt: post.excerpt, //-&gt; only text ;)</span><br><span class="line">    keywords: null //-&gt; it needs settings</span><br><span class="line">    text: post.content, //-&gt; only text minified ;)</span><br><span class="line">    raw: post.raw, //-&gt; original MD content</span><br><span class="line">    content: post.content, //-&gt; final HTML content</span><br><span class="line">    categories: [&#123;</span><br><span class="line">        name: category.name,</span><br><span class="line">        slug: category.slug,</span><br><span class="line">        permalink: category.permalink</span><br><span class="line">    &#125;],</span><br><span class="line">    tags: [&#123;</span><br><span class="line">        name: tag.name,</span><br><span class="line">        slug: tag.slug,</span><br><span class="line">        permalink: tag.permalink</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line"><span class="attr">  meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  keywords:</span> <span class="literal">false</span> <span class="comment"># (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)</span></span><br><span class="line"><span class="attr">  pages:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    slug:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    updated:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    link:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    permalink:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    excerpt:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    keywords:</span> <span class="literal">true</span> <span class="comment"># but only if root keywords option language was set</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    raw:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    content:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    slug:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    updated:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    link:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    permalink:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    excerpt:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    keywords:</span> <span class="literal">true</span> <span class="comment"># but only if root keywords option language was set</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    raw:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    content:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    categories:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在<code>hexo/_config.yml</code>中加入：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line"><span class="attr">  meta:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  pages:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span> <span class="comment">#文章标题</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span> <span class="comment">#发表日期</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span> <span class="comment">#路径</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span> <span class="comment">#文本字段</span></span><br><span class="line"><span class="attr">    raw:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    content:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    slug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    updated:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    permalink:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    excerpt:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    categories:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="literal">true</span> <span class="comment">#标签</span></span><br></pre></td></tr></table></figure>

<p>这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。<br>例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"自定义HEXO站内搜索Javascript+json"</span>,</span><br><span class="line">  <span class="attr">"date"</span>: <span class="string">"2016-11-09T01:24:56.000Z"</span>,</span><br><span class="line">  <span class="attr">"path"</span>: <span class="string">"2016/11/09/自定义HEXO站内搜索Javascript-json.html"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容"</span>,</span><br><span class="line">  <span class="attr">"tags"</span>: [&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"javascript,hexo"</span>,</span><br><span class="line">    <span class="attr">"slug"</span>: <span class="string">"javascript-hexo"</span>,</span><br><span class="line">    <span class="attr">"permalink"</span>: <span class="string">"http://chaoo.oschina.io/tags/javascript-hexo/"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-JavaScript实现代码"><a href="#3-JavaScript实现代码" class="headerlink" title="3.JavaScript实现代码"></a>3.JavaScript实现代码</h3><p>接下来就是用JS实现查询方法并把结果渲染到页面。</p>
<h4 id="3-1-xhr加载数据"><a href="#3-1-xhr加载数据" class="headerlink" title="3.1 xhr加载数据"></a>3.1 xhr加载数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchData;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params">success</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!searchData) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, <span class="string">'/content.json'</span>, <span class="literal">true</span>);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status &gt;= <span class="number">200</span> &amp;&amp; <span class="keyword">this</span>.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> res = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.response || <span class="keyword">this</span>.responseText);</span><br><span class="line">                searchData = res <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? res : res.posts;</span><br><span class="line">                success(searchData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="keyword">this</span>.statusText);</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        success(searchData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-匹配文章内容返回结果"><a href="#3-2-匹配文章内容返回结果" class="headerlink" title="3.2 匹配文章内容返回结果"></a>3.2 匹配文章内容返回结果</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matcher</span>(<span class="params">post, regExp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 匹配优先级：title &gt; tags &gt; text</span></span><br><span class="line">    <span class="keyword">return</span> regtest(post.title, regExp) || post.tags.some(<span class="function"><span class="keyword">function</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> regtest(tag.name, regExp);</span><br><span class="line">    &#125;) || regtest(post.text, regExp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">regtest</span>(<span class="params">raw, regExp</span>) </span>&#123;</span><br><span class="line">    regExp.lastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> regExp.test(raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-结果渲染到页面"><a href="#3-3-结果渲染到页面" class="headerlink" title="3.3 结果渲染到页面"></a>3.3 结果渲染到页面</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span> (data.length) &#123;</span><br><span class="line">        html = data.map(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tpl(searchTpl, &#123;</span><br><span class="line">                title: post.title,</span><br><span class="line">                path: post.path,</span><br><span class="line">                date: <span class="keyword">new</span> <span class="built_in">Date</span>(post.date).toLocaleDateString(),</span><br><span class="line">                tags: post.tags.map(<span class="function"><span class="keyword">function</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'&lt;span&gt;'</span> + tag.name + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">                &#125;).join(<span class="string">''</span>)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;).join(<span class="string">''</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-查询匹配"><a href="#3-3-查询匹配" class="headerlink" title="3.3 查询匹配"></a>3.3 查询匹配</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 关键字 =&gt; 正则，空格隔开的看作多个关键字</span></span><br><span class="line">    <span class="comment">// a b c =&gt; /a|b|c/gmi</span></span><br><span class="line">    <span class="keyword">var</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(key.replace(<span class="regexp">/[ ]/g</span>, <span class="string">'|'</span>), <span class="string">'gmi'</span>);</span><br><span class="line">    loadData(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = data.filter(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> matcher(post, regExp);</span><br><span class="line">        &#125;);</span><br><span class="line">        render(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> hexo博客折腾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[好用的Web包管理器-Bower]]></title>
      <url>http://chaooo.github.io/2016/08/12/Web%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-Bower.html</url>
      <content type="html"><![CDATA[<p>Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。</p>
<a id="more"></a> 
<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>在安装<a href="https://bower.io/" target="_blank" rel="noopener">bower</a>之前，必须确认你已经安装了<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>和<a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a>。</p>
<h3 id="1-安装Bower"><a href="#1-安装Bower" class="headerlink" title="1.安装Bower"></a>1.安装Bower</h3><p>使用npm，打开终端，键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g bower   <span class="comment">#全局安装bower</span></span><br></pre></td></tr></table></figure>

<p>移步<a href="https://github.com/bower/bower/wiki/Troubleshooting" target="_blank" rel="noopener">这里</a>查看不同平台上安装的问题。</p>
<h3 id="2-使用Bower"><a href="#2-使用Bower" class="headerlink" title="2.使用Bower"></a>2.使用Bower</h3><p>使用help命令查看帮助。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bower <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">    bower &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class="line">Commands:</span><br><span class="line">    cache                   Manage bower cache</span><br><span class="line">    <span class="built_in">help</span>                    Display <span class="built_in">help</span> information about Bower</span><br><span class="line">    home                    Opens a package homepage into your favorite browser</span><br><span class="line">    info                    Info of a particular package</span><br><span class="line">    init                    Interactively create a bower.json file</span><br><span class="line">    install                 Install a package locally</span><br><span class="line">    link                    Symlink a package folder</span><br><span class="line">    list                    List <span class="built_in">local</span> packages - and possible updates</span><br><span class="line">    login                   Authenticate with GitHub and store credentials</span><br><span class="line">    lookup                  Look up a package URL by name</span><br><span class="line">    prune                   Removes <span class="built_in">local</span> extraneous packages</span><br><span class="line">    register                Register a package</span><br><span class="line">    search                  Search <span class="keyword">for</span> a package by name</span><br><span class="line">    update                  Update a <span class="built_in">local</span> package</span><br><span class="line">    uninstall               Remove a <span class="built_in">local</span> package</span><br><span class="line">    unregister              Remove a package from the registry</span><br><span class="line">    version                 Bump a package version</span><br><span class="line">Options:</span><br><span class="line">    -f, --force             Makes various commands more forceful</span><br><span class="line">    -j, --json              Output consumable JSON</span><br><span class="line">    -l, --loglevel          What level of logs to report</span><br><span class="line">    -o, --offline           Do not hit the network</span><br><span class="line">    -q, --quiet             Only output important information</span><br><span class="line">    -s, --silent            Do not output anything, besides errors</span><br><span class="line">    -V, --verbose           Makes output more verbose</span><br><span class="line">    --allow-root            Allows running commands as root</span><br><span class="line">    -v, --version           Output Bower version</span><br><span class="line">    --no-color              Disable colors</span><br><span class="line">See <span class="string">'bower help &lt;command&gt;'</span> <span class="keyword">for</span> more information on a specific <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>

<h3 id="3-安装包到本地"><a href="#3-安装包到本地" class="headerlink" title="3.安装包到本地"></a>3.安装包到本地</h3><p>通过命令bower install安装软件包默认到bower_components/目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower install &lt;package&gt;    <span class="comment">#package为包名</span></span><br></pre></td></tr></table></figure>

<p>想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bower install  <span class="comment"># 通过 bower.json 文件安装</span></span><br><span class="line">bower install jquery   <span class="comment"># 通过在github上注册的包名安装</span></span><br><span class="line">bower install desandro/masonry   <span class="comment"># GitHub短链接</span></span><br><span class="line">bower install git://github.com/user/package.git   <span class="comment"># Github上的 .git</span></span><br><span class="line">bower install http://example.com/script.js   <span class="comment"># URL</span></span><br></pre></td></tr></table></figure>

<p>安装选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-F, --force-latest: Force latest version on conflict</span><br><span class="line">-p, --production: Do not install project devDependencies</span><br><span class="line">-S, --save: Save installed packages into the project’s bower.json dependencies</span><br><span class="line">-D, --save-dev: Save installed packages into the project’s bower.json devDependencies</span><br><span class="line">-E, --save-exact: Configure installed packages with an exact version rather than semver</span><br></pre></td></tr></table></figure>

<h3 id="4-用bower-json文件来管理依赖"><a href="#4-用bower-json文件来管理依赖" class="headerlink" title="4.用bower.json文件来管理依赖"></a>4.用bower.json文件来管理依赖</h3><p>发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行<code>bower install</code>就可根据bower.json来安装依赖的包。<br>在项目中执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower init</span><br></pre></td></tr></table></figure>

<p>会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.<br>如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上<code>--save</code>即可。</p>
<h3 id="5-使用下载好的包"><a href="#5-使用下载好的包" class="headerlink" title="5.使用下载好的包"></a>5.使用下载好的包</h3><p>对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bower_components/bootstrap/dist/css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bower_components/jquery/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-更新包"><a href="#6-更新包" class="headerlink" title="6.更新包"></a>6.更新包</h3><p>若下载的包升级了，只需执行<code>update</code>命令即可更新，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower update jquery</span><br></pre></td></tr></table></figure>

<p>这样就可以自动升级到最新版的jquery了。<br>更新选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-F, --force-latest: Force latest version on conflict</span><br><span class="line">-p, --production: Do not install project devDependencies</span><br><span class="line">-S, --save: Update dependencies <span class="keyword">in</span> bower.json</span><br><span class="line">-D, --save-dev: Update devDependencies <span class="keyword">in</span> bower.json</span><br></pre></td></tr></table></figure>

<h3 id="7-搜索包"><a href="#7-搜索包" class="headerlink" title="7.搜索包"></a>7.搜索包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bower search               <span class="comment">#搜索所有包</span></span><br><span class="line">bower search &lt;packageName&gt; <span class="comment">#搜索指定名称的包</span></span><br></pre></td></tr></table></figure>

<p>或者可以在<a href="https://bower.io/search/" target="_blank" rel="noopener">这里:https://bower.io/search/</a>搜索喜欢的包.</p>
<h3 id="8-卸载包"><a href="#8-卸载包" class="headerlink" title="8.卸载包"></a>8.卸载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;]</span><br></pre></td></tr></table></figure>

<p>卸载选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-S, --save: Remove uninstalled packages from the project’s bower.json dependencies</span><br><span class="line">-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bower </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MongoDB学习笔记]]></title>
      <url>http://chaooo.github.io/2016/07/30/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      <content type="html"><![CDATA[<h2 id="part1-安装配置"><a href="#part1-安装配置" class="headerlink" title="part1 安装配置"></a>part1 安装配置</h2><h3 id="一、安装："><a href="#一、安装：" class="headerlink" title="一、安装："></a>一、安装：</h3><p>在mongodb官网下载对应自己电脑系统的安装包，地址为： <a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">http://www.mongodb.org/downloads</a>。</p>
<a id="more"></a> 
<p>1、以Windows64bit为例，下载.msi文件双击安装。<br>2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\MongoDB\bin)。<br>3、创建数据目录(D:\MongoDB\data\db),MongoDB默认数据目录\data\db。<br>4、连接数据库(命令行win+r cmd,到D:\MongoDB\bin目录下，执行代码：mongod –dbpath D:\MongoDB\data\db)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:</span><br><span class="line"><span class="built_in">cd</span> D:\MongoDB\bin</span><br><span class="line">mongod --dbpath D:\MongoDB\data\db</span><br></pre></td></tr></table></figure>

<p>5、启动 MongoDB JavaScript 工具(D:\MongoDB\bin目录下,打开mongo,会看到：)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MongoDB shell version: 3.2.4  //mongodb版本</span><br><span class="line">connecting to: <span class="built_in">test</span>  //默认shell连接的是本机localhost 上面的<span class="built_in">test</span>库</span><br></pre></td></tr></table></figure>

<p>此时就可以操作数据库了。</p>
<h3 id="二、将MongoDB服务器作为Windows服务运行"><a href="#二、将MongoDB服务器作为Windows服务运行" class="headerlink" title="二、将MongoDB服务器作为Windows服务运行"></a>二、将MongoDB服务器作为Windows服务运行</h3><p>1、在D:\MongoDB目录下创建mongodb.config,写入如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 数据库文件目录</span></span><br><span class="line">dbpath=D:/MongoDB/data</span><br><span class="line"><span class="comment">## 日志目录</span></span><br><span class="line">logpath=D:/MongoDB/<span class="built_in">log</span>/mongo.log</span><br><span class="line">diaglog=3</span><br></pre></td></tr></table></figure>

<p>2、常规命令(cmd管理员):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:</span><br><span class="line">cd D:\MongoDB\bin</span><br><span class="line">mongod --config D:\MongoDB\mongodb.config</span><br></pre></td></tr></table></figure>

<p>3、若常规方式失败，则sc方式(cmd管理员)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:</span><br><span class="line">cd D:\MongoDB\bin</span><br><span class="line">sc create mongodb binPath= &quot;D:\MongoDB\bin\mongod.exe --service --config=D:\mongoDB\mongodb.config&quot;</span><br></pre></td></tr></table></figure>

<p>访问地址：localhost:27017测试是否启动成功</p>
<h2 id="part2-CRUD操作-Creat-Read-Update-Delete"><a href="#part2-CRUD操作-Creat-Read-Update-Delete" class="headerlink" title="part2 CRUD操作(Creat,Read,Update,Delete)"></a>part2 CRUD操作(Creat,Read,Update,Delete)</h2><h3 id="一、基础："><a href="#一、基础：" class="headerlink" title="一、基础："></a>一、基础：</h3><p>1、document(文档)</p>
<p>MongoDB把所有数据存放在类似于JSON数据结构的文档内：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"item"</span>: <span class="string">"pencil"</span>, <span class="attr">"qty"</span>: <span class="number">500</span>, <span class="attr">"type"</span>: <span class="string">"no.2"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>2、collection(集合)</p>
<p>集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"item"</span>: <span class="string">"pencil"</span>, <span class="attr">"qty"</span>: <span class="number">500</span>, <span class="attr">"type"</span>: <span class="string">"no.1"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"item"</span>: <span class="string">"pencil2"</span>, <span class="attr">"qty"</span>: <span class="number">550</span>, <span class="attr">"type"</span>: <span class="string">"no.2"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"item"</span>: <span class="string">"pencil3"</span>, <span class="attr">"qty"</span>: <span class="number">800</span>, <span class="attr">"type"</span>: <span class="string">"no.3"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>3、database(数据库)</p>
<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。</p>
<h3 id="二、数据库操作："><a href="#二、数据库操作：" class="headerlink" title="二、数据库操作："></a>二、数据库操作：</h3><p>连接及运行mongoDB<br>“<code>show dbs</code>“命令可以显示所有的数据的列表<br>“<code>db</code>“命令可以显示当前数据库对象或集合<br>“<code>use</code>“命令可以连接到一个指定的数据库<br>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。<br>  1.不能是空字符串（””)。<br>  2.不得含有’ ‘（空格)、.、$、/、\和\0 (空宇符)。<br>  3.应全部小写。<br>  4.最多64字节。</p>
<p>1、创建数据库：<code>use Database_Name</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use <span class="built_in">test</span>  <span class="comment">##创建名为test的数据库</span></span><br></pre></td></tr></table></figure>

<p>2、删除当前数据库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>

<h3 id="三、文档操作（以-Collection-Name-col-为例）"><a href="#三、文档操作（以-Collection-Name-col-为例）" class="headerlink" title="三、文档操作（以 Collection_Name = col 为例）"></a>三、文档操作（以 Collection_Name = col 为例）</h3><h4 id="1、插入："><a href="#1、插入：" class="headerlink" title="1、插入："></a>1、插入：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.col.insert(Document)     <span class="comment">##插入一条或多组数据</span></span><br><span class="line">db.col.insertOne(Document)  <span class="comment">##插入一条数据</span></span><br><span class="line">db.col.insertMany(Document) <span class="comment">##插入多条数据</span></span><br><span class="line"><span class="comment">##例如：</span></span><br><span class="line">    db.col.insertOne(&#123; <span class="string">"item"</span>: <span class="string">"pencil"</span>, <span class="string">"type"</span>: <span class="string">"no.1"</span> &#125;)</span><br><span class="line">    db.col.insertMany([</span><br><span class="line">    &#123; <span class="string">"item"</span>: <span class="string">"dog"</span>, <span class="string">"type"</span>: <span class="string">"no.2"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"item"</span>: <span class="string">"apple"</span>, <span class="string">"type"</span>: <span class="string">"no.3"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"item"</span>: <span class="string">"orange"</span>, <span class="string">"type"</span>: <span class="string">"no.4"</span> &#125;</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>

<h4 id="2、删除："><a href="#2、删除：" class="headerlink" title="2、删除："></a>2、删除：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.col.remove(&#123;&#125;)                    <span class="comment">##删除所有数据</span></span><br><span class="line">db.col.remove(query &lt;,options&gt;)</span><br><span class="line">    <span class="comment">#  query: 查询条件(数据索引或名字)</span></span><br><span class="line">    <span class="comment">#  ptions:两个可选参数</span></span><br><span class="line">    <span class="comment">#      &#123;justOne: &lt;boolean&gt;,     //默认false，删除所有匹配到的。</span></span><br><span class="line">    <span class="comment">#       writeConcern: &lt;document&gt;//抛出异常的级别。</span></span><br><span class="line">    <span class="comment">#      &#125;</span></span><br><span class="line">db.col.deleteOne(query &lt;,options&gt;)   <span class="comment">##同上，无justOne参数，只删除第一条</span></span><br><span class="line">db.col.deleteMany(query &lt;,options&gt;)  <span class="comment">##同上，无justOne参数，只删除多条</span></span><br></pre></td></tr></table></figure>

<h3 id="3、更新："><a href="#3、更新：" class="headerlink" title="3、更新："></a>3、更新：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.col.update(query, update &lt;,options&gt;)</span><br><span class="line">    <span class="comment">#  query:  查询条件(数据索引或名字)</span></span><br><span class="line">    <span class="comment">#  update: 更新的内容，语法：&#123;$set:query&#125;</span></span><br><span class="line">    <span class="comment">#  options:三个可选参数</span></span><br><span class="line">    <span class="comment">#      &#123;upsert: &lt;boolean&gt;,      //如果不存在update的记录，是否插入新数据，默认:false。</span></span><br><span class="line">    <span class="comment">#       multi: &lt;boolean&gt;,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。</span></span><br><span class="line">    <span class="comment">#       writeConcern: &lt;document&gt;//#抛出异常的级别。</span></span><br><span class="line">    <span class="comment">#      &#125;</span></span><br><span class="line"><span class="comment">##例如：</span></span><br><span class="line">    db.col.update(</span><br><span class="line">        &#123;<span class="string">"type"</span>: <span class="string">"no.1"</span>&#125;, </span><br><span class="line">        &#123;<span class="variable">$set</span>: &#123;<span class="string">"item"</span>: <span class="string">"human"</span>&#125;&#125;, </span><br><span class="line">        &#123;upsert: <span class="literal">true</span>, multi: <span class="literal">true</span>&#125;</span><br><span class="line">        )</span><br><span class="line">db.col.updateOne()                    <span class="comment">##同上，无multi参数，只更新第一条</span></span><br><span class="line">db.col.updateMany()                   <span class="comment">##同上，无multi参数</span></span><br><span class="line">db.col.replaceOne()                   <span class="comment">##同updateOne</span></span><br><span class="line">db.col.save(document &lt;,writeConcern&gt;) <span class="comment">##通过传入的文档整个替换</span></span><br></pre></td></tr></table></figure>

<h5 id="insert-与-save的区别"><a href="#insert-与-save的区别" class="headerlink" title="insert 与 save的区别"></a>insert 与 save的区别</h5><p>如果插入的数据的_id相同,save将会更新该文档,而insert将会报错</p>
<h5 id="update常用操作符"><a href="#update常用操作符" class="headerlink" title="update常用操作符"></a>update常用操作符</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$set</span>         <span class="comment">##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.</span></span><br><span class="line"><span class="variable">$unset</span>       <span class="comment">##删除文档中的一个字段.</span></span><br><span class="line"><span class="variable">$rename</span>      <span class="comment">##重命名某个列</span></span><br><span class="line"><span class="variable">$inc</span>         <span class="comment">##增长某个列</span></span><br><span class="line"><span class="variable">$setOnInsert</span> <span class="comment">##当upsert为true时,并且发生了insert操作时,可以补充的字段</span></span><br><span class="line"><span class="variable">$push</span>        <span class="comment">##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.</span></span><br><span class="line"><span class="variable">$pushAll</span>     <span class="comment">##将多个数值一次存入数组.上面的push只能一个一个的存入</span></span><br><span class="line"><span class="variable">$addToSet</span>    <span class="comment">##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.</span></span><br><span class="line"><span class="variable">$pop</span>         <span class="comment">##删除数组最后一个元素</span></span><br><span class="line"><span class="variable">$pull</span>        <span class="comment">##删除数组中的指定的元素,如果删除的字段不是数组,会报错</span></span><br><span class="line"><span class="variable">$pullAll</span>     <span class="comment">##删除数组中的多个值,跟pushAll与push的关系类似.</span></span><br></pre></td></tr></table></figure>

<h3 id="4、查询"><a href="#4、查询" class="headerlink" title="4、查询"></a>4、查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;&#125;)          <span class="comment">##查询所有文档</span></span><br><span class="line">db.col.find().pretty()   <span class="comment">##以易读的方式来读取数据</span></span><br><span class="line">db.collection.find(query, projection)</span><br><span class="line">    <span class="comment">#  query：查询条件(数据索引或名字)</span></span><br><span class="line">    <span class="comment">#  projection：可选。指定返回的字段。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1、深入查询表达式"><a href="#4-1、深入查询表达式" class="headerlink" title="4.1、深入查询表达式"></a>4.1、深入查询表达式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">db.col.find()<span class="comment">##查询所有</span></span><br><span class="line">db.col.find(&#123;filed: value&#125;)                              <span class="comment">##等值查询</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$ne</span>: value&#125;&#125;)                       <span class="comment">##不等于 $ne</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$nin</span>: [value1, value2, ...]&#125;&#125;)      <span class="comment">##不能包含给定的值 $nin</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$all</span>: [value1, value2, ...]&#125;&#125;)      <span class="comment">##必须包含所有给定的值 $all</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$in</span>: [value1, value2, ...]&#125;&#125;)       <span class="comment">##只要包含一个或多个给定的值 $in</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$exists</span>:1&#125;&#125;)                        <span class="comment">##存在filed字段的</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$exists</span>:0&#125;&#125;)                        <span class="comment">##不存在filed字段的</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$mod</span>:[3,1]&#125;&#125;)                       <span class="comment">##模三余一，$mod(取模操作)</span></span><br><span class="line">db.col.find(&#123;<span class="variable">$or</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) <span class="comment">##或 $or</span></span><br><span class="line">db.col.find(&#123;<span class="variable">$nor</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)<span class="comment">##排除 $nor</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$size</span>: 3&#125;&#125;)                         <span class="comment">##返回值得数组是给定的长度(3) $size</span></span><br><span class="line">db.col.find(&#123;<span class="variable">$where</span>: <span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> ...&#125;&#125;)            <span class="comment">##回调，隐式迭代，符合条件才返回</span></span><br><span class="line">db.col.find(&#123;<span class="variable">$where</span>: <span class="string">'...'</span>&#125;&#125;)                            <span class="comment">##同上</span></span><br><span class="line">db.col.find(&#123;age: &#123;<span class="variable">$lt</span>: 5&#125;&#125;).<span class="built_in">limit</span>(3)                    <span class="comment">##查询age的值小于5，限制3条</span></span><br><span class="line">    <span class="comment">#范围查询：</span></span><br><span class="line">    <span class="comment">#    $lt  （小于）</span></span><br><span class="line">    <span class="comment">#    $gt  （大于）</span></span><br><span class="line">    <span class="comment">#    $lte （小于等于）</span></span><br><span class="line">    <span class="comment">#    $gte （大于等于）</span></span><br><span class="line">    <span class="comment">#    limit（限制显示）</span></span><br><span class="line">db.col.find().skip(2).<span class="built_in">limit</span>(3)                           <span class="comment">##跳过前两个文档查询后面三个</span></span><br><span class="line">    <span class="comment">#  skip(num):表示跳过前面num个文档</span></span><br><span class="line">db.col.find().sort(&#123;age: 1&#125;)                             <span class="comment">##查询后以age升序排列显示</span></span><br><span class="line">    <span class="comment">#  sort():排序，这里 1 代表升序, -1 代表降序.</span></span><br><span class="line">db.col.find(&#123;filed: /user.*/i&#125;)                          <span class="comment">##正则，查询filed以user开头不区分大小写（正则效率低）</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$type</span>: 1&#125;&#125;)                         <span class="comment">##查找filed为双精度的文档</span></span><br><span class="line">    <span class="comment"># 根据数据类型查询 $type</span></span><br><span class="line">    <span class="comment">#      |类型　　　　　　　　|编号|</span></span><br><span class="line">    <span class="comment">#      |双精度　　　　　　　|1 　|</span></span><br><span class="line">    <span class="comment">#      |字符串　　　　　　　|2 　|</span></span><br><span class="line">    <span class="comment">#      |对象　　　　　　　　|3   |</span></span><br><span class="line">    <span class="comment">#      |数组　　　　　　　　|4   |</span></span><br><span class="line">    <span class="comment">#      |二进制数据　　　　　|5   |</span></span><br><span class="line">    <span class="comment">#      |对象ID　　　　　　　|7   |</span></span><br><span class="line">    <span class="comment">#      |布尔值　　　　　　　|8   |</span></span><br><span class="line">    <span class="comment">#      |日期　　　　　　　　|9   |</span></span><br><span class="line">    <span class="comment">#      |空　　　　　　　　　|10  |</span></span><br><span class="line">    <span class="comment">#      |正则表达式　　　　　|11  |</span></span><br><span class="line">    <span class="comment">#      |JavaScript　　　　|13  |</span></span><br><span class="line">    <span class="comment">#      |符号　　　　　　　　|14  |</span></span><br><span class="line">    <span class="comment">#      |JavaScript(带范围)|15  |</span></span><br><span class="line">    <span class="comment">#      |32位整数　　　　　　|16  |</span></span><br><span class="line">    <span class="comment">#      |时间戳　　　　　　　|17  |</span></span><br><span class="line">    <span class="comment">#      |64位整数　　　　　　|18  |</span></span><br><span class="line">    <span class="comment">#      |最小键　　　　　　　|255 |</span></span><br><span class="line">    <span class="comment">#      |最大键　　　　　　　|127 |</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2、group分组查询"><a href="#4-2、group分组查询" class="headerlink" title="4.2、group分组查询"></a>4.2、group分组查询</h4><p>group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group(&#123;</span><br><span class="line">  key:&#123;字段:1&#125;,</span><br><span class="line">  initial:&#123;变量:初始值&#125;,</span><br><span class="line">  <span class="variable">$reduce</span>:<span class="keyword">function</span>(doc,prev)&#123;函数代码&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中key下的字段代表,需要按哪个字段分组.<br>initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.<br>$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.</p>
<p>栗子：如下我们按年龄分组,同级不同年龄的用户的多少:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">db.user.find()</span><br><span class="line">    &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b2"</span>), <span class="string">"name"</span> : <span class="string">"user0"</span>, <span class="string">"age"</span> : 0 &#125;</span><br><span class="line">    &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b3"</span>), <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : 1 &#125;</span><br><span class="line">    &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b4"</span>), <span class="string">"name"</span> : <span class="string">"user2"</span>, <span class="string">"age"</span> : 2 &#125;</span><br><span class="line">    &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b5"</span>), <span class="string">"name"</span> : <span class="string">"user3"</span>, <span class="string">"age"</span> : 1 &#125;</span><br><span class="line">    &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b6"</span>), <span class="string">"name"</span> : <span class="string">"user4"</span>, <span class="string">"age"</span> : 1 &#125;</span><br><span class="line">    &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b7"</span>), <span class="string">"name"</span> : <span class="string">"user5"</span>, <span class="string">"age"</span> : 2 &#125;</span><br><span class="line"></span><br><span class="line">db.user.group(&#123;</span><br><span class="line">    key:&#123;age:1&#125;,</span><br><span class="line">    initial:&#123;count:0&#125;,</span><br><span class="line">    <span class="variable">$reduce</span>:<span class="keyword">function</span>(doc,prev)&#123;</span><br><span class="line">        prev.count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br><span class="line">    [</span><br><span class="line">        &#123;<span class="string">"age"</span>: 0, <span class="string">"count"</span>: 1&#125;,</span><br><span class="line">        &#123;<span class="string">"age"</span>: 1, <span class="string">"count"</span>: 3&#125;,</span><br><span class="line">        &#123;<span class="string">"age"</span>: 2, <span class="string">"count"</span>: 2&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">db.user.group(&#123;</span><br><span class="line">    key:&#123;age:1&#125;,</span><br><span class="line">    initial:&#123;users:[]&#125;,</span><br><span class="line">    reduce:<span class="keyword">function</span>(doc,prev)&#123;</span><br><span class="line">        prev.users.push(doc.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  [</span><br><span class="line">      &#123;<span class="string">"age"</span>: 0, <span class="string">"users"</span>: [<span class="string">"user0"</span>]&#125;,</span><br><span class="line">      &#123;<span class="string">"age"</span>: 1, <span class="string">"users"</span>: [<span class="string">"user1"</span>, <span class="string">"user3"</span>, <span class="string">"user4"</span>]&#125;,</span><br><span class="line">      &#123;<span class="string">"age"</span>: 2, <span class="string">"users"</span>: [<span class="string">"user2"</span>, <span class="string">"user5"</span>]&#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>另外本函数还有两个可选参数 condition 和 finalize<br>condition就是分组的条件筛选类似mysql中的having</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.user.group(&#123;</span><br><span class="line">    key:&#123;age:1&#125;,</span><br><span class="line">    initial:&#123;users:[]&#125;,</span><br><span class="line">    <span class="variable">$reduce</span>:<span class="keyword">function</span>(doc,prev)&#123;</span><br><span class="line">        prev.users.push(doc.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    condition:&#123;age:&#123;<span class="variable">$gt</span>:0&#125;&#125;&#125;)</span><br><span class="line">　<span class="comment">##筛选出age大于0的:</span></span><br><span class="line">[</span><br><span class="line">    &#123;<span class="string">"age"</span>: 1, <span class="string">"users"</span>: [<span class="string">"user1"</span>, <span class="string">"user3"</span>, <span class="string">"user4"</span>]&#125;,</span><br><span class="line">    &#123;<span class="string">"age"</span>: 2, <span class="string">"users"</span>: [<span class="string">"user2"</span>, <span class="string">"user5"</span>]&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="4-3、count统计"><a href="#4-3、count统计" class="headerlink" title="4.3、count统计"></a>4.3、count统计</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.goods.count()            <span class="comment">##统计该集合总数</span></span><br><span class="line">db.goods.count(&#123;cat_id: 3&#125;) <span class="comment">##统计cat_id=3的总数</span></span><br></pre></td></tr></table></figure>

<h4 id="4-4、distinct排重"><a href="#4-4、distinct排重" class="headerlink" title="4.4、distinct排重"></a>4.4、distinct排重</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.user.find()</span><br><span class="line">   &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b2"</span>), <span class="string">"name"</span> : <span class="string">"user0"</span>, <span class="string">"age"</span> : 0 &#125;</span><br><span class="line">   &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b3"</span>), <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : 1 &#125;</span><br><span class="line">   &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b4"</span>), <span class="string">"name"</span> : <span class="string">"user2"</span>, <span class="string">"age"</span> : 2 &#125;</span><br><span class="line">   &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b5"</span>), <span class="string">"name"</span> : <span class="string">"user3"</span>, <span class="string">"age"</span> : 1 &#125;</span><br><span class="line">   &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b6"</span>), <span class="string">"name"</span> : <span class="string">"user4"</span>, <span class="string">"age"</span> : 1 &#125;</span><br><span class="line">   &#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5198c286c686eb50e2c843b7"</span>), <span class="string">"name"</span> : <span class="string">"user5"</span>, <span class="string">"age"</span> : 2 &#125;</span><br><span class="line"></span><br><span class="line"> db.user.distinct(<span class="string">"age"</span>) <span class="comment">## 特殊,传入的参数直接是字符串,而不是对象;</span></span><br><span class="line">     [0, 1, 2]</span><br></pre></td></tr></table></figure>

<h4 id="4-5、子文档查询-elemMatch"><a href="#4-5、子文档查询-elemMatch" class="headerlink" title="4.5、子文档查询$elemMatch"></a>4.5、子文档查询$elemMatch</h4><p>elemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。<br>注意：<br>(1)数组中元素是内嵌文档。<br>(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。<br>假设集合school有如下数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> _id: 1,</span><br><span class="line"> zipcode: 63109,</span><br><span class="line"> students: [</span><br><span class="line">              &#123; name: <span class="string">"john"</span>, school: 102, age: 10 &#125;,</span><br><span class="line">              &#123; name: <span class="string">"jess"</span>, school: 102, age: 11 &#125;,</span><br><span class="line">              &#123; name: <span class="string">"jeff"</span>, school: 108, age: 15 &#125;</span><br><span class="line">           ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> _id: 2,</span><br><span class="line"> zipcode: 63110,</span><br><span class="line"> students: [</span><br><span class="line">              &#123; name: <span class="string">"ajax"</span>, school: 100, age: 7 &#125;,</span><br><span class="line">              &#123; name: <span class="string">"achilles"</span>, school: 100, age: 8 &#125;,</span><br><span class="line">           ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> _id: 3,</span><br><span class="line"> zipcode: 63109,</span><br><span class="line"> students: [</span><br><span class="line">              &#123; name: <span class="string">"ajax"</span>, school: 100, age: 7 &#125;,</span><br><span class="line">              &#123; name: <span class="string">"achilles"</span>, school: 100, age: 8 &#125;,</span><br><span class="line">           ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> _id: 4,</span><br><span class="line"> zipcode: 63109,</span><br><span class="line"> students: [</span><br><span class="line">              &#123; name: <span class="string">"barney"</span>, school: 102, age: 7 &#125;,</span><br><span class="line">           ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; <span class="variable">$elemMatch</span>: &#123; school: 102 &#125; &#125; &#125; );</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"_id"</span>: 1, <span class="string">"students"</span>: [&#123;<span class="string">"name"</span>:<span class="string">"john"</span>, <span class="string">"school"</span>:102, <span class="string">"age"</span>:10&#125;]&#125;</span><br><span class="line">&#123;<span class="string">"_id"</span>: 3&#125;</span><br><span class="line">&#123;<span class="string">"_id"</span>: 4, <span class="string">"students"</span>: [&#123;<span class="string">"name"</span>:<span class="string">"barney"</span>, <span class="string">"school"</span>:102, <span class="string">"age"</span>:7&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果说明：<br><code>_id为1的文档</code>，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。<br><code>_id为3的文档</code>，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。</p>
<p>$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; <span class="variable">$elemMatch</span>: &#123; school: 102, age: &#123; <span class="variable">$gt</span>: 10&#125; &#125; &#125; &#125; );</span><br><span class="line"></span><br><span class="line">  &#123;<span class="string">"_id"</span>: 1, <span class="string">"students"</span>: [&#123;<span class="string">"name"</span>:<span class="string">"jess"</span>, <span class="string">"school"</span>:102, <span class="string">"age"</span>:11&#125;]&#125;</span><br><span class="line">  &#123;<span class="string">"_id"</span>: 3&#125;</span><br><span class="line">  &#123;<span class="string">"_id"</span>: 4&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[sublime text3个人习惯配置]]></title>
      <url>http://chaooo.github.io/2016/06/29/sublime-text3%E4%B8%AA%E4%BA%BA%E4%B9%A0%E6%83%AF%E9%85%8D%E7%BD%AE-C.html</url>
      <content type="html"><![CDATA[<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>分别在官网下载并安装 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs</a> 和 <a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">sublime text3</a>。</p>
<h3 id="2、sublime-text3注册："><a href="#2、sublime-text3注册：" class="headerlink" title="2、sublime text3注册："></a>2、sublime text3注册：</h3><a id="more"></a> 
<p>点击菜单【help】－&gt;【Enter License】，粘贴注册码。</p>
<h3 id="3、安装package-control组件，用于管理所有插件"><a href="#3、安装package-control组件，用于管理所有插件" class="headerlink" title="3、安装package control组件，用于管理所有插件"></a>3、安装package control组件，用于管理所有插件</h3><p>按ctrl + ~调出控制台(或点击菜单栏的【View】-&gt;【Show Console】)，在Console窗口中输入以下代码，按回车键：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = <span class="string">'2915d1851351e5ee549c20394736b442'</span> + <span class="string">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).<span class="built_in">read</span>(); dh = hashlib.sha256(by).hexdigest(); <span class="built_in">print</span>(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure>

<p>等待安装完毕，重启Sublime Text3。<br>按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：</p>
<h3 id="4、用Package-Control安装插件"><a href="#4、用Package-Control安装插件" class="headerlink" title="4、用Package Control安装插件"></a>4、用Package Control安装插件</h3><p>按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）<br><code>Material Theme</code><br><code>Emmet</code><br><code>CSS Format</code><br><code>CSScomb</code><br><code>jsFormat</code><br><code>AutoFileName</code><br><code>Autoprefixer</code><br><code>Doc Blockr</code><br><code>SublimeLinter</code><br><code>SublimeLinter-jshint</code><br><code>SublimeLinter-csslint</code><br><code>Color Highlighter</code><br><code>BracketHighlighter</code></p>
<h3 id="5、配置nodejs"><a href="#5、配置nodejs" class="headerlink" title="5、配置nodejs"></a>5、配置nodejs</h3><h5 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h5><p>(1)下载sublime Text的<a href="https://github.com/tanepiper/SublimeText-Nodejs" target="_blank" rel="noopener">nodejs插件</a><br>(2)下载后解压:直接改名为nodejs 放到 Preferences–&gt;浏览程序包Browse Packages所在的文件夹<br>(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cmd"</span>: [<span class="string">"node"</span>, <span class="string">"$file"</span>],</span><br><span class="line">  <span class="attr">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line">  <span class="attr">"selector"</span>: <span class="string">"source.js"</span>,</span><br><span class="line">  <span class="attr">"shell"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"encoding"</span>: <span class="string">"cp1252"</span>, </span><br><span class="line">  <span class="attr">"windows"</span>: </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="attr">"cmd"</span>: [<span class="string">"taskkill /F /IM node.exe &amp; node"</span>, <span class="string">"$file"</span>] </span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="attr">"linux"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"cmd"</span>: [<span class="string">"killall node; node"</span>, <span class="string">"$file"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"osx"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">  <span class="attr">"cmd"</span>: [<span class="string">"killall node; node $file"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)修改为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"cmd"</span>: [<span class="string">"node"</span>, <span class="string">"$file"</span>],</span><br><span class="line">  <span class="attr">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line">  <span class="attr">"selector"</span>: <span class="string">"source.js"</span>,</span><br><span class="line">  <span class="attr">"shell"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"encoding"</span>: <span class="string">"utf-8"</span>,</span><br><span class="line">  <span class="attr">"windows"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"cmd"</span>: [<span class="string">"taskkill /F /IM node.exe"</span>, <span class="string">""</span>],</span><br><span class="line">      <span class="attr">"cmd"</span>: [<span class="string">"node"</span>, <span class="string">"$file"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="attr">"linux"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"cmd"</span>: [<span class="string">"killall node; node"</span>, <span class="string">"$file"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"osx"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">  <span class="attr">"cmd"</span>: [<span class="string">"killall node; node $file"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(5)完成:随便写一段nodejs代码，ctrl+B运行<br>(6)注意：在手动解压sublime Text插件后，需要在preference-&gt;package settings-&gt;package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。</p>
<h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>首先需要先安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs</a>。<br>(1)运行Sublime,菜单上找到Tools —&gt; Build System —&gt; new Build System<br>(2)输入：<br>{<br>  “cmd”: [“node”, “$file”],<br>  “file_regex”: “^[ ]<em>File &quot;(…</em>?)&quot;, line ([0-9]*)”,<br>  “selector”: “source.js”,<br>  “shell”:true,<br>  “encoding”: “utf-8”,<br>  “windows”:<br>    {<br>      “cmd”: [“taskkill /F /IM node.exe”, “”],<br>      “cmd”: [“node”, “$file”]<br>    }<br>}<br>(3)保存文件为NodeJs.sublime-build<br>(4)菜单上找到Tools —&gt; Build System —&gt;选择 NodeJs<br>(5)安装sublime插件 JavaScript &amp; NodeJs Snippets<br>(6)新建test.js文件，输入 console.log(‘Hello Node.js’); 按快捷键 Ctrl + B 运行，成功输出</p>
]]></content>
      
        <categories>
            
            <category> 前端工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sublime </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo3.2+GitHub搭建静态博客]]></title>
      <url>http://chaooo.github.io/2016/05/23/Hexo3-2-github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2.html</url>
      <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>在安装<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>之前，必须确认你已经安装了<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>和<a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a>。</p>
<a id="more"></a> 
<h4 id="1-创建GitHub仓库"><a href="#1-创建GitHub仓库" class="headerlink" title="1.创建GitHub仓库"></a>1.创建GitHub仓库</h4><p>注册<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：<a href="https://github.com/chaooo/chaooo.github.io" target="_blank" rel="noopener">chaooo.github.io</a>，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>
<h4 id="2-配置Git"><a href="#2-配置Git" class="headerlink" title="2.配置Git"></a>2.配置Git</h4><p>设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"username"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<h4 id="3-本地Git与GitHub建立联系"><a href="#3-本地Git与GitHub建立联系" class="headerlink" title="3.本地Git与GitHub建立联系"></a>3.本地Git与GitHub建立联系</h4><p>这里介绍SSH的配置，先检查电脑是否已经有SSH</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"emailt@example.com"</span></span><br></pre></td></tr></table></figure>

<p>然后键入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent -s</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>如果出现这个错误:<code>Could not open a connection to your authentication agent</code>，则先执行如下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br></pre></td></tr></table></figure>

<p>再重新输入指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH key<br>Title自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。<br>最后还是测试一下吧，键入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>你可能会看到有警告，没事，输入“yes”就好。</p>
<h4 id="4-初始化hexo文件夹"><a href="#4-初始化hexo文件夹" class="headerlink" title="4.初始化hexo文件夹"></a>4.初始化hexo文件夹</h4><p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br><span class="line">$ mkdir Hexo-admin</span><br></pre></td></tr></table></figure>

<h3 id="Hexo安装配置"><a href="#Hexo安装配置" class="headerlink" title="Hexo安装配置"></a>Hexo安装配置</h3><h4 id="1-Hexo初始化"><a href="#1-Hexo初始化" class="headerlink" title="1.Hexo初始化"></a>1.Hexo初始化</h4><p>进入Hexo-admin文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Hexo-admin</span><br></pre></td></tr></table></figure>

<p>接下来只需要使用 npm 即可完成 Hexo 的安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>输入Ctrl+C停止服务。</p>
<h4 id="2-Hexo配置"><a href="#2-Hexo配置" class="headerlink" title="2.Hexo配置"></a>2.Hexo配置</h4><p>用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: </span><br><span class="line">  repository:</span><br></pre></td></tr></table></figure>

<p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/chaooo/chaooo.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h4 id="3-完成部署"><a href="#3-完成部署" class="headerlink" title="3.完成部署"></a>3.完成部署</h4><p>最后一步，快要成功了，键入指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href="http://chaooo.github.io/">chaooo.github.io/</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/chaooo/chaooo.github.io.git</span><br><span class="line">   7f3b50a..128a10d  HEAD -&gt; master</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<p>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p>
<h3 id="日常操作"><a href="#日常操作" class="headerlink" title="日常操作"></a>日常操作</h3><h4 id="1-写文章"><a href="#1-写文章" class="headerlink" title="1.写文章"></a>1.写文章</h4><p>执行new命令，生成指定名称的文章至 Admin-blog\source_posts\文章标题.md 。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] <span class="string">"文章标题"</span> <span class="comment">#新建文章</span></span><br></pre></td></tr></table></figure>

<p>然后用编辑器打开“文章标题.md”按照<a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown语法</a>书写文章。<br> 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br> 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\scaffolds\post.md</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br><code>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。</code></p>
<h4 id="2-提交"><a href="#2-提交" class="headerlink" title="2.提交"></a>2.提交</h4><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"..."</span></span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure>

<p>然后才执行hexo generate -d发布网站到master分支上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate -d</span><br></pre></td></tr></table></figure>

<h4 id="3-本地仓库丢失"><a href="#3-本地仓库丢失" class="headerlink" title="3.本地仓库丢失"></a>3.本地仓库丢失</h4><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p>
<h5 id="3-1拷贝仓库"><a href="#3-1拷贝仓库" class="headerlink" title="3.1拷贝仓库"></a>3.1拷贝仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br></pre></td></tr></table></figure>

<h5 id="3-2配置Hexo"><a href="#3-2配置Hexo" class="headerlink" title="3.2配置Hexo"></a>3.2配置Hexo</h5><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ npm install hexo</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h5 id="小Tips-hexo-命令"><a href="#小Tips-hexo-命令" class="headerlink" title="小Tips:hexo 命令"></a>小Tips:hexo 命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br><span class="line">hexo deploy -g  <span class="comment">#生成加部署</span></span><br><span class="line">hexo server -g  <span class="comment">#生成加预览</span></span><br><span class="line"><span class="comment">#命令的简写</span></span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> hexo博客折腾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://chaooo.github.io/2015/12/31/hello-world.html</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> hexo博客折腾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
