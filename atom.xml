<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路，走过去，前面是个天！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chaooo.github.io/"/>
  <updated>2019-09-08T13:56:29.472Z</updated>
  <id>http://chaooo.github.io/</id>
  
  <author>
    <name>郑超(Charles·Zheng)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MD5算法加盐实现用户密码加密</title>
    <link href="http://chaooo.github.io/2019/09/08/MD5%E7%AE%97%E6%B3%95%E5%8A%A0%E7%9B%90%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86.html"/>
    <id>http://chaooo.github.io/2019/09/08/MD5算法加盐实现用户密码加密.html</id>
    <published>2019-09-08T13:49:28.000Z</published>
    <updated>2019-09-08T13:56:29.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MD5加密算法介绍"><a href="#1-MD5加密算法介绍" class="headerlink" title="1. MD5加密算法介绍"></a>1. MD5加密算法介绍</h3><p>MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。</p><h3 id="2-MD5加密算法特点："><a href="#2-MD5加密算法特点：" class="headerlink" title="2. MD5加密算法特点："></a>2. MD5加密算法特点：</h3><ol><li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li><li>容易计算：从原数据计算出MD5值很容易。</li><li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ol><h3 id="3-盐（Salt）"><a href="#3-盐（Salt）" class="headerlink" title="3. 盐（Salt）"></a>3. 盐（Salt）</h3><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p><h3 id="4-java-security-MessageDigest类"><a href="#4-java-security-MessageDigest类" class="headerlink" title="4. java.security.MessageDigest类"></a>4. java.security.MessageDigest类</h3><p>JDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。</p><ul><li>MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。</li><li>MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。</li><li>对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。</li></ul><h3 id="5-封装一个MD5加密工具类"><a href="#5-封装一个MD5加密工具类" class="headerlink" title="5. 封装一个MD5加密工具类"></a>5. 封装一个MD5加密工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s：待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化MessageDigest的MD5算法对象</span></span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="comment">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = md.digest(s.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="comment">//将字节数组转换为16进制字符串并返回</span></span><br><span class="line">            <span class="keyword">return</span> toHex(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随即盐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">salt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用UUID生成随机盐</span></span><br><span class="line">        UUID uuid = UUID.randomUUID();</span><br><span class="line">        <span class="comment">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class="line">        String[] arr = uuid.toString().split(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转换为16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] HEX_DIGITS = <span class="string">"0123456789ABCDEF"</span>.toCharArray();</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class="line">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]);</span><br><span class="line">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class="number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-使用封装的MD5工具类完成用户注册-主要代码"><a href="#6-使用封装的MD5工具类完成用户注册-主要代码" class="headerlink" title="6. 使用封装的MD5工具类完成用户注册(主要代码)"></a>6. 使用封装的MD5工具类完成用户注册(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">register</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">//设置用户名</span></span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="comment">//密码加密后再保存</span></span><br><span class="line">    String salt = MD5Util.salt();</span><br><span class="line">    String md5Password = MD5Util.md5(password+salt);</span><br><span class="line">    <span class="comment">//存入MD5加密后的密码</span></span><br><span class="line">    user.setPassword(md5Password);</span><br><span class="line">    <span class="comment">//随机盐存入数据库，用于登录校验</span></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line">    <span class="comment">//最后将用户数据数据存入数据库</span></span><br><span class="line">    <span class="keyword">int</span> row = userDao.insert(user);</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-使用封装的MD5工具类完成用户登录-主要代码"><a href="#7-使用封装的MD5工具类完成用户登录-主要代码" class="headerlink" title="7. 使用封装的MD5工具类完成用户登录(主要代码)"></a>7. 使用封装的MD5工具类完成用户登录(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据用户名在数据库查找用户</span></span><br><span class="line">    User user = userDao.selectByName(name);</span><br><span class="line">    <span class="comment">//取出用户信息比对</span></span><br><span class="line">    String dbPassword = user.getPassword();</span><br><span class="line">    String  salt = user.getSalt();</span><br><span class="line">    <span class="comment">//通过密码+盐 重新生成 MD5密码</span></span><br><span class="line">    String md5Password = MD5Util.md5(password+salt);</span><br><span class="line">    <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">        <span class="comment">//登录成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-扩展：MessageDigest类常用方法"><a href="#8-扩展：MessageDigest类常用方法" class="headerlink" title="8. 扩展：MessageDigest类常用方法"></a>8. 扩展：MessageDigest类常用方法</h3><h4 id="8-1-构造方法摘要"><a href="#8-1-构造方法摘要" class="headerlink" title="8.1 构造方法摘要"></a>8.1 构造方法摘要</h4><p><code>MessageDigest(String algorithm)</code> –创建具有指定算法名称的MessageDigest 实例对象。</p><ul><li>MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有”MD5”，”SHA”等。</li></ul><h4 id="8-2-成员方法摘要："><a href="#8-2-成员方法摘要：" class="headerlink" title="8.2 成员方法摘要："></a>8.2 成员方法摘要：</h4><table><thead><tr><th>返回值</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Object</td><td><code>clone()</code></td><td>如果实现是可复制的，则返回一个副本。</td></tr><tr><td>byte[]</td><td><code>digest()</code></td><td>通过执行诸如填充之类的最终操作完成哈希计算。</td></tr><tr><td>byte[]</td><td><code>digest(byte[] input)</code></td><td>使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。</td></tr><tr><td>int</td><td><code>digest(byte[] buf, int offset, int len)</code></td><td>通过执行诸如填充之类的最终操作完成哈希计算。</td></tr><tr><td>String</td><td><code>getAlgorithm()</code></td><td>返回标识算法的独立于实现细节的字符串。</td></tr><tr><td>int</td><td><code>getDigestLength()</code></td><td>返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm)</code></td><td>生成实现指定摘要算法的 MessageDigest 对象。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm, Provider provider)</code></td><td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm, String provider)</code></td><td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td></tr><tr><td>Provider</td><td><code>getProvider()</code></td><td>返回此信息摘要对象的提供程序。</td></tr><tr><td>static boolean</td><td><code>isEqual(byte[] digesta, byte[] digestb)</code></td><td>比较两个摘要的相等性。</td></tr><tr><td>void</td><td><code>reset()</code></td><td>重置摘要以供再次使用。</td></tr><tr><td>String</td><td><code>toString()</code></td><td>返回此信息摘要对象的字符串表示形式。</td></tr><tr><td>void</td><td><code>update(byte input)</code></td><td>使用指定的字节更新摘要。</td></tr><tr><td>void</td><td><code>update(byte[] input)</code></td><td>使用指定的字节数组更新摘要。</td></tr><tr><td>void</td><td><code>update(byte[] input, int offset, int len)</code></td><td>使用指定的字节数组，从指定的偏移量开始更新摘要。</td></tr><tr><td>void</td><td><code>update(ByteBuffer input)</code></td><td>使用指定的 ByteBuffer 更新摘要。</td></tr></tbody></table><blockquote><p>★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-MD5加密算法介绍&quot;&gt;&lt;a href=&quot;#1-MD5加密算法介绍&quot; class=&quot;headerlink&quot; title=&quot;1. MD5加密算法介绍&quot;&gt;&lt;/a&gt;1. MD5加密算法介绍&lt;/h3&gt;&lt;p&gt;MD5的全称是Message-Digest Algorithm 
      
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式SQL语言</title>
    <link href="http://chaooo.github.io/2019/09/02/03-%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AF%AD%E8%A8%80.html"/>
    <id>http://chaooo.github.io/2019/09/02/03-嵌入式SQL语言.html</id>
    <published>2019-09-02T06:32:28.000Z</published>
    <updated>2019-09-02T06:37:43.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，</li><li>然而，交互式SQL本身也有很多局限：<a id="more"></a><ul><li>从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以</li><li>从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</li></ul></li><li>因此，高级语言+SQL语言：<ul><li>既继承高级语言的过程控制性</li><li>又结合SQL语言的复杂结果集操作的非过程性</li><li>同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作</li></ul></li><li>嵌入式SQL语言<ul><li>将SQL语言嵌入到某一种高级语言中使用</li><li>这种高级语言，如C/C++, Java, PowerBuilder等，又称宿主语言(Host Language)</li><li>嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式</li></ul></li></ul><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol><li><a href="#id1">变量声明与数据库连接</a></li><li><a href="#id2">事务Transaction</a></li><li><a href="#id3">数据集与游标</a></li><li><a href="#id4">状态捕获及错误处理机制</a></li><li><a href="#id5">动态SQL</a></li><li><a href="#id6">数据字典与SQLDA</a></li><li><a href="#id7">ODBC简介</a></li><li><a href="#id8">JDBC简介</a></li><li><a href="#id9">嵌入式SQL-ODBC-JDBC三者比较</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-变量声明与数据库连接"><a href="#1-变量声明与数据库连接" class="headerlink" title="1. 变量声明与数据库连接"></a>1. 变量声明与数据库连接</h3><ol><li>以宿主语言<strong>C语言</strong>为例，对比交互式SQL语言与嵌入式SQL语言<ul><li>交互式SQL:<code>select Sname, Sage from Student where Sname=&#39;张三&#39;;</code></li><li>嵌入式SQL:<code>exec sql select Sname, Sage into :vSname, :vSage from Student where Sname=&#39;张三&#39;;</code></li></ul></li><li>典型特点<ul><li><strong>exec sql</strong>引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句</li><li>增加一 <strong>into子句</strong>: 该子句用于指出接收SQL语句检索结果的程序变量</li><li>由冒号引导的<strong>程序变量</strong>,如: ‘:vSname’, ‘:vSage’</li></ul></li></ol><h4 id="1-1-变量的声明与使用"><a href="#1-1-变量的声明与使用" class="headerlink" title="1.1 变量的声明与使用"></a>1.1 变量的声明与使用</h4><ul><li><p>在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">    char vSname[10], specName[10]="张三";</span><br><span class="line">    int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br></pre></td></tr></table></figure></li><li><p>变量声明和赋值中，要注意：</p><ul><li>宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为’\0’，而程序中用双引号来描述。</li><li>宿主程序变量类型与数据库字段类型之间有些是有差异的,有些DBMS可支持自动转换，有些不能。</li></ul></li><li><p>声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。</p></li><li><p>嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">    char vSname[10], specName[10]="张三";</span><br><span class="line">    int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">//用户可在此处基于键盘输入给specName赋值</span><br><span class="line">exec sql <span class="keyword">select</span> Sname, Sage <span class="keyword">into</span> :vSname, :vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname = :specName;</span><br><span class="line">//比较相应的交互式SQL语句：</span><br><span class="line"><span class="keyword">select</span> Sname, Sage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-程序与数据库的连接和断开"><a href="#1-2-程序与数据库的连接和断开" class="headerlink" title="1.2 程序与数据库的连接和断开"></a>1.2 程序与数据库的连接和断开</h4><h5 id="1-2-1-数据库的连接connect"><a href="#1-2-1-数据库的连接connect" class="headerlink" title="1.2.1 数据库的连接connect"></a>1.2.1 数据库的连接connect</h5><p>在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异</p><ol><li>SQL标准中建议的连接语法为：<ul><li><code>execsql connecttotarget-server asconnect-name useruser-name;</code></li><li>或 <code>execsql connecttodefault;</code></li></ul></li><li>Oracle中数据库连接:<ul><li><code>execsql connect:user_name identified by :user_pwd;</code></li></ul></li><li>DB2 UDB中数据库连接:<ul><li><code>execsql connecttomydb user:user_name using:user_pwd;</code></li></ul></li></ol><h5 id="1-2-1-数据库的断开disconnect"><a href="#1-2-1-数据库的断开disconnect" class="headerlink" title="1.2.1 数据库的断开disconnect"></a>1.2.1 数据库的断开disconnect</h5><p>在嵌入式SQL程序执行之后，需要与数据库断开连接</p><ol><li>SQL标准中建议的断开连接的语法为：<ul><li><code>exec sql disconnect connect-name;</code></li><li>或 <code>exec sql disconnect current;</code></li></ul></li><li>Oracle中断开连接:<ul><li><code>exec sql commit release;</code></li><li>或 <code>exec sql rollback release;</code></li></ul></li><li>DB2 UDB中断开连接:<ul><li><code>exec sql connect reset;</code></li><li><code>exec sql disconnect current;</code></li></ul></li></ol><h4 id="1-3-SQL执行的提交与撤消"><a href="#1-3-SQL执行的提交与撤消" class="headerlink" title="1.3 SQL执行的提交与撤消"></a>1.3 SQL执行的提交与撤消</h4><p>SQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果</p><ol><li>SQL执行的提交：<ul><li><code>execsql commitwork;</code></li></ul></li><li>SQL执行的撤消：<ul><li><code>execsql rollbackwork;</code></li></ul></li><li>为此，很多DBMS都设计了捆绑提交/撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：<ul><li><code>execsql commitrelease;</code></li><li>或 <code>execsql rollbackrelease;</code></li></ul></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-事务Transaction"><a href="#2-事务Transaction" class="headerlink" title="2. 事务Transaction"></a>2. 事务Transaction</h3><ol><li>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务</li><li>从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li><li>简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；<strong>事务是一个不可分割的工作逻辑单元</strong>。</li></ol><h4 id="2-1-事务的特性-ACID"><a href="#2-1-事务的特性-ACID" class="headerlink" title="2.1 事务的特性: ACID"></a>2.1 事务的特性: ACID</h4><ol><li><strong>原子性</strong>Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行</li><li><strong>一致性</strong>Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的</li><li><strong>隔离性</strong>Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。</li><li><strong>持久性</strong>Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。</li></ol><blockquote><p>换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。</p></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-数据集与游标"><a href="#3-数据集与游标" class="headerlink" title="3. 数据集与游标"></a>3. 数据集与游标</h3><p>读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)</p><ol><li>检索单行结果，可将结果直接传送到宿主程序的变量中(Into)<ul><li>示例：<code>exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;</code></li></ul></li><li>检索多行结果，则需使用游标(Cursor)<ul><li>游标是指向某检索记录集的指针</li><li>通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕</li><li>读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取</li><li>记录集有结束标识EOF, 用来标记后面已没有记录了</li></ul></li></ol><ul><li>游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭</li><li>游标可以定义一次，多次打开(多次执行)，多次关闭</li></ul><h4 id="3-1-游标的使用方法"><a href="#3-1-游标的使用方法" class="headerlink" title="3.1 游标的使用方法"></a>3.1 游标的使用方法</h4><ol><li><p>Cursor的定义：declare cursor</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    Subquery</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">    [<span class="keyword">FOR</span> [ <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> columnname [, columnname…]]]];</span><br><span class="line">//示例:</span><br><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass= :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br></pre></td></tr></table></figure></li><li><p>Cursor的打开和关闭：open cursor //close cursor</p><ul><li>EXEC SQL OPEN cursor_name;</li><li>EXEC SQL CLOSE cursor_name;</li></ul></li><li><p>Cursor的数据读取：Fetch</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH cursor_name</span><br><span class="line">    INTO host-variable , [host-variable, …];</span><br><span class="line">//示例:</span><br><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass= :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br><span class="line">exec sql open cur_student;</span><br><span class="line">…</span><br><span class="line">exec sql fetch cur_student into :vSno, :vSname, :vSage</span><br><span class="line">…</span><br><span class="line">exec sql close cur_student;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-可滚动游标"><a href="#3-2-可滚动游标" class="headerlink" title="3.2 可滚动游标"></a>3.2 可滚动游标</h4><ol><li>ODBC支持的可滚动Cursor<ul><li>标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开</li><li>ODBC(OpenDataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口</li><li>许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能</li></ul></li><li>可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标<ul><li>可滚动游标移动时需判断是否到结束位置，或到起始位置<ul><li>可通过判断是否到EOF位置(最后一条记录的后面),或BOF位置(起始记录的前面)</li><li>如果不需区分，可通过whenevernotfound语句设置来检测</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name [INSENSITIVE] [<span class="keyword">SCROLL</span>] <span class="keyword">CURSOR</span></span><br><span class="line">[<span class="keyword">WITH</span> HOLD] <span class="keyword">FOR</span> Subquery</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> columnname [,</span><br><span class="line">columnname ]…];</span><br><span class="line">EXEC SQL FETCH</span><br><span class="line">[ NEXT | PRIOR | FIRST | LAST</span><br><span class="line">| [ABSOLUTE | RELATIVE] value_spec ]</span><br><span class="line">FROM cursor_name INTO host-variable [, host-variable …];</span><br></pre></td></tr></table></figure><ul><li><code>NEXT</code>向结束方向移动一条；</li><li><code>PRIOR</code>向开始方向移动一条；</li><li><code>FIRST</code>回到第一条；</li><li><code>LAST</code>移动到最后一条；</li><li><code>ABSOLUTvalue_spec</code>定向检索指定位置的行,value_spec由1至当前记录集最大值；</li><li><code>RELATIVEvalue_spec</code>相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动</li></ul><h4 id="3-3-数据库记录的增删改"><a href="#3-3-数据库记录的增删改" class="headerlink" title="3.3 数据库记录的增删改"></a>3.3 数据库记录的增删改</h4><ol><li>数据库记录的删除<ul><li>一种是查找删除(与交互式DELETE语句相同)，一种是定位删除</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">WHERE</span> search_condition | <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line">//示例：查找删除</span><br><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city = ‘Harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid);</span><br><span class="line">//示例：定位删除</span><br><span class="line">exec sql <span class="keyword">declare</span> delcust <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> cid <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city =‘harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> cid;</span><br><span class="line">exec sql open delcust</span><br><span class="line">While (TRUE) &#123;</span><br><span class="line">    exec sql fetch delcust into :cust_id;</span><br><span class="line">    exec sql delete from customers where current of delcust ; &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>数据库记录的更新<ul><li>一种是查找更新(与交互式Update语句相同)，一种是定位更新</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">UPDATE</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">SET</span> columnname = expr [, columnname = expr …]</span><br><span class="line">    [ <span class="keyword">WHERE</span> search_condition ] | <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line">//示例：查找更新</span><br><span class="line">exec sql <span class="keyword">update</span> student s <span class="keyword">set</span> sclass = ‘<span class="number">035102</span>’</span><br><span class="line">    <span class="keyword">where</span> s.sclass = ‘<span class="number">034101</span>’</span><br><span class="line">// 示例：定位更新</span><br><span class="line">exec <span class="keyword">sql</span> <span class="keyword">declare</span> stud <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.sclass =‘<span class="number">034101</span>’</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> sclass;</span><br><span class="line">exec sql open stud</span><br><span class="line">While (TRUE) &#123;</span><br><span class="line">    exec sql fetch stud into :vSno, :vSname, :vSclass;</span><br><span class="line">    exec sql update student set sclass = ‘035102’ where current of stud ; &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>数据库记录的插入<ul><li>只有一种类型的插入语句</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename [ (columnname [,columnname, …] )]</span><br><span class="line">    [ <span class="keyword">VALUES</span> (expr [ , expr , …] ) | subqurey ] ;</span><br><span class="line">//示例：插入语句</span><br><span class="line">exec sql <span class="keyword">insert</span> <span class="keyword">into</span> student ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">values</span> (‘<span class="number">03510128</span>’, ‘张三’, ‘<span class="number">035101</span>’) ;</span><br><span class="line">//示例：插入语句</span><br><span class="line">exec sql <span class="keyword">insert</span> <span class="keyword">into</span> masterstudent ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">select</span> sno, sname, sclass <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-状态捕获及错误处理机制"><a href="#4-状态捕获及错误处理机制" class="headerlink" title="4. 状态捕获及错误处理机制"></a>4. 状态捕获及错误处理机制</h3><h4 id="4-1-基本机制"><a href="#4-1-基本机制" class="headerlink" title="4.1 基本机制"></a>4.1 基本机制</h4><ul><li><p>状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理</p></li><li><p>嵌入式 SQL程序中，状态捕获及处理有三部分构成</p><ol><li>设置SQL通信区:一般在嵌入式SQL程序的开始处便设置<ul><li><code>exec sql include sqlca;</code></li></ul></li><li>设置状态捕获语句:在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域<ul><li><code>exec sql whenever sqlerror goto report_error;</code></li></ul></li><li>状态处理语句:某一段程序以应对SQL操作的某种状态<ul><li><code>report_error: exec sql rollback;</code></li></ul></li></ol></li><li><p>SQL通信区: SQLCA</p><ol><li>SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理</li><li>SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一</li></ol></li><li><p>状态捕获语句: <code>exec sql whenever condition action;</code></p><ul><li>Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).<ul><li>SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS</li><li>NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现</li><li>SQLWARNING: 不是错误，但应引起注意的条件</li></ul></li><li>如果满足condition, 则要采取一些动作(由action指出)<ul><li>CONTINUE: 忽略条件或错误，继续执行</li><li>GOTO 标号: 转移到标号所指示的语句，去进行相应的处理</li><li>STOP: 终止程序运行、撤消当前的工作、断开数据库的连接</li><li>DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行</li></ul></li></ul></li><li><p>状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    exec sql whenever sqlerror <span class="keyword">stop</span>;</span><br><span class="line">    … …</span><br><span class="line">    goto s1</span><br><span class="line">    … …</span><br><span class="line">    exec sql whenever sqlerror continue;</span><br><span class="line">    s1: exec sql <span class="keyword">update</span> agents <span class="keyword">set</span> <span class="keyword">percent</span> = <span class="keyword">percent</span> + <span class="number">1</span>;</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br><span class="line">//S1标号指示的语句受第二个Whenever语句约束。</span><br><span class="line">//注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)</span><br></pre></td></tr></table></figure></li><li><p>状态捕获语句Whenever的使用容易引发无限循环</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    exec sql whenever sqlerror goto handle_error;</span><br><span class="line">    exec sql <span class="keyword">create</span> <span class="keyword">table</span> customers(cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cname <span class="built_in">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">    … …</span><br><span class="line">    handle_error:</span><br><span class="line">        exec sql whenever sqlerror continue;// 控制是否无限循环：无，则可能；有，则不会</span><br><span class="line">        exec sql <span class="keyword">drop</span> customers;</span><br><span class="line">        exec sql disconnect;</span><br><span class="line">        fprintf(stderr,”could not <span class="keyword">create</span> customers <span class="keyword">table</span>\n”);</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-状态信息"><a href="#4-2-状态信息" class="headerlink" title="4.2 状态信息"></a>4.2 状态信息</h4><p>典型DBMS系统记录状态信息的三种方法</p><ul><li>状态记录:<ol><li><code>sqlcode</code>: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。<ul><li>sqlcode== 0, successful call;</li><li>sqlcode &lt; 0, error, e.g., from connect, database does not exist , –16;</li><li>sqlcode &gt; 0, warning, e.g., no rows retrieved from fetch</li></ul></li><li><code>sqlca.sqlcode</code>: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录</li><li><code>sqlstate</code>: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate</li></ol></li><li>当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)</li><li>但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)</li></ul><h4 id="4-3-程序自身进行错误信息的处理"><a href="#4-3-程序自身进行错误信息的处理" class="headerlink" title="4.3 程序自身进行错误信息的处理"></a>4.3 程序自身进行错误信息的处理</h4><p>正确的显式状态处理示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> declar <span class="keyword">section</span>;</span><br><span class="line">    char SQLSTATE[6];</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">exec sql whenever sqlerror goto handle_error;</span><br><span class="line">… …</span><br><span class="line">exec sql whenever sqlerror continue;</span><br><span class="line">exec sql <span class="keyword">create</span> <span class="keyword">table</span> custs</span><br><span class="line">    (cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>, cname <span class="built_in">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">if (strcmp(SQLSTATE, “82100”)==0)</span><br><span class="line">    &lt;处理82100错误的程序&gt;</span><br><span class="line">    … …</span><br></pre></td></tr></table></figure><p>上述的if语句是能被执行的，因为createtable发生错误时是继续向下执行的。</p><p><span id="id5"><span></span></span></p><h3 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h3><h4 id="5-1-动态SQL的概念"><a href="#5-1-动态SQL的概念" class="headerlink" title="5.1 动态SQL的概念"></a>5.1 动态SQL的概念</h4><p>动态SQL是相对于静态SQL而言的</p><ul><li>静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)</li><li>动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量</li></ul><h4 id="5-2-动态SQL的两种执行方式"><a href="#5-2-动态SQL的两种执行方式" class="headerlink" title="5.2 动态SQL的两种执行方式"></a>5.2 动态SQL的两种执行方式</h4><p>如SQL语句已经被构造在host-variable字符串变量中,则：</p><ol><li><strong>立即执行语句</strong>: 运行时编译并执行<ul><li><code>EXEC SQL EXECUTE IMMEDIATE :host-variable;</code></li></ul></li><li><strong>Prepare-Execute-Using语句</strong>:PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句<ul><li><code>EXEC SQL PREPARE sql_temp FROM :host-variable;</code></li><li><code>EXEC SQL EXECUTE sql_temp USING :cond-variable</code></li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-数据字典与SQLDA"><a href="#6-数据字典与SQLDA" class="headerlink" title="6. 数据字典与SQLDA"></a>6. 数据字典与SQLDA</h3><h4 id="6-1-数据字典的概念"><a href="#6-1-数据字典的概念" class="headerlink" title="6.1 数据字典的概念"></a>6.1 数据字典的概念</h4><p>数据字典(Data dictionary)，又称为系统目录(System Catalogs)</p><ul><li>是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等,这些信息又称数据库的元数据–关于数据的数据。</li><li>不同DBMS术语不一样：数据字典(DataDictionary(Oracle))、目录表(DB2UDB)、系统目录(INFORMIX)、系统视图(X/Open)</li><li>不同DBMS中系统目录存储方式可能是不同的,但会有一些信息对DBA公开。这些公开的信息,DBA可以使用一些特殊的SQL命令来检索。</li></ul><h4 id="6-2-数据字典的内容构成"><a href="#6-2-数据字典的内容构成" class="headerlink" title="6.2 数据字典的内容构成"></a>6.2 数据字典的内容构成</h4><p>数据字典通常存储的是数据库和表的元数据，即模式本身的信息：</p><ol><li>与关系相关的信息<ul><li>关系名字</li><li>每一个关系的属性名及其类型</li><li>视图的名字及其定义</li><li>完整性约束</li></ul></li><li>用户与账户信息，包括密码</li><li>统计与描述性数据：如每个关系中元组的数目</li><li>物理文件组织信息：<ul><li>关系是如何存储的(顺序/无序/散列等)</li><li>关系的物理位置</li></ul></li><li>索引相关的信息</li></ol><h4 id="6-3-数据字典的结构"><a href="#6-3-数据字典的结构" class="headerlink" title="6.3 数据字典的结构"></a>6.3 数据字典的结构</h4><ol><li>也是存储在磁盘上的关系</li><li>专为内存高效访问设计的特定的数据结构</li></ol><ul><li>可能的字典数据结构<ul><li><code>Relation_metadata</code> = <code>(relation_name, number_of_attributes, storage_organization, location)</code></li><li><code>Attribute_metadata</code> = <code>(attribute_name, relation_name, domain_type, position, length)</code></li><li><code>User_metadata</code> = <code>(user_name, encrypted_password, group)</code></li><li><code>Index_metadata</code> = <code>(index_name, relation_name, index_type, index_attributes)</code></li><li><code>View_metadata</code> = <code>(view_name, definition)</code></li></ul></li></ul><h4 id="6-4-X-Open标准的系统目录"><a href="#6-4-X-Open标准的系统目录" class="headerlink" title="6.4 X/Open标准的系统目录"></a>6.4 X/Open标准的系统目录</h4><ol><li>X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息<ul><li><code>Table_Schem</code>：表的模式名(通常是表所有者的用户名)</li><li><code>Table_Name</code>：表名</li><li><code>Table_Type</code>：<code>&#39;Base_Table&#39;</code>或<code>&#39;View&#39;</code></li></ul></li><li>可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：<ul><li><code>Select Table_Name From Tables;</code></li></ul></li><li>模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。</li><li>一般而言，一个用户有一个模式。可以使用CreateSchema语句来创建模式(用法参见相关文献)，在CreateTable等语句可以使用所定义的模式名称。</li></ol><h4 id="6-5-Oracle的数据字典"><a href="#6-5-Oracle的数据字典" class="headerlink" title="6.5 Oracle的数据字典"></a>6.5 Oracle的数据字典</h4><ol><li>Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识<ul><li><code>USER_</code> :用户视图，用户所拥有的对象，在用户模式中</li><li><code>ALL_</code>  :扩展的用户视图，用户可访问的对象</li><li><code>DBA_</code>  :DBA视图(所有用户都可访问的DBA对象的子集)</li></ul></li><li>Oracle数据字典中定义了三个视图<code>USER_Tables</code>,<code>ALL_Tables</code>,和<code>DBA_Tables</code>供DBA和用户使用数据字典中关于<strong>表的信息</strong></li><li>同样,Oracle数据字典中也定义了三个视图<code>USER_TAB_Columns</code>,<code>ALL_TAB_Columns</code>(<code>Accessible_Columns</code>),和<code>DBA_TAB_Columns</code>供DBA和用户使用数据字典中关于表的<strong>列的信息</strong></li><li>可以使用SQL语句来访问这些表中的信息：<ul><li><code>Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;</code></li></ul></li><li>Oracle数据字典中还定义了其他视图<ul><li><code>TABLE_PRIVILEDGE</code>(或<code>ALL_TAB_GRANTS</code>)</li><li><code>COLUMN_PRIVILEDGE</code>(或<code>ALL_COL_GRANTS</code>)可访问表的权限，列的权限</li><li><code>CONSTRAINT_DEFS</code>(或<code>ALL_CONSTRAINTS</code>)可访问表的各种约束</li></ul></li><li>可以使用下述命令获取Oracle定义的所有视图信息<ul><li><code>Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;</code></li></ul></li><li>如果用户使用Oracle,可使用其提供的<code>SQL*PLUS</code>进行交互式访问</li><li>动态SQL: 表和列都已知，动态构造检索条件。</li><li>动态SQL:检索条件可动态构造，表和列也可动态构造。</li></ol><h4 id="6-6-SQLDA"><a href="#6-6-SQLDA" class="headerlink" title="6.6 SQLDA"></a>6.6 SQLDA</h4><p>构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息</p><ol><li>SQLDA: SQLDescriptorArea,SQL描述符区域。<ul><li>SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等</li><li>通过读取SQLDA信息可以进行更为复杂的动态SQL的处理</li><li>不同DBMS提供的SQLDA格式并不是一致的。</li></ul></li></ol><p><span id="id7"><span></span></span></p><h3 id="7-ODBC简介"><a href="#7-ODBC简介" class="headerlink" title="7. ODBC简介"></a>7. ODBC简介</h3><h4 id="7-1-ODBC定义"><a href="#7-1-ODBC定义" class="headerlink" title="7.1 ODBC定义"></a>7.1 ODBC定义</h4><p>ODBC：Open DataBase Connection，ODBC是一种标准—不同语言的应用程序与不同数据库服务器之间通讯的标准。</p><ul><li>一组API(应用程序接口)，支持应用程序与数据库服务器的交互</li><li>应用程序通过调用ODBC API, 实现<ol><li>与数据服务器的连接</li><li>向数据库服务器发送SQL命令</li><li>一条一条的提取数据库检索结果中的元组传递给应用程序的变量</li></ol></li><li>具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。</li><li>ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；</li></ul><h4 id="7-2-通过ODBC连接数据库"><a href="#7-2-通过ODBC连接数据库" class="headerlink" title="7.2 通过ODBC连接数据库"></a>7.2 通过ODBC连接数据库</h4><ol><li>ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中</li><li>当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果</li><li>ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄</li><li>应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:<ul><li><code>connection handle</code>, 连接句柄</li><li><code>the server</code>，要连接的数据库服务器</li><li><code>the user identifier</code>，用户</li><li><code>password</code> ，密码</li><li><code>SQL_NTS</code> 类型说明前面的参数是空终止的字符串</li></ul></li><li>示例<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int ODBCexample()&#123;</span><br><span class="line">    RETCODE error; <span class="comment">/* 返回状态吗 */</span></span><br><span class="line">    HENV env; <span class="comment">/* 环境变量 */</span></span><br><span class="line">    HDBC conn; <span class="comment">/* 连接句柄 */</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line">    //分配数据库连接环境</span><br><span class="line">    SQLConnect(conn, "aura.bell-labs.com", SQL_NTS, "avi", SQL_NTS, avipasswd", SQL_NTS);</span><br><span class="line">    //打开一个数据库连接</span><br><span class="line">    &#123; …. Do actual work … &#125;</span><br><span class="line">    //与数据库通讯</span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">    //断开连接与释放环境</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-3-通过ODBC与数据库服务器进行通讯"><a href="#7-3-通过ODBC与数据库服务器进行通讯" class="headerlink" title="7.3 通过ODBC与数据库服务器进行通讯"></a>7.3 通过ODBC与数据库服务器进行通讯</h4><ol><li>应用程序使用SQLExecDirect()向数据库发送SQL命令；</li><li>使用SQLFetch()获取产生的结果元组；</li><li>使用SQLBindCol()绑定C语言变量与结果中的属性<ul><li>当获取一个元组时，属性值会自动地传送到相应的C语言变量中</li></ul></li><li>SQLBindCol()的参数：<ul><li>ODBC定义的stmt变量,查询结果中的属性位置</li><li>SQL到C的类型变换,变量的地址.</li><li>对于类似字符数组一样的可变长度类型，应给出<ul><li>•变量的最大长度</li><li>•当获取到一个元组后，实际长度的存储位置.</li><li>•注:当返回实际长度为负数，说明是一个空值。</li></ul></li></ul></li><li>示例<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">char branchname[80]; float balance;</span><br><span class="line">int lenOut1, lenOut2;</span><br><span class="line">HSTMT stmt;</span><br><span class="line">SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line">//分配一个与指定数据库连接的新的语句句柄</span><br><span class="line">char * sqlquery = "select branch_name, sum (balance)</span><br><span class="line">    from account</span><br><span class="line">    group by branch_name";</span><br><span class="line">error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line">//执行查询，stmt句柄指向结果集合</span><br><span class="line">if (error == SQL_SUCCESS) &#123;</span><br><span class="line">SQLBindCol(stmt, 1, SQL_C_CHAR, branchname , 80, &amp;lenOut1);</span><br><span class="line">SQLBindCol(stmt, 2, SQL_C_FLOAT, &amp;balance, 0 , &amp;lenOut2);</span><br><span class="line">//绑定高级语言变量与stmt句柄中的属性</span><br><span class="line">while (SQLFetch(stmt) &gt;= SQL_SUCCESS) &#123;</span><br><span class="line">//提取一条记录，结果数据被存入高级语言变量中</span><br><span class="line">    printf (" %s %g\n", branchname, balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SQLFreeStmt(stmt, SQL_DROP);</span><br><span class="line">//释放语句句柄</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-4-ODBC的其他功能"><a href="#7-4-ODBC的其他功能" class="headerlink" title="7.4 ODBC的其他功能"></a>7.4 ODBC的其他功能</h4><ol><li>动态SQL语句的预编译-动态参数传递功能</li><li>获取元数据特性<ul><li>发现数据库中的所有关系的特性 以及</li><li>发现每一个查询结果的列的名字和类型等；</li></ul></li><li>默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。<ul><li>应用程序可以关闭一个连接的自动提交特性<ul><li><code>SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)}</code></li></ul></li><li>此时事务要显式地给出提交和撤销的命令<ul><li><code>SQLTransact(conn, SQL_COMMIT)</code> or <code>SQLTransact(conn, SQL_ROLLBACK)</code></li></ul></li></ul></li></ol><p><span id="id8"><span></span></span></p><h3 id="8-JDBC简介"><a href="#8-JDBC简介" class="headerlink" title="8. JDBC简介"></a>8. JDBC简介</h3><h4 id="8-1-JDBC定义"><a href="#8-1-JDBC定义" class="headerlink" title="8.1 JDBC定义"></a>8.1 JDBC定义</h4><p>JDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。</p><ul><li>JDBCAPI分成两个程序包：<ul><li>Java.sql 核心API –J2SE(Java2标准版)的一部分。使用<code>java.sql.DriverManager</code>类、<code>java.sql.Driver</code>和<code>java.sql.Connection</code>接口连接到数据库</li><li>Javax.sql 可选扩展API–J2EE(Java2企业版)的一部分。包含了基于<code>JNDI(JavaNamingandDirectoryInterface,Java命名和目录接口)</code>的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。</li></ul></li></ul><h4 id="8-2-JDBC的功能"><a href="#8-2-JDBC的功能" class="headerlink" title="8.2 JDBC的功能"></a>8.2 JDBC的功能</h4><ol><li><code>java.sql.DriverManager</code>——处理驱动的调入并且对产生新数据库连接提供支持</li><li><code>Java.sql.Driver</code>——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。</li><li><code>java.sql.Connection</code>——代表对特定数据库的连接。</li><li><code>Try {…} Catch {…}</code> ——异常捕获及其处理</li><li><code>java.sql.Statement</code>——对特定的数据库执行SQL语句</li><li><code>java.sql.PreparedStatement</code> —— 用于执行预编译的SQL语句</li><li><code>java.sql.CallableStatement</code> ——用于执行对数据库内嵌过程的调用。</li><li><code>java.sql.ResultSet</code>——从当前执行的SQL语句中返回结果数据。</li></ol><h4 id="8-3-使用JDBC-API访问数据库的过程"><a href="#8-3-使用JDBC-API访问数据库的过程" class="headerlink" title="8.3 使用JDBC API访问数据库的过程"></a>8.3 使用JDBC API访问数据库的过程</h4><ol><li><p>概念性的基本过程</p><ul><li>打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制</li></ul></li><li><p>具体实施过程</p><ol><li>•传递一个Driver给DriverManager，加载数据库驱动。<ul><li><code>Class.forName()</code></li></ul></li><li>•通过URL得到一个Connection对象, 建立数据库连接<ul><li><code>DriverManager.getConnection(sDBUrl)</code></li><li><code>DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)</code></li></ul></li><li>•接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<ul><li><code>Statement stmt=con.createStatement()</code></li></ul></li><li>•查询返回一个ResultSet。<ul><li><code>ResultSet rs=stmt.executeQuery(sSQL)</code></li></ul></li></ol></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">try</span> &#123; <span class="comment">//错误捕获</span></span><br><span class="line">    Class.forName (<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    Connection conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span>, userid, passwd);</span><br><span class="line">    <span class="comment">//加载数据库驱动，建立数据库连接</span></span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    <span class="comment">//创建一个语句对象</span></span><br><span class="line">    … Do Actual Work ….</span><br><span class="line">    <span class="comment">//进行SQL语句的执行与处理工作</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    <span class="comment">//关闭语句对象，关闭连接</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">    System.out.println(<span class="string">"SQLException : "</span> + sqle); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完整的示例程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName (<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    Connection conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span>, userid, passwd);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt.executeUpdate( <span class="string">"insert into instructor values</span></span><br><span class="line"><span class="string">        (‘77987', ‘Kim', ‘Physics’,98000)"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">"插入错误:"</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">    ResultSet rset = stmt.executeQuery(</span><br><span class="line">        <span class="string">"select dept_name, avg(salary) from instructor group by dept_name"</span>);</span><br><span class="line">    <span class="keyword">while</span> ( rset.next() ) &#123;</span><br><span class="line">        System.out.println(rset.getString(“dept_name<span class="string">") + "</span> <span class="string">" + rset.getFloat(2));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    stmt.close();</span></span><br><span class="line"><span class="string">    conn.close();</span></span><br><span class="line"><span class="string">&#125; catch (SQLException sqle) &#123;</span></span><br><span class="line"><span class="string">    System.out.println("</span>SQLException:<span class="string">" + sqle);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id9"><span></span></span></p><h3 id="9-嵌入式SQL-ODBC-JDBC三者比较"><a href="#9-嵌入式SQL-ODBC-JDBC三者比较" class="headerlink" title="9. 嵌入式SQL-ODBC-JDBC三者比较"></a>9. 嵌入式SQL-ODBC-JDBC三者比较</h3><p>执行一条SQL语句，读取执行的结果集合</p><ol><li>嵌入式SQL的思维模式<ol><li>建立数据库连接</li><li>声明一个游标</li><li>打开游标</li><li>读取一条记录(循环)</li><li>关闭游标</li><li>断开数据库连接</li></ol></li><li>ODBC的思维模式<ol><li>建立数据库连接</li><li>分配语句句柄</li><li>用句柄执行SQL</li><li>建立高级语言变量与句柄属性的对应</li><li>读取一条记录(循环)</li><li>释放语句句柄</li><li>断开数据库连接</li></ol></li><li>JDBC的思维模式<ol><li>建立数据库连接</li><li>创建语句对象</li><li>用语句对象执行SQL，并返回结果对象</li><li>从结果对象获取一条记录</li><li>提取对象的属性值传给高级语言变量(返回上一步)</li><li>释放语句对象</li><li>断开数据库连接</li></ol></li></ol><ul><li>相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致</li><li>不同点, 操作方式的不同:<ul><li>嵌入式SQL按照语句进行操作</li><li>ODBC按照函数来进行操作</li><li>JDBC按照对象来进行操作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，&lt;/li&gt;
&lt;li&gt;然而，交互式SQL本身也有很多局限：
    
    </summary>
    
      <category term="数据库系统" scheme="http://chaooo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库语言SQL</title>
    <link href="http://chaooo.github.io/2019/09/01/02-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80SQL.html"/>
    <id>http://chaooo.github.io/2019/09/01/02-数据库语言SQL.html</id>
    <published>2019-09-01T11:36:31.000Z</published>
    <updated>2019-09-03T14:05:36.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h3><p><strong>结构化查询语言</strong>(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p><ul><li>SQL语言是集DDL、DML和DCL于一体的数据库语言<a id="more"></a><ol><li><strong>DDL语句</strong>引导词：Create(建立),Alter(修改),Drop(撤消)<ul><li>模式的定义和删除，包括定义Database,Table,View,Index,完整性约束条件等，也包括定义对象(RowType行对象,Type列对象)</li></ul></li><li><strong>DML语句</strong>引导词：Insert ,Delete, Update, Select<ul><li>各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入</li><li>各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等</li><li>各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等</li></ul></li><li><strong>DCL语句</strong>引导词：Grant,Revoke<ul><li>安全性控制：授权和撤消授权</li></ul></li></ol></li></ul><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol><li><a href="#id1">利用SQL建立数据库</a></li><li><a href="#id2">利用SQL简单查询</a></li><li><a href="#id3">利用SQL多表联合查询</a></li><li><a href="#id4">利用SQL进行增-删-改</a></li><li><a href="#id5">利用SQL语言修正与撤销数据库</a></li><li><a href="#id6">SQL Server介绍</a></li><li><a href="#id7">SQL语言-子查询</a></li><li><a href="#id8">SQL语言-结果计算与聚集计算</a></li><li><a href="#id9">SQL语言-分组查询与分组过滤</a></li><li><a href="#id10">SQL语言实现关系代数操作</a></li><li><a href="#id11">SQL语言之视图及其应用</a></li><li><a href="#id12">数据库完整性</a></li><li><a href="#id13">数据库的静态完整性(约束)</a></li><li><a href="#id14">数据库的动态完整性(触发器)</a></li><li><a href="#id15">数据库索引</a></li><li><a href="#id16">数据库序列</a></li><li><a href="#id17">数据库安全性</a></li><li><a href="#id18">数据库自主安全性机制</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-利用SQL建立数据库"><a href="#1-利用SQL建立数据库" class="headerlink" title="1. 利用SQL建立数据库"></a>1. 利用SQL建立数据库</h3><p>DDL：数据定义语言（Data Definition Language)，<br>DDL通常由<strong>DBA(数据库管理员)</strong>来使用，也有经DBA授权后由应用程序员来使用</p><ol><li>创建数据库(DB)：<strong>Create Database</strong><ul><li>数据库(Database)是若干具有相互关联关系的Table/Relation的集合</li><li>简单语法形式：<code>create database database 数据库名;</code></li></ul></li><li>创建DB中的Table(定义关系模式)：<strong>Create Table</strong><ul><li><code>Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);</code><ul><li><code>[]</code>表示其括起的内容可以省略，<code>|</code>表示其隔开的两项可取其一</li><li><code>Primary key</code>: 主键约束。每个表只能创建一个主键约束</li><li><code>Unique</code>: 唯一性约束(即候选键)。可以有多个唯一性约束</li><li><code>Not null</code>: 非空约束。</li></ul></li></ul></li><li><strong>数据类型</strong>（SQL-92标准）<ul><li><code>char(n)</code>:固定长度的字符串</li><li><code>varchar(n)</code>:可变长字符串</li><li><code>int</code>:整数 //有时不同系统也写作integer</li><li><code>numeric(p，q)</code>:固定精度数字，小数点左边p位，右边(p-q)位</li><li><code>real</code>:浮点精度数字 //有时不同系统也写作<code>float(n)</code>，小数点后保留n位</li><li><code>date</code>:日期 (如 2003-09-12)</li><li><code>time</code>:时间 (如 23:15:003)<blockquote><p>注意: 现行商用DBMS的数据类型有时有些差异</p></blockquote></li></ul></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-利用SQL简单查询"><a href="#2-利用SQL简单查询" class="headerlink" title="2. 利用SQL简单查询"></a>2. 利用SQL简单查询</h3><p>DML：数据操纵语言（Data Manipulation Language)，<br>DML通常由<strong>用户或应用程序员</strong>使用，访问经授权的数据库</p><ol><li><p>向Table中添加数据(追加元组)：<strong>Insert into</strong></p><ul><li><strong><code>insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);</code></strong><ul><li>values值的排列，须与列名排列一致</li><li>若所有列名省略，则values值的排列须与该表存储中的列名排列一致</li></ul></li></ul></li><li><p>单表查询<strong>Select</strong></p><ul><li><strong><code>Select Select 列名[[,列名] …] From 表名[Where 检索条件];</code></strong><ul><li>语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。</li><li>相当于：<code>Π[列名,...,列名](σ检索条件(表名))</code></li></ul></li><li>Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。</li></ul></li><li><p>检索条件的书写<strong>Where</strong></p><ul><li>与选择运算<code>σF(R)</code>的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。</li><li><code>Select Tname From Teacher Where Salary &gt; 2000 and D# = ’03’;</code>//检索教师表中所有工资大于2000元 并且是03系的教师姓名</li></ul></li><li><p>排重(<code>DISTINCT</code>)</p><ul><li>关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。</li><li>在Table中要求无重复元组是通过定义Primary key或Unique来保证的;</li><li>而在检索结果中要求无重复元组, 是通过<strong>DISTINCT保留字</strong>的使用来实现的。</li><li><code>Select DISTINCT S# From SC Where Score &gt; 80;</code></li></ul></li><li><p>排序(<code>ORDER BY</code>)</p><ul><li>Select语句中结果排序是通过增加<strong>order by</strong>子句实现的</li><li><code>order by 列名 [asc|desc]</code></li><li>意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。</li></ul></li><li><p>模糊查询(<code>*LIKE*</code>)</p><ul><li><code>_</code>：一个字符，<code>%</code>：任意长度字符。</li><li><code>Select Sname From Student Where Sname Like &#39;张_ _&#39;;</code>//检索名字为张某某的所有同学姓名</li><li><code>Select Sname From Student Where Sname Not Like &#39;张%&#39;;</code>//检索名字不姓张的所有同学姓名</li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-利用SQL多表联合查询"><a href="#3-利用SQL多表联合查询" class="headerlink" title="3. 利用SQL多表联合查询"></a>3. 利用SQL多表联合查询</h3><p>多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。</p><ul><li>检索语句: <strong><code>Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;</code></strong></li><li>相当于<code>Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))</code></li><li>检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接</li></ul><ol><li><p>θ-连接之<strong>等值连接</strong></p><ul><li>多表连接时，如两个表的属性名相同，则需采用<strong><code>表名.属性名</code></strong>方式来限定该属性是属于哪一个表</li><li><code>Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#=&#39;001&#39; Order By Score DESC;</code>//按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)</li></ul></li><li><p>属性重名重名处理(表别名)</p><ul><li>连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用<strong><code>别名</code></strong>以便区分</li><li><code>Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;</code></li><li>当定义了别名后，在检索条件中可以使用别名来限定属性</li><li>as 可以省略</li></ul></li><li><p>θ-连接之<strong>不等值连接</strong></p><ul><li><code>Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary&gt;T2.Salary;</code>//求有薪水差额的任意两位教师</li></ul></li><li><p>实例：</p><ul><li><code>Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#=&#39;001&#39; and S2.C#=&#39;002&#39; and S1.Score &gt; S2.Score;</code>//求“001”号课成绩比“002”号课成绩高的所有学生的学号</li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-利用SQL进行增-删-改"><a href="#4-利用SQL进行增-删-改" class="headerlink" title="4. 利用SQL进行增-删-改"></a>4. 利用SQL进行增-删-改</h3><ol><li>SQL-之<strong>更新操作</strong><ul><li>元组新增Insert：新增一个或一些元组到数据库的Table中</li><li>元组更新Update:对某些元组中的某些属性值进行重新设定</li><li>元组删除Delete：删除某些元组</li></ul></li></ol><blockquote><ul><li>SQL-DML既能单一记录操作，也能对记录集合进行批更新操作</li><li>SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等</li></ul></blockquote><ol start="2"><li>SQL-之<strong>INSERT</strong><ul><li>单一元组新增命令形式：插入一条指定元组值的元组<ul><li><strong><code>insert into 表名 [(列名[,列名]…)] values (值 [,值]…);</code></strong></li></ul></li><li>批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。<ul><li><strong><code>insert into 表名 [(列名[，列名]…)] 子查询;</code></strong></li><li>示例：<code>Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like &#39;%伟&#39;;</code>//将检索到的满足条件的同学新增到该表中</li></ul></li></ul></li></ol><blockquote><p>注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。</p></blockquote><ol start="3"><li><p>SQL-之<strong>DELETE</strong></p><ul><li>元组删除Delete命令: 删除满足指定条件的元组</li><li><strong><code>Delete From 表名 [ Where 条件表达式];</code></strong></li><li>如果Where条件省略，则删除所有的元组(清空表)。</li><li>示例：<code>Delete From Student Where S# in ( Select S# From SC Where Score &lt; 60 Group by S# Having Count(*)&gt;= 4);</code>//删除有四门不及格课程的所有同学</li></ul></li><li><p>SQL-之<strong>UPDATE</strong></p><ul><li>元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值</li><li><strong><code>Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];</code></strong></li><li>如果Where条件省略，则更新所有的元组。</li><li>示例：<code>Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname=&#39;计算机&#39;);</code>//将所有计算机系的教师工资上调10%</li></ul></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-利用SQL语言修正与撤销数据库"><a href="#5-利用SQL语言修正与撤销数据库" class="headerlink" title="5. 利用SQL语言修正与撤销数据库"></a>5. 利用SQL语言修正与撤销数据库</h3><ol><li><p>修正基本表的定义</p><ul><li><strong><code>alter table tablename</code></strong></li><li><strong><code>[add {colname datatype, …}]</code></strong> //增加新列</li><li><strong><code>[drop {完整性约束名}]</code></strong> //删除完整性约束</li><li><strong><code>[modify {colname datatype, …}]</code></strong> //修改列定义</li><li>示例：<code>Alter Table Student Drop Unique(Sname);</code>删除学生姓名必须取唯一值的约束</li><li>示例：<code>Alter Table Student Add Saddr char[40],PID char[18];</code>在学生表Student上增加二列Saddr, PID</li></ul></li><li><p>SQL-DDL之撤销与修改</p><ul><li><code>drop table 表名;</code> //撤消基本表</li><li><code>drop database 数据库名;</code> //撤消数据库</li></ul></li><li><p>SQL-DDL之数据库指定与关闭命令</p><ul><li>有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。</li><li><code>use 数据库名;</code> //指定当前数据库</li><li><code>close 数据库名;</code> //关闭当前数据库</li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-SQL-Server介绍"><a href="#6-SQL-Server介绍" class="headerlink" title="6. SQL Server介绍"></a>6. SQL Server介绍</h3><p>SQL Server 是 Microsoft提供的一款关系数据库管理系统</p><ol><li>SQL Server 的系统数据库<ul><li>Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。</li><li>Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。</li><li>Msdb：代理服务数据库，提供一个存储空间。</li><li>Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。</li></ul></li><li>SQL Server的数据库<ul><li>文件：有三种文件扩展名：.mdf、.ndf、.ldf<ul><li>主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。</li><li>辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。</li><li>日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。</li></ul></li><li>页面：是SQL Server存储的最小单位。一页为8K或8192字节。</li><li>空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位</li></ul></li></ol><h4 id="6-1-SQL-Server数据库的创建-删除与维护"><a href="#6-1-SQL-Server数据库的创建-删除与维护" class="headerlink" title="6.1 SQL Server数据库的创建-删除与维护"></a>6.1 SQL Server数据库的创建-删除与维护</h4><ol><li>创建数据库<ul><li>语法形式：Create Database 库名</li><li>可视化操作(查询分析器)：Database(鼠标右键) -&gt; new Database… -&gt; 填写数据库名及配置</li><li>创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。</li><li>创建数据库的用户自动成为数据库的拥有者。</li></ul></li><li>删除数据库<ul><li>语法形式：Drop Database 库名</li><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Delete</li><li>对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。</li><li>当数据库处于正在使用或正在恢复状态时，不能删除。</li></ul></li><li>备份数据库<ul><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Back Up…</li><li>备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。<ul><li>完全数据库备份：完全备份数据文件和日志文件。</li><li>差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。</li><li>事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。</li><li>数据库文件和文件组备份：用在数据库相当大的情况下。</li></ul></li></ul></li><li>恢复数据库<ul><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Restore</li><li>数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。</li><li>数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。</li><li>可以通过企业管理器来完成数据库恢复。</li></ul></li><li>数据库授权: <ul><li>语法形式：grant 权限 on 表名 to 用户名</li><li>权限有：select,update,insert,delete,exec,dri。</li><li>对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.</li></ul></li></ol><h4 id="6-2-SQL-Server数据表的创建-与增-删-改-查"><a href="#6-2-SQL-Server数据表的创建-与增-删-改-查" class="headerlink" title="6.2 SQL Server数据表的创建-与增/删/改/查"></a>6.2 SQL Server数据表的创建-与增/删/改/查</h4><ol><li>创建表<ul><li>同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。</li><li>用T-SQL语句创建表，语法形式：<code>CREATE TABLE [数据库名.所有者名.]表名 ({&lt;列名 数据类型&gt;} [缺省值][约束][是否为空] …)</code><blockquote><p>注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持</p></blockquote></li><li>可视化操作(查询分析器)：数据库名 -&gt; Tables -&gt; New Table…</li></ul></li><li>增加、修改表字段<ul><li>语法形式：<code>ALTER TABLE ADD | ALTER 字段名 &lt;类型&gt;</code></li></ul></li><li>创建、删除与修改约束<ul><li>约束是SQL提供自动保持数据库完整性的一种方法，共5种。</li><li>用T-SQL语句建立约束，语法形式：<code>CONSTRAINT 约束名 约束类型 (列名)</code><ul><li>约束名：在库中应该唯一，如不指定，系统会给出</li><li>约束类型 (5种)：<ul><li>primary key constraint (主键值)</li><li>unique constraint (唯一性)</li><li>check constraint (检查性)</li><li>default constraint (默认)</li><li>foreign key constraint (外部键)</li></ul></li><li>列名：要约束的字段名</li></ul></li><li>示例:<code>Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));</code></li></ul></li></ol><p><span id="id7"><span></span></span></p><h3 id="7-SQL语言-子查询"><a href="#7-SQL语言-子查询" class="headerlink" title="7. SQL语言-子查询"></a>7. SQL语言-子查询</h3><ul><li>子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。</li><li>三种类型的子查询：(NOT) IN-子查询；θ-Some/θ-All子查询；(NOT) EXISTS子查询</li></ul><h4 id="7-1-NOT-IN子查询"><a href="#7-1-NOT-IN子查询" class="headerlink" title="7.1 (NOT) IN子查询"></a>7.1 (NOT) IN子查询</h4><ol><li>基本语法：<code>表达式 [not] in (子查询)</code><ul><li>语法中，表达式的最简单形式就是列名或常数。</li><li>语义：判断某一表达式的值是否在子查询的结果中。</li><li>示例：<ul><li><code>Select * From Student Where Sname in (&#39;张三&#39;, &#39;王三&#39;);</code>//列出张三、王三同学的所有信息</li><li><code>Select S#, Sname From Student Where S# in (Select S# From SC Where C#=&#39;001&#39;);</code>//列出选修了001号课程的学生的学号和姓名</li></ul></li></ul></li><li>非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询</li><li>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询</li><li>外层向内层传递的参量需要使用外层的表名或表别名来限定<ul><li>示例：<code>Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#=&#39;001&#39;);</code>//求学过001号课程的同学的姓名</li></ul></li></ol><blockquote><p>注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。</p></blockquote><h4 id="7-2-θ-Some-θ-All子查询"><a href="#7-2-θ-Some-θ-All子查询" class="headerlink" title="7.2 θ-Some/θ-All子查询"></a>7.2 θ-Some/θ-All子查询</h4><ol><li>基本语法：<code>表达式 θ some (子查询)</code> / <code>表达式 θ all (子查询)</code><ul><li>语法中，θ是比较运算符：<code>&lt;, &gt;, &gt;=, &lt;=, =, &lt;&gt;</code>。</li><li>语义：将表达式的值与子查询的结果进行比较：<ul><li>如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则<code>表达式 θ some (子查询)</code>的结果便为真</li><li>如果表达式的值与子查询结果的所有值相比较都满足 关系，则<code>表达式 θ all (子查询)</code>的结果便为真</li></ul></li><li>示例：<ul><li><code>Select Tname From Teacher Where Salary &lt;= all ( Select Salary From Teacher);</code>//找出工资最低的教师姓名</li><li><code>Select S# From SC Where C# = “001” and Score &lt; some ( Select Score From SC Where C#=&#39;001&#39;);</code>//找出001号课成绩不是最高的所有学生的学号</li></ul></li></ul></li></ol><blockquote><p>在SQL标准中，也有θ-Any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。</p></blockquote><ol start="2"><li>等价性变换需要注意<ul><li><code>表达式 = some (子查询)</code>和<code>表达式 in (子查询)</code>含义<strong>相同</strong></li><li><code>表达式 &lt;&gt; some (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>不同</strong></li><li><code>表达式 &lt;&gt; all (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>相同</strong></li></ul></li></ol><h4 id="7-3-NOT-EXISTS子查询"><a href="#7-3-NOT-EXISTS子查询" class="headerlink" title="7.3 (NOT) EXISTS子查询"></a>7.3 (NOT) EXISTS子查询</h4><ol><li>基本语法：<code>[not] Exists [not] Exists (子查询)</code><ul><li>语义：子查询结果中有无元组存在</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：检索选修了赵三老师主讲课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC, Course, Teacher</span><br><span class="line">        <span class="keyword">Where</span> SC.C<span class="comment">#=Course.C# and SC. S#=Student.S#</span></span><br><span class="line">        <span class="keyword">and</span> Course.T<span class="comment"># = Teacher.T# and Tname='赵三');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--示例：检索学过001号教师主讲的所有课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> //不存在</span><br><span class="line">        ( <span class="keyword">Select</span> * <span class="keyword">From</span> Course //有一门<span class="number">001</span>教师主讲课程</span><br><span class="line">        <span class="keyword">Where</span> Course.T<span class="comment"># = ‘001’ and not exists //该同学没学过</span></span><br><span class="line">            ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC</span><br><span class="line">            <span class="keyword">Where</span> S<span class="comment"># = Student.S# and C# = Course.C#));</span></span><br><span class="line"><span class="comment">--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过</span></span><br></pre></td></tr></table></figure><p><span id="id8"><span></span></span></p><h3 id="8-SQL语言-结果计算与聚集计算"><a href="#8-SQL语言-结果计算与聚集计算" class="headerlink" title="8. SQL语言-结果计算与聚集计算"></a>8. SQL语言-结果计算与聚集计算</h3><h4 id="8-1-结果计算"><a href="#8-1-结果计算" class="headerlink" title="8.1 结果计算"></a>8.1 结果计算</h4><p>Select-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算</p><ul><li><code>Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];</code><ul><li>expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书</li><li>agfunc()是一些聚集函数</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求有差额(差额&gt;0)的任意两位教师的薪水差额</span></span><br><span class="line"><span class="keyword">Select</span> T1.Tname <span class="keyword">as</span> TR1, T2.Tname <span class="keyword">as</span> TR2, T1.Salary – T2.Salary</span><br><span class="line">    <span class="keyword">From</span> Teacher T1, Teacher T2</span><br><span class="line">    <span class="keyword">Where</span> T1.Salary &gt; T2.Salary;</span><br></pre></td></tr></table></figure><h4 id="8-2-聚集函数"><a href="#8-2-聚集函数" class="headerlink" title="8.2 聚集函数"></a>8.2 聚集函数</h4><p>SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc,分别是：COUNT、SUM、AVG、MAX、MIN</p><table><thead><tr><th>聚合函数</th><th>支持的数据类型</th><th>描述</th></tr></thead><tbody><tr><td>count()</td><td>任何类型/*</td><td>计算结果集中的总行数</td></tr><tr><td>sum()</td><td>Numeric</td><td>计算指定列中所有非空值的总和</td></tr><tr><td>avg()</td><td>numeric</td><td>计算指定列中所有非空值的平均值</td></tr><tr><td>max()</td><td>char/numeric</td><td>返回指定列中最大值</td></tr><tr><td>min()</td><td>char/numeric</td><td>返回指定列中最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Sum</span>(Salary) <span class="keyword">From</span> Teacher;</span><br><span class="line"><span class="comment">--示例：求计算机系教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Sum</span>(Salary) <span class="keyword">From</span> Teacher T, Dept</span><br><span class="line">    <span class="keyword">Where</span> Dept.Dname = ‘计算机’ <span class="keyword">and</span> Dept.D<span class="comment"># = T.D#;</span></span><br><span class="line"><span class="comment">--示例：求数据库课程的平均成绩</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">AVG</span>(Score) <span class="keyword">From</span> Course C, SC</span><br><span class="line">    <span class="keyword">Where</span> C.Cname = ‘数据库’ <span class="keyword">and</span> C.C<span class="comment"># = SC.C#;</span></span><br></pre></td></tr></table></figure><p><span id="id9"><span></span></span></p><h3 id="9-SQL语言-分组查询与分组过滤"><a href="#9-SQL语言-分组查询与分组过滤" class="headerlink" title="9. SQL语言-分组查询与分组过滤"></a>9. SQL语言-分组查询与分组过滤</h3><h4 id="9-1-分组查询"><a href="#9-1-分组查询" class="headerlink" title="9.1 分组查询"></a>9.1 分组查询</h4><p>分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。</p><ol><li><p>分组的基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 ] ;</span><br></pre></td></tr></table></figure></li><li><p>分组条件可以是：<code>列名1, 列名2, …</code></p></li><li><p>示例： 求每一个学生的平均成绩</p><ul><li><code>Select S#, AVG(Score) From SC Group by S#;</code></li></ul></li></ol><h4 id="9-2-分组过滤"><a href="#9-2-分组过滤" class="headerlink" title="9.2 分组过滤"></a>9.2 分组过滤</h4><p>聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤</p><ul><li>分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。</li><li>Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。</li></ul><ol><li><p>基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 [ <span class="keyword">Having</span> <span class="keyword">Having</span> 分组过滤条件] ] ;</span><br></pre></td></tr></table></figure></li><li><p>示例：求不及格课程超过两门的同学的学号</p><ul><li><code>Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2;</code> </li></ul></li></ol><h4 id="9-3-where子句与having子句的区别"><a href="#9-3-where子句与having子句的区别" class="headerlink" title="9.3 where子句与having子句的区别"></a>9.3 where子句与having子句的区别</h4><ol><li>聚合函数是比较where、having 的关键。在from后面的执行顺序：<ul><li><code>where -&gt; 聚合函数(sum,min,max,avg,count) -&gt;having</code></li></ul></li><li>列出group by来比较二者:<ul><li>where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。</li><li>having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。</li></ul></li></ol><blockquote><p>注意事项 ： </p><ol><li>where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 </li><li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 </li><li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</li></ol></blockquote><p><span id="id10"><span></span></span></p><h3 id="10-SQL语言实现关系代数操作"><a href="#10-SQL语言实现关系代数操作" class="headerlink" title="10. SQL语言实现关系代数操作"></a>10. SQL语言实现关系代数操作</h3><p>SQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。</p><ul><li>基本语法形式：<ul><li><code>子查询 {Union [ALL] | Intersect [ALL] | Except [ALL] 子查询}</code></li></ul></li><li>通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。<ul><li>假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：<ul><li>子查询1 Union ALL 子查询2 ，出现m + n次</li><li>子查询1 Intersect ALL 子查询2 ，出现min(m,n)次</li><li>子查询1 Except ALL 子查询2 ，出现max(0, m – n)次</li></ul></li></ul></li></ul><blockquote><p>UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但<strong>有些DBMS并不支持</strong>这些运算，使用时要注意。</p></blockquote><h4 id="10-1-SQL并运算-UNION"><a href="#10-1-SQL并运算-UNION" class="headerlink" title="10.1 SQL并运算(UNION)"></a>10.1 SQL并运算(UNION)</h4><ol><li>示例：已知两个表<ul><li>Customers(Cid, Cname, City, Discnt)</li><li>Agents(Aid, Aname, City, Percent)</li></ul></li><li>求客户所在的或者代理商所在的城市<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Customers</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Agents;</span><br></pre></td></tr></table></figure></li></ol><h4 id="10-2-SQL交运算-INTERSECT"><a href="#10-2-SQL交运算-INTERSECT" class="headerlink" title="10.2 SQL交运算(INTERSECT)"></a>10.2 SQL交运算(INTERSECT)</h4><ol><li><p>示例：求既学过002号课，又学过003号课的同学学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘002’</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘003’;</span></span><br></pre></td></tr></table></figure></li><li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p><ul><li><code>Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);</code></li></ul></li><li><p>交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。</p></li></ol><h4 id="10-3-SQL差运算-EXCEPT"><a href="#10-3-SQL差运算-EXCEPT" class="headerlink" title="10.3 SQL差运算(EXCEPT)"></a>10.3 SQL差运算(EXCEPT)</h4><ol><li><p>示例： 假定所有学生都有选课，求没学过002号课程的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S<span class="comment"># From SC</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘002’;</span></span><br></pre></td></tr></table></figure></li><li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S<span class="comment"># From SC SC1</span></span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC</span><br><span class="line">        <span class="keyword">Where</span> C<span class="comment"># = ‘002’ and S# = SC1.S#);</span></span><br></pre></td></tr></table></figure></li><li><p>差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。</p></li></ol><h4 id="10-4-空值的处理"><a href="#10-4-空值的处理" class="headerlink" title="10.4 空值的处理"></a>10.4 空值的处理</h4><p>空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p><ol><li>在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。</li><li>空值检测：<ul><li><code>is [not ] null</code> //测试指定列的值是否为空值</li></ul></li><li>示例：找出年龄值为空的学生姓名<ul><li><code>Select Sname From Student Where Sage is null;</code></li></ul></li><li>现行DBMS的空值处理小结<ul><li>除is[not]null之外，空值不满足任何查找条件</li><li>如果null参与算术运算，则该算术表达式的值为null</li><li>如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown</li><li>如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li></ul></li></ol><h4 id="10-5-内连接、外连接"><a href="#10-5-内连接、外连接" class="headerlink" title="10.5 内连接、外连接"></a>10.5 内连接、外连接</h4><ol><li><p>标准SQL语言中连接运算通常为：</p><ul><li><code>Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;</code></li><li>即相当于采用<code>Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))</code>。</li></ul></li><li><p>SQL的高级语法中引入了内连接与外连接运算，具体形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 [ [, 列名] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [<span class="keyword">NATURAL</span>]</span><br><span class="line">    [ <span class="keyword">INNER</span> | &#123; <span class="keyword">LEFT</span> | <span class="keyword">RIGHT</span> | <span class="keyword">FULL</span>&#125; [<span class="keyword">OUTER</span>]] <span class="keyword">JOIN</span> 表名<span class="number">2</span></span><br><span class="line">    &#123; <span class="keyword">ON</span> 连接条件 | <span class="keyword">Using</span> (Colname &#123;, Colname …&#125;) &#125;</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ] … ;</span><br></pre></td></tr></table></figure></li><li><p>由 <strong>连接类型</strong> 和 <strong>连接条件</strong> 构成连接运算。</p><ul><li><strong><code>Natural</code></strong>：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次</li><li><strong><code>Inner Join</code></strong>: 即关系代数中的θ-连接运算</li><li><strong><code>Left Outer Join, Right Outer Join, Full Outer Join</code></strong>: 即关系代数中的外连接运算</li><li><strong><code>on &lt;连接条件&gt;</code></strong>：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li><li><strong><code>using (Col1, Col2, …, Coln)</code></strong>：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次</li></ul></li><li><p>示例:</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher.T<span class="comment">#, Tname, Cname</span></span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Inner</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T<span class="comment"># = Course.T#</span></span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T<span class="comment"># ASC;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher. T<span class="comment">#, Tname, Cname</span></span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Left</span> <span class="keyword">Outer</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T<span class="comment"># = Course.T#</span></span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T<span class="comment"># ASC ;</span></span><br></pre></td></tr></table></figure><p><span id="id11"><span></span></span></p><h3 id="11-SQL语言之视图及其应用"><a href="#11-SQL语言之视图及其应用" class="headerlink" title="11. SQL语言之视图及其应用"></a>11. SQL语言之视图及其应用</h3><ol><li>数据库的三级模式两层映像<ul><li>三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成</li><li>应用–&gt; <strong>外模式</strong>(多个) –&gt; <strong>概念模式</strong>(一个) –&gt; <strong>内模式</strong>(一个) –&gt; 数据库</li><li>两层映像：<code>E-C</code>映像(外模式-&gt;概念模式)、<code>C-I</code>映像(概念模式-&gt;内模式)。</li></ul></li><li>对应概念模式的数据在SQL中被称为<strong>基本表(Table)</strong>,而对应外模式的数据称为<strong>视图(View)</strong>。<strong>视图不仅包含外模式，而且包含其E-C映像</strong>。</li><li><strong>基本表</strong>是实际存储于存储文件中的表，基本表中的<strong>数据是需要存储的</strong></li><li><strong>视图</strong>在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其<strong>数据并不存储</strong>，而是在运行过程中动态产生与维护的</li><li>对视图数据的更改最终要反映在对基本表的更改上。</li></ol><h4 id="11-1-视图的定义"><a href="#11-1-视图的定义" class="headerlink" title="11.1 视图的定义"></a>11.1 视图的定义</h4><p>视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。</p><ol><li>定义视图: <code>create view view_name [(列名[列名] …)] as 子查询 [with check option]</code><ul><li>如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。</li><li>with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式</li></ul></li><li>示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> CompStud <span class="keyword">AS</span></span><br><span class="line">    (<span class="keyword">Select</span> * <span class="keyword">From</span> Student</span><br><span class="line">        <span class="keyword">Where</span> D<span class="comment"># in (Select D# From Dept</span></span><br><span class="line">            <span class="keyword">Where</span> Dname = ‘计算机’));</span><br></pre></td></tr></table></figure></li></ol><h4 id="11-2-视图的使用"><a href="#11-2-视图的使用" class="headerlink" title="11.2 视图的使用"></a>11.2 视图的使用</h4><p>使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用</p><ul><li>示例：检索计算机系的所有学生，我们可使用CompStud<ul><li><code>Select * From CompStud;</code></li></ul></li><li>示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud<ul><li><code>Select * From CompStud Where Sage&lt;20;</code></li></ul></li></ul><h4 id="11-3-视图的更新"><a href="#11-3-视图的更新" class="headerlink" title="11.3 视图的更新"></a>11.3 视图的更新</h4><p>SQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。</p><ol><li>SQL视图更新的可执行性<ul><li>如果视图的select目标列包含聚集函数，则不能更新</li><li>如果视图的select子句使用了unique或distinct，则不能更新</li><li>如果视图中包括了groupby子句，则不能更新</li><li>如果视图中包括经算术表达式计算出来的列，则不能更新</li><li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li></ul></li><li>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新</li><li>可更新SQL视图示例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CStud(S<span class="comment">#, Sname, Sclass)</span></span><br><span class="line"><span class="keyword">as</span> ( <span class="keyword">select</span> S<span class="comment">#, Sname, Sclass from Student where D# ='03');</span></span><br><span class="line"><span class="comment">-- 更新视图</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> CStud <span class="keyword">Values</span> (<span class="string">'98030104'</span>, <span class="string">'张三丰'</span>, <span class="string">'980301'</span>);</span><br><span class="line"><span class="comment">-- 更新视图 将转换为 更新基本表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span> (<span class="string">'98030104'</span>, <span class="string">'张三丰'</span>, <span class="literal">Null</span>, <span class="literal">Null</span>, <span class="string">'03'</span>, <span class="string">'980301'</span>)</span><br></pre></td></tr></table></figure><h4 id="11-4-视图的撤销"><a href="#11-4-视图的撤销" class="headerlink" title="11.4 视图的撤销"></a>11.4 视图的撤销</h4><p>已经定义的视图也可以撤消</p><ul><li>撤消视图：<code>Drop View view_name</code></li></ul><p>不仅视图可以撤消，基本表、数据库等都可以撤消</p><ul><li>撤消基本表：<code>Drop Table 表名</code></li></ul><p><span id="id12"><span></span></span></p><h3 id="12-数据库完整性"><a href="#12-数据库完整性" class="headerlink" title="12. 数据库完整性"></a>12. 数据库完整性</h3><p>数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性–在任何情况下的正确性、有效性和一致性</p><ul><li>广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等</li><li>狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。</li></ul><h4 id="12-1-基本概念"><a href="#12-1-基本概念" class="headerlink" title="12.1 基本概念"></a>12.1 基本概念</h4><p>关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性</p><ol><li>数据库完整性管理的作用<ul><li>防止和避免数据库中不合理数据的出现</li><li>DBMS应尽可能地自动防止DB中语义不合理现象</li><li>如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担</li></ul></li><li>DBMS怎样自动保证完整性：<ul><li>DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)</li><li>当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性</li></ul></li><li><strong>完整性约束条件</strong>(或称完整性约束规则)的一般形式：Integrity Constraint::=(O,P,A,R)<ul><li>O：数据集合：约束的对象(列、多列(元组)、元组集合)</li><li>P：谓词条件：需要定义什么样的约束</li><li>A：触发条件：默认更新时检查</li><li>R：响应动作：默认拒绝</li></ul></li></ol><h4 id="12-2-数据库完整性的分类"><a href="#12-2-数据库完整性的分类" class="headerlink" title="12.2 数据库完整性的分类"></a>12.2 数据库完整性的分类</h4><ol><li><p>按约束对象分类:</p><ul><li>域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的</li><li>关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断</li></ul></li><li><p>按约束来源分类:</p><ul><li>结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；</li><li>内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。</li></ul></li><li><p>按约束状态分类:</p><ul><li>静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。</li><li>动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。</li></ul></li></ol><p><span id="id13"><span></span></span></p><h3 id="13-数据库的静态完整性-约束"><a href="#13-数据库的静态完整性-约束" class="headerlink" title="13. 数据库的静态完整性(约束)"></a>13. 数据库的静态完整性(约束)</h3><ol><li><p>SQL语言支持的约束类别：</p><ul><li>静态约束<ul><li>列完整性—域完整性约束</li><li>表完整性–关系完整性约束</li></ul></li><li>动态约束<ul><li>触发器</li></ul></li></ul></li><li><p>CreateTable有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性</p><ul><li>定义完整性约束条件：列完整性、表完整性</li></ul></li><li><p>列约束：一种<strong>域约束类型</strong>，对单一列的值进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; NOT NULL |                  //列值非空</span><br><span class="line">[ CONSTRAINT constraintname ] //为约束命名，便于以后撤消</span><br><span class="line">&#123; UNIQUE                      //列值是唯一</span><br><span class="line">| PRIMARY KEY                 //列为主键</span><br><span class="line">| <span class="keyword">CHECK</span> (search_cond)         //列值满足条件,条件只能使用列当前值</span><br><span class="line">| <span class="keyword">REFERENCES</span> tablename [(colname) ]</span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">DELETE</span> &#123; <span class="keyword">CASCADE</span> | <span class="keyword">SET</span> <span class="literal">NULL</span> &#125; ] &#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>表约束：一种<strong>关系约束类型</strong>，对多列或元组的值进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ CONSTRAINT constraintname ]       //为约束命名，便于以后撤消</span><br><span class="line">&#123; UNIQUE (colname &#123;,colname…&#125;)      //几列值组合在一起是唯一</span><br><span class="line">| PRIMARY KEY (colname &#123;,colname…&#125;) //几列联合为主键</span><br><span class="line">| <span class="keyword">CHECK</span> (search_condition)          //元组多列值共同满足条件</span><br><span class="line">                                    //条件中只能使用同一元组的不同列当前值</span><br><span class="line">| <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (colname &#123;,colname…&#125;)</span><br><span class="line"><span class="keyword">REFERENCES</span> tablename [(colname &#123;,colname…&#125;)]//引用另一表tablename的若干列的值作为外键</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。</p></blockquote><ol start="5"><li><p>Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)</p><ul><li>示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)<ul><li><code>Alter Table SC DROP CONSTRAINT ctscore;</code></li></ul></li><li>有些DBMS支持独立的追加约束,注意书写格式可能有些差异<ul><li>示例：<code>Alter Table SC Add Constraint nctscore check (Score&gt;=0.0 and Score&lt;=150.0));</code></li></ul></li></ul></li><li><p>现约束的方法-断言ASSERTION</p><ul><li>一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件</li><li>表约束和列约束就是一些特殊的断言</li><li>SQL还提供了复杂条件表达的断言。其语法形式为：<ul><li><code>CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt;</code></li></ul></li><li>当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">assertion</span> sum_constraint <span class="keyword">check</span></span><br><span class="line">    (<span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> branch</span><br><span class="line">    <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">sum</span>(amount ) <span class="keyword">from</span> loan</span><br><span class="line">        <span class="keyword">where</span> loan.branch_name = branch.branch_name )</span><br><span class="line">    &gt;= (<span class="keyword">select</span> <span class="keyword">sum</span> (balance ) <span class="keyword">from</span> <span class="keyword">account</span></span><br><span class="line">        <span class="keyword">where</span> account.branch_name = branch.branch_name )))</span><br><span class="line"><span class="comment">-- 数据表：</span></span><br><span class="line"><span class="keyword">account</span>(branch_name, account_number,…, balance) //分行，账户及其余额</span><br><span class="line">loan(branch_name , loan_number, amount,) //分行的每一笔贷款</span><br><span class="line">branch(branch_name, … ) //分行</span><br></pre></td></tr></table></figure><blockquote><p>断言测试增加了数据库维护的负担，要小心使用复杂的断言。</p></blockquote><p><span id="id14"><span></span></span></p><h3 id="14-数据库的动态完整性-触发器"><a href="#14-数据库的动态完整性-触发器" class="headerlink" title="14. 数据库的动态完整性(触发器)"></a>14. 数据库的动态完整性(触发器)</h3><p>实现数据库动态完整的方法—触发器Trigger</p><ol><li><p>触发器Trigger</p><ul><li>Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger</li><li>Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。</li></ul></li><li><p>基本语法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span></span><br><span class="line">    &#123; <span class="keyword">INSERT</span> | <span class="keyword">DELETE</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> colname &#123;, colname...&#125;] &#125;</span><br><span class="line">    <span class="keyword">ON</span> tablename [<span class="keyword">REFERENCING</span> corr_name_def &#123;, corr_name_def...&#125; ]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> | <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span>]</span><br><span class="line">                //对更新操作的每一条结果(前者)，或整个更新操作完成(后者)</span><br><span class="line">    [<span class="keyword">WHEN</span> (search_condition)]           //检查条件，如满足执行下述程序</span><br><span class="line">    &#123; <span class="keyword">statement</span>         //单行程序直接书写，多行程序要用下行方式</span><br><span class="line">    | BEGIN ATOMIC statement; &#123; statement;...&#125; END &#125;</span><br></pre></td></tr></table></figure></li><li><p>触发器Trigger意义：</p><ul><li>当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件<code>search_condition</code>,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用<code>corr_name_def</code>来限定。</li></ul></li><li><p>事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}</p><ul><li>当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发</li><li>操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由<code>corr_name_def</code>的使用来区分</li></ul></li><li><p><code>corr_name_def</code>的定义</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; OLD [ROW] [AS] old_row_corr_name //更新前的旧元组命别名为</span><br><span class="line">| NEW [ROW] [AS] new_row_corr_name //更新后的新元组命别名为</span><br><span class="line">| OLD TABLE [AS] old_table_corr_name //更新前的旧Table命别名为</span><br><span class="line">| NEW TABLE [AS] new_table_corr_name //更新后的新Table命别名为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>corr_name_def</code>将在检测条件或后面的动作程序段中被引用处理</p></blockquote><ol start="6"><li><p>示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> teacher_chgsal <span class="keyword">before</span> <span class="keyword">update</span> <span class="keyword">of</span> salary</span><br><span class="line">    <span class="keyword">on</span> teacher</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> x, <span class="keyword">old</span> y</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">when</span> (x.salary &lt; y.salary)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    raise_application_error(<span class="number">-20003</span>, <span class="string">'invalid salary on update'</span>);</span><br><span class="line">    //此条语句为Oracle的错误处理函数</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> sumc <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> sc</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> <span class="keyword">row</span> newi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> SumCourse = SumCourse + <span class="number">1</span></span><br><span class="line">    <span class="keyword">where</span> S<span class="comment"># = :newi.S# ;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> delS<span class="comment"># after delete on Student</span></span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">old</span> oldi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> sc <span class="keyword">where</span> S<span class="comment"># = :oldi.S# ;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li></ol><p><span id="id15"><span></span></span></p><h3 id="15-数据库索引"><a href="#15-数据库索引" class="headerlink" title="15. 数据库索引"></a>15. 数据库索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种<strong>数据结构</strong>（最常见的是B-Tree）</p><ol><li>索引的作用<ol><li>快速取数据；</li><li>保证数据记录的唯一性；</li><li>实现表与表之间的参照完整性；</li><li>在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。</li></ol></li><li>创建索引：<code>CREATE INDEX  索引名称  on 表名(字段名);</code></li><li>删除索引：<code>DROP INDEX 索引名称</code></li><li>索引注意事项：<ol><li>查询时减少使用<code>*</code>返回全部列，不要返回不需要的列</li><li>where表达式子句包含索引的表达式置前</li><li>避免在Order by中使用表达式</li><li>索引技术是数据库自动使用，一个表格只存在一个索引就够了</li></ol></li><li>缺点<ol><li>索引的缺点是创建和维护索引需要耗费时间和空间</li><li>索引可以提高查询速度，会减慢写入速度</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li></ol></li></ol><h4 id="15-1-索引主要种类"><a href="#15-1-索引主要种类" class="headerlink" title="15.1 索引主要种类"></a>15.1 索引主要种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p><ol><li>唯一索引<ul><li>唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</li></ul></li><li>主键索引<ul><li>数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</li></ul></li><li>聚集索引<ul><li>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</li></ul></li><li>索引列<ul><li>可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</li></ul></li></ol><p><span id="id16"><span></span></span></p><h3 id="16-数据库序列"><a href="#16-数据库序列" class="headerlink" title="16. 数据库序列"></a>16. 数据库序列</h3><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要<code>CREATE SEQUENCE</code>系统权限。</p><h4 id="16-1-Oracle中的序列（Sequence）"><a href="#16-1-Oracle中的序列（Sequence）" class="headerlink" title="16.1 Oracle中的序列（Sequence）"></a>16.1 Oracle中的序列（Sequence）</h4><ol><li><p>创建序列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> 序列名 </span><br><span class="line">    [<span class="keyword">increment</span> <span class="keyword">by</span> n]   <span class="comment">--每次增加n个，默认为1</span></span><br><span class="line">    [<span class="keyword">start</span> <span class="keyword">with</span> n]     <span class="comment">--起始值n，默认为1</span></span><br><span class="line">    [&#123;maxvalue n | <span class="keyword">nomaxvalue</span>&#125;]  <span class="comment">--最大值设置，递增默认10的27次方，递减默认-1</span></span><br><span class="line">    [&#123;<span class="keyword">minvalue</span> n | <span class="keyword">nominvalue</span>&#125;]  <span class="comment">--最小值设置，递增默认1，递减默认-10的26次方</span></span><br><span class="line">    [&#123;<span class="keyword">cycle</span> | <span class="keyword">nocycle</span>&#125;]   <span class="comment">--是否循环</span></span><br><span class="line">    [&#123;<span class="keyword">cache</span> n | nocache&#125;] <span class="comment">--是否对序列进行内存缓冲，默认为20</span></span><br></pre></td></tr></table></figure></li><li><p>查询序列</p><ul><li><code>NEXTVAL</code>:返回序列中下一个有效的值，任何用户都可以引用。</li><li><code>CURRVAL</code>:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询下一个将要使用的序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.nextval <span class="keyword">from</span> dual</span><br><span class="line"><span class="comment">--查询当前序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.currval <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure><blockquote><ul><li>Oracle将sequence的定义存储在数据字典之中。</li><li>Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。</li></ul></blockquote><ol start="3"><li>删除序列：<code>Drop sequence 序列名</code></li><li>更改序列：<code>Alter sequence 序列名 [其余参数同创建序列]</code></li><li>使用序列示例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.直接使用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person (<span class="keyword">id</span>, <span class="keyword">name</span>, <span class="keyword">password</span>) <span class="keyword">values</span> (序列名.nextval, <span class="string">'张三'</span>, <span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值</span></span><br><span class="line"><span class="comment">-- 2.1创建触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> 触发器名 <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> person</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> 序列名.nextval <span class="keyword">into</span> :new.id <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 2.2插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person ( username, age, <span class="keyword">password</span>) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="number">20</span>, <span class="string">'zhang123'</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>注意点：<ul><li>一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。</li><li>当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。</li><li>大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。</li></ul></li></ol><h4 id="16-2-Mysql中的序列（AUTO-INCREMENT）"><a href="#16-2-Mysql中的序列（AUTO-INCREMENT）" class="headerlink" title="16.2 Mysql中的序列（AUTO_INCREMENT）"></a>16.2 Mysql中的序列（AUTO_INCREMENT）</h4><p>MySQL中最简单使用序列的方法就是使用<code>AUTO_INCREMENT</code>来定义列。</p><ol><li>orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。</li><li>首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。</li><li>mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.</li><li>mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。</li></ol><p><span id="id17"><span></span></span></p><h3 id="17-数据库安全性"><a href="#17-数据库安全性" class="headerlink" title="17. 数据库安全性"></a>17. 数据库安全性</h3><p>数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏</p><ol><li>数据库安全性管理涉及许多方面<ol><li>社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法</li><li>公共政策/制度方面：例如，政府或组织的信息公开或非公开制度</li><li>安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)</li><li>数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)</li><li>数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制</li></ol></li><li>DBMS的安全机制<ol><li><strong>自主安全性机制</strong>：存取控制(AccessControl)<ul><li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li></ul></li><li><strong>强制安全性机制</strong>：<ul><li>通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据</li></ul></li><li>推断控制机制：<ul><li>防止通过历史信息，推断出不该被其知道的信息；</li><li>防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li></ul></li><li>数据加密存储机制：<ul><li>通过加密、解密保护数据，密钥、加密/解密方法与传输</li></ul></li></ol></li><li>DBA的责任和义务<ul><li>熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略</li><li>规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，</li><li><strong>划分好数据的安全级别以及用户的安全级别</strong></li><li>实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等</li></ul></li></ol><p><span id="id18"><span></span></span></p><h3 id="18-数据库自主安全性机制"><a href="#18-数据库自主安全性机制" class="headerlink" title="18. 数据库自主安全性机制"></a>18. 数据库自主安全性机制</h3><ul><li>通常情况下，自主安全性是通过授权机制来实现的。</li><li>用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。<ul><li>授权者：决定用户权利的人</li><li>授权：授予用户访问的权利</li></ul></li></ul><ol><li>DBMS自动实现自主安全性：<ul><li>DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)</li><li>当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问</li></ul></li><li>DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制<ul><li><code>AccessRule ::=(S, O, t, P)</code><ul><li>S: 请求主体(用户)</li><li>O: 访问对象</li><li>t: 访问权利</li><li>P: 谓词</li></ul></li><li>{AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;</li><li>用户多时，可以按用户组建立访问规则</li><li>访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库</li><li>权利：包括创建、增、删、改、查等</li><li>谓词：拥有权利需满足的条件</li></ul></li><li><strong>示例</strong>：员工管理数据库的安全性控制示例<code>Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)</code><ul><li>示例要求：<ul><li>员工管理人员：能访问该数据库的所有内容，便于维护员工信息</li><li>收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问</li><li>每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改</li><li>部门领导：能够查询其所领导部门人员的所有情况</li><li>高层领导：能访问该数据库的所有内容，但只能读</li></ul></li><li>两种控制示例<ul><li>按名控制安全性：存储矩阵</li><li>按内容控制安全性：视图</li></ul></li><li>视图是安全性控制的重要手段</li><li>通过视图可以限制用户对关系中某些数据项的存取,例如：<ul><li>视图1：CreateEmpV1as select*fromEmployee</li><li>视图2：CreateEmpV2as selectPname,D#fromEmployee</li></ul></li><li>通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：<ul><li>视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId</li><li>视图2： CreateEmpV4asselect*fromEmployeewhereHead=:UserId</li></ul></li><li>用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述</li></ul></li></ol><h4 id="18-1-SQL语言的用户与权利"><a href="#18-1-SQL语言的用户与权利" class="headerlink" title="18.1 SQL语言的用户与权利"></a>18.1 SQL语言的用户与权利</h4><ol><li><p>SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴</p></li><li><p>授权机制—自主安全性；视图的运用</p></li><li><p>关系级别(普通用户) &lt;– 账户级别(程序员用户) &lt;– 超级用户(DBA) </p><ul><li>(级别1)Select : 读(读DB, Table, Record, Attribute, … )</li><li>(级别2)Modify : 更新<ul><li>Insert : 插入(插入新元组, … )</li><li>Update : 更新(更新元组中的某些值, …)</li><li>Delete : 删除(删除元组, …)</li></ul></li><li>(级别3)Create : 创建(创建表空间、模式、表、索引、视图等)<ul><li>Create : 创建</li><li>Alter : 更新</li><li>Drop : 删除</li></ul></li></ul></li><li><p>级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。</p></li><li><p>授权命令<code>GRANT</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &#123;<span class="keyword">all</span> <span class="keyword">PRIVILEGES</span> | privilege &#123;,privilege…&#125;&#125;</span><br><span class="line">    <span class="keyword">ON</span> [<span class="keyword">TABLE</span>] tablename | viewname</span><br><span class="line">    <span class="keyword">TO</span> &#123;<span class="keyword">public</span> | <span class="keyword">user</span>-<span class="keyword">id</span> &#123;, <span class="keyword">user</span>-<span class="keyword">id</span>…&#125;&#125;</span><br><span class="line">    [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure><ul><li>user-id ，某一个用户账户，由DBA创建的合法账户</li><li>public, 允许所有有效用户使用授予的权利</li><li>privilege是下面的权利<ul><li>SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES</li></ul></li><li>WITH GRANT OPTION选项是允许被授权者传播这些权利</li></ul></li><li><p>SQL-DCL的控制安全性-授权示例:</p><ul><li>假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)<ul><li>Grant All Priviledges ON Employee TO Emp2001;</li><li>Grant SELECT ON EmpV2 TO Emp5001;</li><li>Grant SELECT ON EmpV3 TO public;</li><li>Grant SELECT ON EmpV4 TO Emp0021;</li></ul></li><li>授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)</li><li>授权者授予的权利必须是授权者已经拥有的权利</li></ul></li><li><p>收回授权命令<code>REVOKE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &#123;<span class="keyword">all</span> <span class="keyword">privilEges</span> | priv &#123;, priv…&#125; &#125; </span><br><span class="line">    <span class="keyword">ON</span> tablename | viewname</span><br><span class="line">    <span class="keyword">FROM</span> &#123;<span class="keyword">public</span> | <span class="keyword">user</span> &#123;, <span class="keyword">user</span>…&#125; &#125;;</span><br></pre></td></tr></table></figure><ul><li>示例: <code>revoke select on employee from UserB;</code></li></ul></li></ol><h4 id="18-2-自主安全性的授权过程及其问题"><a href="#18-2-自主安全性的授权过程及其问题" class="headerlink" title="18.2 自主安全性的授权过程及其问题"></a>18.2 自主安全性的授权过程及其问题</h4><h5 id="18-2-1-授权过程"><a href="#18-2-1-授权过程" class="headerlink" title="18.2.1 授权过程:"></a>18.2.1 授权过程:</h5><ol><li>第一步：DBA创建DB, 并为每一个用户创建一个账户<ul><li>假定建立了五个用户：UserA, UserB, UserC, UserD, UserE</li></ul></li><li>第二步：DBA授予某用户账户级别的权利<ul><li>假定授予UserA</li></ul></li><li>第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利<ul><li>假定UserA创建了Employee, 则UserA就是Employee表的属主账户</li></ul></li><li>第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…<ul><li>假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。</li></ul></li></ol><ul><li>注意授权的传播范围<ul><li>传播范围包括两个方面：水平传播数量和垂直传播数量<ul><li>水平传播数量是授权者的再授权用户数目(树的广度)</li><li>垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)</li></ul></li><li>有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。</li><li>当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回</li><li>如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。</li></ul></li></ul><h5 id="18-2-2-强制安全性机制"><a href="#18-2-2-强制安全性机制" class="headerlink" title="18.2.2 强制安全性机制"></a>18.2.2 强制安全性机制</h5><ol><li>强制安全性机制<ul><li>强制安全性通过对数据对象进行安全性分级<ul><li>绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)</li></ul></li><li>同时对用户也进行上述的安全性分级</li><li>从而强制实现不同级别用户访问不同级别数据的一种机制</li></ul></li><li>强制安全性机制的实现<ul><li>DBMS引入强制安全性机制, 可以通过扩展关系模式来实现<ul><li>关系模式: R(A1: D1, A2: D2, …, An:Dn)</li><li>对属性和元组引入安全性分级特性或称分类特性<ul><li>R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性</li></ul></li></ul></li><li>这样, 关系中的每个元组, 都将扩展为带有安全分级的元组</li><li>强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL语言概述&quot;&gt;&lt;a href=&quot;#SQL语言概述&quot; class=&quot;headerlink&quot; title=&quot;SQL语言概述&quot;&gt;&lt;/a&gt;SQL语言概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;结构化查询语言&lt;/strong&gt;(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL语言是集DDL、DML和DCL于一体的数据库语言
    
    </summary>
    
      <category term="数据库系统" scheme="http://chaooo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>二十三、SpringBoot MVC应用</title>
    <link href="http://chaooo.github.io/2019/08/31/23-SpringBoot-MVC%E5%BA%94%E7%94%A8.html"/>
    <id>http://chaooo.github.io/2019/08/31/23-SpringBoot-MVC应用.html</id>
    <published>2019-08-31T09:31:30.000Z</published>
    <updated>2019-08-31T09:32:41.043Z</updated>
    
    <content type="html"><![CDATA[<p>对Spring Web MVC封装，简化MVC结构web应用开发。</p><a id="more"></a><h3 id="1-SpringBoot-MVC开发Restful服务（前后分离）"><a href="#1-SpringBoot-MVC开发Restful服务（前后分离）" class="headerlink" title="1. SpringBoot MVC开发Restful服务（前后分离）*"></a>1. SpringBoot MVC开发Restful服务（前后分离）*</h3><p>按rest规则发送HTTP请求–&gt;Spring MVC–&gt;返回JSON结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web（springmvc、rest、jackson、tomcat）</li><li>在application.properties修改tomcat端口</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller、Service、Dao组件</li></ol><h3 id="2-SpringBoot-MVC开发JSP应用（PC浏览器）"><a href="#2-SpringBoot-MVC开发JSP应用（PC浏览器）" class="headerlink" title="2. SpringBoot MVC开发JSP应用（PC浏览器）"></a>2. SpringBoot MVC开发JSP应用（PC浏览器）</h3><p>HTTP请求–&gt;Spring MVC–&gt;JSP–&gt;HTML响应输出结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web、jasper解析器、jstl</li><li>在application.properties修改tomcat端口、viewResolver</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller组件，返回ModelAndView</li><li>在src/main/webapp下定义JSP组件</li></ol><h3 id="3-SpringBoot-MVC开发Thymeleaf应用（PC浏览器）"><a href="#3-SpringBoot-MVC开发Thymeleaf应用（PC浏览器）" class="headerlink" title="3. SpringBoot MVC开发Thymeleaf应用（PC浏览器）*"></a>3. SpringBoot MVC开发Thymeleaf应用（PC浏览器）*</h3><p>HTTP请求–&gt;Spring MVC–&gt;Thymeleaf模板–&gt;HTML响应输出结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web、spring-boot-starter-thymeleaf</li><li>在application.properties修改tomcat端口</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller组件，返回ModelAndView</li><li>在src/main/resources/templates下定义模板文件<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"https://www.thymeleaf.org/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">th:text</span>=<span class="string">"$&#123;data&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li>th:text表达式作用：将模型中的数据以只读文本显示到元素中</li><li>th:text表达式作用：将模型中的数据以只读文本显示到元素中。</li><li>th:if 表达式作用：if判断逻辑</li><li>th:each 表达式作用：循环逻辑</li><li>th:href 表达式作用：动态生成href链接</li></ul></blockquote><p>Thymeleaf模板和JSP区别</p><ol><li>运行机制不同<ul><li>JSP–&gt;Servlet–&gt;HTML</li><li>模板+数据–&gt;HTML输出</li></ul></li><li>模板简单易用;JSP相对复杂些<ul><li>JSP:9大内置对象、EL、JSTL、嵌入Java代码、框架标签</li><li>模板：模板表达式</li></ul></li><li>模板效率高,比JSP性能好<ul><li>模板：缓存</li></ul></li></ol><h3 id="4-SpringBoot-MVC静态资源处理"><a href="#4-SpringBoot-MVC静态资源处理" class="headerlink" title="4. SpringBoot MVC静态资源处理"></a>4. SpringBoot MVC静态资源处理</h3><p>静态资源包含图片、js、css等，动态资源servlet、jsp等。</p><p>SpringBoot中src/main/resources目录下有几个约定的静态资源存放位置</p><ul><li>META-INF/resources（优先级最高）</li><li>resources</li><li>static</li><li>public（优先级最低）</li></ul><p>自定义静态资源访问路径，编写一个配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStaticConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/**"</span>)</span><br><span class="line">            .addResourceLocations(</span><br><span class="line">                <span class="string">"classpath:/images/"</span>,</span><br><span class="line">                <span class="string">"classpath:/resources/"</span>,</span><br><span class="line">                <span class="string">"classpath:/static/"</span>,</span><br><span class="line">                <span class="string">"classpath:/public/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-SpringBoot-MVC异常处理"><a href="#5-SpringBoot-MVC异常处理" class="headerlink" title="5. SpringBoot MVC异常处理"></a>5. SpringBoot MVC异常处理</h3><ol><li><p>异常处理机制</p><ul><li>SpringBoot底层提供了异常处理机制。SpringBoot提供了一个ErrorMvcAutoConfiguration自动配置组件，创建了一个BasicErrorController对象，提供两个/error请求处理，一个返回html，另一个返回json。当MVC底层遇到异常会用转发方式发出/error请求。</li></ul></li><li><p>可以自定义ErrorController替代底层BasicErrorController，将错误提示转发到自定义提示界面(全局)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//@RequestMapping("/error")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorController</span> <span class="keyword">implements</span> <span class="title">ErrorController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/error"</span>,produces= MediaType.TEXT_HTML_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.setViewName(<span class="string">"myerror"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/error"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"程序发生了异常"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ExceptionHandler异常处理（局部）</p><ul><li>ErrorController管理全局异常，@ExceptionHandler管理所在Controller组件的异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">"msg"</span>, <span class="string">"发生异常"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, ex.getClass());</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>可以将上述方法封装成一个BasicController，通过@ControllerAdvice作用到所有Controller组件上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//等价于所有Controller都继承它</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"发生异常"</span>);</span><br><span class="line">        map.put(<span class="string">"type"</span>, ex.getClass());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-SpringBoot-AOP"><a href="#6-SpringBoot-AOP" class="headerlink" title="6. SpringBoot AOP"></a>6. SpringBoot AOP</h3><ol><li><p>引入spring-boot-starter-aop</p></li><li><p>定义一个切面组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//将Bean组件纳入Spring容器</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//将Bean组件定义为Aspect切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)<span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----开始处理----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)<span class="comment">//最终通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----处理完毕----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        Object obj = pjp.proceed();<span class="comment">//调用目标组件方法</span></span><br><span class="line">        watch.stop();</span><br><span class="line">        System.out.println(<span class="string">"处理时间:"</span>+watch.getTotalTimeMillis()+<span class="string">" 毫秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置切面组件</p><ul><li>@Aspect、@Before、@After、@Around、@AfterReturning、@AfterThrowing等</li></ul></li></ol><h3 id="7-SpringBoot-MVC拦截器"><a href="#7-SpringBoot-MVC拦截器" class="headerlink" title="7. SpringBoot MVC拦截器"></a>7. SpringBoot MVC拦截器</h3><ol><li><p>编写一个拦截器组件,实现HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了MyInterceptor拦截器"</span>);</span><br><span class="line">        String user = (String)request.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.sendRedirect(<span class="string">"/tologin"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//阻止后续流程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续执行后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyInterceptor my;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(my).addPathPatterns(<span class="string">"/direction/list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-SpringBoot整合Servlet-Filter"><a href="#8-SpringBoot整合Servlet-Filter" class="headerlink" title="8. SpringBoot整合Servlet/Filter"></a>8. SpringBoot整合Servlet/Filter</h3><h4 id="8-1-整合Servlet"><a href="#8-1-整合Servlet" class="headerlink" title="8.1 整合Servlet"></a>8.1 整合Servlet</h4><p>首先导入spring-boot-starter-web</p><h5 id="8-1-1-整合Servlet方式一："><a href="#8-1-1-整合Servlet方式一：" class="headerlink" title="8.1.1 整合Servlet方式一："></a>8.1.1 整合Servlet方式一：</h5><ol><li><p>编写一个Servlet组件，继承HttpServlet</p></li><li><p>在Servlet类定义前使用@WebServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"helloservlet"</span>,urlPatterns= &#123;<span class="string">"/hello.do"</span>&#125;,loadOnStartup=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.getWriter().println(<span class="string">"Hello SpringBoot Servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类前需要使用@ServletComponentScan扫描@WebServlet配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//扫描@WebServlet、@WebFilter、@WebListener组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="8-1-2-整合Servlet方式二："><a href="#8-1-2-整合Servlet方式二：" class="headerlink" title="8.1.2 整合Servlet方式二："></a>8.1.2 整合Servlet方式二：</h5><ol><li><p>编写一个Servlet组件，继承HttpServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.getWriter().println(<span class="string">"Hello Spring Some Servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ServletRegistrationBean+@Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="title">someservlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean&lt;Servlet&gt; bean = <span class="keyword">new</span> ServletRegistrationBean&lt;Servlet&gt;();</span><br><span class="line">        bean.setServlet(<span class="keyword">new</span> SomeServlet());</span><br><span class="line">        bean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        urls.add(<span class="string">"/some.do"</span>);</span><br><span class="line">        bean.setUrlMappings(urls);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-2-整合Filter"><a href="#8-2-整合Filter" class="headerlink" title="8.2 整合Filter"></a>8.2 整合Filter</h4><p>在SpringBoot整合Servlet的基础上整合Filter</p><h5 id="8-2-1-整合Filter方式一："><a href="#8-2-1-整合Filter方式一：" class="headerlink" title="8.2.1 整合Filter方式一："></a>8.2.1 整合Filter方式一：</h5><ol><li><p>编写一个Filter组件，继承Filter</p></li><li><p>在Filter类定义前使用@WebFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns=<span class="string">"/hello.do"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletRequest request, ServletResponse response, FilterChain chain</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----hello filter------servlet执行之前"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">"-----hello filter------servlet执行之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类前需要使用@ServletComponentScan扫描@WebServlet配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//扫描@WebServlet、@WebFilter、@WebListener组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="8-2-2-整合Filter方式二："><a href="#8-2-2-整合Filter方式二：" class="headerlink" title="8.2.2 整合Filter方式二："></a>8.2.2 整合Filter方式二：</h5><ol><li><p>编写一个Filter组件，继承Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletRequest request, ServletResponse response, FilterChain chain</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----som filter------servlet执行之前"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">"-----som filter------servlet执行之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用FilterRegistrationBean+@Bean 注册过滤器并设置拦截的请求地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="title">somefilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; bean = <span class="keyword">new</span> FilterRegistrationBean&lt;Filter&gt;();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> SomeFilter());</span><br><span class="line">        <span class="comment">// 配置要拦截的请求</span></span><br><span class="line">        bean.addUrlPatterns(<span class="string">"/some.do"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="9-SpringBoot-任务调度"><a href="#9-SpringBoot-任务调度" class="headerlink" title="9. SpringBoot 任务调度"></a>9. SpringBoot 任务调度</h3><h4 id="9-1-服务器启动后自动调用"><a href="#9-1-服务器启动后自动调用" class="headerlink" title="9.1 服务器启动后自动调用"></a>9.1 服务器启动后自动调用</h4><p>tomcat服务器启动后自动调用任务，可以使用ApplicationRunner或CommandLineRunner接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask1</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务器启动后自动执行SomeTask1任务---"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask2</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务器启动后自动执行SomeTask2任务-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多个Task任务，可以通过@Order指定先后顺序，多个任务是线程同步调用。</p></blockquote><h4 id="9-2-程序运行后定时调用任务"><a href="#9-2-程序运行后定时调用任务" class="headerlink" title="9.2 程序运行后定时调用任务"></a>9.2 程序运行后定时调用任务</h4><p>Spring提供了一个Spring Schedule模块，封装了任务调用，之前都是采用Quartz组件调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span><span class="comment">//开启Schedule模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在服务器启动1秒后调用任务，每隔3秒调用一次</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(initialDelay=<span class="number">1000</span>,fixedRate=<span class="number">3000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----周期性调用SomeTask3-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在服务器启动0秒后调用任务，每隔5秒调用一次</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0/5 * * * * ?"</span>)<span class="comment">//秒 分 时 日 月 星期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----周期性调用SomeTask4-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Spring Schedule还需要指定cron表达式，表达式具体规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">秒   分    时    日   月   星期   年（可省略）</span><br><span class="line">0    0     10    1   10    ？</span><br><span class="line">秒： 0-59</span><br><span class="line">分： 0-59</span><br><span class="line">时： 0-23</span><br><span class="line">日： 1-31</span><br><span class="line">月： 1-12</span><br><span class="line">星期：1-7，1表示星期日，7表示星期六</span><br><span class="line">* ： 表示每一分、每一秒、每一天，任何一个可能值</span><br><span class="line">? ： 只用在日和星期部分，如果指定日，星期用？;如果指定星期，日用?，避免日和星期冲突 </span><br><span class="line">/ ： 表示增量，0/1表示0\1\2\3\4递增加1；0/5表示0\5\10\15；1/5表示1\6\11\16\21</span><br><span class="line">L ： 只用在日和星期部分，表示最后一天、周六</span><br></pre></td></tr></table></figure><p>cron表达式案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;30 * * * * ?&quot; 每半分钟触发任务</span><br><span class="line">&quot;30 10 * * * ?&quot; 每小时的10分30秒触发任务</span><br><span class="line">&quot;30 10 1 * * ?&quot; 每天1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 * ?&quot; 每月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 10 ? *&quot; 每年10月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 10 ? 2011&quot; 2011年10月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 ? 10 * 2011&quot; 2011年10月每天1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 ? 10 SUN 2011&quot; 2011年10月每周日1点10分30秒触发任务</span><br><span class="line">&quot;15,30,45 * * * * ?&quot; 每15秒，30秒，45秒时触发任务</span><br><span class="line">&quot;15-45 * * * * ?&quot; 15到45秒内，每秒都触发任务</span><br><span class="line">&quot;15/5 * * * * ?&quot; 每分钟的每15秒开始触发，每隔5秒触发一次</span><br><span class="line">&quot;15-30/5 * * * * ?&quot; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次</span><br><span class="line">&quot;0 0/3 * * * ?&quot; 每小时的第0分0秒开始，每三分钟触发一次</span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 星期一到星期五的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 L * ?&quot; 每个月最后一天的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 LW * ?&quot; 每个月最后一个工作日的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 ? * 5L&quot; 每个月最后一个星期四的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 ? * 5#3&quot; 每个月第三周的星期四的10点15分0秒触发任务</span><br></pre></td></tr></table></figure><h4 id="9-3-SpringBoot-Quartz"><a href="#9-3-SpringBoot-Quartz" class="headerlink" title="9.3 SpringBoot+Quartz"></a>9.3 SpringBoot+Quartz</h4><p>导入spring-boot-starter-quartz, 编写Job任务组件，继承QuartzJobBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask5</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过Quartz工具调用定时任务"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置Job组件（JobDetail、Tigger）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将MyTask5任务组件封装成JobDetail</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">task5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(MyTask5.class)</span><br><span class="line">            .withIdentity(<span class="string">"task5"</span>).storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//为JobDetail指定触发时间cron表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">task5Trigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CronScheduleBuilder cronScheduleBuilder = </span><br><span class="line">            CronScheduleBuilder.cronSchedule(<span class="string">"0/5 46 10 * * ?"</span>);</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(task5())</span><br><span class="line">                .withIdentity(<span class="string">"task5"</span>)</span><br><span class="line">                .withSchedule(cronScheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Spring Web MVC封装，简化MVC结构web应用开发。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>二十二、SpringBoot数据库访问</title>
    <link href="http://chaooo.github.io/2019/08/31/22-SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE.html"/>
    <id>http://chaooo.github.io/2019/08/31/22-SpringBoot数据库访问.html</id>
    <published>2019-08-31T09:29:31.000Z</published>
    <updated>2019-08-31T09:30:33.757Z</updated>
    
    <content type="html"><![CDATA[<p>Springboot对于数据访问层，无论是SQL还是NOSQL，都默认采用整合Spring Data的方式进行统一处理，Springboot添加大量自动配置，屏蔽了很多设置。并引入各种<em>Template，</em>Repository来简化我们对数据访问层的操作。</p><a id="more"></a><h3 id="1-SpringBoot数据库访问"><a href="#1-SpringBoot数据库访问" class="headerlink" title="1.SpringBoot数据库访问"></a>1.SpringBoot数据库访问</h3><h4 id="1-1-Spring-DAO-JdbcTemplate"><a href="#1-1-Spring-DAO-JdbcTemplate" class="headerlink" title="1.1 Spring DAO JdbcTemplate"></a>1.1 Spring DAO JdbcTemplate</h4><p>引入spring-boot-starter-jdbc后（hikari、spring-jdbc包），就可以借助DataSourceAutoConfiguration、JdbcTemplateAutoConfiguration自动配置组件创建出HikariDataSource、JdbcTemplate对象。</p><ol><li>引入jdbc启动器、驱动包，创建连接池</li><li>根据要操作表定义entity（pojo，属性名与字段名一致）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义Dao接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>定义Dao实现类，扫描并注入JdbcTemplate使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span><span class="comment">//通过组件扫描加载到Spring容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDirectionDao</span> <span class="keyword">implements</span> <span class="title">DirectionDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;<span class="comment">//通过自动配置加载到Spring容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from direction"</span>;</span><br><span class="line">        RowMapper&lt;Direction&gt; rowMapper = </span><br><span class="line">            <span class="keyword">new</span> BeanPropertyRowMapper&lt;Direction&gt;(Direction.class);</span><br><span class="line">        <span class="keyword">return</span> template.query(sql, rowMapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Spring-MyBatis（XML-SQL版本）"><a href="#1-2-Spring-MyBatis（XML-SQL版本）" class="headerlink" title="1.2 Spring MyBatis（XML SQL版本）"></a>1.2 Spring MyBatis（XML SQL版本）</h4><ul><li>引入spring-boot-starter-jdbc、驱动包、mybatis-spring-boot-starter</li><li>引入application.properties（连接池参数）</li><li>实体类(同上)</li><li>SQL定义</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.xdl.dao.DirectionMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.xdl.entity.Direction"</span>&gt;</span></span><br><span class="line">        select * from direction</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"cn.xdl.entity.Direction"</span>&gt;</span></span><br><span class="line">        select * from direction where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direction <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@MapperScan和mybatis.mapperLocations=classpath:sql/*.xml</p></li><li><p>在启动类前追加@MapperScan</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages=<span class="string">"cn.xdl.dao"</span>)<span class="comment">//扫描Mapper接口创建对象加载到Spring容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在application.properties追加mybatis.mapperLocations</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.mapperLocations=classpath:sql/*.xml</span><br></pre></td></tr></table></figure><h4 id="1-3-Spring-MyBatis（注解-SQL版本）"><a href="#1-3-Spring-MyBatis（注解-SQL版本）" class="headerlink" title="1.3 Spring MyBatis（注解 SQL版本）"></a>1.3 Spring MyBatis（注解 SQL版本）</h4><ul><li>引入spring-boot-starter-jdbc、驱动包、mybatis-spring-boot-starter</li><li>引入application.properties（连接池参数）</li><li>实体类(同上)</li><li>定义Mapper接口，使用@Select、@Update、@Insert、@Delete注解定义SQL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from direction"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from direction where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direction <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update direction set name=#&#123;name&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateName</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id,@<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span>String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用@MapperScan（同上）</li></ul><h3 id="2-Spring-Data-JPA"><a href="#2-Spring-Data-JPA" class="headerlink" title="2. Spring Data JPA"></a>2. Spring Data JPA</h3><h4 id="2-1-Jpa"><a href="#2-1-Jpa" class="headerlink" title="2.1 Jpa"></a>2.1 Jpa</h4><p>Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p><p>Sun引入新的JPA ORM规范主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。</p><blockquote><p>注意:Jpa 是一套规范，不是一套产品，那么像 Hibernate,TopLink,JDO 他们是一套产品，如果说这些产品实现了这个 Jpa 规范，那么我们就可以叫他们为 Jpa 的实现产品。</p></blockquote><h4 id="2-2-Spring-Boot-Jpa"><a href="#2-2-Spring-Boot-Jpa" class="headerlink" title="2.2 Spring Boot Jpa"></a>2.2 Spring Boot Jpa</h4><p>Spring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。</p><blockquote><p>Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现</p></blockquote><p>在Spring中使用JPA访问数据库，需要使用Spring Data模块支持。<br>    - SpringData是对Spring框架一个扩展模块，包含对JPA、Redis、MongoDB等技术的访问支持。</p><p>Spring Boot Jpa的使用 </p><ol><li><p>引入spring-boot-starter-jdbc、spring-boot-starter-data-jpa、驱动包</p></li><li><p>在application.properties定义db连接池参数（同上）</p></li><li><p>定义RunBoot启动类，使用@SpringBootApplication标记（同上）</p></li><li><p>根据要操作的表定义实体类，使用@Entity、@Table、@Id、@Column定义该对象和表结构之间的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"direction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义Dao接口，可以选择继承JpaRepository、PagingAndSortingRepository、CrudRepository等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionDao</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Direction</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3-Dao扩展操作"><a href="#2-3-Dao扩展操作" class="headerlink" title="2.3 Dao扩展操作"></a>2.3 Dao扩展操作</h4><p>分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pageable pageable = PageRequest.of(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//of(页数从0开始,记录条数)</span></span><br><span class="line">Page&lt;Direction&gt; page = dao.findAll(pageable);</span><br><span class="line">List&lt;Direction&gt; list = page.getContent();</span><br><span class="line">list.forEach(d-&gt;&#123;System.out.println(d.getId()+<span class="string">" "</span>+d.getName());&#125;);</span><br><span class="line">System.out.println(<span class="string">"总记录数:"</span>+page.getTotalElements()</span><br><span class="line">+<span class="string">" 页数:"</span>+(page.getNumber()+<span class="number">1</span>)+<span class="string">"/"</span>+page.getTotalPages());</span><br><span class="line">List&lt;Direction&gt; list1 = dao.findByIdGreaterThan2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>按方法名规则扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//where id&gt;?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure><p>定义SQL语句扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(nativeQuery=<span class="keyword">true</span>,value=<span class="string">"select * from direction where id&gt;:id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan1</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p>定义JPQL面向查询语句扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"from Direction where id&gt;:id"</span>) <span class="comment">//使用类型名和属性名替代表名和字段名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan2</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p>按名称模糊查询，带分页支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(nativeQuery=<span class="keyword">true</span>,value=<span class="string">"select * from direction where name like :name"</span></span><br><span class="line">    ,countQuery=<span class="string">"select count(*) from direction where name like :name"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Direction&gt; <span class="title">findByNameLike1</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String name,Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Springboot对于数据访问层，无论是SQL还是NOSQL，都默认采用整合Spring Data的方式进行统一处理，Springboot添加大量自动配置，屏蔽了很多设置。并引入各种&lt;em&gt;Template，&lt;/em&gt;Repository来简化我们对数据访问层的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>二十一、SpringBoot入门</title>
    <link href="http://chaooo.github.io/2019/08/27/21-SpringBoot%E5%85%A5%E9%97%A8.html"/>
    <id>http://chaooo.github.io/2019/08/27/21-SpringBoot入门.html</id>
    <published>2019-08-27T15:06:01.000Z</published>
    <updated>2019-08-27T15:07:05.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-项目管理工具Maven的基本使用"><a href="#1-项目管理工具Maven的基本使用" class="headerlink" title="1. 项目管理工具Maven的基本使用"></a>1. 项目管理工具Maven的基本使用</h3><p>Maven是一个使用java编写的开源的项目管理工具，可以方便灵活的控制项目，不必浪费时间去在不同的环境中配置依赖的jar包，而专心于业务逻辑。</p><h4 id="1-1-配置Maven的系统环境变量"><a href="#1-1-配置Maven的系统环境变量" class="headerlink" title="1.1 配置Maven的系统环境变量"></a>1.1 配置Maven的系统环境变量</h4><ol><li>下载并解压到目录，如<code>D:\apache-maven-3.6.1</code></li><li>添加新的系统环境变量MAVEN_HOME=安装的目录：<code>MAVEN_HOME=D:\apache-maven-3.6.1</code></li><li>添加<code>%MAVEN_HOME%\bin</code>到系统PATH变量.</li><li>测试Maven配置是否成功，打开命令行窗口，输入<code>mvn -v</code>，如果有maven 版本信息输出则证明配置成功，否则请查看自己配置路径等是否正确。</li></ol><blockquote><p>注意：安装Maven前请确保已安装JDK并成功配置其环境变量。</p></blockquote><h4 id="1-2-maven中的术语"><a href="#1-2-maven中的术语" class="headerlink" title="1.2 maven中的术语"></a>1.2 maven中的术语</h4><ul><li><strong>maven插件</strong>：maven主要定义了项目对象模型的生命周期。实际上每个任务都是交由插件完成的。maven的生命周期与插件目标相互绑定，来完成每个具体的任务。</li><li><strong>maven坐标</strong>：就是对项目的定位。groupId：组id，机构名。artifactId：构建id ，产品名或者产品的id。version ：版本号。</li><li><strong>坐标形式</strong>：groupId + artifactId+ version</li><li><strong>maven仓库</strong>：存放maven共享构建的位置。<ol><li>本地仓库：localRepository（使用<code>conf/settings.xml</code>设置）</li><li>私服仓库：部署在局域网中的仓库，方便整个团队的开发使用。</li><li>中央仓库：远程仓库下载地址：<a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a></li></ol></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- conf/settings.xml设置本地仓库路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">...</span></span></span><br><span class="line">    &lt;localRepository&gt;D:/apache-maven-3.6.1/.m2/repository&lt;/localRepository&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="1-3-maven构建的生命周期"><a href="#1-3-maven构建的生命周期" class="headerlink" title="1.3 maven构建的生命周期"></a>1.3 maven构建的生命周期</h4><p>清除–&gt; 编译–&gt; 测试–&gt; 报告–&gt; 打包(jar\war)–&gt; 安装–&gt; 部署</p><ol><li>清除：<code>mvn clean</code></li><li>编译：<code>mvn compile</code></li><li>测试：<code>mvn test</code></li><li>打包：<code>mvn package</code></li><li>安装：<code>mvn install</code></li><li>部署：<code>mvn deploy</code></li></ol><h4 id="1-4-MAVEN优点"><a href="#1-4-MAVEN优点" class="headerlink" title="1.4 MAVEN优点"></a>1.4 MAVEN优点</h4><ol><li>模块化项目<ul><li>项目非常大时，可借助Maven将一个项目拆分成多个工程，最好是一个模块对应一个工程，利于分工协作。而且模块可以通信。</li></ul></li><li>实现Jar包共享<ul><li>借助Maven，可将jar包仅仅保存在“仓库”中，有需要该文件时，就引用该文件接口，不需要复制文件过来占用空间。</li></ul></li><li>jar包的依赖<ul><li>借助Maven可以以规范的方式下载jar包，因为所有的知名框架或第三方工具的jar包已经按照统一的规范存放到了Maven的中央仓库中。</li></ul></li><li>jar包的自动导入<ul><li>通过xml定义引入jar包，Maven会自动导入jar包及其依赖jar包进来。</li></ul></li></ol><h4 id="1-5-MAVEN工具"><a href="#1-5-MAVEN工具" class="headerlink" title="1.5 MAVEN工具"></a>1.5 MAVEN工具</h4><ul><li>可以命令行使用，也可以结合Eclipse和Idea使用</li><li>简化项目搭建、编译、打包、发布等工作</li></ul><h3 id="2-SpringBoot基础"><a href="#2-SpringBoot基础" class="headerlink" title="2. SpringBoot基础"></a>2. SpringBoot基础</h3><ul><li>SpringBoot是对<strong>Spring框架的封装</strong>，用于<strong>简化</strong>Spring应用搭建和开发过程。</li><li>SpringBoot是pivotal公司产品、SpringCloud也是。</li></ul><h4 id="2-1-SpringBoot典型特点："><a href="#2-1-SpringBoot典型特点：" class="headerlink" title="2.1 SpringBoot典型特点："></a>2.1 SpringBoot典型特点：</h4><ul><li>去除XML配置，完全采用Java配置方式</li><li>内置tomcat服务器</li><li>利用自动配置创建很多对象（DataSource、JdbcTemplate、DispatcherServlet等）</li><li>提供一系列启动器（jar包集合）</li><li>采用properties或yml做配置文件</li><li>应用采用jar包发布</li></ul><h4 id="2-2-SpringBoot程序构成"><a href="#2-2-SpringBoot程序构成" class="headerlink" title="2.2 SpringBoot程序构成"></a>2.2 SpringBoot程序构成</h4><ul><li>创建工程，导入boot启动器（jar包）</li><li><code>spring-boot-starter</code> (核心、包含ioc、yml、自动配置、Log日志)</li><li><code>spring-boot-starter-parent</code>（包含参数设置、文件编码、jdk版本等）</li><li><code>spring-boot-starter-jdbc</code>（包含连接池、jdbcTemplate等）</li><li><code>spring-boot-starter-web</code>（包含mvc、restful、tomcat等）</li><li><code>spring-boot-starter-test</code>（包含junit、spring-test等）</li><li>添加配置文件<code>application.properties</code>或<code>application.yml</code></li></ul><h4 id="2-3-SpringBoot配置文件"><a href="#2-3-SpringBoot配置文件" class="headerlink" title="2.3 SpringBoot配置文件"></a>2.3 SpringBoot配置文件</h4><p>application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">server.port=8888</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr"> datasource:</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr"> port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><h4 id="2-4-SpringBoot启动类"><a href="#2-4-SpringBoot启动类" class="headerlink" title="2.4 SpringBoot启动类"></a>2.4 SpringBoot启动类</h4><p>定义启动类，通过main方法启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xxxx</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(Xxxx.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-SpringBoot数据库访问"><a href="#2-5-SpringBoot数据库访问" class="headerlink" title="2.5 SpringBoot数据库访问"></a>2.5 SpringBoot数据库访问</h4><p>在pom.xml定义spring-boot-starter-jdbc、mysql驱动包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在application.properties定义数据库连接参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/ydma</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>定义启动类，内部会根据自动配置机制生成DataSource和JdbcTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");</span></span><br><span class="line">        ApplicationContext ctx = </span><br><span class="line">                SpringApplication.run(RunBoot.class, args);</span><br><span class="line">        DataSource ds = ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(ds.getConnection());</span><br><span class="line">        JdbcTemplate template = ctx.getBean(JdbcTemplate.class);</span><br><span class="line">        System.out.println(template);</span><br><span class="line">        String sql = <span class="string">"insert into paper_score (total_score,my_score,user_id) values (?,?,?)"</span>;</span><br><span class="line">        Object[] params = &#123;<span class="number">100</span>,<span class="number">90</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        template.update(sql,params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提示：DataSource和JdbcTemplate都是基于自动配置机制产生，直接注入使用即可。</span></span><br></pre></td></tr></table></figure><h4 id="2-6-打包发布SpringBoot程序："><a href="#2-6-打包发布SpringBoot程序：" class="headerlink" title="2.6 打包发布SpringBoot程序："></a>2.6 打包发布SpringBoot程序：</h4><ol><li><p>在pom.xml定义spring-boot-maven-plugin插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击工程右键选择run as- maven build …</p></li><li><p>执行完毕后会在项目target目录下生成一个jar包，该包就是发布包</p><ul><li>可以采用java -jar xxxx.jar命令启动</li></ul></li></ol><blockquote><p>提示：eclipse设置jdk必须指向到JDK路径，不要JRE路径。</p></blockquote><h3 id="3-SpringBoot启动过程"><a href="#3-SpringBoot启动过程" class="headerlink" title="3. SpringBoot启动过程"></a>3. SpringBoot启动过程</h3><ol><li>调用SpringApplication的静态的run方法启动</li><li>静态的run方法调用SpringApplication对象的run方法<ul><li>(SpringApplication对象创建时加载spring.factories文件中Initializer和Application Listeners组件，判断程序类型servlet、reactive、default)</li></ul></li><li>对象的run方法会创建Spring的ApplicationContext容器对象<ul><li>获取启动Listener组件</li><li>获取environment环境参数</li><li>获取启动Logo信息Banner</li><li>根据程序类型不同创建不同类型的ApplicationContext对象</li><li>将Listener、environment、banner设置到ApplicationContext容器对象中</li><li>为ApplicationContext容器对象加载程序中各种Bean组件</li><li>开始执行启动任务ApplicationRunner、CommandLineRunner等</li><li>返回ApplicationContext容器对象</li></ul></li></ol><h3 id="4-SpringBootApplication作用"><a href="#4-SpringBootApplication作用" class="headerlink" title="4. @SpringBootApplication作用"></a>4. @SpringBootApplication作用</h3><p>SpringApplication.run方法在启动中，加载一个带有@SpringBootApplication标记的参数，该标记具有以下几种功能。</p><h4 id="4-1-SpringBootConfiguration（SpringBoot-Bean定义）"><a href="#4-1-SpringBootConfiguration（SpringBoot-Bean定义）" class="headerlink" title="4.1 @SpringBootConfiguration（SpringBoot Bean定义）"></a>4.1 @SpringBootConfiguration（SpringBoot Bean定义）</h4><ul><li>spring中bean定义<code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</code></li><li>SpringBoot通过<code>@Bean、@Primary</code>标记定义。</li></ul><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span><span class="comment">//开启Bean定义功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将返回的UserDao对象放入Spring容器，默认方法名为id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userdao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dao2"</span>)<span class="comment">//将返回的UserDao对象放入Spring容器，指定id为dao2</span></span><br><span class="line">    <span class="meta">@Primary</span><span class="comment">//默认注入该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userdao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"userService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@SpringBootConfiguration标记是对Spring的@Configuration封装，所以直接用@Configuration也可以。</p></blockquote><h4 id="4-2-ComponentScan（SpringBoot组件扫描）"><a href="#4-2-ComponentScan（SpringBoot组件扫描）" class="headerlink" title="4.2 @ComponentScan（SpringBoot组件扫描）"></a>4.2 @ComponentScan（SpringBoot组件扫描）</h4><ul><li>spring中组件扫描<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></li><li>SpringBoot通过@ComponentScan<ol><li>扫描指定包路径组件，带@Controller、@Service、@Repository、@Component注解标记组件<ul><li><code>@ComponentScan(basePackages= {&quot;cn.xdl.dao&quot;,&quot;cn.xdl.service&quot;})</code></li></ul></li><li>扫描cn.xdl包及子包下的组件<ul><li><code>@ComponentScan(basePackages=&quot;cn.xdl&quot;)</code></li></ul></li><li>扫描当前包及子包下的组件<ul><li><code>@ComponentScan</code></li></ul></li><li>扫描当前包及子包组件，并且将DeptService组件纳入<ul><li><code>@ComponentScan(includeFilters= {@Filter(type=FilterType.ASSIGNABLE_TYPE,classes=DeptService.class)})</code></li></ul></li><li>扫描当前包及子包组件，带有@Controller、@Service…、@MyComponent注解有效<ul><li><code>@ComponentScan(includeFilters= {@Filter(type=FilterType.ANNOTATION,classes=MyComponent.class)})</code></li></ul></li></ol></li></ul><h4 id="4-3-EnableAutoConfiguration（SpringBoot自动配置）"><a href="#4-3-EnableAutoConfiguration（SpringBoot自动配置）" class="headerlink" title="4.3 @EnableAutoConfiguration（SpringBoot自动配置）"></a>4.3 @EnableAutoConfiguration（SpringBoot自动配置）</h4><p>自动配置机制是SpringBoot框架特有功能，能在启动后自动创建一些常用对象，例如DataSource、JdbcTemplate等。</p><ul><li>自动配置原理：<ol><li>在xxx-autoconfigure.jar包中META-INF目录下有一个spring.factories文件，其中定义了大量的XxxAutoConfiguration配置组件。当开启@EnableAutoConfiguration标记时，标记内部会触发AutoConfigurationImportSelector组件调用SpringFactoriesLoader加载spring.factories文件。</li><li>自动配置组件就是采用@Configuration+@Bean+@Primary标记事先定义好的配置组件，通过Boot启动自动去spring.factories文件加载，然后在Spring容器中创建出约定对象。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataSourceAutoConfiguration<span class="comment">//创建dataSource对象</span></span><br><span class="line">JdbcTemplateAutoConfiguration<span class="comment">//创建jdbcTemplate</span></span><br><span class="line">DispatcherServletAutoConfiguration<span class="comment">//创建DispatcherServlet对象</span></span><br><span class="line">RedisAutoConfiguration<span class="comment">//创建RedisTemplate对象</span></span><br></pre></td></tr></table></figure><ul><li>通过自动配置机制创建DataSource对象<ol><li>引入spring-boot-starter-jdbc（hikari）、驱动包</li><li>在application.properties文件追加db参数</li><li>在启动类使用@EnableAutoConfiguration标记<ul><li>DataSourceAutoConfiguration默认会创建Hikari、tomcat、dbcp2连接池对象，优先级hikari最高，依次tomcat、dbcp2.</li><li>如果通过spring.datasource.type属性指定其他类型连接池组件，SpringBoot可以按指定类型创建连接池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h4 id="4-4-MAVEN如何排除某个jar包（扩展）"><a href="#4-4-MAVEN如何排除某个jar包（扩展）" class="headerlink" title="4.4 MAVEN如何排除某个jar包（扩展）"></a>4.4 MAVEN如何排除某个jar包（扩展）</h4><p>在引入spring-boot-starter-jdbc启动器时，由于jar包依赖会自动引入HikariCP，可以通过&lt; exclusion&gt;标记排除依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-项目管理工具Maven的基本使用&quot;&gt;&lt;a href=&quot;#1-项目管理工具Maven的基本使用&quot; class=&quot;headerlink&quot; title=&quot;1. 项目管理工具Maven的基本使用&quot;&gt;&lt;/a&gt;1. 项目管理工具Maven的基本使用&lt;/h3&gt;&lt;p&gt;Mave
      
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>二十、SSM框架整合(Spring+SpringMVC+MyBatis)</title>
    <link href="http://chaooo.github.io/2019/08/27/20-SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html"/>
    <id>http://chaooo.github.io/2019/08/27/20-SSM框架整合.html</id>
    <published>2019-08-27T14:52:55.000Z</published>
    <updated>2019-08-27T14:56:39.909Z</updated>
    
    <content type="html"><![CDATA[<p>SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。<a id="more"></a></p><ul><li>使用spring MVC负责请求的转发和视图管理</li><li>spring实现业务对象管理</li><li>mybatis作为数据对象的持久化引擎</li></ul><h3 id="1-搭建SSM架构步骤："><a href="#1-搭建SSM架构步骤：" class="headerlink" title="1.搭建SSM架构步骤："></a>1.搭建SSM架构步骤：</h3><ol><li>设计数据库</li><li>先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。</li><li>编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li><li>编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。</li><li>配置spring和mybatis框架的整合(applicationContext.xml)</li><li>编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li><li>配置SpringMVC(web.xml)</li><li>编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li><li>编写JSP页面调用，请求哪些参数，需要获取什么数据。</li></ol><blockquote><p>DataBase –&gt; Entity –&gt; Mapper.xml –&gt; Mapper.Java(DAO) –&gt; Service.java –&gt; Controller.java –&gt; Jsp</p></blockquote><h3 id="2-搭建SSM架构实例（管理员登录）"><a href="#2-搭建SSM架构实例（管理员登录）" class="headerlink" title="2.搭建SSM架构实例（管理员登录）"></a>2.搭建SSM架构实例（管理员登录）</h3><h4 id="1-设计数据库-以MySql为例"><a href="#1-设计数据库-以MySql为例" class="headerlink" title="1. 设计数据库(以MySql为例)"></a>1. 设计数据库(以MySql为例)</h4><p>建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> exam_sys;</span><br><span class="line"><span class="comment">/** 管理员表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">admin</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'管理员ID'</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'管理员账号'</span>,</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">COMMENT</span> <span class="string">'管理员密码'</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_id_pk PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_name_uk <span class="keyword">UNIQUE</span>(<span class="keyword">NAME</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/** 插入数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span> (<span class="keyword">name</span>, <span class="keyword">password</span>) <span class="keyword">VALUES</span>(<span class="string">'admin'</span>, <span class="string">'123456'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h4 id="2-先写实体类entity，定义对象的属性"><a href="#2-先写实体类entity，定义对象的属性" class="headerlink" title="2. 先写实体类entity，定义对象的属性"></a>2. 先写实体类entity，定义对象的属性</h4><p>参照数据库中表的字段来设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.entity;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    private <span class="built_in">String</span> password;</span><br><span class="line">    <span class="comment">/** 添加 getter/setter方法</span></span><br><span class="line"><span class="comment">     *  添加 无参，有参构造</span></span><br><span class="line"><span class="comment">     *  重写toString()以便于测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-编写AdminMapper-xml（Mybatis），定义功能"><a href="#3-编写AdminMapper-xml（Mybatis），定义功能" class="headerlink" title="3. 编写AdminMapper.xml（Mybatis），定义功能"></a>3. 编写AdminMapper.xml（Mybatis），定义功能</h4><p>对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace指定和哪个Mapper映射器接口对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.exam.mapper.AdminDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByNameAndPassword"</span> <span class="attr">resultType</span>=<span class="string">"com.exam.entity.Admin"</span>&gt;</span></span><br><span class="line">        select * from admin where name=#&#123;name, jdbcType=VARCHAR&#125; and password=#&#123;password, jdbcType=VARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。"><a href="#4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。" class="headerlink" title="4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。"></a>4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。</h4><p>导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> com.exam.entity.Admin;</span><br><span class="line"></span><br><span class="line">public interface AdminDao &#123;</span><br><span class="line">    public Admin findByNameAndPassword(@Param(<span class="string">"name"</span>) <span class="built_in">String</span> name, @Param(<span class="string">"password"</span>) <span class="built_in">String</span> password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-配置spring和mybatis框架的整合"><a href="#5-配置spring和mybatis框架的整合" class="headerlink" title="5. 配置spring和mybatis框架的整合"></a>5. 配置spring和mybatis框架的整合</h4><p>导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/exam_sys"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory</span></span><br><span class="line"><span class="comment">        属性dataSource：注入连接池对象</span></span><br><span class="line"><span class="comment">        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置</span></span><br><span class="line"><span class="comment">        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/exam/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="typeAliasesPackage" value="com.exam.entity"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.exam.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="annotationClass" value="com.annotation.MyAnnotation"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启服务层组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.exam.service"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-编写Service-java，为控制层提供服务"><a href="#6-编写Service-java，为控制层提供服务" class="headerlink" title="6. 编写Service.java，为控制层提供服务"></a>6. 编写Service.java，为控制层提供服务</h4><p>接受控制层的参数，完成相应的功能，并返回给控制层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> com.exam.mapper.AdminDao;</span><br><span class="line"></span><br><span class="line">@Service(<span class="string">"adminService"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdminService</span> </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminDao dao;</span><br><span class="line">    </span><br><span class="line">    public boolean Login(<span class="built_in">String</span> name, <span class="built_in">String</span> password) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dao.findByNameAndPassword(name, password)!=<span class="literal">null</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-配置SpringMVC"><a href="#7-配置SpringMVC" class="headerlink" title="7. 配置SpringMVC"></a>7. 配置SpringMVC</h4><p>导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet分发请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler--&gt;</span></span><br></pre></td></tr></table></figure><p>在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启控制器组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.exam.controller"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启标注形式mvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-编写Controller-java，连接页面请求和服务层"><a href="#8-编写Controller-java，连接页面请求和服务层" class="headerlink" title="8. 编写Controller.java，连接页面请求和服务层"></a>8. 编写Controller.java，连接页面请求和服务层</h4><p>获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> com.exam.entity.Admin;</span><br><span class="line"><span class="keyword">import</span> com.exam.service.AdminService;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/admin"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdminController</span> </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminService <span class="keyword">as</span>;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(<span class="string">"/tologin"</span>)</span><br><span class="line">    public <span class="built_in">String</span> toLogin() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"admin/login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(value=<span class="string">"/login"</span>,method=RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public boolean addUser(Admin admin, HttpServletRequest request) &#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+admin);</span><br><span class="line">        System.out.println(admin.getName()+<span class="string">"---"</span>+admin.getPassword());</span><br><span class="line">        boolean bl = <span class="keyword">as</span>.Login(admin.getName(), admin.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(bl) &#123;</span><br><span class="line">            <span class="comment">//登录成功的逻辑</span></span><br><span class="line">            request.getSession().setAttribute(<span class="string">"admin"</span>, admin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//登录失败的逻辑</span></span><br><span class="line">        request.setAttribute(<span class="string">"msg"</span>, <span class="string">"登录失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-编写JSP页面调用"><a href="#9-编写JSP页面调用" class="headerlink" title="9. 编写JSP页面调用"></a>9. 编写JSP页面调用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    管理员: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aName"</span>  <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aPassword"</span>  <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"loginBtn"</span>  <span class="attr">type</span>=<span class="string">"button"</span>  <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="string">"#loginBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"admin/login"</span>,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"post"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: $(<span class="string">"#aName"</span>).val(),</span></span><br><span class="line"><span class="javascript">            password: $(<span class="string">"#aPassword"</span>).val()</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十九、Java持久层框架Mybatis</title>
    <link href="http://chaooo.github.io/2019/08/27/19-Java%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6Mybatis.html"/>
    <id>http://chaooo.github.io/2019/08/27/19-Java持久层框架Mybatis.html</id>
    <published>2019-08-27T14:51:34.000Z</published>
    <updated>2019-08-27T14:55:08.273Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。</p><a id="more"></a><p>MyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。</p><ol><li><a href="#id1">Mybatis框架的构成</a></li><li><a href="#id2">使用Mybatis访问数据库</a></li><li><a href="#id3">Mybatis的CRUD操作</a></li><li><a href="#id4">Mapper映射器</a></li><li><a href="#id5">向mapper传多个参数</a></li><li><a href="#id6">结果集列名和属性名不一致的解决方法</a></li><li><a href="#id7">类型的别名和日志输出</a></li><li><a href="#id8">JdbcType</a></li></ol><p><span id="id1"><span> </span></span></p><h3 id="1-Mybatis框架的构成"><a href="#1-Mybatis框架的构成" class="headerlink" title="1. Mybatis框架的构成"></a>1. Mybatis框架的构成</h3><ul><li>实体类 ： 封装记录信息（JavaBean）</li><li>SQL定义文件 ：定义sql语句（编写SQL语句的XML）</li><li>主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML</li><li>框架API ：用于实现数据库增删改查操作（主要通过SqlSession）</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-使用Mybatis访问数据库"><a href="#2-使用Mybatis访问数据库" class="headerlink" title="2. 使用Mybatis访问数据库"></a>2. 使用Mybatis访问数据库</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p><ol><li><p>准备数据库及创建项目（需要mybatis的jar包和数据库驱动包）</p></li><li><p>根据表建立对应的实体类：<code>Emp(id,name,salary)</code></p></li><li><p>在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"environment"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"environment"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/mapper/EmpMapper.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在【src】包路径下创建配置文件（com/mapper/EmpMapper.xml）,然后根据需求定义sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mapper.EmpMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">         select * from emp32 where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">         select * from emp32 where name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li>parameterType：要求输入参数的类型</li><li>resultType：输出的类型</li></ul></blockquote><ol start="5"><li><p>封装工具类获取SQLSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory ssf;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 先构建SQLSession工厂构建器</span></span><br><span class="line">        SqlSessionFactoryBuilder ssfb = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        <span class="comment">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class="line">        InputStream inputStream = SqlSessionUtil.class.getClassLoader().getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        ssf = ssfb.build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 获取SQLSession</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class="line">        <span class="keyword">return</span> ssf.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SqlSession ss =SqlSessionUtil.getSqlSession();</span><br><span class="line">        Emp emp = ss.selectOne(<span class="string">"findById"</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>基本原理</p><ul><li>应用程序找 MyBatis 要数据</li><li>MyBatis 从数据库中找来数据</li><li>通过 mybatis-config.xml 定位哪个数据库</li><li>通过 EmpMapper.xml 执行对应的 sql 语句</li><li>基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中</li><li>返回一个 Emp 对象</li></ul></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-Mybatis的CRUD操作"><a href="#3-Mybatis的CRUD操作" class="headerlink" title="3. Mybatis的CRUD操作"></a>3. Mybatis的CRUD操作</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p><ol><li>第一步：配置EmpMapper.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertEmp"</span> <span class="attr">parameterType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    insert into emp32(name, salary) values(#&#123;name&#125;, #&#123;salary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    delete from emp32 where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    update emp32 set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">     select * from emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>parameterType：要求输入参数的类型</li><li>resultType：输出的类型</li></ul></blockquote><ol start="2"><li>第二步：SQLSession实现增删改查</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先构建SQLSession工厂构建器</span></span><br><span class="line">SqlSessionFactoryBuilder ssfb = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line"><span class="comment">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class="line">InputStream inputStream = EmpTest.class.getClassLoader().getResourceAsStream(<span class="string">"sqlmap-config.xml"</span>);</span><br><span class="line">SqlSessionFactory ssf = ssfb.build(inputStream);</span><br><span class="line"><span class="comment">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class="line">SqlSession ss = ssf.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">Emp emp = <span class="keyword">new</span> Emp(<span class="number">0</span>,<span class="string">"ef2"</span>,<span class="number">50000</span>);</span><br><span class="line"><span class="keyword">int</span> addRows = ss.insert(<span class="string">"insertEmp"</span>, emp);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">int</span> delRows = ss.delete(<span class="string">"deleteEmpById"</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">Emp emp2 = <span class="keyword">new</span> Emp(<span class="number">1</span>,<span class="string">"hello"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> updateRows = ss.update(<span class="string">"updateEmpById"</span>, emp2);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">Emp emp3 = ss.selectOne(<span class="string">"findById"</span>, <span class="number">6</span>);</span><br><span class="line">List&lt;Emp&gt; empList = ss.selectList(<span class="string">"findAll"</span>);</span><br><span class="line"></span><br><span class="line">ss.commit();</span><br></pre></td></tr></table></figure><blockquote><p>SqlSession对象的操作方法如下：</p><ul><li>insert(..) 插入操作</li><li>update(..) 更新操作</li><li>delete(..) 删除操作</li><li>selectOne(..) 单行查询操作</li><li>selectList(..) 多行查询操作</li><li>通过 session.commit() 来提交事务，也可以简单理解为更新到数据库</li></ul></blockquote><p><span id="id4"><span></span></span></p><h3 id="4-Mapper映射器"><a href="#4-Mapper映射器" class="headerlink" title="4. Mapper映射器"></a>4. Mapper映射器</h3><p>使用规则：</p><ol><li>接口的方法名和SQL定义文件中的id保持一致</li><li>接口方法的返回值类型 要和resultType 保持一致<ul><li>单行：<code>resultType</code></li><li>多行：<code>List&lt;resultType&gt;</code></li><li>增删改返回值，推荐int，也可以是void</li></ul></li><li>接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意</li><li>SQL定义文件中的namespace必须包名.接口名</li></ol><p><span id="id5"><span></span></span></p><h3 id="5-向mapper传多个参数"><a href="#5-向mapper传多个参数" class="headerlink" title="5. 向mapper传多个参数"></a>5. 向mapper传多个参数</h3><h4 id="5-1-第一种方案：-0-，-1-param1-和-param2"><a href="#5-1-第一种方案：-0-，-1-param1-和-param2" class="headerlink" title="5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}"></a>5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}</h4><p>DAO层的函数方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;0&#125; and name = #&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。<br>也可以用#{param1} 和 #{param2}实现同意效果。</p><h4 id="5-2-第二种方案-param"><a href="#5-2-第二种方案-param" class="headerlink" title="5.2 第二种方案@param"></a>5.2 第二种方案@param</h4><p>Dao层的函数方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(@param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id, @<span class="title">param</span><span class="params">(<span class="string">"name"</span>)</span>String name)</span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-第三种方案：采用对象或Map传多参数"><a href="#5-3-第三种方案：采用对象或Map传多参数" class="headerlink" title="5.3 第三种方案：采用对象或Map传多参数"></a>5.3 第三种方案：采用对象或Map传多参数</h4><p>Dao层的函数方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(Emp emp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName2</span><span class="params">(Map&lt;String, Object&gt; params)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">parameterType</span>=<span class="string">"com.bean.Emp"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName2"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id6"><span></span></span></p><h3 id="6-结果集列名和属性名不一致的解决方法"><a href="#6-结果集列名和属性名不一致的解决方法" class="headerlink" title="6. 结果集列名和属性名不一致的解决方法"></a>6. 结果集列名和属性名不一致的解决方法</h3><p>在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。<br>解决方法：</p><ol><li>使用别名，select语句使用与属性一致的别名</li><li>使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系</span></span><br><span class="line"><span class="comment">    type:resultMap最终所映射的Java对象类型，可以使用别名</span></span><br><span class="line"><span class="comment">    id:对resultMap的唯一标识 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.bean.Emp"</span> <span class="attr">id</span>=<span class="string">"empMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id表示查询结果集中唯一标识 </span></span><br><span class="line"><span class="comment">        column:查询出的列名</span></span><br><span class="line"><span class="comment">        property:type所指定的类中的属性名 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"e_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对普通列的映射定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>  <span class="attr">column</span>=<span class="string">"salary"</span>  <span class="attr">property</span>=<span class="string">"sal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"empMap"</span>&gt;</span></span><br><span class="line">         select * from  emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id7"><span></span></span></p><h3 id="7-类型的别名和日志输出"><a href="#7-类型的别名和日志输出" class="headerlink" title="7. 类型的别名和日志输出"></a>7. 类型的别名和日志输出</h3><p>在mybatis-config.xml中自定义类型的别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"emp"</span> <span class="attr">type</span>=<span class="string">"com.bean.Emp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在EmpMapper.xml中使用别名 resultType=”emp”</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"emp"</span>&gt;</span></span><br><span class="line">    select id,name,salary sal from emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置MyBatis的日志输出到控制台</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置是否允许缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置日志输出的目标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id8"><span></span></span></p><h3 id="8-JdbcType"><a href="#8-JdbcType" class="headerlink" title="8. JdbcType"></a>8. JdbcType</h3><p>在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。</p><ul><li>所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。</li><li>一般情况下，我们没有必要按个字段去识别/判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。</li><li>MyBatis包含的JdbcType类型，主要有下面这些：<ul><li>BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where name = #&#123;name, jdbcType=VARCHAR&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id9"><span></span></span></p><h3 id="9-Mabatis中-和-的区别"><a href="#9-Mabatis中-和-的区别" class="headerlink" title="9. Mabatis中#{}和${}的区别"></a>9. Mabatis中#{}和${}的区别</h3><ol><li><code>${}</code>是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂）<ul><li>支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号</li></ul></li><li><code>#{}</code>是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入）<ul><li>不支持表名、排序方式等的占位，默认会将其当成字符串</li></ul></li></ol><h3 id="10-分页"><a href="#10-分页" class="headerlink" title="10. 分页"></a>10. 分页</h3><ol><li>在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置分页拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>查询前使用分页API</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(2, 2);</span><br><span class="line">List<span class="tag">&lt;<span class="name">Emp</span>&gt;</span> emps = dao.orderBySalary();</span><br><span class="line">for(Emp emp: emps) &#123;</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Spring-MyBatis整合"><a href="#11-Spring-MyBatis整合" class="headerlink" title="11. Spring+MyBatis整合"></a>11. Spring+MyBatis整合</h3><p>Spring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API:</p><ol><li>SqlSessionFactoryBean<ul><li>创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源</li><li>依赖于dataSource 和加载SQL定义文件</li></ul></li><li>MapperFactoryBean<ul><li>根据指定的某一个Mapper接口生成Bean实例</li><li>依赖于SqlSessionFactory 和 MApper接口</li></ul></li><li>MapperScannerConfigurer<ul><li>根据指定包批量扫描Mapper接口并生成实例</li></ul></li><li>SqlSessionTemplate<ul><li>类似于JdbcTemplate，便于程序员自己编写Mapper实现类</li></ul></li></ol><h3 id="12-Spring-MyBatis完成sql操作"><a href="#12-Spring-MyBatis完成sql操作" class="headerlink" title="12. Spring+MyBatis完成sql操作"></a>12. Spring+MyBatis完成sql操作</h3><p><strong>第一步</strong>：使用Mybatis（同上）</p><ul><li>导jar包(mybatis包/数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口</li></ul><p><strong>第二步</strong>：配置SqlSessionFactoryBean</p><ul><li>导入jar包（mabatis-spring/ioc/aop/dao/连接池）</li><li>配置SqlSessionFactoryBean注入dataSource和指定sql定义文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：</p><ol><li>方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory<ul><li>最终产生Mapper接口的 实现类，注意这是实现类</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置SqlSessionFactoryBean 产生Mapper接口的 实现类  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"empDao"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"com.dao.EmpDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"empDao2"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"com.dao.EmpDao2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>方式二： MapperScannerConfigurer<ul><li>MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"annotationClass"</span> <span class="attr">value</span>=<span class="string">"com.annotation.MyAnnotation"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13-使用SqlSessionTemplate模板来完成DAO接口的实现类"><a href="#13-使用SqlSessionTemplate模板来完成DAO接口的实现类" class="headerlink" title="13. 使用SqlSessionTemplate模板来完成DAO接口的实现类"></a>13. 使用SqlSessionTemplate模板来完成DAO接口的实现类</h3><ol><li>使用Mybatis（同上）</li><li>配置SqlSessionFactoryBean（同上）</li><li>编写DAO接口的实现类<ul><li>开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory</li><li>使用SqlSessionTemplate对应API完成增删改查</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建SqlSessionTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionTemplate.selectOne(<span class="string">"findById"</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十八、Spring MVC框架</title>
    <link href="http://chaooo.github.io/2019/08/27/18-SpringMVC%E6%A1%86%E6%9E%B6.html"/>
    <id>http://chaooo.github.io/2019/08/27/18-SpringMVC框架.html</id>
    <published>2019-08-27T14:50:22.000Z</published>
    <updated>2019-08-27T14:55:17.931Z</updated>
    
    <content type="html"><![CDATA[<p>Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</p><a id="more"></a><ol><li><a href="#id1">Spring MVC基本概念</a></li><li><a href="#id2">Spring MVC的编写步骤</a></li><li><a href="#id3">标注(注解)形式的MVC</a></li><li><a href="#id4">mvc控制器接收页面参数</a></li><li><a href="#id5">mvc控制器把数据传递给页面</a></li><li><a href="#id6">Spring MVC实现重定向</a></li><li><a href="#id7">Spring MVC 中文参数的乱码问题</a></li><li><a href="#id8">Spring MVC 拦截器</a></li><li><a href="#id9">Spring MVC 拦截器的使用步骤</a></li><li><a href="#id10">Spring MVC异常处理</a></li><li><a href="#id11">Spring MVC文件上传</a></li><li><a href="#id12">文件上传与异常处理的结合</a></li><li><a href="#id13">Spring MVC响应JSON</a></li><li><a href="#id14">REST</a></li><li><a href="#id15">REST实例</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-Spring-MVC基本概念"><a href="#1-Spring-MVC基本概念" class="headerlink" title="1. Spring MVC基本概念"></a>1. Spring MVC基本概念</h3><h4 id="1-1-Spring-MVC-五大核心组件"><a href="#1-1-Spring-MVC-五大核心组件" class="headerlink" title="1.1 Spring MVC 五大核心组件"></a>1.1 Spring MVC 五大核心组件</h4><p>Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</p><ol><li>DispatcherServlet：控制器，请求入口</li><li>HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系</li><li>Controller：控制器，处理请求</li><li>ModelAndView：封装了 数据信息和视图信息</li><li>ViewResolver：视图处理器</li></ol><p>他的两个核心是两个核心：</p><ul><li>处理器映射：选择使用哪个控制器来处理请求 </li><li>视图解析器：选择结果应该如何渲染<blockquote><p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。</p></blockquote></li></ul><h4 id="1-2-SpringMVC运行原理"><a href="#1-2-SpringMVC运行原理" class="headerlink" title="1.2 SpringMVC运行原理"></a>1.2 SpringMVC运行原理</h4><ol><li>Http请求：客户端请求提交到DispatcherServlet。 </li><li>寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 </li><li>调用处理器：DispatcherServlet将请求提交到Controller。 </li><li>调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 </li><li>处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 </li><li>Http响应：视图负责将结果显示到客户端。</li></ol><h4 id="1-3-SpringMVC接口解释"><a href="#1-3-SpringMVC接口解释" class="headerlink" title="1.3 SpringMVC接口解释"></a>1.3 SpringMVC接口解释</h4><ol><li><strong>DispatcherServlet接口</strong>：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： <ol><li>截获符合特定格式的URL请求。 </li><li>初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 </li><li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li></ol></li><li><strong>HandlerMapping接口</strong>：能够完成客户请求到Controller映射。 </li><li><strong>Controller接口</strong>： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 <ul><li>Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 </li><li>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 </li></ul></li><li><strong>ViewResolver接口</strong>：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</li></ol><h4 id="1-4-SpringMVC配置"><a href="#1-4-SpringMVC配置" class="headerlink" title="1.4 SpringMVC配置"></a>1.4 SpringMVC配置</h4><ol><li><p>在web.xml文件中进行配置applicationContext.xml路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置applicationContext.xml，开启注解功能、配置试图解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/toHello.do"</span>&gt;</span>helloController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloController"</span> <span class="attr">class</span>=<span class="string">"com.controller.MyHelleController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-Spring-MVC的编写步骤"><a href="#2-Spring-MVC的编写步骤" class="headerlink" title="2. Spring MVC的编写步骤"></a>2. Spring MVC的编写步骤</h3><ol><li>建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</li><li>在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。</li><li>在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。</li><li>编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象</li><li>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</li></ol><p><span id="id3"><span></span></span></p><h3 id="3-标注-注解-形式的MVC"><a href="#3-标注-注解-形式的MVC" class="headerlink" title="3. 标注(注解)形式的MVC"></a>3. 标注(注解)形式的MVC</h3><ol><li><p>建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</p></li><li><p>在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。</p></li><li><p>开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"包名"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了）</p><ul><li>使用<code>@Controller</code> 可以把普通Java类转换成控制器，同时在容器中创建对象</li><li>使用<code>@RequestMapping(&quot;/路径&quot;)</code> 设置方法上</li></ul></li><li><p>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</p></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-mvc控制器接收页面参数"><a href="#4-mvc控制器接收页面参数" class="headerlink" title="4. mvc控制器接收页面参数"></a>4. mvc控制器接收页面参数</h3><ol><li><p>使用HttpServletRequest类型的参数来接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String acc_no = request.getParameter(<span class="string">"acc_no"</span>);</span><br><span class="line">    String acc_pwd = request.getParameter(<span class="string">"acc_password"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接定义和页面请求参数同名的控制器参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login2.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login2</span><span class="params">(String acc_no,String acc_password, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当页面参数和控制器参数名字不一致，@RequestParam(“acc_no”) 让请求参数和控制器参数对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login3.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login3</span><span class="params">(@RequestParam(<span class="string">"acc_no"</span>)</span> String a,String acc_password, ModelAndView mav) </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制器中 直接定义对象类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login4.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login4</span><span class="params">(Account acc, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-mvc控制器把数据传递给页面"><a href="#5-mvc控制器把数据传递给页面" class="headerlink" title="5. mvc控制器把数据传递给页面"></a>5. mvc控制器把数据传递给页面</h3><p>使用EL表达式在jsp页面接收数据<code>&lt;h1&gt;欢迎 ${acc_no} &lt;/h1&gt;</code></p><ol><li><p>使用域对象 进行传输 (request session ServletContext )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login6.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login6</span><span class="params">(String acc_no, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    req.setAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ModelAndView进行数据传输 </p><ul><li><code>mav.getModel().put(&quot;acc_no&quot;, acc_no);</code></li><li><code>mav.getModelMap().put(key, value);</code></li><li><code>mav.getModelMap().addAttribute(&quot;acc_no&quot;, acc_no);</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login7.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login7</span><span class="params">(String acc_no, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="comment">//mav.getModel().put("acc_no", acc_no);</span></span><br><span class="line">    <span class="comment">//mav.getModelMap().put(key, value)</span></span><br><span class="line">    mav.getModelMap().addAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用Model进行数据传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login8.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login8</span><span class="params">(String acc_no, Model m)</span> </span>&#123;</span><br><span class="line">    m.addAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ModelMap进行数据传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login9.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login9</span><span class="params">(String acc_no, ModelMap m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//m.addAttribute("acc_no", acc_no);</span></span><br><span class="line">    m.put(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(“新名”)修改）</p><ul><li>默认名：<code>&lt;h1&gt;欢迎 ${ account.acc_no } &lt;/h1&gt;</code></li><li>@ModelAttribute(“acc”)：<code>&lt;h1&gt;欢迎 ${ acc.acc_no } &lt;/h1&gt;</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login10.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login10</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id6"><span></span></span></p><h3 id="6-Spring-MVC实现重定向"><a href="#6-Spring-MVC实现重定向" class="headerlink" title="6. Spring MVC实现重定向"></a>6. Spring MVC实现重定向</h3><ol><li>控制器方法返回String <ul><li>redirect:请求路径</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login11.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login11</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    <span class="comment">//return "forward:toMain.do";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:toMain.do"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/toMain.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 干其它的事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>控制器方法返回ModelAndView <ul><li>使用RedirectView  完成</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login12.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login12</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    RedirectView rv = <span class="keyword">new</span> RedirectView(<span class="string">"toMain.do"</span>);</span><br><span class="line">    mav.setView(rv);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id7"><span></span></span></p><h3 id="7-Spring-MVC-中文参数的乱码问题"><a href="#7-Spring-MVC-中文参数的乱码问题" class="headerlink" title="7. Spring MVC 中文参数的乱码问题"></a>7. Spring MVC 中文参数的乱码问题</h3><p>tomcat8中 get 没有乱码问题，post 请求有乱码问题 </p><ol><li><p>参数为页面(HttpServletRequest request)与(HttpServletResponse response)时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>传入参数为<code>@RequestParam</code>时，可以通过字符串重新编码来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> String(string.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>方法名前出现<code>@RequestMapping(value=&quot;XXX&quot;)</code>时可以在value属性后再加一个属性<code>produces=&quot;text/html;charset=UTF-8&quot;</code>来解决</p></li><li><p>在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">utf</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">encodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id8"><span></span></span></p><h3 id="8-Spring-MVC-拦截器"><a href="#8-Spring-MVC-拦截器" class="headerlink" title="8. Spring MVC 拦截器"></a>8. Spring MVC 拦截器</h3><ol><li>拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置）</li><li>HandlerMapping接口<ul><li>preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。</li><li>postHandle：处理器执行后、视图处理前调用。</li><li>afterCompletion：整个请求处理完毕后调用。</li></ul></li></ol><p><span id="id9"><span></span></span></p><h3 id="9-Spring-MVC-拦截器的使用步骤"><a href="#9-Spring-MVC-拦截器的使用步骤" class="headerlink" title="9. Spring MVC 拦截器的使用步骤"></a>9. Spring MVC 拦截器的使用步骤</h3><ol><li>搭建一个基于标注的mvc</li><li>编写一个类实现HandlerInterceptor接口</li><li>在Spring配置文件中配置拦截器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/login.do"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xdl.interceptor.SomeInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id10"><span></span></span></p><h3 id="10-Spring-MVC异常处理"><a href="#10-Spring-MVC异常处理" class="headerlink" title="10. Spring MVC异常处理"></a>10. Spring MVC异常处理</h3><ol><li><p>配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleExceptionResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"exceptionMappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.RuntimeException"</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.Exception"</span>&gt;</span>error2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e)</span> </span>&#123;</span><br><span class="line">ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">mav.setViewName(<span class="string">"error"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">mav.setViewName(<span class="string">"error2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Controller</span></span><br><span class="line"><span class="comment">//public class MyController &#123;</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error3"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><span id="id11"><span></span></span></p><h3 id="11-Spring-MVC文件上传"><a href="#11-Spring-MVC文件上传" class="headerlink" title="11. Spring MVC文件上传"></a>11. Spring MVC文件上传</h3><ol><li><p>jsp页面（method=”POST” enctype=”multipart/form-data type=”file”）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload.do"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"head_img"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id12"><span></span></span></p><h3 id="12-文件上传与异常处理的结合"><a href="#12-文件上传与异常处理的结合" class="headerlink" title="12. 文件上传与异常处理的结合"></a>12. 文件上传与异常处理的结合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/toFile.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">tofile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"file"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(String acc_no, MultipartFile head_img)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"acc_no:"</span> + acc_no );</span><br><span class="line"><span class="keyword">if</span>(head_img.getSize()&gt;<span class="number">1024</span>*<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件过大！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把文件写入磁盘</span></span><br><span class="line">String uniqueStr = UUID.randomUUID().toString();</span><br><span class="line">String oriFilename = head_img.getOriginalFilename();</span><br><span class="line">String suffix = oriFilename.substring(oriFilename.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"F:/Eclipse/datas/"</span>+uniqueStr+suffix);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">head_img.transferTo(file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(oriFilename);</span><br><span class="line">System.out.println(file);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"file"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 局部异常 */</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processError</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"error4"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id13"><span></span></span></p><h3 id="13-Spring-MVC响应JSON"><a href="#13-Spring-MVC响应JSON" class="headerlink" title="13. Spring MVC响应JSON"></a>13. Spring MVC响应JSON</h3><ol><li>搭建基于标注的mvc</li><li>在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON</li><li>给方法加@RequestMapping(“/请求路径”)、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包</li></ol><p><span id="id14"><span></span></span></p><h3 id="14-REST"><a href="#14-REST" class="headerlink" title="14. REST"></a>14. REST</h3><p>REST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。</p><ol><li>REST两个核心规范<ul><li>url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:<a href="http://test/source/1234）" target="_blank" rel="noopener">http://test/source/1234）</a></li><li>对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新</li></ul></li><li>restful<ul><li>符合REST设计规范和风格的应用程序或设计 就是RESTful</li></ul></li><li>Spring MVC对REST的支持<ul><li>@RequestMapping支持URI的模板，以及http请求方式设定的支持<ul><li><code>@RequestMapping(value=&quot;/account/{id}&quot;,method=RequestMethod.POST)</code></li></ul></li><li>对URI上路径变量的处理的支持，@PathVariable<ul><li><code>@PathVariable(&quot;id&quot;) int id</code></li></ul></li><li>rest请求路径是没有后缀的，需要把url-parttern修改成<code>/</code></li><li><code>&lt;servlet-mapping&gt;&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></li><li>需要对静态资源进行放行<code>&lt;mvc:default-servlet-handler/&gt;</code></li></ul></li></ol><p><span id="id15"><span></span></span></p><h3 id="15-REST实例"><a href="#15-REST实例" class="headerlink" title="15. REST实例"></a>15. REST实例</h3><ol><li>配置web.xml与applicationContext.xml(部分配置)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改rest请求路径 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- web.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写控制类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/toLogin.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id查询账户 GET */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        Random rm = <span class="keyword">new</span> Random();</span><br><span class="line">        Account acc = <span class="keyword">new</span> Account(id, <span class="string">"test"</span>+rm.nextInt(<span class="number">100</span>),<span class="string">"123"</span>, rm.nextInt(<span class="number">999</span>)+<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 新增账户 POST */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAccount</span><span class="params">(Account acc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+acc);</span><br><span class="line">        <span class="keyword">if</span>(acc.getId()&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id删除帐户对象 DELETE */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.DELETE)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteAccountById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delete:"</span>+id);</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id更新帐户 PUT */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.PUT)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putAccount</span><span class="params">(@RequestBody Account acc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//@RequestBody将接收的ajax请求的json字符串写入Account对象中</span></span><br><span class="line">        System.out.println(<span class="string">"update:"</span>+acc);</span><br><span class="line">        <span class="keyword">if</span>(acc.getId()&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写jsp页面</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountId"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountNo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountPassword"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>金额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountMoney"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"findBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"addBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"updateBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"delBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="string">"#findBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    findAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#addBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    addAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#updateBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    updateAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#delBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    delAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getDatas</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> accountId = $(<span class="string">"#accountId"</span>).val();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> accountNo = $(<span class="string">"#accountNo"</span>).val();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> accountPassword = $(<span class="string">"#accountPassword"</span>).val();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> accountMoney = $(<span class="string">"#accountMoney"</span>).val();</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line">    id: accountId,</span><br><span class="line">    acc_no: accountNo,</span><br><span class="line">    acc_password: accountPassword,</span><br><span class="line">    acc_money: accountMoney</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">findAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"get"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountNo"</span>).val(res.acc_no);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountPassword"</span>).val(res.acc_password);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountMoney"</span>).val(res.acc_money);</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">addAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"post"</span>,</span></span><br><span class="line">        data: datas,</span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">delAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"delete"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updateAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url:<span class="string">"account/"</span>+ datas.id,</span></span><br><span class="line"><span class="javascript">        type:<span class="string">"put"</span>,</span></span><br><span class="line"><span class="javascript">        data:<span class="built_in">JSON</span>.stringify(datas),</span></span><br><span class="line"><span class="javascript">        contentType:<span class="string">"application/json"</span>,<span class="comment">//以json字符串提交数据</span></span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ul><li>PUT需要以json字符串提交数据<code>contentType:&quot;application/json&quot;</code></li><li>@RequestBody将接收的ajax请求的json字符串写入Account对象中</li><li>JSON.stringify()：将json对象转换为json字符串</li><li>JSON.parse()：将json字符串转换为json对象</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十七、Spring面向切面编程(AOP模块)</title>
    <link href="http://chaooo.github.io/2019/08/27/17-Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP.html"/>
    <id>http://chaooo.github.io/2019/08/27/17-Spring面向切面编程AOP.html</id>
    <published>2019-08-27T14:48:36.000Z</published>
    <updated>2019-08-27T14:55:22.336Z</updated>
    
    <content type="html"><![CDATA[<p>AOP（Aspect Oriented Programming）：面向切面编程，<br>它是面向对象基础上发展来的技术，是面向对象更高层次的应用，<br>它可以在不修改原有代码的情况给组件增强功能。</p><a id="more"></a><ol><li><a href="#id1">AOP涉及到的概念</a></li><li><a href="#id2">编写AOP程序步骤</a></li><li><a href="#id3">切点表达式</a></li><li><a href="#id4">通知的五种类型</a></li><li><a href="#id5">标注形式AOP步骤</a></li><li><a href="#id6">AOP 通知对应的标注</a></li><li><a href="#id7">@Around具体用法</a></li><li><a href="#id8">异常通知</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-AOP涉及到的概念"><a href="#1-AOP涉及到的概念" class="headerlink" title="1. AOP涉及到的概念"></a>1. AOP涉及到的概念</h3><ul><li>Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。</li><li>JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息）</li><li>Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点</li><li>Target：目标，要被切入共通业务逻辑的对象</li><li>Proxy：代理，被增强之后的目标对象就是代理</li><li>Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-编写AOP程序步骤"><a href="#2-编写AOP程序步骤" class="headerlink" title="2. 编写AOP程序步骤"></a>2. 编写AOP程序步骤</h3><ol><li>编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法</li><li>在不修改登录和注册原有代码的情况下，让两个方法调用前输出<code>******</code><ol><li>添加aop的jar包到lib</li><li>编写一个类，定义共同业务逻辑</li><li>配置aplicationContext.xml，创建切面对象</li><li>配置aop:config，切面–&gt;通知–&gt;切点</li></ol></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-切点表达式"><a href="#3-切点表达式" class="headerlink" title="3. 切点表达式"></a>3. 切点表达式</h3><ol><li>Bean限定表达式<ul><li><code>bean(&quot;容器内组件id&quot;)</code>，支持通配符<em>，如：<code>bean(&quot;*Dao&quot;)</code>，`bean(“acc</em>“)`</li></ul></li><li>类型限定表达式<ul><li><code>within(&quot;包名.类型&quot;)</code>，要求表达式最后一部分必须是类型，如：<code>com.dao.impl.类型</code>，<code>com.dao.impl.*</code>，<code>com.dao..*</code></li></ul></li><li>方法限定表达式<ul><li><code>execution(&quot;表达式&quot;)</code>，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:<code>返回值类型 方法名()</code></li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-通知的五种类型"><a href="#4-通知的五种类型" class="headerlink" title="4. 通知的五种类型"></a>4. 通知的五种类型</h3><ol><li><code>&lt;aop:before</code>：前置通知，目标方法执行之前调用</li><li><code>&lt;aop:after-returning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li><li><code>&lt;aop:after-throwing</code>：异常通知，目标方法出异常才调用</li><li><code>&lt;aop:after</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li><li><code>&lt;aop:around</code>：环绕通知，目标方法执行前后都调用</li></ol><p><span id="id5"><span></span></span></p><h3 id="5-标注形式AOP步骤"><a href="#5-标注形式AOP步骤" class="headerlink" title="5. 标注形式AOP步骤"></a>5. 标注形式AOP步骤</h3><ol><li>建项目，添加jar包(ioc,aop)，src下添加配置文件</li><li>编写一个Sevice类，里面有登录和注册两个方法</li><li>开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑</li><li>定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象</li><li>开启标注形式aop：<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true|false&quot; /&gt;</code></li><li>使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： <code>@Aspect，@Before...</code></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-AOP-通知对应的标注"><a href="#6-AOP-通知对应的标注" class="headerlink" title="6. AOP 通知对应的标注"></a>6. AOP 通知对应的标注</h3><ol><li><code>@Before</code>：前置通知，目标方法执行之前调用</li><li><code>@AfterReturning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li><li><code>@AfterThrowing</code>：异常通知，目标方法出异常才调用</li><li><code>@After</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li><li><code>@Around</code>：环绕通知，目标方法执行前后都调用</li></ol><p><span id="id7"><span></span></span></p><h3 id="7-Around具体用法"><a href="#7-Around具体用法" class="headerlink" title="7. @Around具体用法"></a>7. @Around具体用法</h3><p>@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"within(com..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">showAfterDate</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"开始时间："</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">    Object obj = pjp.proceed();</span><br><span class="line">    System.out.println(<span class="string">"结束时间："</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">    System.out.println(<span class="string">"执行时间："</span>date2.getTime() - date.getTime());</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p></blockquote><p><span id="id8"><span></span></span></p><h3 id="8-异常通知"><a href="#8-异常通知" class="headerlink" title="8. 异常通知"></a>8. 异常通知</h3><p>JoinPoint可以获取出异常的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"within(com..*)"</span>, throwing=<span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processException</span><span class="params">(JoinPoint jp, Exception e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"捕获到异常"</span> + jp.getSignature() + <span class="string">":\n【"</span> + e +<span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AOP（Aspect Oriented Programming）：面向切面编程，&lt;br&gt;它是面向对象基础上发展来的技术，是面向对象更高层次的应用，&lt;br&gt;它可以在不修改原有代码的情况给组件增强功能。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十六、Spring事务管理</title>
    <link href="http://chaooo.github.io/2019/08/27/16-Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.html"/>
    <id>http://chaooo.github.io/2019/08/27/16-Spring事务管理.html</id>
    <published>2019-08-27T14:47:30.000Z</published>
    <updated>2019-08-27T14:55:34.127Z</updated>
    
    <content type="html"><![CDATA[<p>事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。</p><a id="more"></a><ol><li><a href="#id1">事务的特性(ACID)</a></li><li><a href="#id2">Spring提供事务管理的3个接口</a></li><li><a href="#id3">TransactionDefinition接口</a></li><li><a href="#id4">TransactionStatus接口</a></li><li><a href="#id5">PlatformTransactionManager接口（事务管理器）</a></li><li><a href="#id6">基于AspectJ的xml方式的声明式事务管理</a></li><li><a href="#id7">基于注解的声明式事务管理</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-事务的特性-ACID"><a href="#1-事务的特性-ACID" class="headerlink" title="1. 事务的特性(ACID)"></a>1. 事务的特性(ACID)</h3><ul><li>事务的特性：<strong>原子性、一致性、隔离性、持久性</strong>。</li><li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。</li><li>隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。</li><li>持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-Spring提供事务管理的3个接口："><a href="#2-Spring提供事务管理的3个接口：" class="headerlink" title="2. Spring提供事务管理的3个接口："></a>2. Spring提供事务管理的3个接口：</h3><ol><li><strong>PlatformTransactionManager</strong>：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。</li><li><strong>TransactionDefinition</strong>：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。</li><li><strong>TransactionStatus</strong>：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。</li></ol><blockquote><p>Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。</p></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-TransactionDefinition接口"><a href="#3-TransactionDefinition接口" class="headerlink" title="3. TransactionDefinition接口"></a>3. TransactionDefinition接口</h3><p>TransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation)</p><ul><li>如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。</li><li>事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。</li></ul><h4 id="3-1-安全问题"><a href="#3-1-安全问题" class="headerlink" title="3.1 安全问题"></a>3.1 安全问题</h4><ol><li>脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。</li><li>不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。</li><li>幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。</li></ol><h4 id="3-2-事务的隔离级别-Isolation-："><a href="#3-2-事务的隔离级别-Isolation-：" class="headerlink" title="3.2 事务的隔离级别(Isolation)："></a>3.2 事务的隔离级别(Isolation)：</h4><ol><li><strong><code>READ_UNCOMMITED</code></strong>(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。</li><li><strong><code>READ_COMMITED</code></strong>(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。</li><li><strong><code>REPEATABLE_READ</code></strong>(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。</li><li><strong><code>SERIALIZABLE</code></strong>(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。</li><li><code>DEFAULT</code>(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别）。</li></ol><h4 id="3-3-事务的传播特性-Propagation-："><a href="#3-3-事务的传播特性-Propagation-：" class="headerlink" title="3.3 事务的传播特性(Propagation)："></a>3.3 事务的传播特性(Propagation)：</h4><ol><li>第一类：运行在同一个事务<ul><li><strong><code>REQUIRED</code></strong>：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li><li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li><li><code>MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常</li></ul></li><li>第二类：运行在不同事务<ul><li><strong><code>REQUIRES_NEW</code></strong>：新建事务，如果当前存在事务，把当前事务挂起</li><li><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li><code>NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常</li></ul></li><li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul><li><strong><code>NESTED</code></strong>：如果当前事务存在，则嵌套事务执行</li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-TransactionStatus接口"><a href="#4-TransactionStatus接口" class="headerlink" title="4. TransactionStatus接口"></a>4. TransactionStatus接口</h3><p>平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。</p><p><span id="id5"><span></span></span></p><h3 id="5-PlatformTransactionManager接口（事务管理器）"><a href="#5-PlatformTransactionManager接口（事务管理器）" class="headerlink" title="5. PlatformTransactionManager接口（事务管理器）"></a>5. PlatformTransactionManager接口（事务管理器）</h3><p>该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。</p><h4 id="5-1-Spring支持两种方式事务管理："><a href="#5-1-Spring支持两种方式事务管理：" class="headerlink" title="5.1 Spring支持两种方式事务管理："></a>5.1 Spring支持两种方式事务管理：</h4><ol><li>编程式事务管理<ul><li>手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用）</li></ul></li><li>声明式事务管理<ul><li>基于TransactionProxyFactoryBean的方式（很少使用）</li><li>基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用）</li><li>基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加<code>@Transactional</code>注解（经常使用）</li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-基于AspectJ的xml方式的声明式事务管理"><a href="#6-基于AspectJ的xml方式的声明式事务管理" class="headerlink" title="6. 基于AspectJ的xml方式的声明式事务管理"></a>6. 基于AspectJ的xml方式的声明式事务管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"jdbc连接池对象id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务的通知（事务的增强） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- propagation:事务传播行为</span></span><br><span class="line"><span class="comment">            isolation:事务的隔离级别</span></span><br><span class="line"><span class="comment">            read-only:只读</span></span><br><span class="line"><span class="comment">            rollback-for:发生哪些异常回滚</span></span><br><span class="line"><span class="comment">            no-rollback-for:发生哪些异常不回滚</span></span><br><span class="line"><span class="comment">            timeout:过期信息    --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"transfer"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">rollback-for</span>=<span class="string">""</span> <span class="attr">timeout</span>=<span class="string">""</span> <span class="attr">no-rollback-for</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut1"</span> <span class="attr">expression</span>=<span class="string">"execution(*cn.muke.spring.demo3.AccountService+.*(.))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id7"><span></span></span></p><h3 id="7-基于注解的声明式事务管理"><a href="#7-基于注解的声明式事务管理" class="headerlink" title="7. 基于注解的声明式事务管理"></a>7. 基于注解的声明式事务管理</h3><ol><li><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.创建一个事务管理器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"事务管理器id"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"jdbc连接池对象id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.开启声明式事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"事务管理器id"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true|false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>transaction-manager</strong>：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource)</li><li><strong>proxy-target-class</strong>：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。</li></ul></li></ol><ol start="2"><li><p>使用，在类上或者方法上标注<code>@Transactional</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(</span><br><span class="line">        rollbackFor=&#123;Exception.class&#125;, </span><br><span class="line">        readOnly=<span class="keyword">false</span>, </span><br><span class="line">        isolation=Isolation.DEFAULT,</span><br><span class="line">        propagation=Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure><ul><li>@Transactional的属性<ul><li><strong>rollbackFor</strong>：设置检查异常也回滚</li><li><strong>noRollbackFor</strong>：指定运行时异常不回滚</li><li><strong>readOnly</strong>： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。</li><li><strong>isolation</strong>：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE)</li><li><strong>propagation</strong>：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER)</li></ul></li><li>Spring中事务管理器默认值针对<strong>运行时异常</strong>回滚，对<strong>检查异常</strong>不回滚。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十五、SpringJDBC详解</title>
    <link href="http://chaooo.github.io/2019/08/27/15-SpringJDBC%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://chaooo.github.io/2019/08/27/15-SpringJDBC详解.html</id>
    <published>2019-08-27T14:46:07.000Z</published>
    <updated>2019-08-27T14:55:39.395Z</updated>
    
    <content type="html"><![CDATA[<p>Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的<strong>声明式</strong>事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。</p><a id="more"></a><ol><li><a href="#id1">数据源配置</a></li><li><a href="#id2">JdbcTemplate的使用</a></li><li><a href="#id3">通过实现RowMapper接口把查询结果映射到Java对象</a></li><li><a href="#id4">JdbcTemplate对象的主要方法</a></li><li><a href="#id5">异常转换</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-数据源配置"><a href="#1-数据源配置" class="headerlink" title="1. 数据源配置"></a>1. 数据源配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">mysqlDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/test"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(mysqlDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用XML配置来实现配置效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义jdbcTemplate对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.jdbc"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id2"><span></span></span></p><h3 id="2-JdbcTemplate的使用"><a href="#2-JdbcTemplate的使用" class="headerlink" title="2. JdbcTemplate的使用"></a>2. JdbcTemplate的使用</h3><p>JdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。<br>JdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。</p><p>基本的查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAO实现类</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(*) from emp32"</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><span id="id3"><span></span></span></p><h3 id="3-通过实现RowMapper接口把查询结果映射到Java对象"><a href="#3-通过实现RowMapper接口把查询结果映射到Java对象" class="headerlink" title="3. 通过实现RowMapper接口把查询结果映射到Java对象"></a>3. 通过实现RowMapper接口把查询结果映射到Java对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Emp</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Emp(</span><br><span class="line">            rs.getInt(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getDouble(<span class="string">"salary"</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAO实现类</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">getEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp32 where id=?"</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> EmpRowMapper(), id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-JdbcTemplate对象的主要方法"><a href="#4-JdbcTemplate对象的主要方法" class="headerlink" title="4. JdbcTemplate对象的主要方法"></a>4. JdbcTemplate对象的主要方法</h3><ol><li><p>queryForInt()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询一个整数类型</span></span><br><span class="line"><span class="keyword">int</span> count = jdbcTemplateObject.queryForInt(<span class="string">"select count(*) from emp32"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个使用绑定变量的简单查询</span></span><br><span class="line"><span class="keyword">int</span> age = jdbcTemplateObject.queryForInt(<span class="string">"select age from emp32 where id = ?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>queryForLong()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询一个 long类型</span></span><br><span class="line"><span class="keyword">long</span> count = jdbcTemplateObject.queryForLong(<span class="string">"select count(*) from emp32"</span>);</span><br></pre></td></tr></table></figure></li><li><p>queryForObject()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询字符串</span></span><br><span class="line">String SQL = <span class="string">"select name from emp32 where id = ?"</span>;</span><br><span class="line">String name = jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询并返回一个对象：</span></span><br><span class="line">String SQL = <span class="string">"select * from emp32 where id = ?"</span>;</span><br><span class="line">emp32 student = jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;, <span class="keyword">new</span> EmpRowMapper());</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询并返回多个对象：</span></span><br><span class="line">String SQL = <span class="string">"select * from emp32"</span>;</span><br><span class="line">List&lt;emp32&gt; students = jdbcTemplateObject.query(SQL, <span class="keyword">new</span> EmpRowMapper());</span><br></pre></td></tr></table></figure></li><li><p>update()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表中插入一行：</span></span><br><span class="line">String SQL = <span class="string">"insert into emp32 (name, age) values (?, ?)"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="string">"Zara"</span>, <span class="number">11</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新表中的一行：</span></span><br><span class="line">String SQL = <span class="string">"update emp32 set name = ? where id = ?"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="string">"Zara"</span>, <span class="number">10</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//从表中删除一行：</span></span><br><span class="line">String SQL = <span class="string">"delete emp32 where id = ?"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">20</span>&#125; );</span><br></pre></td></tr></table></figure></li><li><p>execute()：执行DDL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">"CREATE TABLE emp32(</span></span><br><span class="line"><span class="string">idINT AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">NAMEVARCHAR(30),</span></span><br><span class="line"><span class="string">salaryDOUBLE DEFAULT 5000,</span></span><br><span class="line"><span class="string">CONSTRAINT student_id_pk PRIMARY KEY(id),</span></span><br><span class="line"><span class="string">CONSTRAINT student_name_uk UNIQUE(NAME)</span></span><br><span class="line"><span class="string">)"</span>;</span><br><span class="line">jdbcTemplateObject.execute( SQL );</span><br></pre></td></tr></table></figure></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-异常转换"><a href="#5-异常转换" class="headerlink" title="5. 异常转换"></a>5. 异常转换</h3><ul><li>Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。</li><li>所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。</li><li>这样可以使异常处理机制独立于当前使用的具体数据库。</li><li>除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。</li></ul><p>例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSQLErrorCodeTranslator</span> <span class="keyword">extends</span> <span class="title">SQLErrorCodeSQLExceptionTranslator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DataAccessException customTranslate</span><br><span class="line">      (String task, String sql, SQLException sqlException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlException.getErrorCode() == -<span class="number">104</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DuplicateKeyException(<span class="string">"完整性约束冲突"</span>, sqlException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的&lt;strong&gt;声明式&lt;/strong&gt;事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十四、Spring IoC注解实现</title>
    <link href="http://chaooo.github.io/2019/08/27/14-SpringIoC%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://chaooo.github.io/2019/08/27/14-SpringIoC注解实现.html</id>
    <published>2019-08-27T14:44:07.000Z</published>
    <updated>2019-08-27T14:55:45.009Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="#id1">回顾xml方式管理Java Bean</a></li><li><a href="#id2">注解方式管理Java Bean</a></li><li><a href="#id3">注解方式Bean的注入</a></li><li><a href="#id4">注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-回顾xml方式管理Java-Bean"><a href="#1-回顾xml方式管理Java-Bean" class="headerlink" title="1. 回顾xml方式管理Java Bean"></a>1. 回顾xml方式管理Java Bean</h3><ol><li>将一个Bean交由Spring创建并管理<ul><li><code>&lt;baen id=&quot;bean&quot; class=&quot;包名.Bean&quot;&gt;&lt;/baen&gt;</code></li></ul></li><li>获取Spring上下文<ul><li><code>ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></li></ul></li><li>获取Bean<ul><li><code>Bean bean = app.getBean(&quot;bean&quot;, Bean.class);</code></li></ul></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-注解方式管理Java-Bean"><a href="#2-注解方式管理Java-Bean" class="headerlink" title="2. 注解方式管理Java Bean"></a>2. 注解方式管理Java Bean</h3><p>一、创建一个class配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="comment">//将一个Bean交由Spring创建并管理</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean <span class="title">bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean = <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、获取Spring上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = </span><br><span class="line">    <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfiguration.class);</span><br></pre></td></tr></table></figure><p>三、获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bean1 bean1 = context.getBean(<span class="string">"bean1"</span>, Bean1.class);</span><br></pre></td></tr></table></figure><h4 id="2-1-简化注解方式的步骤1"><a href="#2-1-简化注解方式的步骤1" class="headerlink" title="2.1 简化注解方式的步骤1"></a>2.1 简化注解方式的步骤1</h4><p>一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//该注解可理解当前class等同于一个xml文件</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>) <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在applicationContext.xml中开启组件扫描方式<code>&lt;context:component-scan base-package=&quot;包路径&quot;/&gt;</code>。</p></blockquote><p>二、 将交由Spring管理的类加上<code>@Component</code>注解，或（<code>@Repository</code>，<code>@Controller</code>，<code>@Service</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"bean1"</span>)<span class="comment">//通过构造方法实例化Bean1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 </p><ul><li>@Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 </li><li>@Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 </li><li>@Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 </li></ul></blockquote><h4 id="2-2-Bean别名"><a href="#2-2-Bean别名" class="headerlink" title="2.2 Bean别名"></a>2.2 Bean别名</h4><p>一、 xml形式：通过name属性或alias标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">name</span>=<span class="string">"bean2,bean3"</span> <span class="attr">class</span>=<span class="string">"com...Bean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"bean1"</span> <span class="attr">alias</span>=<span class="string">"bean4"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>二、 注解形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=&#123;<span class="string">"bean1"</span>,<span class="string">"bean2"</span>,<span class="string">"bean3"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：@Component只能指定一个名字，@Component默认值为<strong>类名首字母小写</strong>，也可以自定义，如:<code>@Component(&quot;bean1&quot;)</code>； 默认@scope为singleton单例，也可以进行指定</p></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-注解方式Bean的注入"><a href="#3-注解方式Bean的注入" class="headerlink" title="3. 注解方式Bean的注入"></a>3. 注解方式Bean的注入</h3><p>一、 <strong><code>@Value(&quot;值&quot;)</code></strong>：常用于基本数据类型值注入，<code>值</code>可用EL表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、 <strong><code>@Autowired</code></strong>：常用于复杂类型值的注入<br>    + <code>@Autowired</code>：可以用在<strong>成员变量</strong>，<strong>setter方法</strong>，<strong>构造方法</strong>上；优先按照类型进行匹配，匹配不上启用名字进行匹配。<br>    + <code>@Qualifier(&quot;名字&quot;)</code> 根据名字匹配，配合@Autowired，<strong>不能用在构造方法上</strong>；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，<code>@Autowired(required=false)</code>:尽量去找，组件不存在也不报错。<br>    + @Autowired的<strong>原理</strong>：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于成员变量 */</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//@Qualifier("card1")</span></span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于构造方法 */</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于setter方法 */</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCard</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、 <strong><code>@Resource</code></strong>：常用于复杂类型值的注入<br>    + @Resource：用在<strong>成员变量</strong>和<strong>setter方法</strong>上，是<strong>JDK</strong>1.6支持的注解，优先按照名字匹配，可以通过<code>@Resource(name=&quot;名&quot;)</code>指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"card"</span>)</span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合类型值注入实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"aaa"</span>);</span><br><span class="line">        list.add(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等"><a href="#4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等" class="headerlink" title="4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)"></a>4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</h3><h4 id="4-1-注解方式Bean的作用域"><a href="#4-1-注解方式Bean的作用域" class="headerlink" title="4.1 注解方式Bean的作用域"></a>4.1 注解方式Bean的作用域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-注解方式Bean的懒加载"><a href="#4-2-注解方式Bean的懒加载" class="headerlink" title="4.2 注解方式Bean的懒加载"></a>4.2 注解方式Bean的懒加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="meta">@Lazy</span> <span class="comment">//相当于xml中default-lazy-init="true"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="meta">@Lazy</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-Bean初始化和销毁"><a href="#4-3-Bean初始化和销毁" class="headerlink" title="4.3 Bean初始化和销毁"></a>4.3 Bean初始化和销毁</h4><p>一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、xml形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"example.Bean"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">init-method</span>=<span class="string">"init"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>三、注解形式1，@Bean(initMethod=”init”, destroyMethod=”cleanup”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"cleanup"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean <span class="title">bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、注解形式2，添加@PostConstruct，@PreDestroy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#id1&quot;&gt;回顾xml方式管理Java Bean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#id2&quot;&gt;注解方式管理Java Bean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#id3&quot;&gt;注解方式Bean的注入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十三、Spring基础和IoC控制反转</title>
    <link href="http://chaooo.github.io/2019/08/27/13-Spring%E5%9F%BA%E7%A1%80%E5%92%8CIoC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC.html"/>
    <id>http://chaooo.github.io/2019/08/27/13-Spring基础和IoC控制反转.html</id>
    <published>2019-08-27T14:38:23.000Z</published>
    <updated>2019-08-27T14:55:50.125Z</updated>
    
    <content type="html"><![CDATA[<p>Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。</p><ul><li>IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础<a id="more"></a></li><li>DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装</li><li>WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持</li><li>AOP：是在面向对象的基础上发展来的更高级的技术</li><li>ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库</li><li>JEE：Java的消息服务，远程调用，邮件服务等</li></ul><ol><li><a href="#id1">IoC（控制反转）</a></li><li><a href="#id2">Spring容器初始化</a></li><li><a href="#id3">spring容器创建对象(实例化)</a></li><li><a href="#id4">Spring DI注入的实现</a></li><li><a href="#id5">DI的参数的注入</a></li><li><a href="#id6">Bean的常用配置项(作用域,生命周期,懒加载等)</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-IoC（控制反转）"><a href="#1-IoC（控制反转）" class="headerlink" title="1. IoC（控制反转）"></a>1. IoC（控制反转）</h3><p><strong>IoC</strong>：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。</p><ol><li>控制：控制对象的创建及销毁（生命周期）</li><li>反转：将对象的控制权交给IoC容器</li></ol><p><strong>DI</strong>：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。</p><ul><li>简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入</li></ul><blockquote><p>IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。</p></blockquote><p><span id="id2"><span></span></span></p><h3 id="2-Spring容器初始化"><a href="#2-Spring容器初始化" class="headerlink" title="2. Spring容器初始化"></a>2. Spring容器初始化</h3><p>任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext</p><ul><li>BeanFactory提供配置结构和基本功能，加载并初始化Bean</li><li>ApplicationContext保存了Bean对象并在Spring中被广泛使用</li></ul><h4 id="2-1-初始化ApplicationContext的几种方式："><a href="#2-1-初始化ApplicationContext的几种方式：" class="headerlink" title="2.1 初始化ApplicationContext的几种方式："></a>2.1 初始化ApplicationContext的几种方式：</h4><ol><li><p>本地文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileSystemXmlApplicationContext app = </span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"F:/workspace/appcontext.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Classpath</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext app = </span><br><span class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classath:applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Web应用中依赖Servlet或Listener</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-Spring容器完成IOC的步骤"><a href="#2-2-Spring容器完成IOC的步骤" class="headerlink" title="2.2 Spring容器完成IOC的步骤"></a>2.2 Spring容器完成IOC的步骤</h4><ol><li>建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下</li><li>在spring容器配置文件中配置文件中配置一个对象的创建<ul><li><code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li></ul></li><li>写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件<ul><li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code></li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-spring容器创建对象-实例化"><a href="#3-spring容器创建对象-实例化" class="headerlink" title="3. spring容器创建对象(实例化)"></a>3. spring容器创建对象(实例化)</h3><h4 id="3-1-构造器方式实例化"><a href="#3-1-构造器方式实例化" class="headerlink" title="3.1 构造器方式实例化"></a>3.1 构造器方式实例化</h4><ul><li>配置文件：<code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li><li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code>默认调用类型对应的无参构造方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Date date = app.getBean(<span class="string">"date"</span>, Date.class);</span><br></pre></td></tr></table></figure><h4 id="3-2-静态工厂方法实例化"><a href="#3-2-静态工厂方法实例化" class="headerlink" title="3.2 静态工厂方法实例化"></a>3.2 静态工厂方法实例化</h4><ul><li>使用一个类型对应的静态方法来获取这个类型的对象</li><li><code>&lt;bean id=&quot;对象引用名&quot; class=&quot;包名.工厂类名&quot; factory-method=&quot;静态方法名&quot;&gt;&lt;/bean&gt;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cal"</span> <span class="attr">class</span>=<span class="string">"java.util.Calendar"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Calendar cal = app.getBean(<span class="string">"cal"</span>, Calendar.class);</span><br></pre></td></tr></table></figure><h4 id="3-3-实例工厂方法实例化"><a href="#3-3-实例工厂方法实例化" class="headerlink" title="3.3 实例工厂方法实例化"></a>3.3 实例工厂方法实例化</h4><ul><li>使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象</li><li><code>&lt;bean id=&quot;对象的引用名&quot; factory-bean=&quot;工厂方法的id&quot; factory-method=&quot;成员方法名&quot;&gt;&lt;/bean&gt;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cal"</span> <span class="attr">class</span>=<span class="string">"java.util.Calendar"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"time"</span> <span class="attr">factory-bean</span>=<span class="string">"cal"</span> <span class="attr">factory-method</span>=<span class="string">"getTime"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Date time = app.getBean(<span class="string">"time"</span>, Date.class);</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-Spring-DI注入的实现"><a href="#4-Spring-DI注入的实现" class="headerlink" title="4. Spring DI注入的实现"></a>4. Spring DI注入的实现</h3><p>Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。<br>Bean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。<br>DI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配)</p><ul><li>实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。</li></ul><h4 id="4-1-设值注入"><a href="#4-1-设值注入" class="headerlink" title="4.1 设值注入"></a>4.1 设值注入</h4><p>property(属性)的name参考对象set方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"黑桃"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"A"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player参考其setCard方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"玩家1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span> <span class="attr">ref</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-构造注入（Constructor-arguments）"><a href="#4-2-构造注入（Constructor-arguments）" class="headerlink" title="4.2 构造注入（Constructor arguments）"></a>4.2 构造注入（Constructor arguments）</h4><p>构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card2"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"红桃"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"K"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player参考其构造方法Player(name,card) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player2"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"玩家2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"card"</span> <span class="attr">ref</span>=<span class="string">"card2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-自动化注入（Autowiring-mode）"><a href="#4-3-自动化注入（Autowiring-mode）" class="headerlink" title="4.3 自动化注入（Autowiring mode）"></a>4.3 自动化注入（Autowiring mode）</h4><p>一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire=”byName/byType/constructor”)指定对应的自动化的注入方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">autowire</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>自动装配autowire</strong>属性 有五种自动装配的方式：</p><ul><li><p>No：默认，需要通过<code>ref</code>属性来连接bean。</p></li><li><p><strong>byName</strong>： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card3"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应)</span></span><br><span class="line"><span class="comment">    否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player3"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>byType</strong>：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player4"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>constructor</strong>：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card5"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player5"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"constructor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>autodetect</strong>：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</p></li></ul><p><span id="id5"><span></span></span></p><h3 id="5-DI的参数的注入"><a href="#5-DI的参数的注入" class="headerlink" title="5. DI的参数的注入"></a>5. DI的参数的注入</h3><p>Bean对象 注入类型 可以是 字符串、集合、bean对象。</p><h4 id="5-1-注入字符串"><a href="#5-1-注入字符串" class="headerlink" title="5.1 注入字符串"></a>5.1 注入字符串</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"msg"</span> <span class="attr">class</span>=<span class="string">"com.xdl.bean.OracleDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"scott"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>tiger<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-注入集合"><a href="#5-2-注入集合" class="headerlink" title="5.2 注入集合"></a>5.2 注入集合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"friends"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"friends2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546454"</span> <span class="attr">value</span>=<span class="string">"值1"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546464"</span> <span class="attr">value</span>=<span class="string">"值2"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. props集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164545564"</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164546756"</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-集合参数的单独定义"><a href="#5-3-集合参数的单独定义" class="headerlink" title="5.3 集合参数的单独定义"></a>5.3 集合参数的单独定义</h4><p>注入集合–引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"ref_friends"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:set</span> <span class="attr">id</span>=<span class="string">"ref_buddys"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:set</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">"ref_phones"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"159454644"</span> <span class="attr">value</span>=<span class="string">"值1"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546454"</span> <span class="attr">value</span>=<span class="string">"值2"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. props集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"ref_phonePro"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164545564"</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"16454675665564"</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"ref_db"</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones"</span> <span class="attr">ref</span>=<span class="string">"ref_phones"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones2"</span> <span class="attr">ref</span>=<span class="string">"ref_phonePro"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-Spring的’EL’表达式"><a href="#5-3-Spring的’EL’表达式" class="headerlink" title="5.3 Spring的’EL’表达式"></a>5.3 Spring的’EL’表达式</h4><p>它和EL在语法上很 相似，可以读取一个bean对象/集合中的数据。<br>Spring EL 采用 #{Sp Expression Language} 即 <code>#{spring表达式}</code>，可在xml配置和注解中使用。</p><ul><li>Spring EL配置连接池对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"db"</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.xdl.bean.OracleDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.name&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><span id="id6"><span></span></span></p><h3 id="6-Bean的常用配置项-作用域-生命周期-懒加载等"><a href="#6-Bean的常用配置项-作用域-生命周期-懒加载等" class="headerlink" title="6. Bean的常用配置项(作用域,生命周期,懒加载等)"></a>6. Bean的常用配置项(作用域,生命周期,懒加载等)</h3><p>Bean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization/destruction method</p><h4 id="6-1-Bean作用域（Scope）"><a href="#6-1-Bean作用域（Scope）" class="headerlink" title="6.1 Bean作用域（Scope）"></a>6.1 Bean作用域（Scope）</h4><ol><li>Singleton作用域<ul><li>单例，指一个Bean容器只存在一份</li></ul></li><li>prototype作用域<ul><li>每次请求(使用)创建新的实例，destroy方式不生效</li></ul></li><li>Web环境作用域：<ul><li>request作用域：每个request请求都会创建一个单独的实例。</li><li>session作用域：每个session都会创建一个单独的实例。</li><li>application作用域：每个servletContext都会创建一个单独的实例。</li><li>websocket作用域：每个websocket连接都会创建一个单独的实例。</li></ul></li><li>自定义作用域<ul><li>SimpleThreadScope作用域：每个线程都会创建一个单独的实例。</li></ul></li></ol><h4 id="6-2-Bean的生命周期（Initialization-destruction-method）"><a href="#6-2-Bean的生命周期（Initialization-destruction-method）" class="headerlink" title="6.2 Bean的生命周期（Initialization/destruction method）"></a>6.2 Bean的生命周期（Initialization/destruction method）</h4><p>Bean的生命周期：定义 –&gt; 初始化 –&gt; 使用 –&gt; 销毁</p><h5 id="6-2-1-Bean初始化"><a href="#6-2-1-Bean初始化" class="headerlink" title="6.2.1 Bean初始化"></a>6.2.1 Bean初始化</h5><p>如果需要在Bean实例化之后执行一些逻辑，有两种方法：</p><ul><li>实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。</li><li><strong>配置init-method</strong><ul><li>配置<strong><code>beans</code></strong>的<code>default-init-method</code>属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。</li><li>配置<strong><code>bean</code></strong>的<code>init-method</code>来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleId"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-2-2-Bean销毁"><a href="#6-2-2-Bean销毁" class="headerlink" title="6.2.2 Bean销毁"></a>6.2.2 Bean销毁</h5><p>如果需要在Bean销毁之前执行一些逻辑，有两种方法：</p><ul><li>实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。</li><li><strong>配置destroy-method</strong><ul><li>配置<strong><code>beans</code></strong>的<code>default-destroy-method</code>属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。</li><li>配置<strong><code>bean</code></strong>的<code>destroy-method</code>来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleId"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：销毁方法只针对单例模式的对象</p></blockquote><h4 id="6-3-Bean的懒加载（Lazy-initialization-mode）"><a href="#6-3-Bean的懒加载（Lazy-initialization-mode）" class="headerlink" title="6.3 Bean的懒加载（Lazy-initialization mode）"></a>6.3 Bean的懒加载（Lazy-initialization mode）</h4><p>Spring容器会在创建容器时提前初始化<code>Singleton作用域</code>的bean，可以通过bean标记<code>lazy-init=&quot;true&quot;</code>延迟实例化(对象被使用时才创建)。</p><ul><li><p><strong>配置lazy-init</strong></p><ul><li>配置<strong><code>beans</code></strong>的<code>default-lazy-init=&quot;true&quot;</code>为所有Bean设定懒加载。</li><li>配置<strong><code>bean</code></strong>的<code>lazy-init=&quot;true&quot;</code>为单独的某个Bean设定懒加载。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载</p><ul><li>优点：尽可能的节约了资源</li><li>缺点：可能导致某个操作响应时间增加</li></ul></li></ul><h4 id="6-4-Bean装配的Aware接口"><a href="#6-4-Bean装配的Aware接口" class="headerlink" title="6.4 Bean装配的Aware接口"></a>6.4 Bean装配的Aware接口</h4><p>实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。</p><ol><li>ApplicationContextAware<ul><li>接口方法：setApplicationContext</li><li>作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li><li>实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li></ul></li><li>BeanNameAware<ul><li>接口方法：setBeanName</li><li>作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li><li>实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li></ul></li></ol><h4 id="6-4-Bean装配之Resource"><a href="#6-4-Bean装配之Resource" class="headerlink" title="6.4 Bean装配之Resource"></a>6.4 Bean装配之Resource</h4><p><strong>Resources</strong>（针对于资源文件的统一接口）</p><ol><li>UrlResource：URL 对应的资源，根据一个 URL 地址即可获取</li><li>ClassPathResource：获取类路径下的资源</li><li>FileSystemResource：获取文件系统里面的资源</li><li>ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源</li><li>InputStreamResource：获取输入流封装的资源</li><li>ByteArrayResource：获取字节数组封装的资源</li></ol><p>ResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。</p><ul><li>getResource()参数：<ul><li>classPath方式：”classPath:class路径下文件”</li><li>file方式： “file:本地磁盘文件绝对地址”</li><li>url方式： “url:URL地址下文件”</li><li>没有前缀时依赖applicationContext的配置文件路径: “文件全名”</li></ul></li><li>eg:<code>applicationContext.getResource(&quot;classpath:config.txt&quot;)</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统基础</title>
    <link href="http://chaooo.github.io/2019/07/22/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.html"/>
    <id>http://chaooo.github.io/2019/07/22/01-数据库系统基础.html</id>
    <published>2019-07-22T12:20:19.000Z</published>
    <updated>2019-09-02T06:28:59.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>数据库 是 电子化信息的集合<ul><li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li></ul></li><li>表(Table)：以按行按列形式组织及展现的数据<a id="more"></a><ul><li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li></ul></li><li>数据库系统的构成（概念层次）:<ol><li>数据库(DB):Database：相互之间有关联关系的数据的集合</li><li>数据库管理系统(DBMS):Database Management System</li><li>数据库应用(DBAP):Database Application</li><li>数据库管理员(DBA):Database Asministrator</li><li>计算机基本系统</li></ol></li></ol><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol><li><a href="#id1">数据库管理系统(DBMS)</a></li><li><a href="#id2">数据库系统的标准结构</a></li><li><a href="#id3">三级模式两层映像</a></li><li><a href="#id4">数据模型</a></li><li><a href="#id5">关系模型</a></li><li><a href="#id6">关系模型中的完整性</a></li><li><a href="#id7">关系代数</a></li><li><a href="#id8">关系演算</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-数据库管理系统-DBMS"><a href="#1-数据库管理系统-DBMS" class="headerlink" title="1. 数据库管理系统(DBMS)"></a>1. 数据库管理系统(DBMS)</h3><h4 id="1-1-从用户角度看DBMS-数据库管理系统"><a href="#1-1-从用户角度看DBMS-数据库管理系统" class="headerlink" title="1.1 从用户角度看DBMS(数据库管理系统)"></a>1.1 从用户角度看DBMS(数据库管理系统)</h4><ol><li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等<ul><li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li><li>用户使用DDL描述其所要建立的表的格式</li><li>DBMS依照用户的定义，创建数据库及其中的表</li></ul></li><li>数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等<ul><li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li><li>用户使用DML描述其所要进行的增、删、改、查等操作</li><li>DBMS依照用户的操作描述，实际执行这些操作</li></ul></li><li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)<ul><li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li><li>用户使用DCL描述其对数据库所要实施的控制</li><li>DBMS依照用户描述，实际ijnx控制</li></ul></li><li>数据库维护：转储/恢复/重组/性能监测/分析…<ul><li>DBMS提供了一系列程序(实用程序/例行程序)给用户</li><li>在这些程序中提供了对数据库维护的各种功能</li><li>用户使用这些程序进行各种数据库维护操作</li><li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li></ul></li></ol><h4 id="1-2-数据库语言"><a href="#1-2-数据库语言" class="headerlink" title="1.2 数据库语言"></a>1.2 数据库语言</h4><ul><li>使用者使用数据库语言，利用DBMS操纵数据库</li><li>SQL语言：结构化的数据库语言</li><li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li></ul><h4 id="1-3-从系统实现角度看DBMS的功能"><a href="#1-3-从系统实现角度看DBMS的功能" class="headerlink" title="1.3 从系统实现角度看DBMS的功能"></a>1.3 从系统实现角度看DBMS的功能</h4><ol><li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li><li>DBMS为完成DB管理，在后台运行着一系列程序…<ul><li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li><li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li><li><strong>数据存取与索引</strong>：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等</li><li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li><li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li><li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li><li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li><li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li><li><strong>数据字典管理</strong>：管理用户已经定义的信息</li><li><strong>应用程序接口(API)</strong>：提供应用程序使用DBMS特定功能的二首段</li><li><strong>数据库数据装载、重组等实用程序</strong></li><li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li></ul></li></ol><blockquote><p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p></blockquote><p><span id="id2"><span></span></span></p><h3 id="2-数据库系统的标准结构"><a href="#2-数据库系统的标准结构" class="headerlink" title="2. 数据库系统的标准结构"></a>2. 数据库系统的标准结构</h3><p>DBMS管理数据的三个层次：</p><ol><li>External Level = User Level（外部级别 = 用户级别）<ul><li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li></ul></li><li>Conceptual Level = Logic level（概念级别 = 逻辑级别）<ul><li>从全局角度理解/管理的数据, 含相应的关联约束</li></ul></li><li>Internal Level = Physical level（内部级别 = 物理级别）<ul><li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-三级模式两层映像"><a href="#3-三级模式两层映像" class="headerlink" title="3. 三级模式两层映像"></a>3. 三级模式两层映像</h3><p>数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成</p><ul><li>应用–&gt; 外模式(多个) –&gt; 模式(一个) –&gt; 内模式(一个) –&gt; 数据库</li></ul><h4 id="3-1-数据-视图-与模式-数据的结构"><a href="#3-1-数据-视图-与模式-数据的结构" class="headerlink" title="3.1 数据(视图)与模式(数据的结构)"></a>3.1 数据(视图)与模式(数据的结构)</h4><ul><li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li><li>视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据</li></ul><h4 id="3-2-三级模式-三级视图"><a href="#3-2-三级模式-三级视图" class="headerlink" title="3.2 三级模式(三级视图)"></a>3.2 三级模式(三级视图)</h4><ol><li>External Schema —-(External) View<ul><li>外模式：某一用户能够看到与处理的数据的结构描述</li></ul></li><li>(Conceptual) Schema —- Conceptual View<ul><li>模式(概念模式)：从全局角度理解/管理的数据的结构描述, 含相应的关联约束</li><li>体现在数据之间的内在本质联系</li></ul></li><li>Internal Schema —- Internal  View<ul><li>内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li></ul></li></ol><h4 id="3-3-两层映像"><a href="#3-3-两层映像" class="headerlink" title="3.3 两层映像"></a>3.3 两层映像</h4><ol><li>E-C Mapping：External Schema-Conceptual Schema Mapping <ul><li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li><li>便于用户观察和使用</li></ul></li><li>C-I Mapping：Conceptual Schema-Internal Schema Mapping <ul><li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li><li>便于计算机进行存储和处理</li></ul></li></ol><h4 id="3-4-标准结构的两个独立性"><a href="#3-4-标准结构的两个独立性" class="headerlink" title="3.4 标准结构的两个独立性"></a>3.4 标准结构的两个独立性</h4><ol><li>逻辑数据独立性<ul><li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li></ul></li><li>物理数据独立性<ul><li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-数据模型"><a href="#4-数据模型" class="headerlink" title="4. 数据模型"></a>4. 数据模型</h3><ol><li>数据模型：模式 与 模式的结构<ul><li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li><li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li><li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li></ul></li><li>三大经典数据模型<ul><li>关系模型：<strong>表</strong>的形式组织数据</li><li>层次模型：<strong>树</strong>的形式组织数据</li><li>网状模型：<strong>图</strong>的形式组织数据</li></ul></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-关系模型"><a href="#5-关系模型" class="headerlink" title="5. 关系模型"></a>5. 关系模型</h3><ol><li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：<ul><li>描述DB各种数据的基本结构形式(Table/Relation)</li><li>描述Table与Table之间所可能发生的各种操作(关系运算)</li><li>描述这些操作所应遵循的约束条件(完整性约束)</li></ul></li><li>关系模型的三个要素：<ul><li>基本结构：Relation/Table</li><li>基本操作：Relation Operator<ul><li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li><li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li></ul></li><li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li></ul></li><li>表(Table)的基本构成要素<ul><li>列/字段/属性/数据项：列名，列值</li><li>行/元组/记录</li><li>标题/模式</li></ul></li></ol><h4 id="5-1-“表”的严格定义"><a href="#5-1-“表”的严格定义" class="headerlink" title="5.1 “表”的严格定义"></a>5.1 “表”的严格定义</h4><ul><li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li><li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li><li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li></ul><h4 id="5-2-关系模式与关系"><a href="#5-2-关系模式与关系" class="headerlink" title="5.2 关系模式与关系"></a>5.2 关系模式与关系</h4><ul><li>同一关系模式下，可有很多的关系</li><li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li><li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li></ul><h4 id="5-3-关系的特性"><a href="#5-3-关系的特性" class="headerlink" title="5.3 关系的特性"></a>5.3 关系的特性</h4><ul><li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li><li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li><li>列位置互换性：区分哪一列是靠列名</li><li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)</li><li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li><li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li><li>属性不可再分特性:又被称为关系第一范式</li></ul><h4 id="5-4-关系的一些重要概念"><a href="#5-4-关系的一些重要概念" class="headerlink" title="5.4 关系的一些重要概念"></a>5.4 关系的一些重要概念</h4><ol><li>候选码(Candidate Key)/候选键<ul><li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li></ul></li><li>主码(Primary Key)/主键<ul><li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li></ul></li><li>主属性与非主属性<ul><li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li><li>最简单的，候选码只包含一个属性；</li><li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li></ul></li><li>外码(Foreign Key)/外键<ul><li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li><li>两个关系通常是靠外码连接起来的。</li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-关系模型中的完整性"><a href="#6-关系模型中的完整性" class="headerlink" title="6. 关系模型中的完整性"></a>6. 关系模型中的完整性</h3><h4 id="6-1-实体完整性"><a href="#6-1-实体完整性" class="headerlink" title="6.1 实体完整性"></a>6.1 实体完整性</h4><ul><li>关系的主码中的属性值不能为空值；</li><li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li></ul><h4 id="6-2-参照完整性"><a href="#6-2-参照完整性" class="headerlink" title="6.2 参照完整性"></a>6.2 参照完整性</h4><ul><li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li><li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li></ul><h4 id="6-3-用户自定义完整性"><a href="#6-3-用户自定义完整性" class="headerlink" title="6.3 用户自定义完整性"></a>6.3 用户自定义完整性</h4><ul><li>用户针对具体的应用环境定义的完整性约束条件</li></ul><h4 id="6-4-DBMS对关系完整性的支持"><a href="#6-4-DBMS对关系完整性的支持" class="headerlink" title="6.4 DBMS对关系完整性的支持"></a>6.4 DBMS对关系完整性的支持</h4><ul><li>实体完整性和参照完整性由DBMS系统自动支持</li><li>DBMS系统通常提供了如下机制：<ol><li>它使用户可以自行定义有关的完整性约束条件</li><li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li></ol></li></ul><p><span id="id7"><span></span></span></p><h3 id="7-关系代数"><a href="#7-关系代数" class="headerlink" title="7. 关系代数"></a>7. 关系代数</h3><h4 id="7-1-关系代数的特点"><a href="#7-1-关系代数的特点" class="headerlink" title="7.1 关系代数的特点"></a>7.1 关系代数的特点</h4><ul><li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li><li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li><li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li><li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li><li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li></ul><h4 id="7-2-关系代数的约束"><a href="#7-2-关系代数的约束" class="headerlink" title="7.2 关系代数的约束"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p><ul><li>并相容性：<ol><li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li><li>定义：关系R与关系S存在相容性，当且仅当：<ul><li>(1) 关系R和关系S的属性数目必须相同；</li><li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li></ul></li></ol><ul><li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li><li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li></ul></li></ul><h4 id="7-3-关系代数的基本操作"><a href="#7-3-关系代数的基本操作" class="headerlink" title="7.3 关系代数的基本操作"></a>7.3 关系代数的基本操作</h4><ol><li>集合操作<ul><li>并（UNIO）：R∪S</li><li>交（INTERSECTION）：R∩S</li><li>差（DIFFERENCE）：R-S</li><li>笛卡儿积（Cartesian PRODUCT）：R×S</li></ul></li><li>纯关系操作<ul><li>选择（SELECT）：σF(R)</li><li>投影（PROJECT）：ΠA(R)</li><li>连接（JOIN）：R⋈S</li><li>除（DIVISION）：R÷S</li></ul></li></ol><h5 id="7-3-1-并-Union-操作"><a href="#7-3-1-并-Union-操作" class="headerlink" title="7.3.1 并(Union) 操作"></a>7.3.1 并(Union) 操作</h5><ul><li>定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：<strong><code>R∪S</code></strong>, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li><li>数学描述：<code>R∪S={t|t∈R∨t∈S}</code>，其中t是元组</li><li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li><li>汉语中的“或者…或者…”通常意义是并运算的要求。</li><li><code>R∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li></ul><h5 id="7-3-2-差-Difference-操作"><a href="#7-3-2-差-Difference-操作" class="headerlink" title="7.3.2 差(Difference) 操作"></a>7.3.2 差(Difference) 操作</h5><ul><li>定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：<strong><code>R-S</code></strong>, 它由出现在关系R中但不出现在关系S中的元组构成。</li><li>数学描述：<code>R－S={t|t∈R∧t∉S}</code>，其中t是元组</li><li>汉语中的“是…但不含…”通常意义是差运算的要求。</li><li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li></ul><h5 id="7-3-3-交（Intersection-Referential-integrity）-操作"><a href="#7-3-3-交（Intersection-Referential-integrity）-操作" class="headerlink" title="7.3.3  交（Intersection Referential integrity） 操作"></a>7.3.3  交（Intersection Referential integrity） 操作</h5><ul><li>定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。</li><li>数学描述：<code>R∩S={t|t∈R∧t∈S}</code>，其中t是元组</li></ul><h5 id="7-3-4-广义笛卡尔积-Extended-cartesian-product-操作"><a href="#7-3-4-广义笛卡尔积-Extended-cartesian-product-操作" class="headerlink" title="7.3.4 广义笛卡尔积(Extended cartesian product) 操作"></a>7.3.4 广义笛卡尔积(Extended cartesian product) 操作</h5><ul><li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：<strong><code>RxS</code></strong>；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。</li><li>数学描述：<code>RxS = {&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S}</code></li><li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li><li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li><li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).</li></ul><h5 id="7-3-5-选择-Select"><a href="#7-3-5-选择-Select" class="headerlink" title="7.3.5 选择(Select)"></a>7.3.5 选择(Select)</h5><ul><li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作<strong><code>σF(R)</code></strong>, 它从关系R中选择出满足给定条件condition的元组构成。</li><li>数学描述：<code>σF(R) = {t|t∈R ∧ F(t)=&#39;真&#39;}</code>,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。</li><li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；¬；∧；∨</code> }</li></ul><h5 id="7-3-6-投影-Project"><a href="#7-3-6-投影-Project" class="headerlink" title="7.3.6 投影(Project)"></a>7.3.6 投影(Project)</h5><ul><li>定义：给定一个关系R, 投影运算结果也是一个关系，记作<strong><code>A(R)</code></strong>, 它从关系R中选出属性包含在A中的列构成。</li><li>数学描述：<code>ΠA(R) = {t[A] | t∈R}</code>,其中A为R中的属性列</li><li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li></ul><h4 id="7-4-关系代数的扩展操作"><a href="#7-4-关系代数的扩展操作" class="headerlink" title="7.4 关系代数的扩展操作"></a>7.4 关系代数的扩展操作</h4><h5 id="7-4-1-交-Intersection"><a href="#7-4-1-交-Intersection" class="headerlink" title="7.4.1 交(Intersection)"></a>7.4.1 交(Intersection)</h5><ul><li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：<strong><code>R∩S</code></strong>, 它由同时出现在关系R和关系S中的元组构成。</li><li>数学描述：<code>R∩S = {t|t∈R ∧ t∈S}</code>，其中t是元组</li><li>R∩S 和 S∩R 运算的结果是同一个关系</li><li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li><li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li></ul><h5 id="7-4-2-θ-连接-θ-Join-theta-Join"><a href="#7-4-2-θ-连接-θ-Join-theta-Join" class="headerlink" title="7.4.2 θ-连接(θ-Join, theta-Join)"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul><li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li><li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 <strong><code>R⋈S[AθB]</code></strong>：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li><li>数学描述：<code>R⋈S[AθB] = σ t[A]θs[B] (R×S)</code>，σF(RxS)其中t是R中的元组，s是S中的元组</li><li>在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用</li><li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li></ul><h5 id="7-4-3-等值连接-Equi-Join"><a href="#7-4-3-等值连接-Equi-Join" class="headerlink" title="7.4.3 等值连接(Equi-Join)"></a>7.4.3 等值连接(Equi-Join)</h5><ul><li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作<strong><code>R⋈S[A=B]</code></strong>：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li><li>数学描述：<code>R⋈S[A=B] = σ t[A]=s[B] (R×S)</code></li><li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li><li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接/等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li></ul><h5 id="7-4-4-自然连接-Natural-Join"><a href="#7-4-4-自然连接-Natural-Join" class="headerlink" title="7.4.4 自然连接(Natural-Join)"></a>7.4.4 自然连接(Natural-Join)</h5><ul><li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li><li>数学描述：<code>R⋈S = σ t[B]=s[B] (R×S)</code></li><li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li></ul><h4 id="7-5-关系代数的基本书写思路"><a href="#7-5-关系代数的基本书写思路" class="headerlink" title="7.5 关系代数的基本书写思路"></a>7.5 关系代数的基本书写思路</h4><ol><li>选出将用到的关系/表</li><li>做”积”运算（可用连接运算替换）</li><li>做选择运算保留所需的行/元组</li><li>做投影运算保留所需的列/属性</li></ol><ul><li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li><li>如涉及多个表，则检查：<ul><li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li><li>如不能，能否使用等值或不等值连接(θ-连接)</li><li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li></ul></li><li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li></ul><h4 id="7-6-关系代数之复杂扩展操作"><a href="#7-6-关系代数之复杂扩展操作" class="headerlink" title="7.6 关系代数之复杂扩展操作"></a>7.6 关系代数之复杂扩展操作</h4><h5 id="7-6-1-除-Division"><a href="#7-6-1-除-Division" class="headerlink" title="7.6.1 除(Division)"></a>7.6.1 除(Division)</h5><ul><li>除法运算经常用于求解“查询… 全部的/所有的…”问题</li><li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li><li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li><li>数学描述：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R÷S = &#123;t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) &#125;</span><br><span class="line">    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>其中[R-S]为投影Π的下标(属性)</p></blockquote><h5 id="7-6-2-外连接-Outer-Join"><a href="#7-6-2-外连接-Outer-Join" class="headerlink" title="7.6.2 外连接(Outer-Join)"></a>7.6.2 外连接(Outer-Join)</h5><ul><li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li><li>外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li><li>外连接的形式：左外连接、右外连接、全外连接<ul><li>左外连接 = 自然连接(或连接) + 左侧表中失配的元组</li><li>右外连接 = 自然连接(或连接) + 右侧表中失配的元组</li><li>全外连接 = 自然连接(或连接) + 两侧表中失配的元组</li><li>左外连接(Left Outer Join)记为：⋊</li><li>右外连接(Right Outer Join)记为：⋉</li><li>全外连接(Full Outer Join)记为：⋊⋉</li></ul></li></ul><p><span id="id8"><span></span></span></p><h3 id="8-关系演算"><a href="#8-关系演算" class="headerlink" title="8. 关系演算"></a>8. 关系演算</h3><p>关系演算是<strong>描述关系运算</strong>的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</p><ul><li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ol><li>关系元组演算是以<strong>元组变量</strong>作为谓词变量的基本对象</li><li>关系域演算是以<strong>域变量</strong>作为谓词变量的基本对象</li></ol></li></ul><h4 id="8-1-关系元组演算"><a href="#8-1-关系元组演算" class="headerlink" title="8.1 关系元组演算"></a>8.1 关系元组演算</h4><ol><li>关系元组演算公式：{ t | P(t) }<ul><li>表示：所有使谓词 P 为真的元组 t 的集合</li><li>t 是元组变量</li><li>t ∈ r 表示元组 t 在关系 r 中</li><li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li><li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li></ul></li><li>关系元组演算公式的基本形式：{ t | P(t) }</li><li>P(t)可以是如下三种形式之一的原子公式：<ul><li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li><li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=</li><li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li></ul></li><li>P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造<ul><li>如果F是一个公式，则 ¬F 也是公式</li><li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li></ul></li><li>P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例</li><li>构造P(t)还有两个运算符：∃(存在)、∀(任意)<ul><li>如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式</li><li>如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式</li><li>运算符∃和∀，又称为量词，前者称“<strong>存在量词</strong>”，后者称“<strong>全称量词</strong>”</li><li>而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“<strong>约束变量</strong>”，否则被称为“<strong>自由变量</strong>”。</li></ul></li><li>元组演算的等价性变换<ul><li>符号<code>&lt;=&gt;</code>表示表示等价于,如：<code>¬(A&gt;B) &lt;=&gt; A&lt;=B  &lt;=&gt; A&lt;B∨A=B</code></li></ul></li></ol><h4 id="8-2-关系域演算"><a href="#8-2-关系域演算" class="headerlink" title="8.2 关系域演算"></a>8.2 关系域演算</h4><ol><li>关系域演算公式的基本形式：<code>{&lt;x1,x2, …,xn&gt; | P(x1,x2, …,xn)}</code>,其中 xi 代表域变量或常量, P为以xi为变量的公式。</li><li>元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；</li><li>域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。</li><li>公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。</li><li>元组演算和域演算可以等价互换。</li></ol><h5 id="8-2-1-基于关系域演算的QBE语言"><a href="#8-2-1-基于关系域演算的QBE语言" class="headerlink" title="8.2.1 基于关系域演算的QBE语言"></a>8.2.1 基于关系域演算的QBE语言</h5><p>QBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。</p><ol><li>特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可</li><li>QBE操作框架由四个部分构成<ul><li>关系名区：用于书写欲待查询的关系名</li><li>属性名区：用于显示对应关系名区关系的所有属性名</li><li>操作命令区：用于书写查询操作的命令</li><li>查询条件区：用于书写查询条件</li></ul></li><li>QBE的操作命令<ul><li>Print 或 P.   —- 显示输出操作</li><li>Delete或D.   —- 删除操作</li><li>Insert或I.     —- 插入操作</li><li>Update或U. —- 更新操作</li></ul></li><li>构造查询的几个要素 <ul><li>示例元素: 即域变量， 一定要加下划线 </li><li>示例元素是这个域中可能的一个值， 它不必是查询结果中的元素</li><li>打印操作符P.: 指定查询结果所含属性列 </li><li>查询条件: 不用加下划线</li><li>可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略</li><li>排序要求 <ul><li>升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高</li></ul></li></ul></li></ol><h4 id="8-3-安全性"><a href="#8-3-安全性" class="headerlink" title="8.3 安全性"></a>8.3 安全性</h4><p>关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的</p><ol><li>关系代数是一种集合运算，是安全的<ul><li>集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。</li></ul></li><li>关系演算不一定是安全的<ul><li>如：{t|¬(R(t))}, {t R(t)∨t[2]&gt;3}可能表示无限关系</li></ul></li><li>需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。</li></ol><h5 id="8-3-1-安全约束有限集合DOM"><a href="#8-3-1-安全约束有限集合DOM" class="headerlink" title="8.3.1 安全约束有限集合DOM"></a>8.3.1 安全约束有限集合DOM</h5><ol><li>DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。</li><li>DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。</li><li>安全元组演算表达式，满足三个条件：<ul><li>只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。<ul><li>{ t|ψ(t) }中t的取值只能是DOM中的值，有限的。</li></ul></li><li>对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。<ul><li>{ t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。</li></ul></li><li>对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。<ul><li>{ t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。</li></ul></li></ul></li></ol><h4 id="8-4-关于三种关系运算的一些观点"><a href="#8-4-关于三种关系运算的一些观点" class="headerlink" title="8.4 关于三种关系运算的一些观点"></a>8.4 关于三种关系运算的一些观点</h4><ol><li>关系运算有三种：关系代数、关系元组演算和关系域演算</li><li>三种关系运算都是抽象的数学运算，体现了三种不同的思维<ul><li>关系代数—以集合为对象的操作思维，由集合到集合的变换</li><li>元组演算—以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环</li><li>域演算—以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件</li></ul></li><li>三种运算之间是等价的<ul><li>关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等<br>价的。即一种形式的表达式可以被等价地转换为另一种形式</li></ul></li><li>三种关系运算都可说是非过程性的<ul><li>相比之下：域演算的非过程性最好，元组演算次之，关系代数最差</li></ul></li><li>三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础<ul><li>一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的</li><li>目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等</li></ul></li><li>数据库语言可以基于这三种抽象运算来设计<ul><li>用“键盘符号”来替换抽象的数学符号</li><li>用易于理解的符号组合来表达抽象的数学符号</li><li>例如：ISBL语言—基于关系代数的数据库语言</li><li>再例如：Ingres系统的QUEL语言</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据库 是 电子化信息的集合&lt;ul&gt;
&lt;li&gt;将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;表(Table)：以按行按列形式组织及展现的数据
    
    </summary>
    
      <category term="数据库系统" scheme="http://chaooo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>十二、JavaWeb编程基础</title>
    <link href="http://chaooo.github.io/2019/07/20/12_JavaWeb%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html"/>
    <id>http://chaooo.github.io/2019/07/20/12_JavaWeb编程基础.html</id>
    <published>2019-07-20T12:59:40.000Z</published>
    <updated>2019-09-03T15:25:01.750Z</updated>
    
    <content type="html"><![CDATA[<p>JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。</p><a id="more"></a><ol><li><a href="#id1">http协议</a></li><li><a href="#id2">Servlet</a></li><li><a href="#id3">请求的转发与重定向</a></li><li><a href="#id4">上下文对象ServletContext</a></li><li><a href="#id5">会话跟踪（状态管理）</a></li><li><a href="#id6">JSP</a></li><li><a href="#id7">内置对象(隐含对象)</a></li><li><a href="#id8">taglib指令</a></li><li><a href="#id9">JavaWeb三大组件</a></li><li><a href="#id10">JSON在Java中的使用</a></li><li><a href="#id11">AJAX</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-http协议"><a href="#1-http协议" class="headerlink" title="1. http协议"></a>1. http协议</h3><p>超文本传输协议，是一种应用层的网络传输协议</p><ul><li>http协议的特点：<ol><li>简单，快速：支持多种不同的的数据提交方式，如get/post</li><li>数据传输灵活，支持任意类型数据的传输</li><li>无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。</li><li>无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。</li></ol></li><li>http协议的组成部分：<ol><li>请求：浏览器连接服务器的过程</li><li>响应：服务器回复浏览器的过程</li></ol></li><li>http协议的请求：<ol><li>请求头：描述客户端的信息</li><li>请求体：GET没有请求体，请求体用于存储POST请求发送的数据。</li><li>请求空行：请求头与请求体之间的一行空白</li><li>请求行：描述请求方式，服务器地址，协议版本等</li></ol></li><li>http协议的响应：<ol><li>响应头：描述服务器的信息</li><li>响应体：响应的内容，文本，json数据等。</li><li>响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。</li></ol></li></ul><p><span id="id2"><span></span></span></p><h3 id="2-Servlet"><a href="#2-Servlet" class="headerlink" title="2. Servlet"></a>2. Servlet</h3><p>servlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。</p><h4 id="2-1-Servlet编写步骤："><a href="#2-1-Servlet编写步骤：" class="headerlink" title="2.1 Servlet编写步骤："></a>2.1 Servlet编写步骤：</h4><ol><li>编写一个Java类，继承HttpServlet类</li><li>重新service方法</li><li>在service方法中，对用户请求进行响应。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解：添加访问的网址</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.设置响应体的编码，以及内容类型</span></span><br><span class="line">res.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="comment">//2.得到响应体输出的打印流</span></span><br><span class="line">PrintWriter out = res.getWriter();</span><br><span class="line"><span class="comment">//3.打印文字</span></span><br><span class="line">out.println(<span class="string">"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-配置ervlet类的访问网址"><a href="#2-2-配置ervlet类的访问网址" class="headerlink" title="2.2 配置ervlet类的访问网址"></a>2.2 配置ervlet类的访问网址</h4><ul><li>web3.0版本之后使用注解的方式配置ervlet类的访问网址</li><li>web3.0版本之前配置Servlet访问网址的方式：<ul><li>将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 </li><li>配置Servlet类的别名，并给指定别名的Servlet添加映射网址。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet类别名，用于后续添加映射网址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet类全名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>day01_Servlet.demo1.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给指定别名的Servlet添加映射网址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-Servlet生命周期"><a href="#2-3-Servlet生命周期" class="headerlink" title="2.3 Servlet生命周期"></a>2.3 Servlet生命周期</h4><ul><li>实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用</li><li>创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。</li><li>销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。</li><li>tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：<ul><li>init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。</li><li>service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。</li><li>destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。</li></ul></li></ul><h4 id="2-4-get和post区别"><a href="#2-4-get和post区别" class="headerlink" title="2.4 get和post区别"></a>2.4 get和post区别</h4><ul><li>GET请求：<ul><li>没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&amp;连接键值对。</li><li>只能传输字符串类型参数</li><li>浏览器url地址最大长度4kb</li><li>数据传输时，参数在url中明文显示，不安全。</li></ul></li><li>POST请求：<ul><li>有请求体，是一个单独的数据包，用于存储请求中的多个参数</li><li>可传输任意类型的数据，进行文件上传必须POST请求</li><li>可以传递的数据大小，理论上没有上限</li><li>数据传输时在单独的数据包，较为安全。</li></ul></li></ul><h4 id="2-5-接收请求中的参数"><a href="#2-5-接收请求中的参数" class="headerlink" title="2.5 接收请求中的参数"></a>2.5 接收请求中的参数</h4><ol><li>根据参数的名称，接收参数的单个值<ul><li>String value = <strong>request.getParameter(String name)</strong>;</li></ul></li><li>根据参数的名称，接收一组参数的值<ul><li>String[] values = <strong>request.getParameterValues(String name)</strong>;</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">  response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">  <span class="comment">//1.接收</span></span><br><span class="line">  String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">  String[] password = request.getParameterValues(<span class="string">"password"</span>);</span><br><span class="line">  <span class="comment">//2.打印</span></span><br><span class="line">  System.out.println(<span class="string">"username:"</span> + username);</span><br><span class="line">  System.out.println(<span class="string">"password:"</span> + password[<span class="number">0</span>]);</span><br><span class="line">  System.out.println(<span class="string">"password2:"</span> + password[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">//3.浏览器输出</span></span><br><span class="line">  response.getWriter().append(<span class="string">"&lt;div&gt;很遗憾注册失败，点击&lt;a href=\"demo1.html\"&gt;重新注册&lt;/a&gt;&lt;/div&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-乱码处理"><a href="#2-6-乱码处理" class="headerlink" title="2.6 乱码处理"></a>2.6 乱码处理</h4><h4 id="2-6-1-乱码情况："><a href="#2-6-1-乱码情况：" class="headerlink" title="2.6.1 乱码情况："></a>2.6.1 乱码情况：</h4><ul><li>浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。</li><li>tomcat8版本之前(不包含tomcat8版本), GET请求乱码</li><li>任何版本, POST请求乱码</li></ul><h4 id="2-6-2-请求乱码处理："><a href="#2-6-2-请求乱码处理：" class="headerlink" title="2.6.2 请求乱码处理："></a>2.6.2 请求乱码处理：</h4><ul><li>适用于所有乱码问题：(Tomcat8之后get无乱码)<ol><li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li><li>将接收到的中文乱码重新编码：</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">String userName = <span class="keyword">new</span> String( name.getByte(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><ul><li>仅适用于POST请求：<ol><li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li><li>Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li></ol></li></ul><h4 id="2-6-3-响应乱码的处理："><a href="#2-6-3-响应乱码的处理：" class="headerlink" title="2.6.3 响应乱码的处理："></a>2.6.3 响应乱码的处理：</h4><ul><li>方式一：设置响应的内容类型, 以及编码格式:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>;</li><li>方式二：进设置编码格式, 不设置响应内容类型:<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code>(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);</li></ul><h4 id="2-7-Servlet的创建时机"><a href="#2-7-Servlet的创建时机" class="headerlink" title="2.7 Servlet的创建时机"></a>2.7 Servlet的创建时机</h4><ul><li>通过web.xml配置Servlet, 可以修改Servlet加载的时机。</li><li>可以给Servlet节点，添加<code>&lt;load-on-startup&gt;</code>节点来制定servlet启动顺序。</li><li>节点中的值为数字：<ul><li><code>-1</code>：默认-1，表示当用户第一次请求时，创建对象</li><li><code>&gt;=0</code>：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>demo.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id3"><span></span></span></p><h3 id="3-请求的转发与重定向"><a href="#3-请求的转发与重定向" class="headerlink" title="3. 请求的转发与重定向"></a>3. 请求的转发与重定向</h3><h4 id="3-1-请求对象request的常用操作"><a href="#3-1-请求对象request的常用操作" class="headerlink" title="3.1 请求对象request的常用操作"></a>3.1 请求对象request的常用操作</h4><ol><li>getMethod() : 得到请求的方式</li><li>getRequestURI() : 获取浏览器请求地址</li><li>getRemoteAddr() : 获取客户端ip地址</li><li>getRemoteHost() : 获取客户端名称</li><li>getServerName() : 获取服务器名称</li><li>getServerPort() : 获取服务器端口号</li><li>getQueryString() : 获取get请求参数字符串，其他请求返回null</li></ol><h4 id="3-1-请求的转发与重定向注意事项"><a href="#3-1-请求的转发与重定向注意事项" class="headerlink" title="3.1 请求的转发与重定向注意事项"></a>3.1 请求的转发与重定向注意事项</h4><ul><li>请求转发与重定向操作，必须要有出口。</li><li>当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了</li></ul><h4 id="3-2-转发"><a href="#3-2-转发" class="headerlink" title="3.2 转发*"></a>3.2 转发*</h4><ul><li>一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理</li><li>步骤：<ol><li>获取请求转发器：<code>RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;);</code></li><li>进行转发操作：<code>rd.forward(request, response);</code></li></ol></li><li>因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:<ul><li><code>request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response);</code></li></ul></li><li>特点：<ul><li>转发过程中，多个web组件之间共享一个请求对象request与响应对象response</li><li>在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变</li><li>转发不能跨项目实现</li><li>比重定向效率更高</li></ul></li></ul><h4 id="3-3-重定向"><a href="#3-3-重定向" class="headerlink" title="3.3 重定向*"></a>3.3 重定向*</h4><ul><li>一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址</li><li>格式：<code>response.sendRedirect(&quot;重定向地址&quot;)</code>；</li><li>原理：当客户端请求服务器时，发起重定向流程：<ol><li>给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.</li><li>当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.</li><li>浏览器自动发起新的请求 , 跳转到新地址.</li></ol></li><li>特点：<ol><li>重定向会产生两个请求对象，多个请求对象中数据不互通</li><li>浏览器地址发生了改变</li><li>重定向可以跨域实现</li><li>比转发效率低</li></ol></li></ul><p><span id="id4"><span></span></span></p><h3 id="4-上下文对象ServletContext"><a href="#4-上下文对象ServletContext" class="headerlink" title="4. 上下文对象ServletContext"></a>4. 上下文对象ServletContext</h3><ul><li>用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享</li><li>每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。</li></ul><p>获取ServletContext对象：<code>ServletContext context = getServletContext();</code></p><ul><li>常用方法<ul><li>context.setAttributes(String key, Objexct value); //设置替换数据</li><li>context.getAttributes(String key); //获取数据</li><li>context.removeAttributes(String key); //删除数据</li><li>context.getRealPath(“/“); //获取项目运行时所在文件路径</li></ul></li></ul><p><span id="id5"><span></span></span></p><h3 id="5-会话跟踪（状态管理）"><a href="#5-会话跟踪（状态管理）" class="headerlink" title="5. 会话跟踪（状态管理）"></a>5. 会话跟踪（状态管理）</h3><ul><li><p>存在两种实现：</p><ol><li>cookie: 将浏览器产生的状态存储在浏览器中</li><li>Session: 将浏览器产生的状态存储在服务器中</li></ol></li><li><p>cookie技术原理：</p><ul><li>服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，</li><li>浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来</li><li>当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器</li></ul></li><li><p>Session技术原理：</p><ul><li>当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，</li><li>该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器</li><li>浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。</li></ul></li></ul><h4 id="5-1-Cookie"><a href="#5-1-Cookie" class="headerlink" title="5.1 Cookie"></a>5.1 Cookie</h4><ul><li>创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对<ul><li><code>Cookie cookie = new Cookie(String key, String value);</code></li><li>注意：tomcat8.5版本之前，cookie无法出场中文</li></ul></li><li>通过响应对象，将cookie添加到响应头,可添加多个<ul><li><strong>response.addCookie(Cookie cookie)</strong>;</li></ul></li><li>通过请求头得到cookie数组，没有则返回null<ul><li><strong>Cookie[] cookies = request.getCookies()</strong>;</li><li>取键：cookie.getName();</li><li>取值：cookie.getValue()</li></ul></li><li>Cookie的存储时长：<ul><li>cookie.setMaxAge(int 秒)；<ul><li>正数：倒计时秒数</li><li>0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它</li><li>负数：默认-1，表示会话结束时自动删除（关闭浏览器）</li></ul></li></ul></li><li>Cookie的存储路径问题<ul><li>存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同</li><li>为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“/“);</li></ul></li></ul><h4 id="5-2-Cookie的优缺点"><a href="#5-2-Cookie的优缺点" class="headerlink" title="5.2 Cookie的优缺点"></a>5.2 Cookie的优缺点</h4><ul><li>缺点：<ol><li>Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。</li><li>数据存储在客户的计算机中，不安全，不建议存储安全敏感数据</li><li>保存数据量有限制，大约4kb左右</li><li>依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除</li></ol></li><li>优点：<ol><li>分散服务器的压力</li></ol></li></ul><h4 id="5-3-Session"><a href="#5-3-Session" class="headerlink" title="5.3 Session"></a>5.3 Session</h4><ul><li>获取Session<ul><li>格式1：<strong>request.getSession()</strong>;//等价参数传true</li><li>格式2：request.getSession(boolean isNew);<ul><li>true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回</li><li>false，根据浏览器的SessionId查找一个session，若没有就返回null</li></ul></li></ul></li><li>Session常用方法<ul><li><strong>session.setAttribute(String key, object value)</strong>;//设置/替换值</li><li><strong>session.getAttribute(String key)</strong>;//获取值</li><li>session.invalidate();//销毁</li></ul></li><li>设置session存活时长<ul><li>默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。</li><li>可以通过修改配置文件，修改所有的session时长<ul><li>修改<code>conf/web.xml</code>的<code>&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt;</code></li></ul></li><li>可以通过session对象，修改单个对象的session时长<ul><li>void session.setMaxInactiveInterval(int seconds)</li></ul></li></ul></li></ul><h4 id="5-4-Session的优缺点"><a href="#5-4-Session的优缺点" class="headerlink" title="5.4 Session的优缺点"></a>5.4 Session的优缺点</h4><ul><li>缺点：<ul><li>数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源</li></ul></li><li>优点：<ol><li>数据存储在服务器中，安全</li><li>数据类型为Object，在Java中表示可以存储所有类型的数据</li><li>session存储的数据大小，理论上无限的。</li></ol></li></ul><h4 id="5-5-Cookie和Session的使用"><a href="#5-5-Cookie和Session的使用" class="headerlink" title="5.5 Cookie和Session的使用"></a>5.5 Cookie和Session的使用</h4><ul><li>Cookie和Session不是互斥的，是相辅相成的</li><li>在项目开发时：<ul><li>对安全敏感的数据，存储在session中</li><li>对安全不敏感的字符串数据，可以选择存储在Cookie中</li><li>对于大的数据，应该存在数据库和文件中</li></ul></li></ul><blockquote><p>注意：cookie和session是为了管理状态而非存储数据。</p></blockquote><p><span id="id6"><span></span></span></p><h3 id="6-JSP"><a href="#6-JSP" class="headerlink" title="6.JSP"></a>6.JSP</h3><h4 id="6-1-JSP语法基础"><a href="#6-1-JSP语法基础" class="headerlink" title="6.1 JSP语法基础"></a>6.1 JSP语法基础</h4><ul><li><p>Java Server Pages：java动态网页技术</p></li><li><p>JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应</p></li><li><p>注意：</p><ol><li>JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet</li><li>执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html</li></ol></li><li><p>JSP语法结构</p><ol><li>html代码</li><li>Java代码</li><li>Jsp特有的语法结构</li></ol></li><li><p>Java代码声明区：指的是类的成员位置</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">  <span class="comment">// Java代码声明区</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><ul><li>Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  <span class="comment">// Java代码执行区</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><ul><li>JSP输出表达式<ul><li>用于快速的将Java中的数据，输出到网页中..</li><li>语法格式：<code>&lt;%=数据 %&gt;</code>，编译后被转换成out.print(数据)</li></ul></li><li>JSP注释：<ul><li>html中可以用<code>&lt;!-- --&gt;</code></li><li>java中可以用<code>//，/**/，/** */</code></li><li>jsp注释<code>&lt;%-- --%&gt;</code><ul><li>html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略</li></ul></li></ul></li></ul><h4 id="6-2-JSP三大指令"><a href="#6-2-JSP三大指令" class="headerlink" title="6.2 JSP三大指令"></a>6.2 JSP三大指令</h4><ul><li>page指令</li><li>include指令</li><li>taglib指令</li></ul><ul><li>指令使用格式：&lt;%@ 指令名称 属性1=值 属性2=值 属性n=值 %&gt;<br>*语法上，JSP允许在单个页面出现多个相同的JSP指令</li></ul><h5 id="6-2-1-page指令"><a href="#6-2-1-page指令" class="headerlink" title="6.2.1 page指令"></a>6.2.1 page指令</h5><ul><li>用于配置页面信息</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page</span><br><span class="line">  language=<span class="string">"java"</span>：语言</span><br><span class="line">  contentType=<span class="string">"text/html;charset=utf-8"</span>：响应的内容类型，以及响应的编码格式</span><br><span class="line">  pageEncoding=<span class="string">"UTF-8"</span>：文件存储的编码格式</span><br><span class="line">  extends=<span class="string">"继承的父类"</span></span><br><span class="line">  buffer=<span class="string">"数字/none"</span>：是否允许缓存，默认值<span class="number">8</span>kb</span><br><span class="line">  autoFlush=<span class="string">"true/false"</span>：是否自动清除缓存，默认<span class="keyword">true</span></span><br><span class="line">  session=<span class="string">"true/false"</span>：是否提前准备session对象，默认<span class="keyword">true</span></span><br><span class="line">  isThreadSafe=<span class="string">"true/false"</span>：是否线程安全的</span><br><span class="line">  <span class="keyword">import</span>=<span class="string">"java.util.List"</span>：用于导包，多个包使用<span class="string">","</span>隔开</span><br><span class="line">  errorPage=<span class="string">"网址"</span>：当页面发生BUG后，显示哪个页面</span><br><span class="line">  isErrorPage=<span class="string">"true/false"</span>：当前页面是否是一个错误处理页面，如果结果为<span class="keyword">true</span>，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="6-3-项目发生错误时，统一的处理方式"><a href="#6-3-项目发生错误时，统一的处理方式" class="headerlink" title="6.3 项目发生错误时，统一的处理方式"></a>6.3 项目发生错误时，统一的处理方式</h4><ol><li>打开项目的web.xml</li><li>加入子节点<code>&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt;</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>include指令：用于将jsp或html引入到另一个jsp中<ul><li>语法格式：<code>&lt;%@ include file=&quot;地址&quot; %&gt;</code></li></ul></li><li>include动作：用于将jsp或html引入到另一个jsp中<ul><li>语法格式：<code>&lt;jsp:include page=&quot;地址&quot;&gt;</code></li></ul></li></ul><blockquote><p>include指令 与 include动作区别：</p><ul><li>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp =&gt; 一个Servlet）</li><li>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp =&gt; 多个Servlet）</li></ul></blockquote><p><span id="id7"><span></span></span></p><h3 id="7-内置对象-隐含对象"><a href="#7-内置对象-隐含对象" class="headerlink" title="7.内置对象(隐含对象)"></a>7.内置对象(隐含对象)</h3><ul><li>在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。</li><li>内置对象通常是我们会主动创建的对象</li></ul><h4 id="7-1-九大内置对象"><a href="#7-1-九大内置对象" class="headerlink" title="7.1 九大内置对象"></a>7.1 九大内置对象</h4><ol><li>request<ul><li>对象类型：java.servlet.<strong>HttpServletRequest</strong></li><li>request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。</li></ul></li><li>response<ul><li>对象类型：javax.servlet.<strong>HttpServletResponse</strong></li><li>response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。</li></ul></li><li>config<ul><li>对象类型：javax.servlet.<strong>ServletConfig</strong></li><li>在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。</li></ul></li><li>out<ul><li>对象类型：javax.servlet.jsp.<strong>JspWriter</strong></li><li>在JSP开发过程中使用得最为频繁的对象</li></ul></li><li>page<ul><li>对象类型：java.lang.<strong>Object</strong></li><li>page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。</li></ul></li><li>pageContext<ul><li>对象类型：<strong>pageContext</strong></li><li>pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</li></ul></li><li>session<ul><li>对象类型：java.servlet.http.<strong>HttpSession</strong></li><li>session是与请求有关的会话期，用来表示和存储当前页面的请求信息。</li></ul></li><li>application<ul><li>对象类型：javax.servlet.<strong>ServletContext</strong></li><li>用于实现用户之间的数据共享（多使用于网络聊天系统）。</li></ul></li><li>exception<ul><li>对象类型：java.lang.<strong>Throwable</strong></li><li>作用 exception内置对象是用来处理页面出现的异常错误。</li></ul></li></ol><h4 id="7-2-JSP四大域对象"><a href="#7-2-JSP四大域对象" class="headerlink" title="7.2 JSP四大域对象"></a>7.2 JSP四大域对象</h4><ul><li>九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据</li><li>域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法：<ol><li>存储数据：setAttribute(String key, Object value);</li><li>获取数据：Object value = getAttribute(String);</li><li>删除数据： removeAttribute(String key);</li></ol></li><li>四大内置对象，分别指的是：<ol><li>pageContext: (作用域：1个页面)<ul><li>页面上下文，存储在pageContext中的数据, 作用域是最小的,  pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁.</li></ul></li><li>request: (作用域：一次请求，如果请求被转发，可能跨越多个页面)<ul><li>请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁.</li></ul></li><li>session: (作用域：一次会话，一次会话可能包含多个请求)<ul><li>会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。</li></ul></li><li>application: (域范围：一次服务，应用从启动到关闭application一直都在)<ul><li>Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用.</li></ul></li></ol></li></ul><h4 id="7-3-EL表达式"><a href="#7-3-EL表达式" class="headerlink" title="7.3 EL表达式"></a>7.3 EL表达式</h4><ul><li>用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。</li><li>格式：<code>${表达式}</code></li><li>EL表达式用于运算<ul><li>在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是:   246 </li></ul></li><li>用于取出域对象中的数据<ul><li>取出数据直接输出：<code>${域对象中存储的键}</code></li><li>如果取出的数据不存在, 则不输出 (不可能显示null)</li></ul></li><li>取出对象数据的属性值:<ul><li>格式1： ${对象存储的键.属性名}</li><li>格式2： ${对象存储的键[“属性名”]}</li><li>格式3(动态取值)： ${对象存储的键[属性存储的键]}</li></ul></li><li>取出集合中的数据<ul><li>格式: ${集合存储时的key[下标]}</li></ul></li></ul><h4 id="7-4-EL表达式取出数据的流程"><a href="#7-4-EL表达式取出数据的流程" class="headerlink" title="7.4 EL表达式取出数据的流程"></a>7.4 EL表达式取出数据的流程</h4><ul><li>四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据.</li><li>步骤:<ol><li>先从pageContext中, 寻找数据是否存在.</li><li>如果pageContext中数据不存在, 则去request中寻找数据是否存在</li><li>如果request 中数据不存在, 则去session中寻找数据是否存在</li><li>如果session中数据不存在, 则去application中寻找数据是否存在</li><li>如果application中数据不存在,则不输出任何数据.</li></ol></li></ul><p><span id="id8"><span></span></span></p><h3 id="8-taglib指令"><a href="#8-taglib指令" class="headerlink" title="8. taglib指令"></a>8. taglib指令</h3><p>用于在JSP文件中，引入标签库文件。</p><ul><li>格式： <code>&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt;</code><ul><li>prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：<code>&lt;标签库名称:标签名&gt;</code></li><li>uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性</li></ul></li><li>JSTL(JSP Standard Tag Library): JSP标准标签库<ul><li>使用时，需要引入jar文件</li><li>if 标签，格式：&lt;库名称:if text=”${ booble }”&gt;</li><li>forEach 标签，格式：&lt;库名称:forEach items=”${ List }” var=”item”&gt;</li></ul></li><li>自定义标签库:<ol><li>编写一个Java类, 继承SimpleTagSupport类.</li><li>重写父类的doTag方法.</li><li>在doTag方法中, 通过getJspContext方法,  的到JSP页面的上下文</li><li>通过上下文对象, 得到JSP中的out对象, </li><li>通过out对象,  向网页中输出内容</li><li>编写tld文件 , 描述标签库 以及 标签.</li></ol></li></ul><p>自定义标签库案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTag1</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ArrayList&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        data.add(<span class="string">"流水在碰到底处时才会释放活力。——歌德"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">        JspContext context = getJspContext();</span><br><span class="line">        JspWriter out = context.getOut();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> index = r.nextInt(data.size());</span><br><span class="line">        out.println(<span class="string">"&lt;span&gt;"</span>+data.get(index)+<span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述标签库 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是对于标签库的介绍 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>我们这个标签库, 是闲的慌 , 所以写的.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述标签库的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>xdl<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签库的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>11.88<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 建议的短命名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>xdl<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签库的表示, 用于引入时匹配标签库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://shuidianshuisg.com<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开始描述标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对于标签的介绍 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>这个标签用于随机向网页中, 输出一句名言<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>heiheihei<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签所对应的的Java类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.xdl.tag.MyTag1<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签的内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id9"><span></span></span></p><h3 id="9-JavaWeb三大组件-Servlet-filter-Lister"><a href="#9-JavaWeb三大组件-Servlet-filter-Lister" class="headerlink" title="9. JavaWeb三大组件(Servlet,filter,Lister)"></a>9. JavaWeb三大组件(Servlet,filter,Lister)</h3><h4 id="9-1-Filter过滤器"><a href="#9-1-Filter过滤器" class="headerlink" title="9.1 Filter过滤器"></a>9.1 Filter过滤器</h4><ul><li>请求的过滤器，面向切面编程思想（AOP）</li><li>使用步骤：<ol><li>编写一个类，实现Filter接口</li><li>通过注解或web.xml配置过滤器规则</li></ol></li><li>过滤器链：<ul><li>当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求</li></ul></li><li>过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml）<ul><li>注解方式：按照类名的自然顺序先后</li><li>web.xml配置方式：按照web.xml配置顺序，先后执行</li></ul></li><li>案例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/home.jsp"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Filter即将销毁时执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有新的请求, 满足了过滤器的过滤规则,  正在过滤</span></span><br><span class="line"><span class="comment">     * 参数1.   请求对象</span></span><br><span class="line"><span class="comment">     * 参数2. 响应对象</span></span><br><span class="line"><span class="comment">     * 参数3.  过滤器链对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"过滤管理员登录的过滤器 正在执行"</span>);</span><br><span class="line">        <span class="comment">//1.    从请求中, 得到session</span></span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="comment">//2.    判断session中是否存在username</span></span><br><span class="line">        Object username = session.getAttribute(<span class="string">"username"</span>);</span><br><span class="line">        <span class="comment">//3.    如果存在, 且值为admin , 则放行 </span></span><br><span class="line">        <span class="keyword">if</span>(username !=<span class="keyword">null</span> &amp;&amp; username.equals(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4.    否则拦截, 并响应, 提示请先以管理员身份登录</span></span><br><span class="line">            response.getWriter().append(<span class="string">"&lt;script&gt;alert('请先以管理员身份登录, 再访问管理页面');window.location.href='login.jsp'&lt;/script&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Filter初始化时 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web.xml配置方式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.xdl.demo1.EnCodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/home.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-Listener监听器"><a href="#9-2-Listener监听器" class="headerlink" title="9.2 Listener监听器"></a>9.2 Listener监听器</h4><ul><li>监听服务器的一些状态事件，事件驱动机制。</li><li>分为两类状态事件：<ul><li>服务器中组件的生命周期</li><li>一些域对象中数据变化的事件</li></ul></li><li>监听服务器的启动与关闭：ServletContextListener</li><li>监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener</li><li>监听Session会话的开启与关闭：HttpSessionListener </li><li>监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener </li></ul><p><span id="id10"><span></span></span></p><h3 id="10-JSON在Java中的使用"><a href="#10-JSON在Java中的使用" class="headerlink" title="10. JSON在Java中的使用"></a>10. JSON在Java中的使用</h3><ul><li>JSON：JavaScript Object Notation</li><li>GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入jar文件</span></span><br><span class="line">Gson g = <span class="keyword">new</span> Gson();</span><br><span class="line">String str = g.toJson(Java对象);<span class="comment">//转换JSON字符串</span></span><br><span class="line">类型 对象名 = g.fromJson(Json字符串, 类型.class);<span class="comment">//转换为Java对象</span></span><br></pre></td></tr></table></figure><p><span id="id11"><span></span></span></p><h3 id="11-AJAX"><a href="#11-AJAX" class="headerlink" title="11. AJAX"></a>11. AJAX</h3><ul><li>一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作</li><li>Ajax请求的状态（readyState）<ul><li>0：正在初始化</li><li>1：请求正在发送</li><li>2：请求发送完毕</li><li>3：服务器开始响应</li><li>4：响应接收完毕，连接断开</li></ul></li><li>Ajax响应的状态（status）<ul><li>200：成功</li><li>404：找不到资源</li><li>500：服务器错误</li></ul></li></ul><h4 id="11-1-GET请求AJAX"><a href="#11-1-GET请求AJAX" class="headerlink" title="11.1 GET请求AJAX"></a>11.1 GET请求AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"地址?参数列表"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//通过xhr.responseText接收响应体</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//失败处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h4 id="11-2-POST请求AJAX"><a href="#11-2-POST请求AJAX" class="headerlink" title="11.2 POST请求AJAX"></a>11.2 POST请求AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"地址"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//通过xhr.responseText接收响应体</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//失败处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//POST请求设置请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>); </span><br><span class="line">xhr.send(参数列表); <span class="comment">//发送请求参数</span></span><br></pre></td></tr></table></figure><h4 id="11-2-Jquery中的AJAX"><a href="#11-2-Jquery中的AJAX" class="headerlink" title="11.2 Jquery中的AJAX"></a>11.2 Jquery中的AJAX</h4><ol><li><code>$.ajax({url,[settings]})</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"请求的网址"</span>,</span><br><span class="line">    type:<span class="string">"请求方式GET/POST..."</span>,</span><br><span class="line">    <span class="keyword">async</span>:<span class="string">"请求是否异步, 默认true"</span>,</span><br><span class="line">    data:<span class="string">"请求的参数列表, 格式与GET请求?后的格式一致"</span>,</span><br><span class="line">    dataType:<span class="string">"TEXT或JSON"</span>,<span class="comment">//服务器返回的数据类型</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="comment">//当服务器响应状态码在200-299之间时, 这里执行</span></span><br><span class="line">        <span class="comment">//参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//当服务器响应状态码不再200-299之间时, 这里执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>$.get(url, [data], [callback], [type])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>("请求的网址", &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><code>$.post(url, [data], [callback], [type])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;, <span class="string">"json"</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li><code>$.getJSON(url, [data], [callback])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li><code>jquery对象.load(url, [data], [callback])</code></li></ol><ul><li>载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#dom"</span>).load(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//加载成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="11-3-Vue中的AJAX"><a href="#11-3-Vue中的AJAX" class="headerlink" title="11.3 Vue中的AJAX"></a>11.3 Vue中的AJAX</h4><ul><li>使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js</li><li>不创建Vue对象的情况下, 使用的ajax:<ul><li><code>Vue.http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li><li><code>Vue.http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li></ul></li><li>创建Vue实例, 使用ajax<ul><li><code>this.$http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li><li><code>this.$http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GET请求: 传递参数列表: </span></span><br><span class="line">&#123;</span><br><span class="line">    params:&#123;</span><br><span class="line">        参数名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">        参数名<span class="number">2</span>:值<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">POST请求: 传递参数列表:</span><br><span class="line">&#123;</span><br><span class="line">    参数名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">    参数名<span class="number">2</span>:值<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>success函数 与 error函数<ul><li>格式: function(res){} //res , 就是响应对象, 包含了响应的相关信息</li><li>响应对象的常用属性:<ol><li>url : 响应的网址</li><li>body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string</li><li>ok  : boolean值, 响应码在200-299之间时  为 true</li><li>status : 响应码, 例如: 200,302,404,500</li><li>statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok</li></ol></li><li>响应对象的常用函数:<ol><li>text() : 以字符串的形式, 返回响应体</li><li>json() : 以对象的形式, 返回响应体</li><li>blob() : 以二进制的形式 , 返回响应体.</li></ol></li></ul></li></ul><h4 id="11-4-AJAX缓存问题"><a href="#11-4-AJAX缓存问题" class="headerlink" title="11.4 AJAX缓存问题"></a>11.4 AJAX缓存问题</h4><ul><li>浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。</li><li>缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。</li><li>在请求地址加上随机参数可以比避免缓存，如:<code>&quot;s1.do?time=&quot;+new Date().getTime();</code></li></ul><h4 id="11-5-AJAX跨域问题"><a href="#11-5-AJAX跨域问题" class="headerlink" title="11.5 AJAX跨域问题"></a>11.5 AJAX跨域问题</h4><ul><li>默认编写的Servlet . 不允许其他网站的ajax跨域请求.</li><li>我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域:<ul><li><code>response.addHeader(&quot;Access-Control-allow-Origin&quot;,&quot;*&quot;)</code>;</li><li><code>response.addHeader(&quot;Access-Control-allow-Methods&quot;,&quot;GET,POST&quot;)</code>;</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
  </entry>
  
  <entry>
    <title>十一、JavaSE数据结构与算法入门</title>
    <link href="http://chaooo.github.io/2019/07/15/11_JavaSE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8.html"/>
    <id>http://chaooo.github.io/2019/07/15/11_JavaSE数据结构与算法入门.html</id>
    <published>2019-07-15T10:12:38.000Z</published>
    <updated>2019-07-20T15:08:05.419Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。</p><a id="more"></a><ol><li><a href="#id1">Java数据结构</a></li><li><a href="#id2">时间复杂度与空间复杂度</a></li><li><a href="#id3">算法的基本概念</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-Java数据结构-Data-Structure"><a href="#1-Java数据结构-Data-Structure" class="headerlink" title="1.Java数据结构(Data Structure)"></a>1.Java数据结构(Data Structure)</h3><h4 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h4><ol><li>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</li><li>而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。</li><li>而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</li></ol><h4 id="1-2-Java数据结构"><a href="#1-2-Java数据结构" class="headerlink" title="1.2 Java数据结构"></a>1.2 Java数据结构</h4><ul><li>数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。<ol><li>线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。</li><li>非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。</li></ol></li><li>按数据的存储结构分为：顺序存储结构和链式存储结构<ol><li>顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 </li><li>链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。</li></ol></li></ul><h4 id="1-2-1-线性数据结构"><a href="#1-2-1-线性数据结构" class="headerlink" title="1.2.1 线性数据结构"></a>1.2.1 线性数据结构</h4><p>常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。</p><ol><li>一维数组<ul><li>在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。</li><li>ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。</li><li>数组的插入/更新/删除效率比较低，而<strong>查询效率非常高</strong>,查询效率时间复杂度是1。</li></ul></li><li>线性表<ul><li>线性表是有序的储存结构、链式的储存结构。</li><li>链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。</li><li>常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。</li><li>线性表<strong>插入效率比较高</strong>，而查询效率就比较低（add(),get()）。</li></ul></li><li>栈Stack<ul><li>栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。</li></ul></li><li>队列<ul><li>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。</li><li>Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</li><li>使用场景也非常多，如线程池，mq，连接池等。</li></ul></li><li>串<ul><li>串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）</li></ul></li></ol><h4 id="1-2-2-非线性数据结构"><a href="#1-2-2-非线性数据结构" class="headerlink" title="1.2.2 非线性数据结构"></a>1.2.2 非线性数据结构</h4><p>常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。</p><ol><li>多维数组<ul><li>Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</li></ul></li><li>集合<ul><li>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</li></ul></li><li>树<ul><li>在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。</li><li>除了根节点，其他结点有且只有一个直接父节点</li><li>每个结点可以有任意多个直接子节点。</li><li>树的数据结构又分为：<ol><li>自由树/普通树：对子节点没有任何约束。</li><li>二叉树：每个节点最多含有两个子节点的树称为二叉树。</li><li>二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）</li><li>B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。</li><li>B+tree：又称B+。是B-树的变体，也是一种多路搜索树。</li></ol></li></ul></li><li>Hash<ul><li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）</li><li>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li><li>Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。</li><li>Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</li><li>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</li></ul></li><li>图<ul><li>图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</li></ul></li></ol><h3 id="2-时间复杂度与空间复杂度"><a href="#2-时间复杂度与空间复杂度" class="headerlink" title="2. 时间复杂度与空间复杂度"></a>2. 时间复杂度与空间复杂度</h3><h4 id="2-1-时间复杂度"><a href="#2-1-时间复杂度" class="headerlink" title="2.1 时间复杂度"></a>2.1 时间复杂度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为<strong>T(n)</strong></p><p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。</p><p>有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。</p><p>常见的算法的时间 复杂度之间的关系为：<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</code></p><h4 id="2-2-空间复杂度"><a href="#2-2-空间复杂度" class="headerlink" title="2.2 空间复杂度"></a>2.2 空间复杂度</h4><p>空间复杂度：算法所需存储空间的度量，记作：<code>S(n)=O( f(n) )</code>，其中 n 为问题的规模。</p><p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p><p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p><blockquote><ul><li>空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。</li><li>时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。</li><li>稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。</li></ul></blockquote><h3 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h3><ul><li>算法: 简单来说就是解决问题的步骤。</li><li>算法的五个特征:有穷性，确定性，可行性，有输入，有输出<ol><li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li><li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li><li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li><li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li><li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li></ol></li><li>算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求<ul><li>描述算法的速度必须要和数据项的个数联系起来。</li><li>算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；</li><li>一个算法的效率越高越好，而存储量是越低越好。</li></ul></li></ul><h3 id="4-常用的查找算法"><a href="#4-常用的查找算法" class="headerlink" title="4. 常用的查找算法"></a>4. 常用的查找算法</h3><h4 id="4-1-线性（顺序）查找算法"><a href="#4-1-线性（顺序）查找算法" class="headerlink" title="4.1 线性（顺序）查找算法"></a>4.1 线性（顺序）查找算法</h4><ol><li>使用目标元素与样本数列中第一个元素起依次进行比较</li><li>若目标元素等于样本元素，则表示查找成功</li><li>若目标元素与样本元素比较完毕也不相等，则表示查找失败</li></ol><h4 id="4-2-二分查找算法"><a href="#4-2-二分查找算法" class="headerlink" title="4.2 二分查找算法"></a>4.2 二分查找算法</h4><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。</p><ul><li>普通循环实现二分查找算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(srcArray, <span class="number">28</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找普通循环实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcArray 有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 查找元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span> srcArray[], <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = srcArray.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == srcArray[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = srcArray.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p></blockquote><ul><li>递归实现二分查找递归实现算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(srcArray, <span class="number">0</span>,<span class="number">15</span>,<span class="number">28</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcArray  有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 数组低地址下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end   数组高地址下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  查找元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 查找元素不存在返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span> srcArray[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">    <span class="keyword">if</span> (srcArray[mid] == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(srcArray, mid + <span class="number">1</span>, end, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(srcArray, start, mid - <span class="number">1</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p></blockquote><h3 id="4-常用的排序算法"><a href="#4-常用的排序算法" class="headerlink" title="4. 常用的排序算法"></a>4. 常用的排序算法</h3><ul><li>八大排序算法<ul><li>一、直接插入排序（Insertion Sort）</li><li>二、希尔排序（Shell Sort）</li><li>三、选择排序（Selection Sort）</li><li>四、堆排序（Heap Sort）</li><li>五、冒泡排序（Bubble Sort）</li><li>六、快速排序（Quick Sort）</li><li>七、归并排序（Merging Sort）</li><li>八、基数排序（Radix Sort）</li></ul></li></ul><h4 id="4-1-冒泡排序算法"><a href="#4-1-冒泡排序算法" class="headerlink" title="4.1 冒泡排序算法"></a>4.1 冒泡排序算法</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><ul><li><p>算法描述：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</li></ol></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//声明标志位</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="keyword">int</span> temp = arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j++<span class="number">1</span>] = temp;</span><br><span class="line">          flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//若此轮结束flag还是为true,则证明已经有序</span></span><br><span class="line">      <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>冒泡排序算法复杂度:</p><ul><li>平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)</li><li>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</li></ul></li></ul><blockquote><p>Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。&lt;br&gt;算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>十、JavaSE常用设计模式</title>
    <link href="http://chaooo.github.io/2019/07/15/10_JavaSE%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://chaooo.github.io/2019/07/15/10_JavaSE常用设计模式.html</id>
    <published>2019-07-15T00:34:55.000Z</published>
    <updated>2019-07-20T15:03:36.395Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><a id="more"></a><ol><li><a href="#id1">常用的设计原则</a></li><li><a href="#id2">设计模式分类</a></li><li><a href="#id3">单例模式</a></li><li><a href="#id4">模板模式</a></li><li><a href="#id5">工厂模式</a></li><li><a href="#id6">适配器模式</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-常用的设计原则"><a href="#1-常用的设计原则" class="headerlink" title="1.常用的设计原则"></a>1.常用的设计原则</h3><ul><li><strong>开闭原则</strong>：对扩展开发，对修改方便</li><li><strong>里氏代换原则</strong>：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）</li><li><strong>依赖倒转原则</strong>：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li><li><strong>接口隔离原则</strong>：尽量多依赖小接口而不是大接口</li><li><strong>迪米特法则</strong>（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。</li><li><strong>合成复用原则</strong>：尽量多使用合成/聚合的方式，而不是继承的方式。</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2.设计模式分类"></a>2.设计模式分类</h3><h4 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><ul><li>设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。</li><li>设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。</li><li>设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性</li></ul><h4 id="2-2-具体分类"><a href="#2-2-具体分类" class="headerlink" title="2.2 具体分类"></a>2.2 具体分类</h4><ol><li><strong>创建型模式</strong>：<em>用于对象创建的过程</em><ul><li><strong>单例模式</strong>、<strong>工厂方法模式</strong>、抽象工厂模式、建造者模式(生成器模式)、原型模式</li></ul></li><li><strong>结构型模式</strong>：<em>用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构</em><ul><li>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)</li></ul></li><li><strong>行为型模式</strong>：<em>用于解决类或对象之间的交互，更合理的优化类或对象之间的关系</em><ul><li>责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、<strong>模板模式</strong>、访问者模式、备忘录模式、</li></ul></li><li>JEE 设计模式<ul><li>数据访问对象模式 </li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-单例模式（Singleton）"><a href="#3-单例模式（Singleton）" class="headerlink" title="3.单例模式（Singleton）"></a>3.单例模式（Singleton）</h3><h4 id="3-1-实现流程："><a href="#3-1-实现流程：" class="headerlink" title="3.1 实现流程："></a>3.1 实现流程：</h4><ol><li>私有的构造方法</li><li>私有的静态的当前类的对象作为属性</li><li>共有的静态方法返回当前对象<h4 id="3-1-实现方式："><a href="#3-1-实现方式：" class="headerlink" title="3.1 实现方式："></a>3.1 实现方式：</h4></li><li>饿汉式：立即加载，对象启动时就加载</li><li>懒汉式：延迟加载，对象什么时候用到时才会加载</li><li>生命周期托管：单例对象交给别人处理</li></ol><p><span id="id4"><span></span></span></p><h3 id="4-模板模式"><a href="#4-模板模式" class="headerlink" title="4.模板模式"></a>4.模板模式</h3><p>在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。</p><ul><li>eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">      initialize();</span><br><span class="line">      start();</span><br><span class="line">      end();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 不同子类以不同方法实现抽象类的的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span> <span class="keyword">extends</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Initialized!."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Started."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> <span class="keyword">extends</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Initialized!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Started!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Software s1 = <span class="keyword">new</span> Browser();</span><br><span class="line">      s1.play();</span><br><span class="line">      s1 = <span class="keyword">new</span> Editor();</span><br><span class="line">      s1.play();    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-模式模式优缺点："><a href="#4-1-模式模式优缺点：" class="headerlink" title="4.1 模式模式优缺点："></a>4.1 模式模式优缺点：</h4><ol><li>优点<ul><li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li></ul></li><li>缺点<ul><li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li></ul></li><li>适用场景<ul><li>在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。</li></ul></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5. 工厂模式"></a>5. 工厂模式</h3><ol><li>简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；</li><li>工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；</li><li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。</li></ol><h4 id="5-1-简单工厂模式的实现："><a href="#5-1-简单工厂模式的实现：" class="headerlink" title="5.1 简单工厂模式的实现："></a>5.1 简单工厂模式的实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span></span>; &#125;</span><br><span class="line">  <span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span> </span>&#123; <span class="comment">/*苹果*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pear</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span> </span>&#123; <span class="comment">/* 梨 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"apple"</span>)) &#123;<span class="comment">//生产苹果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pear"</span>)) &#123;<span class="comment">//生产梨</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">FruitFactory mFactory = <span class="keyword">new</span> FruitFactory();</span><br><span class="line">Apple apple = (Apple) mFactory.createFruit(<span class="string">"apple"</span>);<span class="comment">//获得苹果</span></span><br><span class="line">Pear pear = (Pear) mFactory.createFruit(<span class="string">"pear"</span>);<span class="comment">//获得梨</span></span><br></pre></td></tr></table></figure><blockquote><p>简单工厂只适合于产品对象较少，且产品固定的需求</p></blockquote><h4 id="5-2-工厂方法模式实现："><a href="#5-2-工厂方法模式实现：" class="headerlink" title="5.2 工厂方法模式实现："></a>5.2 工厂方法模式实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Fruit <span class="title">createFruit</span><span class="params">()</span></span>;<span class="comment">//生产水果</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PearFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">AppleFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">PearFactory pearFactory = <span class="keyword">new</span> PearFactory();</span><br><span class="line">Apple apple = (Apple) appleFactory.createFruit();<span class="comment">//获得苹果</span></span><br><span class="line">Pear pear = (Pear) pearFactory.createFruit();<span class="comment">//获得梨</span></span><br></pre></td></tr></table></figure><blockquote><p>工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂</p></blockquote><h4 id="5-3-抽象工厂模式实现："><a href="#5-3-抽象工厂模式实现：" class="headerlink" title="5.3 抽象工厂模式实现："></a>5.3 抽象工厂模式实现：</h4><ul><li>抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；</li><li>eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// cpu接口和实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cpu650</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">/* 625 也厉害 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cpu825</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* 825 处理更强劲 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 屏幕接口和实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Screen5</span> <span class="keyword">implements</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="comment">/* 5寸 */</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Screen6</span> <span class="keyword">implements</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">/* 6寸 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Cpu <span class="title">getCpu</span><span class="params">()</span></span>;<span class="comment">//使用的cpu</span></span><br><span class="line">    <span class="function">Screen <span class="title">getScreen</span><span class="params">()</span></span>;<span class="comment">//使用的屏幕</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 具体工厂实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cpu.Cpu825();<span class="comment">//高性能处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Screen <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Screen.Screen6();<span class="comment">//6寸大屏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HongMiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cpu.Cpu650();<span class="comment">//高效处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Screen <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Screen.Screen5();<span class="comment">//小屏手机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；</p></blockquote><h4 id="5-4-三种工厂方式总结："><a href="#5-4-三种工厂方式总结：" class="headerlink" title="5.4 三种工厂方式总结："></a>5.4 三种工厂方式总结：</h4><ol><li>对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；</li><li>抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；</li></ol><p><span id="id6"><span></span></span></p><h3 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6.适配器模式（Adapter）"></a>6.适配器模式（Adapter）</h3><ul><li>适配器模式Adapter是结构型模式的一种，分为<strong>类适配器模式</strong>，<strong>对象适配器模式</strong>，<strong>缺省适配器模式</strong>。<ul><li>类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；</li><li>对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。</li></ul></li></ul><blockquote><p>适配器模式的缺点<br><br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p></blockquote><h4 id="6-1-缺省适配器模式"><a href="#6-1-缺省适配器模式" class="headerlink" title="6.1 缺省适配器模式"></a>6.1 缺省适配器模式</h4><ul><li>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</li><li>缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)</li><li>适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>九、JavaSE网络编程</title>
    <link href="http://chaooo.github.io/2019/07/12/09_JavaSE%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"/>
    <id>http://chaooo.github.io/2019/07/12/09_JavaSE网络编程.html</id>
    <published>2019-07-12T03:59:46.000Z</published>
    <updated>2019-07-20T15:01:52.870Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br>java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p><a id="more"></a><ol><li><a href="#id1">网络编程常识</a></li><li><a href="#id2">基于tcp协议的编程模型</a></li><li><a href="#id3">基于udp协议的编程模型</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-网络编程常识"><a href="#1-网络编程常识" class="headerlink" title="1. 网络编程常识"></a>1. 网络编程常识</h3><h4 id="1-1-七层网络模型"><a href="#1-1-七层网络模型" class="headerlink" title="1.1 七层网络模型"></a>1.1 七层网络模型</h4><p>为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：<br><br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><ul><li>当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；</li><li>当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；</li></ul><h4 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h4><ul><li>IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。</li><li>日常生活中采用<strong>点分十进制</strong>表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1</li></ul><h4 id="1-3-端口号"><a href="#1-3-端口号" class="headerlink" title="1.3 端口号"></a>1.3 端口号</h4><ul><li>根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。</li><li>网络编程需要提供：IP地址 和 端口号</li><li>端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。</li></ul><h4 id="1-4-tcp协议与udp协议"><a href="#1-4-tcp协议与udp协议" class="headerlink" title="1.4 tcp协议与udp协议"></a>1.4 tcp协议与udp协议</h4><ul><li>TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。</li><li>UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li><li>tcp协议与udp协议比较：</li></ul><table><thead><tr><th>tcp协议</th><th>udp协议</th></tr></thead><tbody><tr><td>传输控制协议，面向连接</td><td>用户数据报协议，非面向连接</td></tr><tr><td>通信过程全程保持连接</td><td>通信过程不需要全程连接</td></tr><tr><td>保证了数据传输的可靠性和有序性</td><td>不保证数据传输的可靠性和有序性</td></tr><tr><td>全双工的字节流的通信方式</td><td>全双工的数据报的通信方式</td></tr><tr><td>服务器的资源消耗多，压力大，效率低</td><td>服务器资源消耗少，压力小，效率高</td></tr></tbody></table><p><span id="id2"><span></span></span></p><h3 id="2-基于tcp协议的编程模型"><a href="#2-基于tcp协议的编程模型" class="headerlink" title="2. 基于tcp协议的编程模型"></a>2. 基于tcp协议的编程模型</h3><h4 id="2-1-编程模型"><a href="#2-1-编程模型" class="headerlink" title="2.1 编程模型"></a>2.1 编程模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器端                         客户端</span><br><span class="line"></span><br><span class="line">创建监听服务</span><br><span class="line">等待连接    &lt;----建立连接------  连接服务器           </span><br><span class="line">进行通讯    &lt;----进行通讯-----&gt;  进行通讯</span><br><span class="line">关闭连接                        关闭连接</span><br></pre></td></tr></table></figure><ul><li>服务器：<ol><li>创建ServerSocket类型的对象并提供端口号；</li><li>等待客户端的连接请求，调用accept方法；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li><li>客户端：<ol><li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li></ul><h4 id="2-2-ServerSocket类和Socket类"><a href="#2-2-ServerSocket类和Socket类" class="headerlink" title="2.2 ServerSocket类和Socket类"></a>2.2 ServerSocket类和Socket类</h4><ul><li>java.net.ServerSocket类主要用于描述服务器套接字信息。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>根据参数指定的端口号来构造对象</td></tr><tr><td>Socket accept()</td><td>监听并接收到此套接字的连接请求</td></tr><tr><td>void close()</td><td>用于关闭套接字</td></tr></tbody></table><ul><li>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>Socket(String host, int port)</td><td>根据指定主机名和端口号来构造对象</td></tr><tr><td>InputStream getInputStream()</td><td>用于获取当前套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>用于获取当前套接字的输出流</td></tr><tr><td>void close()</td><td>用于关闭套接字</td></tr></tbody></table><p><span id="id3"><span></span></span></p><h3 id="3-客户端与服务端通信演示："><a href="#3-客户端与服务端通信演示：" class="headerlink" title="3.客户端与服务端通信演示："></a>3.客户端与服务端通信演示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Socket s;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 3.使用输入输出流进行通信</span></span><br><span class="line">      BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">          <span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">      PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 实现服务器接收到字符串内容后打印出来</span></span><br><span class="line">        <span class="comment">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class="line">        String str = br.readLine();</span><br><span class="line">        <span class="comment">//System.out.println("服务器接收到的数据是：" + str);</span></span><br><span class="line">        <span class="comment">// 当服务器接收到"bye"后，则聊天结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"bye"</span>.equalsIgnoreCase(str)) &#123;</span><br><span class="line">          System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() + <span class="string">"已下线！"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() </span><br><span class="line">          + <span class="string">"发来的消息是："</span> + str);  </span><br><span class="line">        <span class="comment">// 当服务器接收到客户端发来的消息后，向客户端回发消息"I received!"</span></span><br><span class="line">        ps.println(<span class="string">"I received!"</span>);</span><br><span class="line">        <span class="comment">//System.out.println("服务器发送数据成功！");</span></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 4.关闭Socket</span></span><br><span class="line">      ps.close();</span><br><span class="line">      br.close();</span><br><span class="line">      s.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStringTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建ServerSocket类型的对象并提供端口号</span></span><br><span class="line">      ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">      <span class="comment">// 2.等待客户端的连接请求，调用accept方法</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"等待客户端的连接请求..."</span>);</span><br><span class="line">        <span class="comment">// 当没有客户端连接时，阻塞在accept方法的调用这里</span></span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        <span class="comment">// 获取连接成功的客户端通信地址</span></span><br><span class="line">        System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() + <span class="string">"连接成功！"</span>);</span><br><span class="line">        <span class="comment">// 当有客户端连接成功后，则启动一个新的线程为之服务</span></span><br><span class="line">        <span class="keyword">new</span> ServerThread(s).start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//ss.close();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientStringTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建Socket类型的对象并提供服务器的通信地址和端口号</span></span><br><span class="line">      Socket s = <span class="keyword">new</span> Socket(<span class="string">"XDL-20170621QCO"</span>, <span class="number">8888</span>);</span><br><span class="line">      System.out.println(<span class="string">"连接服务器成功！"</span>);</span><br><span class="line">      <span class="comment">// 2.使用输入输出流进行通信</span></span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">      BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">          <span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞</span></span><br><span class="line">        <span class="comment">//Thread.sleep(10000);</span></span><br><span class="line">        <span class="comment">// 练习：实现客户端向服务器发送的内容由用户从键盘输入</span></span><br><span class="line">        System.out.println(<span class="string">"请输入要发送的内容："</span>);</span><br><span class="line">        <span class="comment">//String msg = sc.next(); // 读取字符串内容时，遇到空格停止</span></span><br><span class="line">        String msg = sc.nextLine();</span><br><span class="line">        <span class="comment">// 实现客户端向服务器发送字符串内容"hello"</span></span><br><span class="line">        <span class="comment">//ps.println("hello");</span></span><br><span class="line">        ps.println(msg);</span><br><span class="line">        System.out.println(<span class="string">"客户端发送数据成功！"</span>);</span><br><span class="line">        <span class="comment">// 判断客户端发送的内容是否为"bye"，若是则聊天结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"bye"</span>.equalsIgnoreCase(msg)) &#123;</span><br><span class="line">          System.out.println(<span class="string">"聊天结束！"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现服务器回发消息的接收</span></span><br><span class="line">        <span class="comment">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class="line">        String str = br.readLine();</span><br><span class="line">        System.out.println(<span class="string">"客户端接收到的数据是："</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.关闭Socket</span></span><br><span class="line">      br.close();</span><br><span class="line">      sc.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      s.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-基于udp协议的编程模型"><a href="#4-基于udp协议的编程模型" class="headerlink" title="4. 基于udp协议的编程模型"></a>4. 基于udp协议的编程模型</h3><h4 id="4-1-编程模型"><a href="#4-1-编程模型" class="headerlink" title="4.1 编程模型"></a>4.1 编程模型</h4><ul><li>主机A(接收方):<ol><li>创建DatagramSocket类型的对象，并提供端口号；</li><li>创建DatagramPacket类型的对象，用于接收发来的数据；</li><li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li><li>主机B(发送方)<ol><li>创建DatagramSocket类型的对象；</li><li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li><li>通过Socket发送数据，调用<strong>send()</strong>方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li></ul><h4 id="4-2-DatagramSocket类"><a href="#4-2-DatagramSocket类" class="headerlink" title="4.2 DatagramSocket类"></a>4.2 DatagramSocket类</h4><ul><li>java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>无参的方式构造对象。</td></tr><tr><td>DatagramSocket(int port)</td><td>根据参数指定的端口号来构造对象。</td></tr><tr><td>void receive(DatagramPacket p)</td><td>用于接收数据并存放到参数指定的变量中。</td></tr><tr><td>void send(DatagramPacket p)</td><td>用于将参数指定的数据发送出去。</td></tr><tr><td>void close()</td><td></td></tr></tbody></table><h4 id="4-3-DatagramPacket类"><a href="#4-3-DatagramPacket类" class="headerlink" title="4.3 DatagramPacket类"></a>4.3 DatagramPacket类</h4><ul><li>java.net.DatagramPacket类用于描述数据报信息(信件)；</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int length)</td><td>用于接收数据包并记录到参数变量中；</td></tr><tr><td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td><td>用于将参数指定的数据发送到参数指定的位置</td></tr><tr><td>InetAddress getAddress()</td><td>用于获取发送方或接收方的通信地址信息。</td></tr><tr><td>int getPort()</td><td>用于获取发送方或接收方的端口信息。</td></tr><tr><td>int getLength()</td><td>用于获取发送或接收数据的长度。</td></tr></tbody></table><h4 id="4-4-InetAddress类"><a href="#4-4-InetAddress类" class="headerlink" title="4.4 InetAddress类"></a>4.4 InetAddress类</h4><ul><li>java.net.InetAddress类用于描述互联网协议地址。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>static InetAddress getLocalHost()</td><td>用于获取本地主机的通信地址信息。</td></tr><tr><td>static InetAddress getByName(String host)</td><td>根据参数指定的主机名来获取通信地址。</td></tr><tr><td>String getHostName()</td><td>用于获取通信地址中的主机名信息。</td></tr><tr><td>String getHostAddress()</td><td>用于获取通信地址中的IP地址信息。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。&lt;br&gt;java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谈谈开源</title>
    <link href="http://chaooo.github.io/2019/07/11/%E8%B0%88%E8%B0%88%E5%BC%80%E6%BA%90.html"/>
    <id>http://chaooo.github.io/2019/07/11/谈谈开源.html</id>
    <published>2019-07-11T12:13:15.000Z</published>
    <updated>2019-08-27T15:02:02.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是开源"><a href="#什么是开源" class="headerlink" title="什么是开源"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p><p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p><a id="more"></a><p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p><h3 id="开源是否等于免费"><a href="#开源是否等于免费" class="headerlink" title="开源是否等于免费"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p><p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p><p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p><p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p><p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p><h3 id="为什么要选择开源软件"><a href="#为什么要选择开源软件" class="headerlink" title="为什么要选择开源软件"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p><p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p><p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p><p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p><p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p><blockquote><p>参考连接：</p><ul><li><a href="https://blog.csdn.net/happmaoo/article/details/83201544" target="_blank" rel="noopener">https://blog.csdn.net/happmaoo/article/details/83201544</a></li><li><a href="https://www.oschina.net/news/58921/what-is-open-source" target="_blank" rel="noopener">https://www.oschina.net/news/58921/what-is-open-source</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是开源&quot;&gt;&lt;a href=&quot;#什么是开源&quot; class=&quot;headerlink&quot; title=&quot;什么是开源&quot;&gt;&lt;/a&gt;什么是开源&lt;/h3&gt;&lt;p&gt;所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。&lt;/p&gt;
&lt;p&gt;在IT领域来说的话，字面意思就是&lt;strong&gt;开放源代码&lt;/strong&gt;，开源软件的源代码任何人都可以审查、修改和增强。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://chaooo.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="开源" scheme="http://chaooo.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
</feed>
