<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路，走过去，前面是个天！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chaooo.github.io/"/>
  <updated>2020-02-23T15:37:07.664Z</updated>
  <id>http://chaooo.github.io/</id>
  
  <author>
    <name>郑超(Charles·Zheng)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java知识梳理】对象的拷贝与原型模式</title>
    <link href="http://chaooo.github.io/article/20200223.html"/>
    <id>http://chaooo.github.io/article/20200223.html</id>
    <published>2020-02-23T15:19:12.000Z</published>
    <updated>2020-02-23T15:37:07.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-拷贝的概念"><a href="#1-拷贝的概念" class="headerlink" title="1. 拷贝的概念"></a>1. 拷贝的概念</h3><p>对象的拷贝（复制，克隆）：根据原来的对象”复制”一份 属性、状态一致的新对象。<br><strong>浅拷贝</strong>：只”复制”对象的第一层属性，即：浅拷贝将返回该类的新的实例，该实例的引用类型对象共享。<br><strong>深拷贝</strong>：对象的属性进行递归”复制”，即：深拷贝也会返回该类的新的实例，但是该实例的引用类型属性也是拷贝的新对象。</p><a id="more"></a><h4 id="1-1-对象拷贝的应用场景"><a href="#1-1-对象拷贝的应用场景" class="headerlink" title="1.1 对象拷贝的应用场景"></a>1.1 对象拷贝的应用场景</h4><ol><li>构造数据时，需要构造多个类似的对象且只有其中少数值不同，可以利用对象拷贝的方式简化代码。</li><li>多线程环境中，可以利用对象拷贝的方式让各个线程对对象的修改互不影响。</li></ol><h4 id="1-2-浅拷贝和深拷贝的区别"><a href="#1-2-浅拷贝和深拷贝的区别" class="headerlink" title="1.2 浅拷贝和深拷贝的区别"></a>1.2 浅拷贝和深拷贝的区别</h4><p><img src="http://cdn.chaooo.top/Java/clone.png" alt></p><p>浅拷贝和深拷贝的主要区别在于<strong>对于引用类型是否共享</strong>。</p><h3 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2. 浅拷贝"></a>2. 浅拷贝</h3><p><code>Object</code>的<code>clone</code>函数默认是浅拷贝，可以从源码中找到答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates and returns a copy of this object.  The precise meaning</span></span><br><span class="line"><span class="comment">   * of "copy" may depend on the class of the object. The general</span></span><br><span class="line"><span class="comment">   * intent is that ...</span></span><br><span class="line"><span class="comment">   * 具体注释请查看源码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从源码的注释中了解到：</p><ul><li>如果调用<code>clone</code>函数的类没有实现<code>Cloneable</code>接口将会抛出<code>CloneNotSupportedException</code>。</li><li>所有的数组对象都默认实现了<code>Cloneable</code>接口。</li><li><code>clone</code>函数实现的是浅拷贝而不是深拷贝。</li></ul><h4 id="3-1-通过编码验证"><a href="#3-1-通过编码验证" class="headerlink" title="3.1 通过编码验证"></a>3.1 通过编码验证</h4><ol><li>准备两个实体类：产品<code>Product</code>和订单<code>Order</code>，并且订单实现<code>Cloneable</code>接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; products;</span><br><span class="line">    <span class="comment">/** Object的clone函数用protected修饰，需要重写 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Order) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写测试方法验证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">mock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setId(<span class="number">1L</span>);</span><br><span class="line">        order.setOrderNo(<span class="string">"N001"</span>);</span><br><span class="line">        List&lt;Product&gt; products = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Product item = <span class="keyword">new</span> Product();</span><br><span class="line">        item.setId(<span class="number">0L</span>);</span><br><span class="line">        item.setName(<span class="string">"第一个商品名称"</span>);</span><br><span class="line">        products.add(item);</span><br><span class="line">        order.setProducts(products);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShallowClone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Order order = mock();</span><br><span class="line">        Order cloneOrder = order.clone();</span><br><span class="line">        assertFalse(order == cloneOrder);</span><br><span class="line">        assertTrue(order.getProducts() == cloneOrder.getProducts());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该单元测试可以通过，从而证实了<code>clone</code>函数的注释，证实了浅拷贝的表现。<br>因此如果使用浅拷贝，修改拷贝订单的商品列表，那么原始订单对象的商品列表也会受到影响。</p><h3 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3. 深拷贝"></a>3. 深拷贝</h3><p>虽然浅拷贝能够实现拷贝的功能，但是浅拷贝的引用类型成员变量是共享的，修改极可能导致相互影响。<br>深拷贝有两种实现方式，一种是<code>Cloneable</code>接口并手动实现深拷贝，另一种是用序列化的方式来实现深拷贝</p><h4 id="3-1-实现Cloneable接口方式-实现深拷贝"><a href="#3-1-实现Cloneable接口方式-实现深拷贝" class="headerlink" title="3.1 实现Cloneable接口方式 实现深拷贝"></a>3.1 实现<code>Cloneable</code>接口方式 实现深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">/** Object的clone函数用protected修饰，需要重写 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Product) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; products;</span><br><span class="line">    <span class="comment">/** 手动实现深拷贝 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Order order = (Order)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 引用对象也需要克隆</span></span><br><span class="line">        List&lt;Product&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Product product : products) &#123;</span><br><span class="line">            items.add(product.clone());</span><br><span class="line">        &#125;</span><br><span class="line">        order.setProducts(items);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试方法验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeepClone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Order order = mock();</span><br><span class="line">    Order cloneOrder = order.clone();</span><br><span class="line">    assertFalse(order == cloneOrder);</span><br><span class="line">    assertFalse(order.getProducts() == cloneOrder.getProducts());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该单测可顺利通过。由于克隆的对象和内部的引用类型的属性全部都是依据原始对象新建的对象，因此如果修改拷贝对象的商品列表，原始订单对象的商品列表并不会受到影响。</p><h4 id="3-2-实现Serializable接口方式-实现深拷贝-序列化"><a href="#3-2-实现Serializable接口方式-实现深拷贝-序列化" class="headerlink" title="3.2 实现Serializable接口方式 实现深拷贝(序列化)"></a>3.2 实现<code>Serializable</code>接口方式 实现深拷贝(序列化)</h4><p>实体类需要实现<code>Serializable</code>接口，借助对象输入和输出流编写拷贝工具函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; products;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK序列化方式深拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deepClone</span><span class="params">(T origin)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);)&#123;</span><br><span class="line">            objectOutputStream.writeObject(origin);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = outputStream.toByteArray();</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);)&#123;</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(inputStream);</span><br><span class="line">            <span class="keyword">return</span> (T) objectInputStream.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试方法验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeepClone2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = mock();</span><br><span class="line">    <span class="comment">// 调用自定义工具类深拷贝</span></span><br><span class="line">    Order cloneOrder = MyUtils.deepClone(order);</span><br><span class="line">    assertFalse(order == cloneOrder);</span><br><span class="line">    assertFalse(order.getProducts() == cloneOrder.getProducts());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Debug</code>可以看到，序列化方式得到跟实现<code>Cloneable</code>方式一样的结果，序列化的方式也实现了深拷贝。<br>需要注意的是：序列化需要实现<code>Serializable</code>接口，而且效率不是特别高。</p><h4 id="3-3-常见工具类实现深拷贝-序列化"><a href="#3-3-常见工具类实现深拷贝-序列化" class="headerlink" title="3.3 常见工具类实现深拷贝(序列化)"></a>3.3 常见工具类实现深拷贝(序列化)</h4><p>我们可以利用项目中引用的常见工具包的工具类实现深拷贝，避免重复造轮子。</p><ol><li>使用<code>commons-lang3</code>的序列化工具类：<code>org.apache.commons.lang3.SerializationUtils#clone</code>。<ul><li>使用方式：<code>SerializationUtils.clone(order)</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 使用方式：SerializationUtils.clone(order) */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = mock();</span><br><span class="line">    Order cloneOrder = SerializationUtils.clone(order);</span><br><span class="line">    assertFalse(order == cloneOrder);</span><br><span class="line">    assertFalse(order.getItemList() == cloneOrder.getItemList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用<code>Google</code>的<code>Gson</code>库，自定义实现基于<code>JSON</code>序列化方式的深拷贝<ul><li>使用方式：<code>MyUtils.deepCloneByGson(order, Order.class)</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtils</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Gson方式实现深拷贝</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">deepCloneByGson</span><span class="params">(T origin, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">      Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">      <span class="keyword">return</span> gson.fromJson(gson.toJson(origin), clazz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withGson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order order = mock();</span><br><span class="line">    Order cloneOrder = MyUtils.deepCloneByGson(order, Order.class);</span><br><span class="line">    assertFalse(order == cloneOrder);</span><br><span class="line">    assertFalse(order.getItemList() == cloneOrder.getItemList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.原型模式"></a>4.原型模式</h3><p>未完待续…</p><blockquote><p>参考资料：</p><ul><li><a href="https://www.imooc.com/read/55" target="_blank" rel="noopener">码出规范：《阿里巴巴Java开发手册》详解</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-拷贝的概念&quot;&gt;&lt;a href=&quot;#1-拷贝的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 拷贝的概念&quot;&gt;&lt;/a&gt;1. 拷贝的概念&lt;/h3&gt;&lt;p&gt;对象的拷贝（复制，克隆）：根据原来的对象”复制”一份 属性、状态一致的新对象。&lt;br&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;：只”复制”对象的第一层属性，即：浅拷贝将返回该类的新的实例，该实例的引用类型对象共享。&lt;br&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;：对象的属性进行递归”复制”，即：深拷贝也会返回该类的新的实例，但是该实例的引用类型属性也是拷贝的新对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【环境配置】Redis与MySQL多实例配置</title>
    <link href="http://chaooo.github.io/article/20200211.html"/>
    <id>http://chaooo.github.io/article/20200211.html</id>
    <published>2020-02-11T15:08:46.000Z</published>
    <updated>2020-02-14T10:25:51.481Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于工作的需要，需要在同一台服务器上搭建两个<code>Redis</code>与<code>MySQL</code>的实例。<br>多实例：就是在一台机器上面开启多个不同的端口(如<code>Redis</code>用<code>6379</code>/<code>6380</code>，<code>MySQL</code>用<code>3306</code>/<code>3307</code>等)，运行多个服务进程；公用一套安装程序，使用不同的配置文件，数据文件。</p><a id="more"></a><h3 id="1-Redis多实例配置"><a href="#1-Redis多实例配置" class="headerlink" title="1. Redis多实例配置"></a>1. Redis多实例配置</h3><h4 id="1-1-查看主机Redis信息"><a href="#1-1-查看主机Redis信息" class="headerlink" title="1.1 查看主机Redis信息"></a>1.1 查看主机Redis信息</h4><ol><li>用<code>ps</code>命令查看<code>Redis</code>进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] ps -ef |grep redis</span><br><span class="line">root      1706     1  0  2019 ?        04:12:09 /usr/<span class="built_in">local</span>/bin/redis-server *:6379                    </span><br><span class="line">root     18174  2560  0 15:35 pts/0    00:00:00 grep redis</span><br></pre></td></tr></table></figure><ol start="2"><li>查找配置文件位置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] locate redis.conf</span><br><span class="line">/etc/redis.conf</span><br></pre></td></tr></table></figure><h4 id="1-2-拷贝配置文件并修改"><a href="#1-2-拷贝配置文件并修改" class="headerlink" title="1.2 拷贝配置文件并修改"></a>1.2 拷贝配置文件并修改</h4><ol><li>拷贝<code>redis.conf</code>并命名为<code>redis6380.conf</code>，并修改参数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] cp /etc/redis.conf /etc/redis6380.conf</span><br><span class="line">[root@localhost ~] vim /etc/redis6380.conf</span><br><span class="line"><span class="comment"># 查找 /pidfile 找到pid位置</span></span><br><span class="line"><span class="comment"># pidfile /var/run/redis.pid        #修改pid，每个实例需要运行在不同的pid</span></span><br><span class="line">pidfile /var/run/redis6380.pid</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查找 /port 6379 找到端口位置</span></span><br><span class="line"><span class="comment"># port 6379                         #修改端口</span></span><br><span class="line">port 6380</span><br><span class="line"><span class="comment">#                      </span></span><br><span class="line"><span class="comment"># 查找 /dir 找到数据目录位置</span></span><br><span class="line"><span class="comment"># dir /mnt/newdatadrive/data/redis  #修改数据存放目录</span></span><br><span class="line">dir /mnt/newdatadrive/data/redis6380</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 已开启Redis持久化</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><ol start="2"><li>准备上面配置的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mkdir –p /mnt/newdatadrive/data/redis6380</span><br><span class="line">[root@localhost ~] cp /var/run/redis.pid /var/run/redis6380.pid</span><br></pre></td></tr></table></figure><h4 id="1-3-启动测试"><a href="#1-3-启动测试" class="headerlink" title="1.3 启动测试"></a>1.3 启动测试</h4><ol><li>启动<code>6380</code>端口<code>Redis</code>服务，并查看<code>Redis</code>进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] /usr/<span class="built_in">local</span>/bin/redis-server /etc/redis6380.conf</span><br><span class="line">[root@localhost ~] ps -ef |grep redis</span><br><span class="line">root      1706     1  0  2019 ?        04:12:00 /usr/<span class="built_in">local</span>/bin/redis-server *:6379         </span><br><span class="line">root     15967     1  0 12:16 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server *:6380             </span><br><span class="line">root     15994  8014  0 12:16 pts/2    00:00:00 grep redis</span><br></pre></td></tr></table></figure><ol start="2"><li>测试登录<code>Redis</code>客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; QUIT     <span class="comment">#退出</span></span><br></pre></td></tr></table></figure><ol start="3"><li>停止<code>6380</code>端口的<code>Redis</code>服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6380 shutdown</span><br></pre></td></tr></table></figure><h4 id="1-4-Redis数据迁移"><a href="#1-4-Redis数据迁移" class="headerlink" title="1.4 Redis数据迁移"></a>1.4 Redis数据迁移</h4><ol><li>登录原<code>Redis</code>客户端(<code>6379</code>)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; SAVE             <span class="comment">#数据备份</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET dir   <span class="comment">#查看Redis数据目录</span></span><br><span class="line">1) <span class="string">"dir"</span></span><br><span class="line">2) <span class="string">"/mnt/newdatadrive/data/redis"</span></span><br><span class="line">127.0.0.1:6379&gt; QUIT             <span class="comment">#退出</span></span><br></pre></td></tr></table></figure><ol start="2"><li>拷贝数据文件<code>appendonly.aof</code>和<code>dump.rdb</code>到<code>6380</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看6379的数据文件</span></span><br><span class="line">[root@localhost ~] <span class="built_in">cd</span> /mnt/newdatadrive/data/redis &amp;&amp; ll</span><br><span class="line">total 55176</span><br><span class="line">-rw-r--r-- 1 root root 55411226 Feb 11 09:25 appendonly.aof</span><br><span class="line">-rw-r--r-- 1 root root  1017181 Feb 11 12:28 dump.rdb</span><br><span class="line"><span class="comment"># 拷贝到6380</span></span><br><span class="line">[root@localhost ~] \cp /mnt/newdatadrive/data/redis/appendonly.aof /mnt/newdatadrive/data/redis6380/appendonly.aof</span><br><span class="line">[root@localhost ~] \cp /mnt/newdatadrive/data/redis/dump.rdb /mnt/newdatadrive/data/redis6380/dump.rdb</span><br></pre></td></tr></table></figure><ol start="3"><li>启动<code>6380</code>端口<code>Redis</code>服务，导入<code>AOF</code>数据文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] /usr/<span class="built_in">local</span>/bin/redis-server /etc/redis6380.conf</span><br><span class="line">[root@localhost ~] redis-cli -p 6380 --pipe &lt; /mnt/newdatadrive/data/redis6380/appendonly.aof</span><br></pre></td></tr></table></figure><ol start="4"><li>登录<code>Redis</code>查看数据</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt;   <span class="comment">#输入具体命令查看数据</span></span><br></pre></td></tr></table></figure><h4 id="1-5-配置远程可访问"><a href="#1-5-配置远程可访问" class="headerlink" title="1.5 配置远程可访问"></a>1.5 配置远程可访问</h4><ol><li>修改配置文件<code>redis6380.conf</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] vim /etc/redis6380.conf</span><br><span class="line"><span class="comment"># 查找 /bind 找到：bind 127.0.0.1并注释，其它ip地址也可访问</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查找 /requirepass 去掉注释#，并把foobared 替换为密码，例如：password123456</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass password123456</span><br></pre></td></tr></table></figure><ol start="2"><li>开启防火墙的端口号规则（安全组），将<code>6380</code>端口号开通</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 6380 -j ACCEPT</span><br></pre></td></tr></table></figure><ol start="3"><li>修改完成后，要在服务里重启<code>Redis</code>服务才能使设置生效</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/redis-server /etc/redis6380.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>测试远程访问</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zc&gt; redis-cli -h 192.168.111.226 -p 6380 -a password123456</span><br><span class="line">192.168.111.226:6380&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>停止<code>6380</code>的<code>Redis</code>服务也需要密码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] redis-cli -p 6380 -a password123456 shutdown</span><br></pre></td></tr></table></figure><h3 id="2-MySQL多实例配置"><a href="#2-MySQL多实例配置" class="headerlink" title="2. MySQL多实例配置"></a>2. MySQL多实例配置</h3><h4 id="2-1-查看主机MySQL信息"><a href="#2-1-查看主机MySQL信息" class="headerlink" title="2.1 查看主机MySQL信息"></a>2.1 查看主机MySQL信息</h4><ol><li>查看现有<code>MySQL</code>数据库实例占用端口</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] netstat -anp | grep mysqld</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      1089/mysqld         </span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     20497    1089/mysqld          /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure><blockquote><p><strong>须先关闭单实例，跟多实例会有冲突</strong></p><ul><li>备份数据：<code>[root@localhost ~] mysqldump -P 3306 -u root -p --all-databases &gt; /home/backup/data3306.bak</code></li><li>停止单实例服务：<code>[root@localhost ~] service mysqld stop</code></li></ul></blockquote><ol start="2"><li>查找配置文件位置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] locate my.cnf</span><br><span class="line">/etc/my.cnf</span><br><span class="line">/etc/my.cnf.d</span><br></pre></td></tr></table></figure><h4 id="2-2-添加一个3307端口的实例"><a href="#2-2-添加一个3307端口的实例" class="headerlink" title="2.2 添加一个3307端口的实例"></a>2.2 添加一个3307端口的实例</h4><ol><li>拷贝<code>my.cnf</code>并命名为<code>my3307.cnf</code>，并修改参数，主要修改port,sockt,datadir</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] cp /etc/my.cnf /etc/my3307.cnf</span><br><span class="line">[root@localhost ~] vi /etc/my3307.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># server端字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line">user=root</span><br><span class="line"><span class="comment"># 修改端口</span></span><br><span class="line">port=3307</span><br><span class="line"><span class="comment"># 修改数据存放目录</span></span><br><span class="line">datadir=/var/lib/mysql3307</span><br><span class="line"><span class="comment"># 客户端连接socket</span></span><br><span class="line">socket=/var/lib/mysql/mysql3307.sock</span><br><span class="line"><span class="comment"># 修改日志文件</span></span><br><span class="line"><span class="built_in">log</span>-error=/var/<span class="built_in">log</span>/mysqld3307.log</span><br><span class="line"><span class="comment"># 修改pid，每个实例需要运行在不同的pid</span></span><br><span class="line">pid-file=/var/run/mysqld/mysqld3307.pid</span><br><span class="line"><span class="comment"># 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated</span></span><br><span class="line">explicit_defaults_for_timestamp=<span class="literal">true</span></span><br><span class="line"><span class="comment"># skip_grant_tables</span></span><br><span class="line">[mysql]</span><br><span class="line">socket=/var/lib/mysql/mysql3307.sock</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql.server]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql_safe]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line">socket=/var/lib/mysql/mysql3307.sock</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化数据库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入host避免反解析报错</span></span><br><span class="line">[root@localhost ~] <span class="built_in">echo</span> <span class="string">"127.0.0.1   `hostname`"</span> &gt;&gt; /etc/hosts &amp;&amp; cat /etc/hosts</span><br><span class="line">[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --initialize-insecure</span><br></pre></td></tr></table></figure><ol start="3"><li>启动<code>3307</code>端口<code>MySQL</code>服务，并查看<code>MySQL</code>进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --user=root &amp;</span><br></pre></td></tr></table></figure><ol start="4"><li>登录<code>MySQL</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多实例为root增加密码</span></span><br><span class="line">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock password <span class="string">'123qwe'</span></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">[root@localhost ~] mysql -S /var/lib/mysql/mysql3307.sock -p</span><br></pre></td></tr></table></figure><ol start="5"><li>停止本实例<code>MySQL</code>服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock shutdown</span><br></pre></td></tr></table></figure><h4 id="2-3-再添加一个3308端口的实例"><a href="#2-3-再添加一个3308端口的实例" class="headerlink" title="2.3 再添加一个3308端口的实例"></a>2.3 再添加一个3308端口的实例</h4><ol><li>拷贝<code>my.cnf</code>并命名为<code>my3308.cnf</code>，并修改参数，主要修改port,sockt,datadir</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] cp /etc/my.cnf /etc/my3308.cnf</span><br><span class="line">[root@localhost ~] vi /etc/my3308.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># server端字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line">user=root</span><br><span class="line"><span class="comment"># 修改端口</span></span><br><span class="line">port=3308</span><br><span class="line"><span class="comment"># 修改数据存放目录</span></span><br><span class="line">datadir=/var/lib/mysql3308</span><br><span class="line"><span class="comment"># 客户端连接socket</span></span><br><span class="line">socket=/var/lib/mysql/mysql3308.sock</span><br><span class="line"><span class="comment"># 修改日志文件</span></span><br><span class="line"><span class="built_in">log</span>-error=/var/<span class="built_in">log</span>/mysqld3308.log</span><br><span class="line"><span class="comment"># 修改pid，每个实例需要运行在不同的pid</span></span><br><span class="line">pid-file=/var/run/mysqld/mysqld3308.pid</span><br><span class="line"><span class="comment"># 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated</span></span><br><span class="line">explicit_defaults_for_timestamp=<span class="literal">true</span></span><br><span class="line"><span class="comment"># skip_grant_tables</span></span><br><span class="line">[mysql]</span><br><span class="line">socket=/var/lib/mysql/mysql3308.sock</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql.server]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql_safe]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line">socket=/var/lib/mysql/mysql3308.sock</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化数据库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --initialize-insecure</span><br></pre></td></tr></table></figure><ol start="3"><li>启动<code>3308</code>端口<code>MySQL</code>服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --user=root &amp;</span><br></pre></td></tr></table></figure><ol start="4"><li>登录<code>MySQL</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多实例为root增加密码</span></span><br><span class="line">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock password <span class="string">'123qwe'</span></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">[root@localhost ~] mysql -S /var/lib/mysql/mysql3308.sock -p</span><br></pre></td></tr></table></figure><ol start="5"><li>停止本实例<code>MySQL</code>服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock shutdown</span><br></pre></td></tr></table></figure><h4 id="2-4-实例3307开启远程访问"><a href="#2-4-实例3307开启远程访问" class="headerlink" title="2.4 实例3307开启远程访问"></a>2.4 实例3307开启远程访问</h4><ol><li>开启<code>3307</code>端口防火墙</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 3307 -j ACCEPT</span><br></pre></td></tr></table></figure><ol start="2"><li>测试远程访问</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zc&gt;mysql -h 192.168.111.227 -P 3307 -u root -p</span><br><span class="line">Enter password: ******</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近由于工作的需要，需要在同一台服务器上搭建两个&lt;code&gt;Redis&lt;/code&gt;与&lt;code&gt;MySQL&lt;/code&gt;的实例。&lt;br&gt;多实例：就是在一台机器上面开启多个不同的端口(如&lt;code&gt;Redis&lt;/code&gt;用&lt;code&gt;6379&lt;/code&gt;/&lt;code&gt;6380&lt;/code&gt;，&lt;code&gt;MySQL&lt;/code&gt;用&lt;code&gt;3306&lt;/code&gt;/&lt;code&gt;3307&lt;/code&gt;等)，运行多个服务进程；公用一套安装程序，使用不同的配置文件，数据文件。&lt;/p&gt;
    
    </summary>
    
      <category term="环境配置" scheme="http://chaooo.github.io/categories/env/"/>
    
    
      <category term="环境配置" scheme="http://chaooo.github.io/tags/env/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】基于Shiro前后端分离的认证与授权(三.前端篇)</title>
    <link href="http://chaooo.github.io/article/20200207.html"/>
    <id>http://chaooo.github.io/article/20200207.html</id>
    <published>2020-02-06T18:10:46.000Z</published>
    <updated>2020-02-06T19:22:36.543Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇我们整合了<code>SpringBoot+Shiro+JWT+Redis</code>实现了登录认证，接口权限控制，接下来将要实现前端Vue的动态路由控制。</p><h3 id="1-前端权限控制思路（Vue）"><a href="#1-前端权限控制思路（Vue）" class="headerlink" title="1. 前端权限控制思路（Vue）"></a>1. 前端权限控制思路（Vue）</h3><p>前端的权限控制，不同的权限对应着不同的路由，同时菜单也需根据不同的权限，异步生成。<br>先回顾下整体流程：<a id="more"></a><br><img src="http://cdn.chaooo.top/Java/auth-global.png" alt></p><ul><li>登录: 提交账号和密码到服务端签发<code>token</code>，拿到<code>token</code>之后存入浏览器，再携带<code>token</code>(一般放在请求头中)再去获取用户的详细信息(包括用户权限等信息)。</li><li>权限验证：通过用户权限信息 构建 对应权限的路由，通过<code>router.addRoutes</code>动态挂载这些路由。</li></ul><p>接下来将基于Vue开源后台模板<a href="https://github.com/PanJiaChen/vue-admin-template" target="_blank" rel="noopener">vue-admin-template</a>来演示具体流程，这里只演示重要代码，完整项目移步文章末尾获取源码。</p><h3 id="2-登录"><a href="#2-登录" class="headerlink" title="2. 登录"></a>2. 登录</h3><ol><li>先准备基础的静态路由(<code>src/router/index.js</code>)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRoutes = [</span><br><span class="line">  <span class="comment">// 登陆页面</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/login'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/login/index'</span>),</span><br><span class="line">    hidden: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 首页</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: <span class="string">'/dashboard'</span>,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: <span class="string">'dashboard'</span>,</span><br><span class="line">      name: <span class="string">'Dashboard'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/dashboard/index'</span>),</span><br><span class="line">      meta: &#123; <span class="attr">title</span>: <span class="string">'首页'</span>, <span class="attr">icon</span>: <span class="string">'dashboard'</span> &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/404'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/404'</span>),</span><br><span class="line">    hidden: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>登录页面(src/views/login/index.vue)<code>click</code>事件触发登录操作</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'user/login'</span>, <span class="keyword">this</span>.loginForm).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">'/'</span> &#125;); <span class="comment">//登录成功之后重定向到首页</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.$message.error(err); <span class="comment">//登录失败提示错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>登录逻辑(src/store/modules/user.js)<code>action</code>:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// user login</span></span><br><span class="line">  login(&#123; commit &#125;, userInfo) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; account, password &#125; = userInfo</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里的login调用api接口请求数据</span></span><br><span class="line">      login(&#123; <span class="attr">account</span>: account.trim(), <span class="attr">password</span>: password &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line">        commit(<span class="string">'SET_TOKEN'</span>, data)</span><br><span class="line">        setToken(data)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// get user info</span></span><br><span class="line">  getInfo(&#123; commit, state &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里的getInfo调用api接口请求数据</span></span><br><span class="line">      getInfo(state.token).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">          reject(<span class="string">'Verification failed, please Login again.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> &#123; nickname, avatar, roles, permissions &#125; = data</span><br><span class="line">        <span class="comment">// 全局储存用户信息</span></span><br><span class="line">        commit(<span class="string">'SET_NAME'</span>, nickname)</span><br><span class="line">        commit(<span class="string">'SET_AVATAR'</span>, avatar)</span><br><span class="line">        <span class="comment">// 角色信息</span></span><br><span class="line">        commit(<span class="string">'SET_ROLES'</span>, roles)</span><br><span class="line">        <span class="comment">// 指令权限信息</span></span><br><span class="line">        commit(<span class="string">'SET_PERMISSIONS'</span>, permissions)</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>/login</code>与<code>/getInfo</code>接口与返回的数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST (localhost:<span class="number">8282</span>/login)</span><br><span class="line">请求参数: &#123;<span class="string">"username"</span>:<span class="string">"admin"</span>,<span class="string">"password"</span>:<span class="string">"123456"</span>&#125;</span><br><span class="line">响应: &#123;</span><br><span class="line">    <span class="string">"code"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">"msg"</span>:<span class="string">"登录成功"</span>,</span><br><span class="line">    <span class="string">"data"</span>:<span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhZG1pbiIsInVpZCI6MSwiZXhwIjoxNTgwOTk4MTIzfQ.6jgqt_opjnosASlJ2oSIYZn1Sb2BQO-eUo_6OVTHv50"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------getInfo--------------</span></span><br><span class="line">GET (localhost:<span class="number">8282</span>/user/info)</span><br><span class="line">Headers: &#123;<span class="string">"X-Token"</span>:<span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhZG1pbiIsInVpZCI6MSwiZXhwIjoxNTgwOTk4MTIzfQ.6jgqt_opjnosASlJ2oSIYZn1Sb2BQO-eUo_6OVTHv50"</span>&#125;</span><br><span class="line">响应: &#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">"获取成功"</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">        <span class="string">"account"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"nickname"</span>: <span class="string">"超级管理员"</span>,</span><br><span class="line">        <span class="string">"roles"</span>: [<span class="string">"admin"</span>],</span><br><span class="line">        <span class="string">"permissions"</span>: [<span class="string">"user:list"</span>,<span class="string">"user:add"</span>,<span class="string">"user:delete"</span>,<span class="string">"user:update"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>获取用户信息(src/permission.js)<ul><li>用户登录成功之后，我们会在全局钩子<code>router.beforeEach</code>中拦截路由，判断是否已获得<code>token</code>，在获得<code>token</code>之后我们就要去获取用户的基本信息 并且根据用户角色动态挂载路由。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">'/login'</span>] <span class="comment">// 白名单</span></span><br><span class="line">router.beforeEach(<span class="keyword">async</span>(to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断是否已获得token</span></span><br><span class="line">  <span class="keyword">const</span> hasToken = getToken()</span><br><span class="line">  <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.path === <span class="string">'/login'</span>) &#123;</span><br><span class="line">      next(&#123; <span class="attr">path</span>: <span class="string">'/'</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> hasRole = store.getters.role</span><br><span class="line">      <span class="keyword">if</span> (hasRole) &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取用户角色 ['admin'] 或,['developer','editor']</span></span><br><span class="line">          <span class="keyword">const</span> &#123; roles &#125; = <span class="keyword">await</span> store.dispatch(<span class="string">'user/getInfo'</span>)</span><br><span class="line">          <span class="comment">// 动态根据 角色 算出其对应有权限的路由</span></span><br><span class="line">          <span class="keyword">const</span> accessRoutes = <span class="keyword">await</span> store.dispatch(<span class="string">'permission/generateRoutes'</span>, roles)</span><br><span class="line">          <span class="comment">// 动态挂载路由</span></span><br><span class="line">          router.addRoutes(accessRoutes)</span><br><span class="line">          <span class="comment">// addRouter是让挂载的路由生效，但是挂载后'router.options.routes'并未刷新(应该是个bug)</span></span><br><span class="line">          <span class="comment">// 所以还需要手动将路由加入'router.options.routes'</span></span><br><span class="line">          router.options.routes = constantRoutes.concat(accessRoutes)</span><br><span class="line">          next()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="keyword">await</span> store.dispatch(<span class="string">'user/resetToken'</span>)</span><br><span class="line">          Message.error(error || <span class="string">'Has Error'</span>)</span><br><span class="line">          next(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* has no token*/</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.indexOf(to.path) !== <span class="number">-1</span>) &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-动态挂载路由"><a href="#3-动态挂载路由" class="headerlink" title="3. 动态挂载路由"></a>3. 动态挂载路由</h3><p>主要思路，前端会有一份包含所有路由的路由表。创建<code>Vue</code>实例时会先挂载登录等公共路由；当用户登录之后，通过<code>getInfo(token)</code>获取用户的角色(<code>roles</code>)，动态根据用户的<code>roles</code>算出其对应有权限的路由，再通过<code>router.addRoutes</code>动态挂载路由；使用<code>vuex</code>管理路由表，根据<code>vuex</code>中可访问的路由渲染菜单。但这些控制都只是页面级的，后端接口也需要做权限验证。</p><ol><li>改造一下路由表，添加异步路由列表，将角色添加到元数据<code>meta</code>中：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/user'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: <span class="string">'/user/list'</span>,</span><br><span class="line">    name: <span class="string">'User'</span>,</span><br><span class="line">    meta: &#123; <span class="attr">title</span>: <span class="string">'用户管理'</span>, <span class="attr">icon</span>: <span class="string">'example'</span> &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'list'</span>,</span><br><span class="line">        name: <span class="string">'UserList'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/user/list'</span>),</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'用户列表'</span>, <span class="attr">icon</span>: <span class="string">'nested'</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'edit'</span>,</span><br><span class="line">        name: <span class="string">'UserEdit'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/user/form'</span>),</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'添加用户'</span>, <span class="attr">icon</span>: <span class="string">'form'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/admin'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'index'</span>,</span><br><span class="line">        name: <span class="string">'Form1'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/test/index'</span>),</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'管理员角色测试'</span>, <span class="attr">icon</span>: <span class="string">'form'</span>, <span class="attr">roles</span>: [<span class="string">'admin'</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/editor'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'index'</span>,</span><br><span class="line">        name: <span class="string">'Form2'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/test/index'</span>),</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'编辑角色测试'</span>, <span class="attr">icon</span>: <span class="string">'form'</span>, <span class="attr">roles</span>: [<span class="string">'editor'</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/form'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'index'</span>,</span><br><span class="line">        name: <span class="string">'Form3'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/test/index'</span>),</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'用户角色测试'</span>, <span class="attr">icon</span>: <span class="string">'form'</span>, <span class="attr">roles</span>: [<span class="string">'user'</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/nested'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: <span class="string">'/nested/menu3'</span>,</span><br><span class="line">    name: <span class="string">'Nested'</span>,</span><br><span class="line">    meta: &#123; <span class="attr">title</span>: <span class="string">'子菜单权限测试'</span>, <span class="attr">icon</span>: <span class="string">'form'</span> &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'menu1'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/test/index'</span>),</span><br><span class="line">        name: <span class="string">'Menu1'</span>,</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'管理员可见'</span>, <span class="attr">roles</span>: [<span class="string">'admin'</span>] &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'menu2'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/test/index'</span>),</span><br><span class="line">        name: <span class="string">'Menu1'</span>,</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'编辑者可见'</span>, <span class="attr">roles</span>: [<span class="string">'editor'</span>] &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'menu3'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/test/index'</span>),</span><br><span class="line">        name: <span class="string">'Menu1'</span>,</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'普通用户可见'</span>, <span class="attr">roles</span>: [<span class="string">'user'</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ol start="2"><li>根据前面获取用户信息的代码可发现，通过<code>store.dispatch(&#39;permission/generateRoutes&#39;,roles)</code>来获得有权限的路由，新建<code>src/store/modules/permission.js</code>如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; asyncRoutes, constantRoutes &#125; <span class="keyword">from</span> <span class="string">'@/router'</span></span><br><span class="line"><span class="comment">/** 判断用户是否拥有此路由的权限 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPermission</span>(<span class="params">roles, route</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (route.meta &amp;&amp; route.meta.roles) &#123;</span><br><span class="line">    <span class="keyword">return</span> roles.some(<span class="function"><span class="params">role</span> =&gt;</span> route.meta.roles.includes(role))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 递归组装路由表，返回符合用户角色权限的路由列表 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">filterAsyncRoutes</span>(<span class="params">routes, roles</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = &#123; ...route &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasPermission(roles, tmp)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmp.children) &#123;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        tmp.children = filterAsyncRoutes(tmp.children, roles)</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(tmp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  routes: [], <span class="comment">// 所有路由,包括静态路由和动态路由</span></span><br><span class="line">  addRoutes: [] <span class="comment">// 动态路由</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  SET_ROUTES: <span class="function">(<span class="params">state, routes</span>) =&gt;</span> &#123;</span><br><span class="line">    state.addRoutes = routes</span><br><span class="line">    <span class="comment">// 合并路由</span></span><br><span class="line">    state.routes = constantRoutes.concat(routes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// 生成动态路由</span></span><br><span class="line">  generateRoutes(&#123; commit &#125;, roles) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> accessedRoutes</span><br><span class="line">      <span class="keyword">if</span> (roles.includes(<span class="string">'admin'</span>)) &#123;</span><br><span class="line">        <span class="comment">// '超级管理员'拥有所有的路由，这样判断节省加载时间</span></span><br><span class="line">        accessedRoutes = asyncRoutes || []</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 筛选出该角色有权限的路由</span></span><br><span class="line">        accessedRoutes = filterAsyncRoutes(asyncRoutes, roles)</span><br><span class="line">      &#125;</span><br><span class="line">      commit(<span class="string">'SET_ROUTES'</span>, accessedRoutes)</span><br><span class="line">      resolve(accessedRoutes)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-axios拦截器"><a href="#4-axios拦截器" class="headerlink" title="4. axios拦截器"></a>4. axios拦截器</h3><p>通过<code>request</code>拦截器在每个请求头里面塞入<code>token</code>，好让后端对请求进行权限验证；代码位置:<code>src/utils/request.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">'@/utils/auth'</span></span><br><span class="line"><span class="comment">// create an axios instance</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">  baseURL: process.env.VUE_APP_BASE_API, <span class="comment">// url = base url + request url</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// send cookies when cross-domain requests</span></span><br><span class="line">  timeout: <span class="number">5000</span> <span class="comment">// request timeout</span></span><br><span class="line">&#125;)</span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (store.getters.token) &#123;</span><br><span class="line">      <span class="comment">// 登陆后将token放入headers['X-Token']中</span></span><br><span class="line">      config.headers[<span class="string">'X-Token'</span>] = getToken()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></table></figure><h3 id="5-指令权限"><a href="#5-指令权限" class="headerlink" title="5. 指令权限"></a>5. 指令权限</h3><p>可以使用全局权限判断函数，实现按钮级别的权限判断。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-if</span>=<span class="string">"checkPermission('user:add')"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-if</span>=<span class="string">"checkPermission('user:delete')"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-if</span>=<span class="string">"checkPermission('user:update')"</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-if</span>=<span class="string">"checkPermission('user:list')"</span>&gt;</span>查看<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> checkPermission <span class="keyword">from</span> <span class="string">'@/utils/permission'</span> <span class="comment">// 权限判断函数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">   methods: &#123;</span><br><span class="line">    checkPermission(value) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> checkPermission(value)</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>src/utils/permission.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">checkPermission</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> permissions = store.getters.permissions</span><br><span class="line">  <span class="keyword">return</span> permissions.indexOf(value) &gt; <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-效果演示："><a href="#6-效果演示：" class="headerlink" title="6. 效果演示："></a>6. 效果演示：</h3><p><img src="http://cdn.chaooo.top/Java/auth-admin.jpg" alt></p><blockquote><p>注：搭建到这里的代码在<code>github</code>源码<code>tag</code>的<code>V3.0</code>中。<br>源码地址: <a href="https://github.com/chaooo/springboot-vue-shiro.git" target="_blank" rel="noopener">https://github.com/chaooo/springboot-vue-shiro.git</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇我们整合了&lt;code&gt;SpringBoot+Shiro+JWT+Redis&lt;/code&gt;实现了登录认证，接口权限控制，接下来将要实现前端Vue的动态路由控制。&lt;/p&gt;
&lt;h3 id=&quot;1-前端权限控制思路（Vue）&quot;&gt;&lt;a href=&quot;#1-前端权限控制思路（Vue）&quot; class=&quot;headerlink&quot; title=&quot;1. 前端权限控制思路（Vue）&quot;&gt;&lt;/a&gt;1. 前端权限控制思路（Vue）&lt;/h3&gt;&lt;p&gt;前端的权限控制，不同的权限对应着不同的路由，同时菜单也需根据不同的权限，异步生成。&lt;br&gt;先回顾下整体流程：
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】基于Shiro前后端分离的认证与授权(二.授权篇)</title>
    <link href="http://chaooo.github.io/article/20200121.html"/>
    <id>http://chaooo.github.io/article/20200121.html</id>
    <published>2020-01-21T10:10:55.000Z</published>
    <updated>2020-02-14T10:17:13.388Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们整合了<code>SpringBoot+Shiro+JWT</code>实现了登录认证，但还没有实现权限控制，这是接下来的工作。<a id="more"></a></p><h3 id="1-JWT的Token续签"><a href="#1-JWT的Token续签" class="headerlink" title="1. JWT的Token续签"></a>1. JWT的Token续签</h3><h4 id="1-1-续签思路"><a href="#1-1-续签思路" class="headerlink" title="1.1 续签思路"></a>1.1 续签思路</h4><ol><li>业务逻辑：<ul><li>登录成功后，用户在未过期时间内继续操作，续签token。</li><li>登录成功后，空闲超过过期时间，返回token已失效，重新登录。</li></ul></li><li>实现逻辑：<ol><li>登录成功后将token存储到redis里面(这时候k、v值一样都为token)，并设置过期时间为token过期时间</li><li>当用户请求时token值还未过期，则重新设置redis里token的过期时间。</li><li>当用户请求时token值已过期，但redis中还在，则JWT重新生成token并覆盖v值(这时候k、v值不一样了)，然后设置redis过期时间。</li><li>当用户请求时token值已过期，并且redis中也不存在，则用户空闲超时，返回token已失效，重新登录。</li></ol></li></ol><h4 id="1-2-编码实现"><a href="#1-2-编码实现" class="headerlink" title="1.2 编码实现"></a>1.2 编码实现</h4><ol><li><code>pom.xml</code>引入<code>Redis</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写<code>Redis</code>工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>JwtUtil中增加返回过期秒数的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 设置过期时间: 30分钟 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//... 其他代码省略</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回设置的过期秒数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long 秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getExpireTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  EXPIRE_TIME/<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>改写登录逻辑，生成<code>token</code>后存入<code>Redis</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysServiceImpl</span> <span class="keyword">implements</span> <span class="title">SysService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getToken</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 生成token</span></span><br><span class="line">        String token = JwtUtil.createToken(user);</span><br><span class="line">        <span class="comment">// 为了过期续签，将token存入redis，并设置超时时间</span></span><br><span class="line">        redisUtil.set(token, token, JwtUtil.getExpireTime());</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录(用户名，密码)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title">login</span><span class="params">(String account, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理比对密码</span></span><br><span class="line">        User user = sysDao.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            String  salt = user.getSalt();</span><br><span class="line">            String md5Password = Md5Util.md5(password+salt);</span><br><span class="line">            String dbPassword = user.getPassword();</span><br><span class="line">            <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">                <span class="comment">//生成token给用户，并存入redis</span></span><br><span class="line">                String token = getToken(user);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ResponseVo&lt;&gt;(<span class="number">0</span>,<span class="string">"登录成功"</span>, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseVo&lt;&gt;( -<span class="number">1</span>, <span class="string">"登录失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>改写<code>MyRealm</code>，加入<code>token</code>续签逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"MyRealm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JWT Token续签：</span></span><br><span class="line"><span class="comment">     * 业务逻辑：登录成功后，用户在未过期时间内继续操作，续签token。</span></span><br><span class="line"><span class="comment">     *         登录成功后，空闲超过过期时间，返回token已失效，重新登录。</span></span><br><span class="line"><span class="comment">     * 实现逻辑：</span></span><br><span class="line"><span class="comment">     *    1.登录成功后将token存储到redis里面(这时候k、v值一样都为token)，并设置过期时间为token过期时间</span></span><br><span class="line"><span class="comment">     *    2.当用户请求时token值还未过期，则重新设置redis里token的过期时间。</span></span><br><span class="line"><span class="comment">     *    3.当用户请求时token值已过期，但redis中还在，则JWT重新生成token并覆盖v值(这时候k、v值不一样了)，然后设置redis过期时间。</span></span><br><span class="line"><span class="comment">     *    4.当用户请求时token值已过期，并且redis中也不存在，则用户空闲超时，返回token已失效，重新登录。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tokenRefresh</span><span class="params">(String token, User user)</span> </span>&#123;</span><br><span class="line">        String cacheToken = String.valueOf(redisUtil.get(token));</span><br><span class="line">        <span class="comment">// 过期后会得到"null"值，所以需判断字符串"null"</span></span><br><span class="line">        <span class="keyword">if</span> (cacheToken != <span class="keyword">null</span> &amp;&amp; cacheToken.length() != <span class="number">0</span> &amp;&amp; !<span class="string">"null"</span>.equals(cacheToken)) &#123;</span><br><span class="line">            <span class="comment">// 校验token有效性</span></span><br><span class="line">            <span class="keyword">if</span> (!JwtUtil.isVerify(cacheToken)) &#123;</span><br><span class="line">                <span class="comment">// 生成token</span></span><br><span class="line">                String newToken = JwtUtil.createToken(user);</span><br><span class="line">                <span class="comment">// 将token存入redis,并设置超时时间</span></span><br><span class="line">                redisUtil.set(token, newToken, JwtUtil.getExpireTime());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重新设置超时时间</span></span><br><span class="line">                redisUtil.expire(token, JwtUtil.getExpireTime());</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"打印存入redis的过期时间："</span>+redisUtil.getExpire(token));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写认证逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken auth)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"————————身份认证——————————"</span>);</span><br><span class="line">        String token = (String) auth.getCredentials();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == token) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"token为空!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解密获得username，用于和数据库进行对比</span></span><br><span class="line">        String account = JwtUtil.parseTokenAud(token);</span><br><span class="line">        User user = sysService.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == user) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"用户不存在!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验token是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (!tokenRefresh(token, user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"Token已过期!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user, token,<span class="string">"MyRealm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，JWT的Token续签的功能已经全部实现了。</p><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a>2. 权限管理</h3><h4 id="2-1-首先增加三张数据表"><a href="#2-1-首先增加三张数据表" class="headerlink" title="2.1 首先增加三张数据表"></a>2.1 首先增加三张数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 角色表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`sys_role`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键id'</span>,</span><br><span class="line">  <span class="string">`role_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色名称'</span>,</span><br><span class="line">  <span class="string">`description`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'描述'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=<span class="keyword">COMPACT</span> <span class="keyword">COMMENT</span>=<span class="string">'角色表'</span>;</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> <span class="string">`sys_role`</span>(<span class="string">`id`</span>,<span class="string">`role_name`</span>,<span class="string">`description`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'admin'</span>,<span class="string">'管理角色'</span>),(<span class="number">2</span>,<span class="string">'user'</span>,<span class="string">'用户角色'</span>);</span><br><span class="line"><span class="comment">/** 权限表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`sys_permission`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_permission`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键id'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'菜单标题'</span>,</span><br><span class="line">  <span class="string">`url`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'路径'</span>,</span><br><span class="line">  <span class="string">`menu_type`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'菜单类型(0:一级菜单; 1:子菜单:2:按钮权限)'</span>,</span><br><span class="line">  <span class="string">`perms`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'菜单权限编码'</span>,</span><br><span class="line">  <span class="string">`sort_no`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'菜单排序'</span>,</span><br><span class="line">  <span class="string">`del_flag`</span> <span class="built_in">INT</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'删除状态 0正常 1已删除'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_prem_sort_no`</span> (<span class="string">`sort_no`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_prem_del_flag`</span> (<span class="string">`del_flag`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=<span class="keyword">COMPACT</span> <span class="keyword">COMMENT</span>=<span class="string">'菜单权限表'</span>;</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> <span class="string">`sys_permission`</span>(<span class="string">`id`</span>,<span class="string">`name`</span>,<span class="string">`url`</span>,<span class="string">`menu_type`</span>,<span class="string">`perms`</span>,<span class="string">`sort_no`</span>,<span class="string">`del_flag`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>,<span class="string">'新增用户'</span>,<span class="string">'/user/add'</span>,<span class="number">2</span>,<span class="string">'user:add'</span>,<span class="number">1</span>,<span class="number">0</span>),(<span class="string">'2'</span>,<span class="string">'删除用户'</span>,<span class="string">'/user/delete'</span>,<span class="number">2</span>,<span class="string">'user:delete'</span>,<span class="number">2</span>,<span class="number">0</span>),(<span class="string">'3'</span>,<span class="string">'修改用户'</span>,<span class="string">'/user/update'</span>,<span class="number">2</span>,<span class="string">'user:update'</span>,<span class="number">3</span>,<span class="number">0</span>),(<span class="string">'4'</span>,<span class="string">'查询用户'</span>,<span class="string">'/user/list'</span>,<span class="number">2</span>,<span class="string">'user:list'</span>,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/** 角色与权限关联表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`sys_role_permission`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_role_permission`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色id'</span>,</span><br><span class="line">  <span class="string">`permission_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限id'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_group_role_per_id`</span> (<span class="string">`role_id`</span>,<span class="string">`permission_id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_group_role_id`</span> (<span class="string">`role_id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_group_per_id`</span> (<span class="string">`permission_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">6</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=<span class="keyword">COMPACT</span> <span class="keyword">COMMENT</span>=<span class="string">'角色权限表'</span>;</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> <span class="string">`sys_role_permission`</span>(<span class="string">`id`</span>,<span class="string">`role_id`</span>,<span class="string">`permission_id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-编码实现"><a href="#2-2-编码实现" class="headerlink" title="2.2 编码实现"></a>2.2 编码实现</h4><ol><li>补全<code>MyRealm</code>中授权验证逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"MyRealm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...其他代码省略</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户权限信息，包括角色以及权限。</span></span><br><span class="line"><span class="comment">     * 只有当触发检测用户权限时才会调用此方法，例如checkRole,checkPermissionJwtToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"————权限认证 [ roles、permissions]————"</span>);</span><br><span class="line">        User user = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (principals != <span class="keyword">null</span>) &#123;</span><br><span class="line">            user = (User) principals.getPrimaryPrincipal();</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户拥有的角色，比如“admin/user”</span></span><br><span class="line">            String role = sysService.getRoleByRoleid(user.getRoleid());</span><br><span class="line">            simpleAuthorizationInfo.addRole(role);</span><br><span class="line">            log.info(<span class="string">"角色为："</span>+role);</span><br><span class="line">            <span class="comment">// 用户拥有的权限集合，比如“role:add,user:add”</span></span><br><span class="line">            Set&lt;String&gt; permissions = sysService.getPermissionsByRoleid(user.getRoleid());</span><br><span class="line">            simpleAuthorizationInfo.addStringPermissions(permissions);</span><br><span class="line">            log.info(<span class="string">"权限有："</span>+permissions.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Service</code>中添加获取角色与权限的方法，DAO与Mapper请移步源码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SysService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据roleid查找用户角色名，自定义Realm中调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> roleid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> roles</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getRoleByRoleid</span><span class="params">(Integer roleid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据roleid查找用户权限，自定义Realm中调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> roleid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  Set&lt;permissions&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">getPermissionsByRoleid</span><span class="params">(Integer roleid)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysServiceImpl</span> <span class="keyword">implements</span> <span class="title">SysService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoleByRoleid</span><span class="params">(Integer roleid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sysDao.getRoleByRoleid(roleid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getPermissionsByRoleid</span><span class="params">(Integer roleid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sysDao.getPermissionsByRoleid(roleid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>Controller</code>中使用<code>@RequiresPermissions</code>来控制权限</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApi</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"user:list"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/list"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseVo <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userService.loadUser();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户更新资料</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"user:update"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user/update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseVo <span class="title">update</span><span class="params">(User user, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String token = request.getHeader(<span class="string">"X-Token"</span>);</span><br><span class="line"><span class="keyword">return</span> userService.modifyUser(token, user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这里的登录认证+授权控制 在<code>github</code>源码<code>tag</code>的<code>V2.0</code>中，后续版本再加入前端动态路由控制等。<br>源码地址: <a href="https://github.com/chaooo/springboot-vue-shiro.git" target="_blank" rel="noopener">https://github.com/chaooo/springboot-vue-shiro.git</a><br>仅下载后端认证+授权控制源码:<br><code>git clone --branch V2.0 https://github.com/chaooo/springboot-vue-shiro.git</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们整合了&lt;code&gt;SpringBoot+Shiro+JWT&lt;/code&gt;实现了登录认证，但还没有实现权限控制，这是接下来的工作。
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】基于Shiro前后端分离的认证与授权(一.认证篇)</title>
    <link href="http://chaooo.github.io/article/20200118.html"/>
    <id>http://chaooo.github.io/article/20200118.html</id>
    <published>2020-01-18T15:26:02.000Z</published>
    <updated>2020-01-21T10:20:47.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-开始之前"><a href="#1-开始之前" class="headerlink" title="1. 开始之前"></a>1. 开始之前</h3><h4 id="1-1-技术选型"><a href="#1-1-技术选型" class="headerlink" title="1.1 技术选型"></a>1.1 技术选型</h4><p>选用<code>SpringBoot+Shiro+JWT</code>实现登录认证，结合<code>Redis</code>服务实现<code>token</code>的续签，前端选用<code>Vue</code>动态构造路由及更细粒度的操作权限控制。</p><ul><li>前后端分离项目中，我们一般采用的是无状态登录：服务端不保存任何客户端请求者信息，客户端需要自己携带着信息去访问服务端，并且携带的信息可以被服务端辨认。</li><li>而<code>Shiro</code>默认的拦截跳转都是跳转<code>url</code>页面，拦截校验机制恰恰使用的<code>session</code>；而前后端分离后，后端并无权干涉页面跳转。</li><li>因此前后端分离项目中使用<code>Shiro</code>就需要对其进行改造，我们可以在整合<code>Shiro</code>的基础上自定义登录校验，继续整合<code>JWT</code>(或者oauth2.0等)，使其成为支持服务端无状态登录，即<code>token</code>登录。</li><li>在<code>Vue</code>项目中，只需要根据登录用户的权限信息动态的加载路由列表就可以动态的构造出访问菜单。<a id="more"></a></li></ul><h4 id="1-2-整体流程"><a href="#1-2-整体流程" class="headerlink" title="1.2 整体流程"></a>1.2 整体流程</h4><ul><li>首次通过<code>post</code>请求将用户名与密码到<code>login</code>进行登入，登录成功后返回<code>token</code>；</li><li>每次请求，客户端需通过<code>header</code>将<code>token</code>带回服务器做<code>JWT Token</code>的校验；</li><li>服务端负责<code>token</code>生命周期的刷新，用户权限的校验；</li></ul><p><img src="http://cdn.chaooo.top/Java/auth-global.png" alt></p><h3 id="2-SpringBoot整合Shiro-JWT"><a href="#2-SpringBoot整合Shiro-JWT" class="headerlink" title="2. SpringBoot整合Shiro+JWT"></a>2. SpringBoot整合Shiro+JWT</h3><p>这里贴出主要逻辑，源码请移步文章末尾获取。</p><ol><li>数据表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 系统用户表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> sys_user;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sys_user(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">    <span class="keyword">account</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">    <span class="keyword">PASSWORD</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">COMMENT</span> <span class="string">'用户密码'</span>,</span><br><span class="line">    <span class="keyword">salt</span> <span class="built_in">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">COMMENT</span> <span class="string">'随机盐'</span>,</span><br><span class="line">    nickname <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">COMMENT</span> <span class="string">'用户昵称'</span>,</span><br><span class="line">    roleId <span class="built_in">INT</span> <span class="keyword">COMMENT</span> <span class="string">'角色ID'</span>,</span><br><span class="line">    createTime <span class="built_in">DATE</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    updateTime <span class="built_in">DATE</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">    deleteStatus <span class="built_in">VARCHAR</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'是否有效：1有效，2无效'</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> sys_user_id_pk PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> sys_user_account_uk <span class="keyword">UNIQUE</span>(<span class="keyword">account</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>pom.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- shiro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>shiro</code>配置类：构建<code>securityManager</code>环境，及配置<code>shiroFilter</code>并将<code>jwtFilter</code>添加进<code>shiro</code>的拦截器链中，放行登录注册请求。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"securityManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">getManager</span><span class="params">(MyRealm myRealm)</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">// 使用自己的realm</span></span><br><span class="line">        securityManager.setRealm(myRealm);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 关闭shiro自带的session，详情见文档</span></span><br><span class="line"><span class="comment">         * http://shiro.apache.org/session-management.html#SessionManagement-StatelessApplications%28Sessionless%29</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DefaultSubjectDAO subjectDAO = <span class="keyword">new</span> DefaultSubjectDAO();</span><br><span class="line">        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = <span class="keyword">new</span> DefaultSessionStorageEvaluator();</span><br><span class="line">        defaultSessionStorageEvaluator.setSessionStorageEnabled(<span class="keyword">false</span>);</span><br><span class="line">        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);</span><br><span class="line">        securityManager.setSubjectDAO(subjectDAO);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"shiroFilter"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">factory</span><span class="params">(DefaultWebSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean factoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        factoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 拦截器</span></span><br><span class="line">        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 配置不会被拦截的链接 顺序判断，规则：http://shiro.apache.org/web.html#urls-</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/register"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/unauthorized"</span>, <span class="string">"anon"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加自己的过滤器并且取名为jwt</span></span><br><span class="line">        Map&lt;String, Filter&gt; filterMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        filterMap.put(<span class="string">"jwt"</span>, <span class="keyword">new</span> JwtFilter());</span><br><span class="line">        factoryBean.setFilters(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤链定义，从上向下顺序执行，一般将/**放在最为下边</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"jwt"</span>);</span><br><span class="line">        <span class="comment">// 未授权返回</span></span><br><span class="line">        factoryBean.setUnauthorizedUrl(<span class="string">"/unauthorized"</span>);</span><br><span class="line"></span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加注解支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@DependsOn</span>(<span class="string">"lifecycleBeanPostProcessor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        <span class="comment">// 强制使用cglib，防止重复代理和可能引起代理出错的问题</span></span><br><span class="line">        <span class="comment">// https://zhuanlan.zhihu.com/p/29161098</span></span><br><span class="line">        defaultAdvisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title">lifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(DefaultWebSecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor advisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        advisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>自定义<code>Realm</code>：继承<code>AuthorizingRealm</code>类，在其中实现登陆验证及权限获取的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"MyRealm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 注入SysService */</span></span><br><span class="line">    <span class="keyword">private</span> SysService sysService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSysService</span><span class="params">(SysService sysService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sysService = sysService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须重写此方法，不然Shiro会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> JwtToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来进行身份认证，也就是说验证用户输入的账号和密码是否正确，</span></span><br><span class="line"><span class="comment">     * 获取身份验证信息，错误抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken auth)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"————————身份认证——————————"</span>);</span><br><span class="line">        String token = (String) auth.getCredentials();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == token || !JwtUtil.isVerify(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"token无效!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解密获得username，用于和数据库进行对比</span></span><br><span class="line">        String account = JwtUtil.parseTokenAud(token);</span><br><span class="line">        User user = sysService.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == user) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"用户不存在!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user, token,<span class="string">"MyRealm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户权限信息，包括角色以及权限。</span></span><br><span class="line"><span class="comment">     * 只有当触发检测用户权限时才会调用此方法，例如checkRole,checkPermissionJwtToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"————权限认证 [ roles、permissions]————"</span>);</span><br><span class="line">        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="comment">/* 暂不编写，此处编写后，controller中可以使用@RequiresPermissions来对用户权限进行拦截 */</span></span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>鉴权登录过滤器：继承<code>BasicHttpAuthenticationFilter</code>类,该拦截器需要拦截所有请求除(除登陆、注册等请求)，用于判断请求是否带有<code>token</code>，并获取<code>token</code>的值传递给<code>shiro</code>的登陆认证方法作为参数，用于获取<code>token</code>；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtFilter</span> <span class="keyword">extends</span> <span class="title">BasicHttpAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executeLogin(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            unauthorized(response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        String authorization = httpServletRequest.getHeader(<span class="string">"X-Token"</span>);</span><br><span class="line">        JwtToken token = <span class="keyword">new</span> JwtToken(authorization);</span><br><span class="line">        <span class="comment">// 提交给realm进行登入，如果错误他会抛出异常并被捕获</span></span><br><span class="line">        getSubject(request, response).login(token);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败 跳转到 /unauthorized</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unauthorized</span><span class="params">(ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpServletResponse httpServletResponse = (HttpServletResponse) resp;</span><br><span class="line">            httpServletResponse.sendRedirect(<span class="string">"/unauthorized"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对跨域提供支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse) response;</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">"Access-control-Allow-Origin"</span>, httpServletRequest.getHeader(<span class="string">"Origin"</span>));</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"GET,POST,OPTIONS,PUT,DELETE"</span>);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, httpServletRequest.getHeader(<span class="string">"Access-Control-Request-Headers"</span>));</span><br><span class="line">        <span class="comment">// 跨域时会首先发送一个option请求，给option请求直接返回正常状态</span></span><br><span class="line">        <span class="keyword">if</span> (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;</span><br><span class="line">            httpServletResponse.setStatus(HttpStatus.OK.value());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><code>JwtToken</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtToken</span> <span class="keyword">implements</span> <span class="title">AuthenticationToken</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line">    JwtToken(String token) &#123;</span><br><span class="line">        <span class="keyword">this</span>.token = token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPrincipal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCredentials</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><code>JWT</code>工具类：利用登陆信息生成<code>token</code>，根据<code>token</code>获取<code>username</code>，<code>token</code>验证等方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 设置过期时间: 30分钟 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/** 服务端的私钥secret,在任何场景都不应该流露出去 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_SECRET = <span class="string">"zhengchao"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名，30分钟过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createToken</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">            <span class="comment">// 私钥和加密算法</span></span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">// 设置头部信息</span></span><br><span class="line">            Map&lt;String, Object&gt; header = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            header.put(<span class="string">"typ"</span>, <span class="string">"JWT"</span>);</span><br><span class="line">            header.put(<span class="string">"alg"</span>, <span class="string">"HS256"</span>);</span><br><span class="line">            <span class="comment">// 返回token字符串</span></span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">"aud"</span>, user.getAccount())</span><br><span class="line">                    .withClaim(<span class="string">"uid"</span>, user.getId())</span><br><span class="line">                    .withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验token是否正确</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVerify</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出uid信息,用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseTokenUid</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"uid"</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出aud信息,用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseTokenAud</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"aud"</span>).asString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">paraseExpiresTime</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span>  jwt.getExpiresAt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>MD5加密工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5Util</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s：待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化MessageDigest的MD5算法对象</span></span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="comment">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = md.digest(s.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="comment">//将字节数组转换为16进制字符串并返回</span></span><br><span class="line">            <span class="keyword">return</span> toHex(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随即盐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">salt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用UUID生成随机盐</span></span><br><span class="line">        UUID uuid = UUID.randomUUID();</span><br><span class="line">        <span class="comment">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class="line">        String[] arr = uuid.toString().split(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转换为16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] HEX_DIGITS = <span class="string">"0123456789ABCDEF"</span>.toCharArray();</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class="line">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]);</span><br><span class="line">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class="number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-注册与登录主要逻辑"><a href="#3-注册与登录主要逻辑" class="headerlink" title="3. 注册与登录主要逻辑"></a>3. 注册与登录主要逻辑</h3><p>这里只贴出主要逻辑，<code>DAO</code>和<code>Mapper</code>映射可查看源码，源码请移步文章末尾获取。</p><ol><li>登录<code>Controller</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysApi</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入服务类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SysService sysService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSysService</span><span class="params">(SysService sysService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sysService = sysService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册(用户名，密码)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title">register</span><span class="params">(String account, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sysService.register(account, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录(用户名，密码)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title">login</span><span class="params">(String account, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sysService.login(account, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理非法请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/unauthorized"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseVo <span class="title">unauthorized</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseVo(-<span class="number">1</span>, <span class="string">"Token失效请重新登录!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Service</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SysService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册(用户名，密码)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResponseVo&lt;String&gt; <span class="title">register</span><span class="params">(String account, String password)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录(用户名，密码)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResponseVo&lt;String&gt; <span class="title">login</span><span class="params">(String account, String password)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据account查找用户，自定义Realm中调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">selectByAccount</span><span class="params">(String account)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysServiceImpl</span> <span class="keyword">implements</span> <span class="title">SysService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SysDao sysDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入DAO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSysDao</span><span class="params">(SysDao sysDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sysDao = sysDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户注册(用户名，密码)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title">register</span><span class="params">(String account, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查用户名是否被占用</span></span><br><span class="line">        User user = sysDao.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseVo&lt;&gt;( -<span class="number">1</span>, <span class="string">"用户名被占用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加用户信息</span></span><br><span class="line">        user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//设置用户名</span></span><br><span class="line">        user.setAccount(account);</span><br><span class="line">        <span class="comment">//密码加密后再保存</span></span><br><span class="line">        String salt = Md5Util.salt();</span><br><span class="line">        String md5Password = Md5Util.md5(password+salt);</span><br><span class="line">        user.setPassword(md5Password);</span><br><span class="line">        user.setSalt(salt);</span><br><span class="line">        <span class="comment">//设置注册时间</span></span><br><span class="line">        user.setCreatetime(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="comment">//添加到数据库</span></span><br><span class="line">        <span class="keyword">int</span> row = sysDao.insertSelective(user);</span><br><span class="line">        <span class="comment">//返回信息</span></span><br><span class="line">        <span class="keyword">if</span>(row&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//生成token给用户</span></span><br><span class="line">            String token = JwtUtil.createToken(user);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseVo&lt;&gt;(<span class="number">0</span>,<span class="string">"注册成功"</span>, token);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseVo&lt;&gt;( -<span class="number">1</span>, <span class="string">"注册失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录(用户名，密码)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title">login</span><span class="params">(String account, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理比对密码</span></span><br><span class="line">        User user = sysDao.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            String  salt = user.getSalt();</span><br><span class="line">            String md5Password = Md5Util.md5(password+salt);</span><br><span class="line">            String dbPassword = user.getPassword();</span><br><span class="line">            <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">                <span class="comment">//生成token给用户</span></span><br><span class="line">                String token = JwtUtil.createToken(user);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ResponseVo&lt;&gt;(<span class="number">0</span>,<span class="string">"登录成功"</span>, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseVo&lt;&gt;( -<span class="number">1</span>, <span class="string">"登录失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据account查找用户，自定义Realm中调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectByAccount</span><span class="params">(String account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sysDao.selectByAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>统一接口返回格式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseVo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 状态码 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">/** 提示信息 */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/** 返回的数据 */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseVo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseVo</span><span class="params">(Integer code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseVo</span><span class="params">(Integer code, String msg, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这里的登录认证逻辑在<code>github</code>源码<code>tag</code>的<code>V1.0</code>中，后续版本再加入<code>Token</code>续签和<code>shiro</code>前后端权限管理等。<br>源码地址: <a href="https://github.com/chaooo/springboot-vue-shiro.git" target="_blank" rel="noopener">https://github.com/chaooo/springboot-vue-shiro.git</a><br>仅下载认证逻辑源码:<br><code>git clone --branch V1.0 https://github.com/chaooo/springboot-vue-shiro.git</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-开始之前&quot;&gt;&lt;a href=&quot;#1-开始之前&quot; class=&quot;headerlink&quot; title=&quot;1. 开始之前&quot;&gt;&lt;/a&gt;1. 开始之前&lt;/h3&gt;&lt;h4 id=&quot;1-1-技术选型&quot;&gt;&lt;a href=&quot;#1-1-技术选型&quot; class=&quot;headerlink&quot; title=&quot;1.1 技术选型&quot;&gt;&lt;/a&gt;1.1 技术选型&lt;/h4&gt;&lt;p&gt;选用&lt;code&gt;SpringBoot+Shiro+JWT&lt;/code&gt;实现登录认证，结合&lt;code&gt;Redis&lt;/code&gt;服务实现&lt;code&gt;token&lt;/code&gt;的续签，前端选用&lt;code&gt;Vue&lt;/code&gt;动态构造路由及更细粒度的操作权限控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前后端分离项目中，我们一般采用的是无状态登录：服务端不保存任何客户端请求者信息，客户端需要自己携带着信息去访问服务端，并且携带的信息可以被服务端辨认。&lt;/li&gt;
&lt;li&gt;而&lt;code&gt;Shiro&lt;/code&gt;默认的拦截跳转都是跳转&lt;code&gt;url&lt;/code&gt;页面，拦截校验机制恰恰使用的&lt;code&gt;session&lt;/code&gt;；而前后端分离后，后端并无权干涉页面跳转。&lt;/li&gt;
&lt;li&gt;因此前后端分离项目中使用&lt;code&gt;Shiro&lt;/code&gt;就需要对其进行改造，我们可以在整合&lt;code&gt;Shiro&lt;/code&gt;的基础上自定义登录校验，继续整合&lt;code&gt;JWT&lt;/code&gt;(或者oauth2.0等)，使其成为支持服务端无状态登录，即&lt;code&gt;token&lt;/code&gt;登录。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Vue&lt;/code&gt;项目中，只需要根据登录用户的权限信息动态的加载路由列表就可以动态的构造出访问菜单。
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】Shiro安全框架入门</title>
    <link href="http://chaooo.github.io/article/20191222.html"/>
    <id>http://chaooo.github.io/article/20191222.html</id>
    <published>2019-12-22T12:44:40.000Z</published>
    <updated>2019-12-29T15:22:40.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-初识Shiro"><a href="#1-初识Shiro" class="headerlink" title="1. 初识Shiro"></a>1. 初识Shiro</h3><p><code>Apache Shiro</code>是一个强大易用的Java安全框架，提供了认证、授权、加密、会话管理、与Web集成、缓存等。</p><ul><li><p>具体来说，满足对如下元素的支持：</p><ul><li>用户，角色，权限(仅仅是操作权限，数据权限必须与业务需求紧密结合)，资源(url)。</li><li>用户分配角色，角色定义权限。</li><li>访问授权时支持角色或者权限，并且支持多级的权限定义。<a id="more"></a></li></ul></li><li><p>Shiro作为一个完善的权限框架，可以应用在多种需要进行身份认证和访问授权的场景，例如：<code>独立应用</code>、<code>web应用</code>、<code>spring框架中集成</code>等。</p></li></ul><h3 id="2-Shiro整体架构"><a href="#2-Shiro整体架构" class="headerlink" title="2. Shiro整体架构"></a>2. Shiro整体架构</h3><p>在shiro架构中，有3个最主要的组件：<code>Subject</code>，<code>SecurityManager</code>，<code>Realm</code>。</p><p><img src="http://cdn.chaooo.top/Java/Shiro.png" alt></p><ol><li><strong><code>Subject</code></strong>(如图上层部分)：”操作用户(<strong>主体</strong>)”，本质上就是当前访问用户的抽象描述。</li><li><strong><code>SecurityManager</code></strong>(如图中层部分)：是Shiro架构中最核心的组件(<strong>控制器</strong>)，通过它可以协调其他组件完成用户认证和授权。<ul><li><code>Authenticator</code>：认证器，协调一个或者多个Realm，从Realm指定的数据源取得数据之后进行执行具体的认证。</li><li><code>Authorizer</code>：授权器，用户访问控制授权，决定用户是否拥有执行指定操作的权限。</li><li><code>Session Manager</code>：Session管理器，Shiro自己实现了一套Session管理机制。</li><li><code>Session DAO</code>：实现了Session的操作，主要有增删改查。</li><li><code>CacheManager</code>：缓存管理器，缓存角色数据和权限数据等。</li><li><code>Pluggable Realms</code>：数据库与数据源之间的一个桥梁。Shiro获取认证信息、权限数据、角色数据 通过Realms来获取。</li><li><code>Cryptography</code>：是用来做加解密，能非常快捷的实现数据加密。</li></ul></li><li><strong><code>Realm</code></strong>(如图下层部分)：定义了访问数据的方式，用来连接不同的<strong>数据源</strong>，如：LDAP，关系数据库，配置文件等等。</li></ol><h3 id="3-Shiro认证与授权"><a href="#3-Shiro认证与授权" class="headerlink" title="3. Shiro认证与授权"></a>3. Shiro认证与授权</h3><h4 id="3-1-Shiro认证"><a href="#3-1-Shiro认证" class="headerlink" title="3.1 Shiro认证"></a>3.1 Shiro认证</h4><p>【创建<code>SecurityManager</code>】&gt;【主体提交请求】&gt;【<code>SecurityManager</code>调用<code>Authenticator</code>去认证】&gt;【<code>Realm</code>验证】</p><ul><li>操作用户（主体）提交请求到Security Manager调用Authenticator去认证,Authenticator通过Pluggable Realms去获取认证信息，Pluggable Realms是从下面的数据源（数据库）中去获取的认证信息，然后用通过Pluggable Realms从数据库中获取的认证信息和主体提交过来的认证数据做比对。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shiro认证 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建一个简单的数据源</span></span><br><span class="line">    SimpleAccountRealm simpleAccountRealm = <span class="keyword">new</span> SimpleAccountRealm();</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 参数分别为：用户名，密码，权限...</span></span><br><span class="line">        simpleAccountRealm.addAccount(<span class="string">"chaooo"</span>, <span class="string">"123456"</span>, <span class="string">"admin"</span>,<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAuthentication</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1.构建SecurityManager环境</span></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        defaultSecurityManager.setRealm(simpleAccountRealm);</span><br><span class="line">        <span class="comment">// 2. 主体提交认证请求</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 3. 调用Subject.login(token)方法开始用户认证流程</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"chaooo"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        　　subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">"用户不存在: %s"</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">"密码不正确: %s"</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConcurrentAccessException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">"用户重复登录: %s"</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccountException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">"其他账户异常: %s"</span>, username), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-Shiro授权"><a href="#3-2-Shiro授权" class="headerlink" title="3.2 Shiro授权"></a>3.2 Shiro授权</h4><p>shiro访问授权有3种实现方式：<strong><code>api</code>调用</strong>，<strong><code>java</code>注解</strong>，<strong><code>jsp</code>标签</strong>。</p><ol><li>通过api调用实现:【创建<code>SecurityManager</code>】&gt;【主体授权】&gt;【<code>SecurityManager</code>调用<code>Authorizer</code>授权】&gt;【<code>Realm</code>获取角色权限数据】<ul><li>大体上和认证操作一样，也是通过Pluggable Realms从下面的数据源（数据库）中去获取权限数据,角色数据。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在执行访问授权验证之前，必须执行用户认证</span></span><br><span class="line"><span class="comment">// 角色验证</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">　　<span class="comment">//用户属于角色admin</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　<span class="comment">//用户不属于角色admin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// subject.checkRoles("admin","user");同时check多个角色</span></span><br><span class="line"><span class="comment">// 权限验证</span></span><br><span class="line">String perm = <span class="string">"log:manage:*"</span>;</span><br><span class="line"><span class="keyword">if</span>(subject.isPermitted(perm)) &#123;</span><br><span class="line">　　logger.info(String.format(<span class="string">"用户： %s 拥有权限：%s"</span>, name, perm));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">　　logger.error(String.format(<span class="string">"用户：%s 没有权限：%s"</span>, name, perm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在spring框架中可以通过java注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions</span>(value=&#123;<span class="string">"log:manage:*"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">home</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">　　ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"home"</span>);</span><br><span class="line">　　<span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在JSP页面中还可以直接使用jsp标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用shiro标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"log:manage:*"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%=request.getContextPath()%&gt;/user/home"</span>&gt;</span>操作日志审计<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-Quickstart"><a href="#3-3-Quickstart" class="headerlink" title="3.3 Quickstart"></a>3.3 Quickstart</h4><ol><li>新建一个<code>Maven</code>项目，<code>pom</code>导入<code>jar</code>包:<code>shiro-all</code>、<code>slf4j-api</code>、<code>slf4j-log4j12</code>、<code>log4j</code>;</li><li><code>classpath</code>下新建<code>shiro.ini</code>配置文件:</li></ol><figure class="highlight ini"><figcaption><span>shiro.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Users and their assigned roles</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each line conforms to the format defined in the</span></span><br><span class="line"><span class="comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="comment"># user 'root' with password 'secret' and the 'admin' role</span></span><br><span class="line"><span class="attr">root</span> = secret, admin</span><br><span class="line"><span class="comment"># user 'guest' with the password 'guest' and the 'guest' role</span></span><br><span class="line"><span class="attr">guest</span> = guest, guest</span><br><span class="line"><span class="comment"># user 'chaooo' with password '123456' and roles 'user' and 'guest'</span></span><br><span class="line"><span class="attr">chaooo</span> = <span class="number">123456</span>, user, guest</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Roles with assigned permissions</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Each line conforms to the format defined in the</span></span><br><span class="line"><span class="comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="comment"># 'admin' role has all permissions, indicated by the wildcard '*'</span></span><br><span class="line"><span class="attr">admin</span> = *</span><br><span class="line"><span class="comment"># The 'schwartz' role can do anything (*) with any lightsaber:</span></span><br><span class="line"><span class="attr">user</span> = user:*</span><br><span class="line"><span class="comment"># The 'goodguy' role is allowed to 'query' (action) the user (type) with license plate 'zhangsan' (instance specific id)</span></span><br><span class="line"><span class="attr">guest</span> = user:query:zhangsan</span><br></pre></td></tr></table></figure><ol start="3"><li>启动运行Quickstart</li></ol><figure class="highlight java"><figcaption><span>Quickstart.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quickstart</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger log = LoggerFactory.getLogger(Quickstart.class);</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建SecurityManager环境</span></span><br><span class="line">        DefaultSecurityManager securityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        IniRealm iniRealm = <span class="keyword">new</span> IniRealm(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">        securityManager.setRealm(iniRealm);</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get the currently executing user:</span></span><br><span class="line">        <span class="comment">// 获取当前的 Subject</span></span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Do some stuff with a Session (no need for a web or EJB container!!!)</span></span><br><span class="line">        <span class="comment">// 测试使用 shiro的Session</span></span><br><span class="line">        Session session = currentUser.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">"someKey"</span>, <span class="string">"aValue"</span>);</span><br><span class="line">        String value = (String) session.getAttribute(<span class="string">"someKey"</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">"aValue"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"---&gt; Retrieved the correct value! ["</span> + value + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// let's login the current user so we can check against roles and permissions:</span></span><br><span class="line">        <span class="comment">// 测试当前的用户是否已经被认证. 即是否已经登录.</span></span><br><span class="line">        <span class="comment">// 调动 Subject 的 isAuthenticated()</span></span><br><span class="line">        <span class="keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">            <span class="comment">// 把用户名和密码封装为 UsernamePasswordToken 对象</span></span><br><span class="line">            UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"chaooo"</span>, <span class="string">"123456"</span>);</span><br><span class="line">            <span class="comment">// rememberme</span></span><br><span class="line">            token.setRememberMe(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行登录.</span></span><br><span class="line">                currentUser.login(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若没有指定的账户, 则 shiro 将会抛出 UnknownAccountException 异常.</span></span><br><span class="line">            <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">                log.info(<span class="string">"----&gt; There is no user with username of "</span> + token.getPrincipal());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若账户存在, 但密码不匹配, 则 shiro 会抛出 IncorrectCredentialsException 异常。</span></span><br><span class="line">            <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">                log.info(<span class="string">"----&gt; Password for account "</span> + token.getPrincipal() + <span class="string">" was incorrect!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用户被锁定的异常 LockedAccountException</span></span><br><span class="line">            <span class="keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">                log.info(<span class="string">"The account for username "</span> + token.getPrincipal() + <span class="string">" is locked.  "</span> +</span><br><span class="line">                        <span class="string">"Please contact your administrator to unlock it."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span></span><br><span class="line">            <span class="comment">// 所有认证时异常的父类.</span></span><br><span class="line">            <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">                <span class="comment">//unexpected condition?  error?</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//say who they are:</span></span><br><span class="line">        <span class="comment">//print their identifying principal (in this case, a username):</span></span><br><span class="line">        log.info(<span class="string">"----&gt; User ["</span> + currentUser.getPrincipal() + <span class="string">"] logged in successfully."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test a role:</span></span><br><span class="line">        <span class="comment">// 测试是否有某一个角色. 调用 Subject 的 hasRole 方法.</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.hasRole(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"----&gt; May the Admin be with you!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"----&gt; Hello, mere mortal."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//test a typed permission (not instance-level)</span></span><br><span class="line">        <span class="comment">// 测试用户是否具备某一个行为. 调用 Subject 的 isPermitted() 方法。</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">"user:query, edit"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"----&gt; You are permitted to 'query' and 'edit' 'user'"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Sorry, you don't have permission"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//a (very powerful) Instance Level permission:</span></span><br><span class="line">        <span class="comment">// 测试用户是否具备某一个行为. 资源标识符:操作:对象实例ID</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">"user:query:zhangsan"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"----&gt; You are permitted to 'delete' 'user' 'zhangsan'"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Sorry, you don't have permission!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//all done - log out!</span></span><br><span class="line">        <span class="comment">// 执行登出. 调用 Subject 的 Logout() 方法.</span></span><br><span class="line">        System.out.println(<span class="string">"----&gt;"</span> + currentUser.isAuthenticated());</span><br><span class="line">        currentUser.logout();</span><br><span class="line">        System.out.println(<span class="string">"----&gt;"</span> + currentUser.isAuthenticated());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-在SpringMVC框架中集成Shiro"><a href="#4-在SpringMVC框架中集成Shiro" class="headerlink" title="4. 在SpringMVC框架中集成Shiro"></a>4. 在SpringMVC框架中集成Shiro</h3><h4 id="4-1-配置Maven依赖"><a href="#4-1-配置Maven依赖" class="headerlink" title="4.1 配置Maven依赖"></a>4.1 配置Maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables support for web-based applications. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables AspectJ support for Shiro AOP and Annotations. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables Ehcache-based famework caching. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables Spring Framework integration. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>Shiro</code>使用了日志框架<code>slf4j</code>，因此需要对应配置指定的日志实现组件，如：<code>log4j</code>，<code>logback</code>等。<ul><li>在此，以使用<code>log4j</code>为日志实现为例：</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">shiro使用slf4j作为日志框架，所以必需配置slf4j。</span></span><br><span class="line"><span class="comment">同时，使用log4j作为底层的日志实现框架。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-集成Shiro"><a href="#4-2-集成Shiro" class="headerlink" title="4.2 集成Shiro"></a>4.2 集成Shiro</h4><p>在<code>Spring</code>框架中集成<code>Shiro</code>，本质上是与<code>Spring IoC</code>容器和<code>Spring MVC</code>框架集成。</p><h5 id="4-2-1-Shiro与Spring-IoC容器集成"><a href="#4-2-1-Shiro与Spring-IoC容器集成" class="headerlink" title="4.2.1 Shiro与Spring IoC容器集成"></a>4.2.1 <code>Shiro</code>与<code>Spring IoC</code>容器集成</h5><ul><li><code>Spring IoC</code>容器提供了一个非常重要的功能，就是依赖注入，将<code>Bean</code>的定义以及<code>Bean</code>之间关系的耦合通过容器来处理。</li><li>也就是说，在<code>Spring</code>中集成<code>Shiro</code>时，<code>Shiro</code>中的相应<code>Bean</code>的定义以及他们的关系也需要通过<code>Spring IoC</code>容器实现。</li><li><code>Shiro</code>提供了与<code>Web</code>集成的支持，其通过一个<code>ShiroFilter</code>入口来拦截需要安全控制的<code>URL</code>，然后进行相应的控制。</li><li><code>ShiroFilter</code>类是安全控制的入口点，其负责读取配置（如<code>ini</code>配置文件），然后判断<code>URL</code> 是否需要登录/权限等工作。<ul><li>[urls] 部分的配置，其格式是：<code>url = 拦截器[参数], 拦截器[参数]</code></li></ul></li><li><code>shiro</code>中默认的过滤器：</li></ul><table><thead><tr><th>默认拦截器名</th><th>拦截器类与说明（括号里的表示默认值）</th></tr></thead><tbody><tr><td><span style="white-space:nowrap;">身份验证相关</span></td><td></td></tr><tr><td>authc</td><td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter<br>基于表单的拦截器；如”/**=authc”，如果没有登录会跳到相应的登录页面登录；主要属性：usernameParam：表单提交的用户名参数名（ username）；  passwordParam：表单提交的密码参数名（password）； rememberMeParam：表单提交的密码参数名（rememberMe）；  loginUrl：登录页面地址（/login.jsp）；successUrl：登录成功后的默认重定向地址； failureKeyAttribute：登录失败后错误信息存储key（shiroLoginFailure）；</td></tr><tr><td>authcBasic</td><td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter<br>Basic HTTP身份验证拦截器，主要属性：applicationName：弹出登录框显示的信息（application）；</td></tr><tr><td>logout</td><td>org.apache.shiro.web.filter.authc.LogoutFilter<br>退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/）;示例”/logout=logout”</td></tr><tr><td>user</td><td>org.apache.shiro.web.filter.authc.UserFilter<br>用户拦截器，用户已经身份验证/记住我登录的都可；示例”/**=user”</td></tr><tr><td>anon</td><td>org.apache.shiro.web.filter.authc.AnonymousFilter<br>匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例”/static/**=anon”</td></tr><tr><td>授权相关</td><td></td></tr><tr><td>roles</td><td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter<br>角色授权拦截器，验证用户是否拥有所有角色；主要属性：loginUrl：登录页面地址（/login.jsp）；unauthorizedUrl：未授权后重定向的地址；示例”/admin/**=roles[admin]”</td></tr><tr><td>perms</td><td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter<br>权限授权拦截器，验证用户是否拥有所有权限；属性和roles一样；示例”/user/**=perms[“user:create”]”</td></tr><tr><td>port</td><td>org.apache.shiro.web.filter.authz.PortFilter<br>端口拦截器，主要属性：port（80）：可以通过的端口；示例”/test= port[80]”，如果用户访问该页面是非80，将自动将请求端口改为80并重定向到该80端口，其他路径/参数等都一样</td></tr><tr><td>rest</td><td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter<br>rest风格拦截器，自动根据请求方法构建权限字符串（GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create）构建权限字符串；示例”/users=rest[user]”，会自动拼出”user:read,user:create,user:update,user:delete”权限字符串进行权限匹配（所有都得匹配，isPermittedAll）；</td></tr><tr><td>ssl</td><td>org.apache.shiro.web.filter.authz.SslFilter<br>SSL拦截器，只有请求协议是https才能通过；否则自动跳转会https端口（443）；其他和port拦截器一样；</td></tr><tr><td>其他</td><td></td></tr><tr><td>noSessionCreation</td><td>org.apache.shiro.web.filter.session.NoSessionCreationFilter<br>不创建会话拦截器，调用 subject.getSession(false)不会有什么问题，但是如果 subject.getSession(true)将抛出 DisabledSessionException异常；</td></tr></tbody></table><ul><li><code>URL</code>匹配模式：url模式使用Ant 风格模式<ul><li>Ant 路径通配符支持<code>?</code>、<code>*</code>、<code>**</code>，注意通配符匹配不包括目录分隔符“/”：</li><li><code>?</code>：匹配一个字符，如/admin? 将匹配/admin1，但不匹配/admin 或/admin/；</li><li><code>*</code>：匹配零个或多个字符串，如/admin 将匹配/admin、/admin123，但不匹配/admin/1；</li><li><code>**</code>：匹配路径中的零个或多个路径，如/admin/** 将匹配/admin/a 或/admin/a/b</li></ul></li><li><code>URL</code>匹配顺序：URL 权限采取<strong>第一次匹配优先</strong>的方式，即从头开始使用第一个匹配的url模式对应的拦截器链。如：<ul><li>/bb/**=filter1</li><li>/bb/aa=filter2</li><li>/**=filter3</li><li>如果请求的url是“/bb/aa”，因为按照声明顺序进行匹配，那么将使用filter1 进行拦截，所以通配符一般写在靠后。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/index"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"successUrl"</span> <span class="attr">value</span>=<span class="string">"/home"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/unauthorized.jsp"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- The 'filters' property is not necessary since any declared javax.servlet.Filter bean  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- defined will be automatically acquired and available via its beanName in chain        --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- definitions, but you can perform instance overrides or name aliases here if you like: --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;property name="filters"&gt;</span></span><br><span class="line"><span class="comment">      &lt;util:map&gt;</span></span><br><span class="line"><span class="comment">          &lt;entry key="logout" value-ref="logoutFilter" /&gt;</span></span><br><span class="line"><span class="comment">      &lt;/util:map&gt;</span></span><br><span class="line"><span class="comment">  &lt;/property&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">          # some example chain definitions:</span><br><span class="line">          # /admin/** = authc, roles[admin]</span><br><span class="line">          # /docs/** = authc, perms[document:read]</span><br><span class="line">          /login = anon</span><br><span class="line">          /logout = anon</span><br><span class="line">          /error = anon</span><br><span class="line">          /** = user</span><br><span class="line">          # more URL-to-FilterChain definitions here</span><br><span class="line">      <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"myRealm"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- By default the servlet container sessions will be used.  Uncomment this line</span></span><br><span class="line"><span class="comment">       to use shiro's native sessions (see the JavaDoc for more): --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;property name="sessionMode" value="native"/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Define the Shiro Realm implementation you want to use to connect to your back-end --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- security datasource: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myRealm"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.realm.jdbc.JdbcRealm"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionsLookupEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enable Shiro Annotations for Spring-configured beans.  Only run after --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- the lifecycleBeanProcessor has run: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span> <span class="attr">depends-on</span>=<span class="string">"lifecycleBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-2-与Spring-MVC集成"><a href="#4-2-2-与Spring-MVC集成" class="headerlink" title="4.2.2 与Spring MVC集成"></a>4.2.2 与<code>Spring MVC</code>集成</h5><ul><li>跟在普通<code>Java Web</code>应用中使用<code>Shiro</code>一样，集成<code>Shiro</code>到<code>Spring MVC</code>时，实际上就是通过在<code>web.xml</code>中添加指定<code>Filter</code>实现。配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The filter-name matches name of a 'shiroFilter' bean inside applicationContext.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- DelegatingFilterProxy作用是自动到Spring 容器查找名字为shiroFilter（filter-name）的bean并把所有Filter 的操作委托给它。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Make sure any request you want accessible to Shiro is filtered. /* catches all --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- requests.  Usually this filter mapping is defined first (before all others) to --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ensure that Shiro works in subsequent filters in the filter chain:             --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Spring</code>中集成<code>Shiro</code>的原理就是：通过在<code>web.xml</code>中配置的<code>Shiro Filter</code>与<code>Spring IoC</code>中定义的相应的<code>Shiro Bean</code>定义建立关系，从而实现在<code>Spring</code>框架集成<code>Shiro</code>。</p></blockquote><h4 id="4-3-数据源配置"><a href="#4-3-数据源配置" class="headerlink" title="4.3 数据源配置"></a>4.3 数据源配置</h4><p>在<code>Shiro</code>中，<code>Realm</code>定义了访问数据的方式，用来连接不同的数据源，如：LDAP，关系数据库，配置文件等。</p><ul><li>以<code>org.apache.shiro.realm.jdbc.JdbcRealm</code>为例，将用户信息存放在关系型数据库中。</li><li>在使用<code>JdbcRealm</code>时，必须要在关系型数据库中存在3张表，分别是<ul><li><code>users</code>表，存放认证用户基本信息，在该表中必须存在2个字段：<code>username</code>，<code>password</code>。</li><li><code>roles_permissions</code>表，存放角色和权限定义，在该表中必须存在2个字段：<code>role_name</code>，<code>permission</code>。</li><li><code>user_roles</code>表，存放用户角色对应关系，在该表中必须存在2个字段：<code>username</code>，<code>role_name</code>。</li></ul></li><li>实际上，在更加复杂的应用场景下，通常需要扩展<code>JdbcRealm</code>。</li></ul><h4 id="4-4-认证"><a href="#4-4-认证" class="headerlink" title="4.4 认证"></a>4.4 认证</h4><p>在<code>Shiro</code>中，认证即执行用户登录，读取指定<code>Realm</code>连接的数据源，以验证用户身份的有效性与合法性。</p><ul><li>在shiro中，用户需要提供principals （身份）和credentials（证明）给shiro，从而应用能验证用户身份：<ul><li>principals：身份，即主体的标识属性，可以是任何属性，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/邮箱/手机号。</li><li>credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</li><li>最常见的principals 和credentials 组合就是用户名/密码了</li></ul></li><li>身份认证流程：<ol><li>首先调用Subject.login(token) 进行登录，其会自动委托给SecurityManager</li><li>SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator 进行身份验证；</li><li>Authenticator 才是真正的身份验证者，ShiroAPI 中核心的身份认证入口点，此处可以自定义插入自己的实现；</li><li>Authenticator 可能会委托给相应的AuthenticationStrategy进行多Realm 身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm 身份验证；</li><li>Authenticator 会把相应的token 传入Realm，从Realm 获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。<ul><li>Realm：一般继承AuthorizingRealm（授权）即可；其继承了AuthenticatingRealm（即身份验证），而且也间接继承了CachingRealm（带有缓存实现）</li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(!subject.isAuthenticated()) &#123;</span><br><span class="line">　　UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(name, password);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    　　subject.login(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">"用户不存在: %s"</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">"密码不正确: %s"</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConcurrentAccessException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">"用户重复登录: %s"</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AccountException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">"其他账户异常: %s"</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-授权"><a href="#4-5-授权" class="headerlink" title="4.5 授权"></a>4.5 授权</h4><p>Shiro作为权限框架，仅仅只能控制对资源的操作权限，并不能完成对数据权限的业务需求。</p><ul><li>而对于Java Web环境下Shiro授权，包含两个方面的含义。<ul><li>其一，对于前端来说，用户只能看到他对应访问权限的元素。</li><li>其二，当用户执行指定操作（即：访问某个uri资源）时，需要验证用户是否具备对应权限。</li></ul></li><li>对于第一点，在Java Web环境下，通过Shiro提供的JSP标签实现。</li><li>对于第二点，与在非Java Web环境下一样，需要在后端调用API进行权限（或者角色）检验。</li><li>在Spring框架中集成Shiro，还可以直接通过Java注解方式实现</li><li><code>Permissions</code>：<ul><li>规则：<code>资源标识符：操作：对象实例ID</code>,即对哪个资源的哪个实例可以进行什么操作.其默认支持通配符权限字符串，: 表示资源/操作/实例的分割；, 表示操作的分割，* 表示任意资源/操作/实例。如：<code>user:edit:manager</code><ul><li>也可以使用通配符来定义，如：<code>user:edit:*</code>、<code>user:*:*</code>、<code>user:*:manager</code></li><li>部分省略通配符：缺少的部件意味着用户可以访问所有与之匹配的值，比如：<code>user:edit</code>等价于<code>user:edit:*</code>、<code>user</code>等价于<code>user:*:*</code></li><li>注意：通配符只能从字符串的结尾处省略部件，也就是说<code>user:edit</code>并<strong>不等价</strong>于<code>user:*:edit</code></li></ul></li></ul></li><li>授权流程:<ol><li>首先调用Subject.isPermitted<em>/hasRole</em> 接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer；</li><li>Authorizer是真正的授权者，如果调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission 实例；</li><li>在进行授权之前，其会调用相应的Realm 获取Subject 相应的角色/权限用于匹配传入的角色/权限；</li><li>Authorizer 会判断Realm 的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted<em>/hasRole</em> 会返回true，否则返回false表示授权失败。<ul><li><code>ModularRealmAuthorizer</code>进行多Realm 匹配流程：<ol><li>首先检查相应的Realm 是否实现了实现了Authorizer；</li><li>如果实现了Authorizer，那么接着调用其相应的<code>isPermitted*/hasRole*</code>接口进行匹配；</li><li>如果有一个Realm匹配那么将返回true，否则返回false。</li></ol></li></ul></li></ol></li></ul><h5 id="4-5-1-Shiro标签"><a href="#4-5-1-Shiro标签" class="headerlink" title="4.5.1 Shiro标签"></a>4.5.1 Shiro标签</h5><ol><li><code>&lt;shiro:guest&gt;&lt;/shiro:guest&gt;</code>:用户没有身份验证时显示相应信息，即游客访问信息</li><li><code>&lt;shiro:user&gt;&lt;/shiro:user&gt;</code>:用户已经经过认证/记住我登录后显示相应的信息。</li><li><code>&lt;shiro:authenticated&gt;&lt;/shiro:authenticated&gt;</code>:用户已经身份验证通过，即Subject.login登录成功，<strong>不是记住我登录的</strong></li><li><code>&lt;shiro:notAuthenticated&gt;&lt;/shiro:notAuthenticated&gt;</code>标签：用户未进行身份验证，即没有调用Subject.login进行登录，<strong>包括记住我自动登录</strong>的也属于未进行身份验证。</li><li><code>&lt;shiro:pincipal&gt;&lt;/shiro:pincipal&gt;</code>：<strong>显示用户身份信息</strong>，默认调用<code>Subject.getPrincipal()</code>获取，即Primary Principal。</li><li><strong><code>&lt;shiro:hasRole&gt;&lt;/shiro:hasRole&gt;</code></strong>标签：如果当前Subject 有角色将显示body 体内容</li><li><code>&lt;shiro:hasAnyRoles&gt;&lt;/shiro:hasAnyRoles&gt;</code>标签：如果当前Subject有任意一个角色（或的关系）将显示body体内容</li><li><code>&lt;shiro:lacksRole&gt;&lt;/shiro:lacksRole&gt;</code>：如果当前Subject 没有角色将显示body 体内容</li><li><strong><code>&lt;shiro:hasPermission&gt;&lt;/shiro:hasPermission&gt;</code></strong>：如果当前Subject 有权限将显示body体内容</li><li><code>&lt;shiro:lacksPermission&gt;&lt;/shiro:lacksPermission&gt;</code>：如果当前Subject没有权限将显示body体内容</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在jsp页面中引入shiro标签库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> <span class="attr">uri</span>=<span class="string">"http://shiro.apache.org/tags"</span> %&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 权限控制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"winnebago:drive:eagle5"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span>&gt;</span>操作审计<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-5-2-调用API进行权限（或者角色）检验"><a href="#4-5-2-调用API进行权限（或者角色）检验" class="headerlink" title="4.5.2 调用API进行权限（或者角色）检验"></a>4.5.2 调用API进行权限（或者角色）检验</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String roleAdmin = <span class="string">"admin"</span>;</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(!currentUser.hasRole(roleAdmin)) &#123;</span><br><span class="line">　　<span class="comment">//todo something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-5-3-Shiro权限注解"><a href="#4-5-3-Shiro权限注解" class="headerlink" title="4.5.3 Shiro权限注解"></a>4.5.3 Shiro权限注解</h5><ul><li><code>@RequiresAuthentication</code>：表示当前Subject已经通过login 进行了身份验证；即Subject. isAuthenticated() 返回true</li><li><code>@RequiresUser</code>：表示当前Subject 已经身份验证或者通过记住我登录的。</li><li><code>@RequiresGuest</code>：表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。</li><li><code>@RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)</code>：表示当前Subject 需要角色admin 和user</li><li><code>@RequiresPermissions(value={“user:a”, “user:b”}, logical= Logical.OR)</code>：表示当前Subject 需要权限user:a或user:b。</li><li>通过自定义拦截器可以扩展功能，例如：动态url-角色/权限访问控制的实现、根据Subject 身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">　　<span class="meta">@RequestMapping</span>(<span class="string">"/home"</span>)</span><br><span class="line">　　<span class="meta">@RequiresPermissions</span>(value=&#123;<span class="string">"log:manage:*"</span>&#125;)</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">home</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">　　　　ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"home"</span>);</span><br><span class="line">　　　　<span class="keyword">return</span> mv;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-Spring集成Shiro注意事项"><a href="#4-6-Spring集成Shiro注意事项" class="headerlink" title="4.6 Spring集成Shiro注意事项"></a>4.6 Spring集成Shiro注意事项</h4><ol><li><code>Spring 4.2.0 RELEASE</code><strong><code>+</code></strong> 与 <code>Spring 4.1.9 RELEASE</code><strong><code>-</code></strong>版本，配置方式有所不同。</li><li>虽然<code>shiro</code>的注解定义是在<code>Class</code>级别的，但是实际验证只能支持方法级别：<code>@RequiresAuthentication</code>、<code>@RequiresPermissions</code>、<code>@RequiresRoles</code>。</li></ol><h3 id="5-Shiro会话管理"><a href="#5-Shiro会话管理" class="headerlink" title="5. Shiro会话管理"></a>5. Shiro会话管理</h3><p>Shiro提供了完整的企业级会话管理功能，不依赖于底层容器（如web容器tomcat），不管JavaSE还是JavaEE环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对Web 的透明支持、SSO 单点登录的支持等特性。</p><h4 id="5-1-会话相关的API"><a href="#5-1-会话相关的API" class="headerlink" title="5.1 会话相关的API"></a>5.1 会话相关的API</h4><ul><li>Subject.getSession()：即可获取会话；其等价于Subject.getSession(true)，即如果当前没有创建Session 对象会创建一个；Subject.getSession(false)，如果当前没有创建Session 则返回null</li><li>session.getId()：获取当前会话的唯一标识</li><li>session.getHost()：获取当前Subject的主机地址</li><li>session.getTimeout() &amp; session.setTimeout(毫秒)：获取/设置当前Session的过期时间</li><li>session.getStartTimestamp() &amp; session.getLastAccessTime()：获取会话的启动时间及最后访问时间；如果是 JavaSE 应用需要自己定期调用 session.touch() 去更新最后访问时间；如果是 Web 应用，每次进入 ShiroFilter 都会自动调用 session.touch() 来更新最后访问时间。</li><li>session.touch() &amp; session.stop()：更新会话最后访问时间及销毁会话；当Subject.logout()时会自动调用 stop 方法来销毁会话。如果在web中，调用 HttpSession. invalidate()也会自动调用Shiro Session.stop 方法进行销毁Shiro 的会话</li><li>session.setAttribute(key, val) &amp; session.getAttribute(key) &amp; session.removeAttribute(key)：设置/获取/删除会话属性；在整个会话范围内都可以对这些属性进行操作</li></ul><h4 id="5-2-会话监听器"><a href="#5-2-会话监听器" class="headerlink" title="5.2 会话监听器"></a>5.2 会话监听器</h4><p>会话监听器(SessionListiner):会话监听器用于监听会话创建、过期及停止事件</p><h4 id="5-3-SessionDao"><a href="#5-3-SessionDao" class="headerlink" title="5.3 SessionDao"></a>5.3 SessionDao</h4><ul><li>AbstractSessionDAO 提供了 SessionDAO 的基础实现，如生成会话ID等</li><li>CachingSessionDAO 提供了对开发者透明的会话缓存的功能，需要设置相应的 CacheManager</li><li>MemorySessionDAO 直接在内存中进行会话维护</li><li>EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用ConcurrentHashMap 保存缓存的会话。 </li></ul><h4 id="5-4-数据表"><a href="#5-4-数据表" class="headerlink" title="5.4 数据表"></a>5.4 数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sessions (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">session</span> <span class="built_in">varchar</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">constraint</span> pk_sessions primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><h4 id="5-5-会话验证"><a href="#5-5-会话验证" class="headerlink" title="5.5 会话验证"></a>5.5 会话验证</h4><ul><li>Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话</li><li>出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 web 环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器SessionValidationScheduler</li><li>Shiro 也提供了使用Quartz会话验证调度器：QuartzSessionValidationScheduler</li></ul><h3 id="6-Shiro缓存"><a href="#6-Shiro缓存" class="headerlink" title="6. Shiro缓存"></a>6. Shiro缓存</h3><ul><li>CacheManagerAware 接口<ul><li>Shiro 内部相应的组件（DefaultSecurityManager）会自动检测相应的对象（如Realm）是否实现了CacheManagerAware 并自动注入相应的CacheManager。</li></ul></li><li>Realm 缓存<ul><li>Shiro 提供了 CachingRealm，其实现了CacheManagerAware 接口，提供了缓存的一些基础实现；</li><li>AuthenticatingRealm 及 AuthorizingRealm 也分别提供了对AuthenticationInfo 和 AuthorizationInfo 信息的缓<br>存。</li></ul></li><li>Session 缓存<ul><li>如 SecurityManager 实现了 SessionSecurityManager，其会判断 SessionManager 是否实现了acheManagerAware 接口，如果实现了会把CacheManager 设置给它。</li><li>SessionManager 也会判断相应的 SessionDAO（如继承自CachingSessionDAO）是否实现了CacheManagerAware，如果实现了会把 CacheManager设置给它</li><li>设置了缓存的 SessionManager，查询时会先查缓存，如果找不到才查数据库。</li></ul></li><li>RememberMe<ul><li>Shiro 提供了记住我（RememberMe）的功能，比如访问如淘宝等一些网站时，关闭了浏览器，下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问，基本流程如下：<ol><li>首先在登录页面选中 RememberMe 然后登录成功；如果是浏览器登录，一般会把 RememberMe 的Cookie 写到客户端并保存下来；</li><li>关闭浏览器再重新打开；会发现浏览器还是记住你的；</li><li>访问一般的网页服务器端还是知道你是谁，且能正常访问；</li><li>但是比如我们访问淘宝时，如果要查看我的订单或进行支付时，此时还是需要再进行身份认证的，以确保当前用户还是你。</li></ol></li></ul></li><li>认证和记住我<ul><li>subject.isAuthenticated() 表示用户进行了身份验证登录的，即使有 Subject.login 进行了登录；</li><li>subject.isRemembered()：表示用户是通过记住我登录的，此时可能并不是真正的你（如你的朋友使用你的电脑，或者你的cookie 被窃取）在访问的</li><li>两者二选一，即 subject.isAuthenticated()==true，则subject.isRemembered()==false；反之一样。</li></ul></li><li>建议<ul><li>访问一般网页：如个人在主页之类的，我们使用user 拦截器即可，user 拦截器只要用户登录(isRemembered() || isAuthenticated())过即可访问成功；</li><li>访问特殊网页：如我的订单，提交订单页面，我们使用authc 拦截器即可，authc 拦截器会判断用户是否是通过Subject.login（isAuthenticated()==true）登录的，如果是才放行，否则会跳转到登录页面叫你重新登录。</li></ul></li><li>实现<ul><li>如果要自己做RememeberMe，需要在登录之前这样创建Token：UsernamePasswordToken(用户名，密码，是否记住我)，且调用UsernamePasswordToken 的：token.setRememberMe(true); 方法</li></ul></li></ul><blockquote><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/nuccch/p/6775855.html" target="_blank" rel="noopener">细说shiro之一：shiro简介</a></li><li><a href="https://www.cnblogs.com/nuccch/p/6775855.html" target="_blank" rel="noopener">细说shiro之五：在spring框架中集成shiro</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-初识Shiro&quot;&gt;&lt;a href=&quot;#1-初识Shiro&quot; class=&quot;headerlink&quot; title=&quot;1. 初识Shiro&quot;&gt;&lt;/a&gt;1. 初识Shiro&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Apache Shiro&lt;/code&gt;是一个强大易用的Java安全框架，提供了认证、授权、加密、会话管理、与Web集成、缓存等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;具体来说，满足对如下元素的支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户，角色，权限(仅仅是操作权限，数据权限必须与业务需求紧密结合)，资源(url)。&lt;/li&gt;
&lt;li&gt;用户分配角色，角色定义权限。&lt;/li&gt;
&lt;li&gt;访问授权时支持角色或者权限，并且支持多级的权限定义。
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】基于Redis的分布式锁实现</title>
    <link href="http://chaooo.github.io/article/20191208.html"/>
    <id>http://chaooo.github.io/article/20191208.html</id>
    <published>2019-12-08T08:04:23.000Z</published>
    <updated>2019-12-08T08:26:49.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SETNX命令简介"><a href="#SETNX命令简介" class="headerlink" title="SETNX命令简介"></a>SETNX命令简介</h3><ul><li><code>SETNX key value</code>返回(<code>1:key</code>的值被设置，<code>0:key</code>的值没被设置)，将<code>key</code>的值设为<code>value</code>，并且仅当<code>key</code>不存在。</li><li>锁的<code>key</code>为目标数据的唯一键，<code>value</code>为锁的期望超时时间点；</li><li>基于<code>Redis</code>实现的分布式锁，主要基于<code>redis</code>的<code>setnx（set if not exist）</code>命令；<a id="more"></a></li></ul><h3 id="1-jedis实现分布式锁"><a href="#1-jedis实现分布式锁" class="headerlink" title="1. jedis实现分布式锁"></a>1. jedis实现分布式锁</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-1-实现示例"><a href="#1-1-实现示例" class="headerlink" title="1.1 实现示例:"></a>1.1 实现示例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">correctGetLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">    String result = jedis.set(lockKey, requestId, <span class="string">"NX"</span>, <span class="string">"PX"</span>, expireTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"OK"</span>.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jedis.set(String key, String value, String nxxx, String expx, int time)</code><br>    - <strong><code>key</code></strong>：保证唯一，用来当锁（<code>redis</code>记录的<code>key</code>）<br>    - <strong><code>value</code></strong>：<code>redis</code>记录的<code>value</code>，目的是为了标志锁的所有者（竞争锁的客户端），保证解锁时只能解自己加的锁。<code>requestId</code>可以使用<code>UUID.randomUUID().toString()</code>方法生成<br>    - <strong><code>nxxx</code></strong>：<code>&quot;NX&quot;</code>意思是<code>SET IF NOT EXIST</code>，即当<code>key</code>不存在时，我们进行<code>set</code>操作，若<code>key</code>已经存在，则不做任何操作<br>    - <strong><code>expx</code></strong>：<code>&quot;PX&quot;</code>意思是要给这个<code>key</code>加一个过期的设置（单位毫秒），过期时间由第五个参数决定<br>    - <strong><code>time</code></strong>：<code>expx</code>设置为<code>&quot;PX&quot;</code>时，<code>redis key</code>的过期时间</p><h4 id="1-2-解锁示例"><a href="#1-2-解锁示例" class="headerlink" title="1.2 解锁示例:"></a>1.2 解锁示例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">correctReleaseLock</span><span class="params">(String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">    String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">    <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eval</code>命令执行<code>Lua</code>代码的时候，<code>Lua</code>代码将被当成一个命令去执行，并且直到<code>eval</code>命令执行完成，<code>Redis</code>才会执行其他命令，所以保证了检查和删除操作都是原子的。</p><h4 id="1-3-这类琐最大的缺点"><a href="#1-3-这类琐最大的缺点" class="headerlink" title="1.3 这类琐最大的缺点"></a>1.3 这类琐最大的缺点</h4><p>加锁时只作用在一个<code>Redis</code>节点上，即使<code>Redis</code>通过<code>sentinel</code>保证高可用，如果这个<code>master</code>节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p><ol><li>在<code>Redis</code>的<code>master</code>节点上拿到了锁；</li><li>但是这个加锁的<code>key</code>还没有同步到<code>slave</code>节点；</li><li><code>master</code>故障，发生故障转移，<code>slave</code>节点升级为<code>master</code>节点；</li><li>导致锁丢失。</li></ol><blockquote><p>因此，<code>Redis</code>作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：<code>Redlock</code>。基于<code>Redis</code>的<code>Redisson</code>实现了<code>Redlock</code>。</p></blockquote><h3 id="2-Redisson实现普通分布式锁"><a href="#2-Redisson实现普通分布式锁" class="headerlink" title="2. Redisson实现普通分布式锁"></a>2. Redisson实现普通分布式锁</h3><p>普通分布式实现非常简单，无论是那种架构，向<code>Redis</code>通过<code>EVAL</code>命令执行<code>LUA脚本</code>即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>单机模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造redisson实现分布式锁必要的Config</span></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">"redis://172.29.1.180:5379"</span>)</span><br><span class="line">                        .setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 构造RedissonClient</span></span><br><span class="line">RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"><span class="comment">// 设置锁定资源名称, 还可以getFairLock(), getReadWriteLock()</span></span><br><span class="line">RLock lock = redissonClient.getLock(<span class="string">"DISLOCK"</span>);</span><br><span class="line"><span class="keyword">boolean</span> isLock;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line">    <span class="comment">// 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</span></span><br><span class="line">    isLock = lock.tryLock(<span class="number">500</span>, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">//TODO if get lock success, do something;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论如何, 最后都要解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哨兵模式:</strong><br>即<code>Sentinel</code>模式，实现代码和单机模式几乎一样，唯一的不同就是<code>Config</code>的构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSentinelServers().addSentinelAddress(</span><br><span class="line">        <span class="string">"redis://172.29.3.245:26378"</span>,<span class="string">"redis://172.29.3.245:26379"</span>, <span class="string">"redis://172.29.3.245:26380"</span>)</span><br><span class="line">      .setMasterName(<span class="string">"mymaster"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>集群模式:</strong><br>即<code>Cluster</code>模式，集群模式构造<code>Config</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useClusterServers().addNodeAddress(</span><br><span class="line">        <span class="string">"redis://172.29.3.245:6375"</span>,<span class="string">"redis://172.29.3.245:6376"</span>, <span class="string">"redis://172.29.3.245:6377"</span>,</span><br><span class="line">        <span class="string">"redis://172.29.3.245:6378"</span>,<span class="string">"redis://172.29.3.245:6379"</span>, <span class="string">"redis://172.29.3.245:6380"</span>)</span><br><span class="line">      .setPassword(<span class="string">"a123456"</span>).setScanInterval(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h3 id="3-Redisson实现Redlock分布式锁"><a href="#3-Redisson实现Redlock分布式锁" class="headerlink" title="3. Redisson实现Redlock分布式锁"></a>3. Redisson实现Redlock分布式锁</h3><h4 id="3-1-Redlock算法大概原理："><a href="#3-1-Redlock算法大概原理：" class="headerlink" title="3.1 Redlock算法大概原理："></a>3.1 Redlock算法大概原理：</h4><ul><li>在<code>Redis</code>的分布式环境中，我们假设有<code>N</code>个<code>Redis master</code>。这些节点<strong>完全互相独立，不存在主从复制或者其他集群协调机制</strong>。我们确保将在<code>N</code>个实例上使用与在<code>Redis</code>单实例下相同方法获取和释放锁。</li><li>为了取到锁，客户端应该执行以下操作:<ul><li>获取当前<code>Unix</code>时间，以毫秒为单位。</li><li>依次尝试从<code>N</code>个实例，使用相同的<code>key</code>和具有唯一性的<code>value</code>（例如UUID）获取锁。</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。</li><li><strong>当且仅当(N/2+1)的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功</strong>，例如3个节点至少需要<code>3/2+1=2</code>2个。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li><li>若获取锁失败，客户端应该在<strong>所有的Redis实例上进行解锁</strong>（即便某些Redis实例根本就没有加锁成功）。</li></ul></li></ul><h4 id="3-2-使用Redlock"><a href="#3-2-使用Redlock" class="headerlink" title="3.2 使用Redlock"></a>3.2 使用<code>Redlock</code></h4><p>单机模式<code>Redis</code>为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useClusterServers().addNodeAddress(</span><br><span class="line">        <span class="string">"redis://127.0.0.1:6379"</span>,<span class="string">"redis://127.0.0.1:6369"</span>, <span class="string">"redis://127.0.0.1:6359"</span>,</span><br><span class="line">        <span class="string">"redis://127.0.0.1:6349"</span>,<span class="string">"redis://127.0.0.1:6339"</span>)</span><br><span class="line">        .setPassword(<span class="string">"******"</span>);</span><br><span class="line"><span class="comment">// 节点1</span></span><br><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><br><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class="line"><span class="comment">// 节点2</span></span><br><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><br><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6378"</span>);</span><br><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class="line"><span class="comment">// 节点3</span></span><br><span class="line">Config config3 = <span class="keyword">new</span> Config();</span><br><span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6377"</span>);</span><br><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class="line"><span class="comment">// 设置锁定资源名称</span></span><br><span class="line">String resourceName = <span class="string">"REDLOCK"</span>;</span><br><span class="line">RLock lock1 = redissonClient1.getLock(resourceName);</span><br><span class="line">RLock lock2 = redissonClient2.getLock(resourceName);</span><br><span class="line">RLock lock3 = redissonClient3.getLock(resourceName);</span><br><span class="line"><span class="comment">// 实例化RedissonRedLock</span></span><br><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLock = redLock.tryLock(<span class="number">500</span>, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">//TODO if get lock success, do something;</span></span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最核心的变化就是 <code>RedissonRedLock redLock</code>=<strong><code>new RedissonRedLock(lock1,lock2,lock3)</code>;</strong>，因为我这里是以三个节点为例。</p><ul><li>如果是主从<code>Redis</code>架构、哨兵<code>Redis</code>架构、集群<code>Redis</code>架构实现<code>Redlock</code>，只需要改变上述<code>config1</code>、<code>config2</code>、<code>config3</code>为主从模式、哨兵模式、集群模式配置即可，但相应需要<code>3</code>个独立的<code>Redis</code>主从集群、<code>3</code>个<code>Redis</code>独立的哨兵集群、<code>3</code>个独立的<code>Cluster</code>集群。</li><li>以<code>sentinel</code>模式架构为例，<code>3</code>个<code>sentinel</code>模式集群，如果要获取分布式锁，那么需要向这<code>3</code>个<code>sentinel</code>集群通过<code>EVAL</code>命令执行<code>LUA</code>脚本，需要<code>3/2+1=2</code>，即至少2个<code>sentinel</code>集群响应成功，才算成功的以<code>Redlock</code>算法获取到分布式锁。</li></ul><h3 id="4-Redlock问题合集"><a href="#4-Redlock问题合集" class="headerlink" title="4. Redlock问题合集"></a>4. Redlock问题合集</h3><h4 id="4-1-N个节点的理解"><a href="#4-1-N个节点的理解" class="headerlink" title="4.1 N个节点的理解"></a>4.1 N个节点的理解</h4><p>假设我们用<code>N(&gt;=3)</code>个节点实现<code>Redlock</code>算法的分布式锁。<strong>不是</strong>一个有<code>N</code>个主节点的cluster集群；而是<strong>要么是<code>N</code>个redis单实例，要么是<code>N</code>个sentinel集群，要么是<code>N</code>个cluster集群</strong>。</p><h4 id="4-2-失效时间如何设置"><a href="#4-2-失效时间如何设置" class="headerlink" title="4.2 失效时间如何设置"></a>4.2 失效时间如何设置</h4><p>这个问题的场景是，假设设置失效时间10秒，如果由于某些原因导致10秒还没执行完任务，这时候锁自动失效，导致其他线程也会拿到分布式锁。<br>这确实是Redis分布式最大的问题，不管是普通分布式锁，还是Redlock算法分布式锁，都没有解决这个问题。也有一些文章提出了对失效时间续租，即延长失效时间，很明显这又提升了分布式锁的复杂度（没有现成的框架有实现）。</p><h4 id="4-3-redis分布式锁的高可用"><a href="#4-3-redis分布式锁的高可用" class="headerlink" title="4.3 redis分布式锁的高可用"></a>4.3 redis分布式锁的高可用</h4><p>关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者Antirez之间已经发生过一场争论。有兴趣的同学，搜索”基于Redis的分布式锁到底安全吗”就能得到你想要的答案，需要注意的是，有上下两篇（这应该就是传说中的神仙打架吧）。</p><h4 id="4-4-使用Zookeeper还是Redis实现分布式锁"><a href="#4-4-使用Zookeeper还是Redis实现分布式锁" class="headerlink" title="4.4 使用Zookeeper还是Redis实现分布式锁"></a>4.4 使用Zookeeper还是Redis实现分布式锁</h4><p>没有绝对的好坏，只有更适合自己的业务。<br>就<strong>性能</strong>而言，<code>Redis</code>很明显优于<code>Zookeeper</code>；就分布式锁实现的健壮性(<strong>高可用</strong>)而言，<code>Zookeeper</code>很明显优于<code>Redis</code>。至于如何选择，还要看具体业务场景。</p><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SETNX命令简介&quot;&gt;&lt;a href=&quot;#SETNX命令简介&quot; class=&quot;headerlink&quot; title=&quot;SETNX命令简介&quot;&gt;&lt;/a&gt;SETNX命令简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SETNX key value&lt;/code&gt;返回(&lt;code&gt;1:key&lt;/code&gt;的值被设置，&lt;code&gt;0:key&lt;/code&gt;的值没被设置)，将&lt;code&gt;key&lt;/code&gt;的值设为&lt;code&gt;value&lt;/code&gt;，并且仅当&lt;code&gt;key&lt;/code&gt;不存在。&lt;/li&gt;
&lt;li&gt;锁的&lt;code&gt;key&lt;/code&gt;为目标数据的唯一键，&lt;code&gt;value&lt;/code&gt;为锁的期望超时时间点；&lt;/li&gt;
&lt;li&gt;基于&lt;code&gt;Redis&lt;/code&gt;实现的分布式锁，主要基于&lt;code&gt;redis&lt;/code&gt;的&lt;code&gt;setnx（set if not exist）&lt;/code&gt;命令；
    
    </summary>
    
      <category term="Redis" scheme="http://chaooo.github.io/categories/Redis/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【ElasticStack】Beats+Logstash+Elasticsearch+Kibana基础整合</title>
    <link href="http://chaooo.github.io/article/20191123.html"/>
    <id>http://chaooo.github.io/article/20191123.html</id>
    <published>2019-11-23T14:29:59.000Z</published>
    <updated>2020-02-14T10:46:09.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ElasticStack的组成"><a href="#1-ElasticStack的组成" class="headerlink" title="1. ElasticStack的组成"></a>1. ElasticStack的组成</h3><ol><li><strong><code>Beats</code></strong>：数据采集</li><li><strong><code>LogStash</code></strong>: 数据处理</li><li><strong><code>ElasticSearch</code></strong>(核心引擎): 数据存储、查询和分析</li><li><strong><code>Kibana</code></strong>: 数据探索与可视化分析<a id="more"></a></li></ol><p><img src="http://cdn.chaooo.top/Java/elastic-stream.jpg" alt></p><h3 id="2-Filebeat"><a href="#2-Filebeat" class="headerlink" title="2. Filebeat"></a>2. Filebeat</h3><p><code>Filebeat</code>是本地文件的轻量型日志数据采集器。<br><code>Beats</code>可以直接（或者通过<code>Logstash</code>）将数据发送到<code>Elasticsearch</code>，在那里你可以进一步处理和增强数据，然后在<code>Kibana</code>中将其可视化。</p><h4 id="2-1-Filebeat工作原理"><a href="#2-1-Filebeat工作原理" class="headerlink" title="2.1 Filebeat工作原理"></a>2.1 Filebeat工作原理</h4><p>Filebeat由两个主要组件组成：<code>prospector</code>和<code>harvester</code>。这些组件一起工作来读取文件（tail file）并将事件数据发送到您指定的输出</p><ul><li><strong><code>Harvester</code></strong>：<ul><li>负责<strong>读取单个文件</strong>的内容</li><li>如果文件在读取时被删除或重命名，<code>Filebeat</code>将继续读取文件</li></ul></li><li><strong><code>prospector</code></strong>：<ul><li><code>prospector</code>负责<strong>管理<code>harvester</code></strong>并找到所有要读取的文件来源</li><li>如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个<code>harvester</code></li><li><code>Filebeat</code>目前支持两种<code>prospector</code>类型：<code>log</code>和<code>stdin</code></li></ul></li></ul><p><img src="http://cdn.chaooo.top/Java/filebeat.jpg" alt></p><blockquote><ul><li><code>Filebeat</code>如何<strong>保持文件的状态</strong><ul><li><code>Filebeat</code> 保存每个文件的状态并经常将状态刷新到磁盘上的注册文件中</li><li>该状态用于记住<code>harvester</code>正在读取的最后偏移量，并确保发送所有日志行</li><li>如果输出（例如<code>Elasticsearch</code>或<code>Logstash</code>）无法访问，<code>Filebeat</code>会跟踪最后发送的行，并在输出再次可用时继续读取文件。</li><li>在<code>Filebeat</code>运行时，每个<code>prospector</code>内存中也会保存的文件状态信息，当重新启动<code>Filebeat</code>时，将使用注册文件的数据来重建文件状态，<code>Filebeat</code>将每个<code>harvester</code>在从保存的最后偏移量继续读取</li><li><code>Filebeat</code>存储唯一标识符以检测文件是否先前已采集过</li></ul></li></ul></blockquote><blockquote><ul><li><code>Filebeat</code>如何<strong>确保至少一次交付</strong><ul><li><code>Filebeat</code>保证事件至少会被传送到配置的输出一次，并且不会丢失数据。 <code>Filebeat</code>能够实现此行为，因为它将每个事件的传递状态存储在注册文件中。</li><li>在输出阻塞或未确认所有事件的情况下，<code>Filebeat</code>将继续尝试发送事件，直到接收端确认已收到。</li><li>如果<code>Filebeat</code>在发送事件的过程中关闭，它不会等待输出确认所有收到事件。</li><li>发送到输出但在<code>Filebeat</code>关闭前未确认的任何事件在重新启动<code>Filebeat</code>时会再次发送。</li><li>这可以确保每个事件至少发送一次，但最终会将重复事件发送到输出。</li><li>也可以通过设置<code>shutdown_timeout</code>选项来配置<code>Filebeat</code>以在关闭之前等待特定时间</li></ul></li></ul></blockquote><h4 id="2-2-Filebeat安装与配置"><a href="#2-2-Filebeat安装与配置" class="headerlink" title="2.2 Filebeat安装与配置"></a>2.2 Filebeat安装与配置</h4><p>安装<code>Filebeat</code>，创建配置文件<code>itcast.yml</code>，控制台运行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建如下配置文件 itcast.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: stdin  <span class="comment"># 标准输入</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">output.console: <span class="comment"># 输出到控制台</span></span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#启动filebeat</span></span><br><span class="line">./filebeat -e -c itcast.yml</span><br></pre></td></tr></table></figure><p>输入hello运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"@timestamp"</span>: <span class="string">"2019-11-23T09:21:19.213Z"</span>,</span><br><span class="line">  <span class="string">"@metadata"</span>: &#123; <span class="comment">#元数据信息</span></span><br><span class="line">    <span class="string">"beat"</span>: <span class="string">"filebeat"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"7.4.2"</span> <span class="comment"># beat版本</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"host"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"chaooo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"agent"</span>: &#123; &#125;,</span><br><span class="line">  <span class="string">"log"</span>: &#123;</span><br><span class="line">    <span class="string">"offset"</span>: 0,</span><br><span class="line">    <span class="string">"file"</span>: &#123;</span><br><span class="line">      <span class="string">"path"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"hello"</span>, <span class="comment"># 输入的内容</span></span><br><span class="line">  <span class="string">"input"</span>: &#123; <span class="comment"># 控制台标准输入</span></span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"stdin"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"ecs"</span>: &#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.1.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-读取文件"><a href="#2-3-读取文件" class="headerlink" title="2.3 读取文件"></a>2.3 读取文件</h4><p>创建配置文件<code>itcast-log.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /<span class="built_in">test</span>/*.<span class="built_in">log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line">output.console: <span class="comment"># 输出到控制台</span></span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"><span class="comment">#启动filebeat</span></span><br><span class="line">./filebeat -e -c itcast-log.yml</span><br></pre></td></tr></table></figure><p>在<code>/test/</code>下创建<code>a.log</code>文件，并输入如下内容<code>hello world</code>,观察<code>filebeat</code>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"@timestamp"</span>: <span class="string">"2019-11-23T09:45:56.379Z"</span>,</span><br><span class="line">  <span class="string">"@metadata"</span>: &#123;</span><br><span class="line">    <span class="string">"beat"</span>: <span class="string">"filebeat"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"7.4.2"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"log"</span>: &#123;</span><br><span class="line">    <span class="string">"offset"</span>: 0,</span><br><span class="line">    <span class="string">"file"</span>: &#123;</span><br><span class="line">      <span class="string">"path"</span>: <span class="string">"/test/a.log"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"hello"</span>,</span><br><span class="line">  <span class="string">"input"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"log"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"ecs"</span>: &#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.1.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"host"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"chaooo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"agent"</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"@timestamp"</span>: <span class="string">"2019-11-23T09:45:56.379Z"</span>,</span><br><span class="line">  <span class="string">"@metadata"</span>: &#123;</span><br><span class="line">    <span class="string">"beat"</span>: <span class="string">"filebeat"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"7.4.2"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"host"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"chaooo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"agent"</span>: &#123; &#125;,</span><br><span class="line">  <span class="string">"log"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: &#123;</span><br><span class="line">      <span class="string">"path"</span>: <span class="string">"/test/a.log"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"offset"</span>: 7</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"world"</span>,</span><br><span class="line">  <span class="string">"input"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"log"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"ecs"</span>: &#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.1.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-自定义字段"><a href="#2-4-自定义字段" class="headerlink" title="2.4 自定义字段"></a>2.4 自定义字段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /<span class="built_in">test</span>/*.<span class="built_in">log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line">  tags: [<span class="string">"web"</span>] <span class="comment">#添加自定义tag，便于后续的处理</span></span><br><span class="line">  fields: <span class="comment">#添加自定义字段</span></span><br><span class="line">    from: itcast-im</span><br><span class="line">  fields_under_root: <span class="literal">true</span> <span class="comment">#true为添加到根节点，false为添加到子节点中</span></span><br><span class="line">output.console: <span class="comment"># 输出到控制台</span></span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="2-5-输出到Elasticsearch"><a href="#2-5-输出到Elasticsearch" class="headerlink" title="2.5 输出到Elasticsearch"></a>2.5 输出到Elasticsearch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /<span class="built_in">test</span>/*.<span class="built_in">log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line">  tags: [<span class="string">"web"</span>] <span class="comment">#添加自定义tag，便于后续的处理</span></span><br><span class="line">  fields: <span class="comment">#添加自定义字段</span></span><br><span class="line">    from: itcast-im</span><br><span class="line">  fields_under_root: <span class="literal">false</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3 <span class="comment">#指定索引的分区数</span></span><br><span class="line">output.elasticsearch: <span class="comment">#指定ES的配置</span></span><br><span class="line">  hosts: [<span class="string">"192.168.1.7:9200"</span>,<span class="string">"192.168.1.7:9201"</span>,<span class="string">"192.168.1.7:9202"</span>]</span><br></pre></td></tr></table></figure><h4 id="2-6-读取Nginx日志文件"><a href="#2-6-读取Nginx日志文件" class="headerlink" title="2.6 读取Nginx日志文件"></a>2.6 读取Nginx日志文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /usr/<span class="built_in">local</span>/nginx/logs/*.<span class="built_in">log</span></span><br><span class="line">  tags: [<span class="string">"nginx"</span>] </span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3 <span class="comment">#指定索引的分区数</span></span><br><span class="line">output.elasticsearch: <span class="comment">#指定ES的配置</span></span><br><span class="line">  hosts: [<span class="string">"192.168.1.7:9200"</span>,<span class="string">"192.168.1.7:9201"</span>,<span class="string">"192.168.1.7:9202"</span>]</span><br></pre></td></tr></table></figure><h4 id="2-7-Filebeat的Module"><a href="#2-7-Filebeat的Module" class="headerlink" title="2.7 Filebeat的Module"></a>2.7 Filebeat的Module</h4><p>日志数据的读取与处理可以不用手动配置的，在<code>Filebeat</code>中，有大量的<code>Module</code>，可以直接使用简化配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">./filebeat modules list</span><br><span class="line">Enabled:</span><br><span class="line">  </span><br><span class="line">Disabled:</span><br><span class="line">apache</span><br><span class="line">auditd</span><br><span class="line">aws</span><br><span class="line">cef</span><br><span class="line">cisco</span><br><span class="line">coredns</span><br><span class="line">elasticsearch</span><br><span class="line">envoyproxy</span><br><span class="line">googlecloud</span><br><span class="line">haproxy</span><br><span class="line">ibmmq</span><br><span class="line">icinga</span><br><span class="line">iis</span><br><span class="line">iptables</span><br><span class="line">kafka</span><br><span class="line">kibana</span><br><span class="line">logstash</span><br><span class="line">mongodb</span><br><span class="line">mssql</span><br><span class="line">mysql</span><br><span class="line">nats</span><br><span class="line">netflow</span><br><span class="line">nginx</span><br><span class="line">osquery</span><br><span class="line">panw</span><br><span class="line">postgresql</span><br><span class="line">rabbitmq</span><br><span class="line">redis</span><br><span class="line">santa</span><br><span class="line">suricata</span><br><span class="line">system</span><br><span class="line">traefik</span><br><span class="line">zeek</span><br></pre></td></tr></table></figure><p>可以看到，内置了很多的<code>module</code>，但都没有启用，如果需要启用需要进行<code>enable</code>操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/filebeat modules <span class="built_in">enable</span> nginx <span class="comment">#启动</span></span><br><span class="line">./filebeat modules <span class="built_in">disable</span> nginx <span class="comment">#禁用</span></span><br></pre></td></tr></table></figure><h4 id="2-8-nginx-module与filebeat配置"><a href="#2-8-nginx-module与filebeat配置" class="headerlink" title="2.8 nginx module与filebeat配置"></a>2.8 nginx module与filebeat配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- module: nginx</span><br><span class="line">  access:      <span class="comment"># Access logs</span></span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    var.paths: [<span class="string">"/usr/local/nginx/logs/access.log*"</span>]</span><br><span class="line">  error:       <span class="comment"># Error logs</span></span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    var.paths: [<span class="string">"/usr/local/nginx/logs/error.log*"</span>]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-nginx.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line"><span class="comment">#- type: log</span></span><br><span class="line"><span class="comment"># enabled: true</span></span><br><span class="line"><span class="comment"># paths:</span></span><br><span class="line"><span class="comment"># - /usr/local/nginx/logs/*.log</span></span><br><span class="line"><span class="comment"># tags: ["nginx"]</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [<span class="string">"192.168.40.133:9200"</span>,<span class="string">"192.168.40.134:9200"</span>,<span class="string">"192.168.40.135:9200"</span>]</span><br><span class="line">filebeat.config.modules:</span><br><span class="line">  path: <span class="variable">$&#123;path.config&#125;</span>/modules.d/*.yml</span><br><span class="line">  reload.enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>若启动报错，需要在<code>Elasticsearch</code>中安装<code>ingest-user-agent、ingest-geoip</code>插件</p><h3 id="3-Metricbeat"><a href="#3-Metricbeat" class="headerlink" title="3. Metricbeat"></a>3. Metricbeat</h3><p>用于从系统和服务<strong>收集指标</strong>。<code>Metricbeat</code>和<code>Filebeat</code>一样，是一个<strong>轻量级的采集器</strong>，<code>Metricbeat</code>由模块(<code>Module</code>)和度量集(<code>Metricset</code>)组成。<code>Metricbeat</code>模块定义了从特定服务（如Redis，MySQL等）收集数据的基本逻辑。该模块指定有关服务的详细信息，包括如何连接，收集指标的频率以及要收集的指标。</p><ul><li><code>Metricbeat</code>有2部分组成，一部分是<code>Module</code>，另一部分为<code>Metricset</code>。</li><li><code>Module</code><ul><li>收集的对象，如：<code>mysql、redis、nginx、操作系统</code>等；</li></ul></li><li><code>Metricset</code><ul><li>收集指标的集合，如：<code>cpu、memory、network</code>等；</li></ul></li><li>以<code>Redis Module</code>为例：<br><img src="http://cdn.chaooo.top/Java/metricbeat.jpg" alt></li></ul><h4 id="3-1-安装配置"><a href="#3-1-安装配置" class="headerlink" title="3.1 安装配置"></a>3.1 安装配置</h4><p>安装Metricbeat，根据实际情况配置文件<code>metricbeat.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">metricbeat.config.modules:</span><br><span class="line">  path: <span class="variable">$&#123;path.config&#125;</span>/modules.d/*.yml</span><br><span class="line">  reload.enabled: <span class="literal">false</span></span><br><span class="line">setup.kibana:</span><br><span class="line">  host: <span class="string">"192.168.56.13:5601"</span></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [<span class="string">"192.168.56.13:9200"</span>]</span><br><span class="line">  username: <span class="string">"elastic"</span></span><br><span class="line">  password: <span class="string">"qiuyuetao"</span></span><br></pre></td></tr></table></figure><p>启动：<code>./metricbeat -e</code><br>查看<code>module</code>列表：<code>./metricbeat modules list</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Enabled:</span><br><span class="line">system <span class="comment">#默认启用</span></span><br><span class="line">  </span><br><span class="line">Disabled:</span><br><span class="line">apache</span><br><span class="line">elasticsearch</span><br><span class="line">nginx</span><br><span class="line">mysql</span><br><span class="line">redis</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>system module</code>默认启用的，其配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cat system.yml</span><br><span class="line"><span class="comment"># Module: system</span></span><br><span class="line"><span class="comment"># Docs: https://www.elastic.co/guide/en/beats/metricbeat/6.5/metricbeat-modulesystem.html</span></span><br><span class="line">- module: system</span><br><span class="line">  period: 10s</span><br><span class="line">  metricsets:</span><br><span class="line">    - cpu</span><br><span class="line">    - load</span><br><span class="line">    - memory</span><br><span class="line">    - network</span><br><span class="line">    - process</span><br><span class="line">    - process_summary</span><br><span class="line">    <span class="comment">#- core</span></span><br><span class="line">    <span class="comment">#- diskio</span></span><br><span class="line">    <span class="comment">#- socket</span></span><br><span class="line">  process.include_top_n:</span><br><span class="line">    by_cpu: 5 <span class="comment"># include top 5 processes by CPU</span></span><br><span class="line">    by_memory: 5 <span class="comment"># include top 5 processes by memory</span></span><br><span class="line">- module: system</span><br><span class="line">  period: 1m</span><br><span class="line">  metricsets:</span><br><span class="line">    - filesystem</span><br><span class="line">    - fsstat</span><br><span class="line">  processors:</span><br><span class="line">  - drop_event.when.regexp:</span><br><span class="line">    system.filesystem.mount_point: <span class="string">'^/(sys|cgroup|proc|dev|etc|host|lib)($|/)'</span></span><br><span class="line">- module: system</span><br><span class="line">  period: 15m</span><br><span class="line">  metricsets:</span><br><span class="line">    - uptime</span><br></pre></td></tr></table></figure><h4 id="3-2-Nginx-Module"><a href="#3-2-Nginx-Module" class="headerlink" title="3.2 Nginx Module"></a>3.2 Nginx Module</h4><p>在nginx中，需要开启状态查询，才能查询到指标数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置nginx</span></span><br><span class="line">location /nginx-status &#123;</span><br><span class="line">    stub_status on;</span><br><span class="line">    access_log off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<code>192.168.56.13/nginx-status</code>查看<code>nginx-status</code><ul><li><code>Active connections</code>：正在处理的活动连接数</li><li><code>server accepts handled requests</code>（连接数，握手数，处理请求总数）</li><li><code>Reading: 0 Writing: 1 Waiting: 1</code>（ 读取到客户端的Header信息数，返回给客户端Header信息数，已经处理完正在等候下一次请求指令的驻留链接）</li></ul></li></ul><p>配置<code>Nginx Module（metricbeat/modules.d/nginx.yml）</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- module: nginx</span><br><span class="line">  metricsets: [<span class="string">"stubstatus"</span>]</span><br><span class="line">  period: 10s</span><br><span class="line">  <span class="comment"># Nginx hosts</span></span><br><span class="line">  hosts: [<span class="string">"http://192.168.56.11"</span>]</span><br><span class="line">  <span class="comment"># Path to server status. Default server-status</span></span><br><span class="line"> server_status_path: <span class="string">"nginx_status"</span></span><br></pre></td></tr></table></figure><p>启动：<code>./metricbeat -e</code></p><h3 id="4-Logstash"><a href="#4-Logstash" class="headerlink" title="4. Logstash"></a>4. Logstash</h3><p><code>Logstash</code>是<code>ElasticStack</code>中的实时数据采集引擎，可以采集来自不同数据源的数据，并对数据进行处理后输出到多种输出源，是<code>Elastic Stack</code>的重要组成部分。<br><img src="http://cdn.chaooo.top/Java/elastic-logstash.jpg" alt></p><h4 id="4-1-Logstash的数据处理过程"><a href="#4-1-Logstash的数据处理过程" class="headerlink" title="4.1 Logstash的数据处理过程"></a>4.1 Logstash的数据处理过程</h4><ul><li><code>Inputs(Codecs)--&gt;Filters--&gt;Outputs(Codecs)</code><ul><li>用户通过定义<code>pipeline</code>配置文件，设置需要使用的<code>input</code>，<code>filter</code>，<code>output</code>, <code>codec</code>插件，以实现特定的数据采集，数据处理，数据输出等功能</li></ul></li></ul><ol><li><code>Inputs</code>：用于从数据源获取数据，常见的插件如<code>file, syslog, redis, beats</code>等</li><li><code>Filters</code>：用于处理数据如格式转换，数据派生等，常见的插件如<code>grok, mutate, drop, clone, geoip</code>等</li><li><code>Outputs</code>：用于数据输出，常见的插件如<code>elastcisearch，file, graphite, statsd</code>等</li><li><code>Codecs</code>：<code>Codecs</code>不是一个单独的流程，而是在输入和输出等插件中用于数据转换的模块，用于对数据进行编码处理，常见的插件如<code>json，multiline</code></li></ol><h4 id="4-2-执行模型"><a href="#4-2-执行模型" class="headerlink" title="4.2 执行模型"></a>4.2 执行模型</h4><ol><li>每个<code>Input</code>启动一个线程，从对应数据源获取数据 </li><li><code>Input</code>会将数据写入一个队列：默认为内存中的有界队列（意外停止会导致数据丢失）。为了防止数丢失<code>Logstash</code>提供了两个特性：<ul><li><code>Persistent Queues</code>：通过磁盘上的<code>queue</code>来防止数据丢失</li><li><code>Dead Letter Queues</code>：保存无法处理的<code>event</code>（仅支持<code>Elasticsearch</code>作为输出源）  </li></ul></li><li><code>Logstash</code>会有多个<code>pipeline worker</code>, 每一个<code>pipeline worker</code>会从队列中取一批数据，然后执行<code>filter</code>和<code>output</code>（<code>worker</code>数目及每次处理的数据量均由配置确定）</li></ol><h4 id="4-3-安装配置"><a href="#4-3-安装配置" class="headerlink" title="4.3 安装配置"></a>4.3 安装配置</h4><p>下载<code>Logstash</code>并解压，配置有三部分，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123; <span class="comment">#输入</span></span><br><span class="line">stdin &#123; ... &#125; <span class="comment">#标准输入</span></span><br><span class="line">&#125;</span><br><span class="line">filter &#123; <span class="comment">#过滤，对数据进行分割、截取等处理</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">output &#123; <span class="comment">#输出</span></span><br><span class="line">stdout &#123; ... &#125; <span class="comment">#标准输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-读取自定义日志"><a href="#4-4-读取自定义日志" class="headerlink" title="4.4 读取自定义日志"></a>4.4 读取自定义日志</h4><ol><li>日志结构：<code>2019-11-23 21:21:21|ERROR|读取数据出错|参数：id=1002</code>，日志中的内容是使用<code>“|”</code>进行分割的，使用，我们在处理的时候，也需要对数据做分割处理。</li><li>编写配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-pipeline.conf</span></span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">"/itcast/logstash/logs/app.log"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123;<span class="string">"message"</span>=&gt;<span class="string">"|"</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>启动测试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">./bin/logstash -f ./itcast-pipeline.conf</span><br><span class="line"><span class="comment">#写日志到文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2019-11-23 21:21:21|ERROR|读取数据出错|参数：id=1002"</span> &gt;&gt; app.log</span><br><span class="line"><span class="comment">#输出的结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"@timestamp"</span> =&gt; 2019-03-15T08:44:04.749Z,</span><br><span class="line">        <span class="string">"path"</span> =&gt; <span class="string">"/itcast/logstash/logs/app.log"</span>,</span><br><span class="line">    <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"host"</span> =&gt; <span class="string">"node01"</span>,</span><br><span class="line">     <span class="string">"message"</span> =&gt; [</span><br><span class="line">        [0] <span class="string">"2019-11-23 21:21:21"</span>,</span><br><span class="line">        [1] <span class="string">"ERROR"</span>,</span><br><span class="line">        [2] <span class="string">"读取数据出错"</span>,</span><br><span class="line">        [3] <span class="string">"参数：id=1002"</span></span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>输出到<code>Elasticsearch</code>配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ <span class="string">"192.168.40.133:9200"</span>,<span class="string">"192.168.40.134:9200"</span>,<span class="string">"192.168.40.135:9200"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Elasticsearch-Logstash-Beats-Kibana基础整合"><a href="#5-Elasticsearch-Logstash-Beats-Kibana基础整合" class="headerlink" title="5. Elasticsearch + Logstash + Beats + Kibana基础整合"></a>5. Elasticsearch + Logstash + Beats + Kibana基础整合</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">           (读取)          (发送)           (写入)                (读取)</span><br><span class="line">【日志文件】&lt;----【FileBeat】----&gt;【Logstash】----&gt;【Elasticsearch】&lt;----【Kibana】</span><br></pre></td></tr></table></figure><ol><li><code>Filebeat</code>配置与启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-dashboard.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /itcast/logs/*.<span class="built_in">log</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">"192.168.40.133:5044"</span>] <span class="comment">#Logstash端口号</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">./filebeat -e -c itcast-dashboard.yml</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Logstash</code>配置与启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-dashboard.conf</span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; <span class="string">"5044"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123;<span class="string">"message"</span>=&gt;<span class="string">"|"</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      <span class="string">"userId"</span> =&gt; <span class="string">"%&#123;message[1]&#125;"</span></span><br><span class="line">      <span class="string">"visit"</span> =&gt; <span class="string">"%&#123;message[2]&#125;"</span></span><br><span class="line">      <span class="string">"date"</span> =&gt; <span class="string">"%&#123;message[3]&#125;"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">      convert =&gt; &#123;</span><br><span class="line">        <span class="string">"userId"</span> =&gt; <span class="string">"integer"</span></span><br><span class="line">        <span class="string">"visit"</span> =&gt; <span class="string">"string"</span></span><br><span class="line">        <span class="string">"date"</span> =&gt; <span class="string">"string"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ <span class="string">"192.168.40.133:9200"</span>,<span class="string">"192.168.40.134:9200"</span>,<span class="string">"192.168.40.135:9200"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">./bin/logstash -f itcast-dashboard.conf</span><br></pre></td></tr></table></figure><ol start="3"><li><code>ElasticSearch</code>启动与<code>Kibana</code>启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ElasticSearch默认端口:9200</span></span><br><span class="line">bin/elasticsearch </span><br><span class="line"><span class="comment"># kibana默认端口:5601</span></span><br><span class="line">bin/kibana</span><br><span class="line"><span class="comment">#通过浏览器进行访问,添加Logstash索引到Kibana中</span></span><br><span class="line">http://192.168.40.133:5601</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ElasticStack的组成&quot;&gt;&lt;a href=&quot;#1-ElasticStack的组成&quot; class=&quot;headerlink&quot; title=&quot;1. ElasticStack的组成&quot;&gt;&lt;/a&gt;1. ElasticStack的组成&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Beats&lt;/code&gt;&lt;/strong&gt;：数据采集&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;LogStash&lt;/code&gt;&lt;/strong&gt;: 数据处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ElasticSearch&lt;/code&gt;&lt;/strong&gt;(核心引擎): 数据存储、查询和分析&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Kibana&lt;/code&gt;&lt;/strong&gt;: 数据探索与可视化分析
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【ElasticStack】ElasticSearch聚合分析与数据建模</title>
    <link href="http://chaooo.github.io/article/20191121.html"/>
    <id>http://chaooo.github.io/article/20191121.html</id>
    <published>2019-11-21T14:30:47.000Z</published>
    <updated>2020-02-14T11:16:53.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ElasticSearch中的聚合分析"><a href="#1-ElasticSearch中的聚合分析" class="headerlink" title="1. ElasticSearch中的聚合分析"></a>1. ElasticSearch中的聚合分析</h3><p>聚合分析，英文<code>Aggregation</code>，是ES除了搜索功能之外提供的针对ES数据进行统计分析的功能。</p><ul><li>特点：<ul><li>①功能丰富，可满足大部分分析需求；</li><li>②实时性高，所有计算结果实时返回。</li></ul></li><li>基于分析规则的不同，ES将聚合分析主要划分为以下4种：<ol><li><strong><code>Metric</code></strong>: 指标分析类型，如：计算最值，平均值等；</li><li><strong><code>Bucket</code></strong>: 分桶类型，类似于<code>group by</code>语法，根据一定规则划分为若干个桶分类；</li><li><strong><code>Pipeline</code></strong>: 管道分析类型，基于上一级的聚合分析结果进行再分析；</li><li><code>Matrix</code>: 矩阵分析类型。<a id="more"></a></li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 聚合分析格式：</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123; <span class="comment"># 关键词</span></span><br><span class="line">  <span class="string">"&lt;aggregation_name&gt;"</span>:&#123; <span class="comment"># 自定义聚合分析名称，一般起的有意义</span></span><br><span class="line">   <span class="string">"&lt;aggregation_type&gt;"</span>:&#123; <span class="comment"># 聚合分析类型</span></span><br><span class="line">    <span class="string">"&lt;aggregation_body&gt;"</span> <span class="comment"># 聚合分析主体</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [,<span class="string">"aggs"</span>:&#123;[&lt;svb_aggregation&gt;]+&#125;] <span class="comment"># 可包含多个子聚合分析</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-Metric聚合分析"><a href="#1-1-Metric聚合分析" class="headerlink" title="1.1 Metric聚合分析"></a>1.1 Metric聚合分析</h4><p>主要分为两类：单值分析（输出单个结果）和多值分析（输出多个结果）。</p><h5 id="1-1-1-单值分析"><a href="#1-1-1-单值分析" class="headerlink" title="1.1.1 单值分析"></a>1.1.1 单值分析</h5><ol><li><code>min</code>：返回数值类型字段的最小值</li><li><code>max</code>：返回数值类型字段的最大值</li><li><code>avg</code>：返回数值类型字段的平均值</li><li><code>sum</code>：返回数值类型字段值的总和</li><li><code>cardinality</code>：返回字段的基数</li><li>使用多个单值分析关键词，返回多个结果</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"min_age"</span>:&#123;</span><br><span class="line">   <span class="string">"min"</span>:&#123; <span class="comment"># 关键字min/max/avg/sum/cardinality</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span>    </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用多个单值分析关键词，返回多个分析结果</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>: &#123;</span><br><span class="line">  <span class="string">"min_age"</span>:&#123;</span><br><span class="line">   <span class="string">"min"</span>:&#123;  <span class="comment"># 求最小年龄</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"max_age"</span>:&#123;</span><br><span class="line">   <span class="string">"max"</span>:&#123;  <span class="comment"># 求最大年龄</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"avg_age"</span>:&#123;</span><br><span class="line">   <span class="string">"avg"</span>:&#123;  <span class="comment"># 求平均年龄</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"sum_age"</span>:&#123;</span><br><span class="line">   <span class="string">"sum"</span>:&#123;  <span class="comment"># 求年龄总和</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-2-多值分析"><a href="#1-1-2-多值分析" class="headerlink" title="1.1.2 多值分析"></a>1.1.2 多值分析</h5><ol><li><code>stats</code>：返回所有单值结果</li><li><code>extended_stats</code>：对<code>stats</code>进行扩展，包含更多，如：方差，标准差，标准差范围等</li><li><code>Percentile</code>：百分位数统计</li><li><code>Top hits</code>：一般用于分桶之后获取该桶内最匹配的定不稳当列表，即详情数据</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"stats_age"</span>:&#123;</span><br><span class="line">   <span class="string">"stats"</span>:&#123; <span class="comment"># 关键字stats/extended_stats/percentiles</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span>    </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用percentiles关键词进行百分位数预测。</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"per_age"</span>:&#123;</span><br><span class="line">   <span class="string">"percentiles"</span>:&#123;    <span class="comment"># 关键字</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span>,</span><br><span class="line">    <span class="string">"values"</span>:[20, 25] <span class="comment"># 判断20和25分别在之前的年轻区间的什么位置，以百分数显示</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用top_hits关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"jobs"</span>:&#123;</span><br><span class="line">   <span class="string">"terms"</span>:&#123;</span><br><span class="line">    <span class="string">"match"</span>:&#123;</span><br><span class="line">     <span class="string">"field"</span>:<span class="string">"job.keyword"</span>, <span class="comment"># 按job.keyword进行分桶聚合</span></span><br><span class="line">     <span class="string">"size"</span>:10</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"aggs"</span>:&#123;</span><br><span class="line">     <span class="string">"top_employee"</span>:&#123;</span><br><span class="line">      <span class="string">"top_hits"</span>:&#123;</span><br><span class="line">       <span class="string">"size"</span>:10,    <span class="comment"># 返回文档数量</span></span><br><span class="line">       <span class="string">"sort"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="string">"age"</span>:&#123;</span><br><span class="line">          <span class="string">"order"</span>:<span class="string">"desc"</span>  <span class="comment"># 按年龄倒叙排列</span></span><br><span class="line">         &#125; </span><br><span class="line">        &#125;</span><br><span class="line">       ]</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Bucket聚合分析"><a href="#1-2-Bucket聚合分析" class="headerlink" title="1.2 Bucket聚合分析"></a>1.2 Bucket聚合分析</h4><p><code>Bucket</code>，意为桶。即：按照一定规则，将文档分配到不同的桶中，达分类的目的。常见的有以下五类：</p><ol><li><code>Terms</code>: 直接按<code>term</code>进行分桶，如果是<code>text</code>类型，按分词后的结果分桶</li><li><code>Range</code>: 按指定数值范围进行分桶</li><li><code>Date Range</code>: 按指定日期范围进行分桶</li><li><code>Histogram</code>: 直方图，按固定数值间隔策略进行数据分割</li><li><code>Date Histogram</code>: 日期直方图，按固定时间间隔进行数据分割</li></ol><h5 id="1-2-1-Terms"><a href="#1-2-1-Terms" class="headerlink" title="1.2.1 Terms"></a>1.2.1 Terms</h5><p><code>Terms</code>: 直接按<code>term</code>进行分桶，如果是<code>text</code>类型，按分词后的结果分桶</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用terms关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"terms_job"</span>:&#123;</span><br><span class="line">   <span class="string">"terms"</span>:&#123;    <span class="comment"># 关键字</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"job.keyword"</span>, <span class="comment"># 按job.keyword进行分桶</span></span><br><span class="line">    <span class="string">"size"</span>:5               <span class="comment"># 返回五个文档</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-Range"><a href="#1-2-2-Range" class="headerlink" title="1.2.2 Range"></a>1.2.2 Range</h5><p><code>Range</code>: 按指定数值范围进行分桶：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用range关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"number_ranges"</span>:&#123;</span><br><span class="line">   <span class="string">"range"</span>:&#123;    <span class="comment"># 关键字</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span>,    <span class="comment"># 按age进行分桶</span></span><br><span class="line">    <span class="string">"ranges"</span>:[</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">"key"</span>:<span class="string">"&gt;=19 &amp;&amp; &lt; 25"</span>,  <span class="comment"># 第一个桶：  19&lt;=年龄&lt;25</span></span><br><span class="line">      <span class="string">"from"</span>:19,</span><br><span class="line">      <span class="string">"to"</span>:25</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">"key"</span>:<span class="string">"&lt; 19"</span>,    <span class="comment"># 第二个桶：  年龄&lt;19</span></span><br><span class="line">      <span class="string">"to"</span>:19</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">"key"</span>:<span class="string">"&gt;= 25"</span>,    <span class="comment"># 第三个桶：  年龄&gt;=25</span></span><br><span class="line">      <span class="string">"from"</span>:25</span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-3-Date-Range"><a href="#1-2-3-Date-Range" class="headerlink" title="1.2.3 Date Range"></a>1.2.3 Date Range</h5><p><code>Date Range</code>: 按指定日期范围进行分桶</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用date_range关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"date_ranges"</span>:&#123;</span><br><span class="line">   <span class="string">"date_range"</span>:&#123;    <span class="comment"># 关键字</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"birth"</span>,    <span class="comment"># 按age进行分桶</span></span><br><span class="line">    <span class="string">"format"</span>:<span class="string">"yyyy"</span>,</span><br><span class="line">    <span class="string">"ranges"</span>:[</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">"key"</span>:<span class="string">"&gt;=1980 &amp;&amp; &lt; 1990"</span>,  <span class="comment"># 第一个桶：  1980&lt;=出生日期&lt;1990</span></span><br><span class="line">      <span class="string">"from"</span>:<span class="string">"1980"</span>,</span><br><span class="line">      <span class="string">"to"</span>:<span class="string">"1990"</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">"key"</span>:<span class="string">"&lt; 1980"</span>,    <span class="comment"># 第二个桶：  出生日期&lt;1980</span></span><br><span class="line">      <span class="string">"to"</span>:1980</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">"key"</span>:<span class="string">"&gt;= 1990"</span>,    <span class="comment"># 第三个桶：  出生日期&gt;=1990</span></span><br><span class="line">      <span class="string">"from"</span>:1990</span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-4-Histogram"><a href="#1-2-4-Histogram" class="headerlink" title="1.2.4 Histogram"></a>1.2.4 Histogram</h5><p><code>Histogram</code>: 直方图，按固定数值间隔策略进行数据分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用histogram关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"age_hist"</span>:&#123;</span><br><span class="line">   <span class="string">"histogram"</span>:&#123;     <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"age"</span>,</span><br><span class="line">    <span class="string">"interval"</span>:3,    <span class="comment"># 设定间隔大小为2</span></span><br><span class="line">    <span class="string">"extended_bounds"</span>:&#123;    <span class="comment"># 设定数据范围</span></span><br><span class="line">     <span class="string">"min"</span>:0,</span><br><span class="line">     <span class="string">"max"</span>:30</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-5-Date-Histogram"><a href="#1-2-5-Date-Histogram" class="headerlink" title="1.2.5 Date Histogram"></a>1.2.5 Date Histogram</h5><p><code>Date Histogram</code>: 日期直方图，按固定时间间隔进行数据分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用date_histogram关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"birth_hist"</span>:&#123;</span><br><span class="line">   <span class="string">"date_histogram"</span>:&#123;     <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"birth"</span>,</span><br><span class="line">    <span class="string">"interval"</span>:<span class="string">"year"</span>,    <span class="comment"># 设定间隔大小为年year</span></span><br><span class="line">    <span class="string">"format"</span>:<span class="string">"yyyy"</span>,</span><br><span class="line">    <span class="string">"extended_bounds"</span>:&#123;    <span class="comment"># 设定数据范围</span></span><br><span class="line">     <span class="string">"min"</span>:<span class="string">"1980"</span>,</span><br><span class="line">     <span class="string">"max"</span>:<span class="string">"1990"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Bucket-Metric聚合分析"><a href="#1-3-Bucket-Metric聚合分析" class="headerlink" title="1.3 Bucket+Metric聚合分析"></a>1.3 Bucket+Metric聚合分析</h4><p>Bucket聚合分析允许通过添加子分析来进一步进行分析，该子分析可以是Bucket，也可以是Metric。</p><ol><li>分桶之后再分桶（Bucket+Bucket），在数据可视化中一般使用千层饼图进行显示。</li><li>分桶之后再数据分析（Bucket+Metric）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分桶之后再分桶——Bucket+Bucket</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"jobs"</span>:&#123;</span><br><span class="line">   <span class="string">"terms"</span>:&#123;             <span class="comment"># 第一层Bucket</span></span><br><span class="line">    <span class="string">"match"</span>:&#123;</span><br><span class="line">     <span class="string">"field"</span>:<span class="string">"job.keyword"</span>,</span><br><span class="line">     <span class="string">"size"</span>:10</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"aggs"</span>:&#123;</span><br><span class="line">     <span class="string">"age_range"</span>:&#123;</span><br><span class="line">      <span class="string">"range"</span>:&#123;             <span class="comment"># 第二层Bucket</span></span><br><span class="line">       <span class="string">"field"</span>:<span class="string">"age"</span>,</span><br><span class="line">       <span class="string">"ranges"</span>:[</span><br><span class="line">        &#123;<span class="string">"to"</span>:20&#125;,</span><br><span class="line">        &#123;<span class="string">"from"</span>:20,<span class="string">"to"</span>:30&#125;,</span><br><span class="line">        &#123;<span class="string">"from"</span>:30&#125;</span><br><span class="line">       ]</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分桶之后再数据分析——Bucket+Metric</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"jobs"</span>:&#123;</span><br><span class="line">   <span class="string">"terms"</span>:&#123;             <span class="comment"># 第一层Bucket</span></span><br><span class="line">    <span class="string">"match"</span>:&#123;</span><br><span class="line">     <span class="string">"field"</span>:<span class="string">"job.keyword"</span>,</span><br><span class="line">     <span class="string">"size"</span>:10</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"aggs"</span>:&#123;                 </span><br><span class="line">     <span class="string">"stats_age"</span>:&#123;</span><br><span class="line">      <span class="string">"stats"</span>:&#123;            <span class="comment"># 第二层Metric</span></span><br><span class="line">       <span class="string">"field"</span>:<span class="string">"age"</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-Pipeline聚合分析"><a href="#1-4-Pipeline聚合分析" class="headerlink" title="1.4 Pipeline聚合分析"></a>1.4 Pipeline聚合分析</h4><p>针对聚合分析的结果进行再分析，且支持链式调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pipeline聚合分析,计算订单月平均销售额。</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"sales_per_month"</span>:&#123;</span><br><span class="line">   <span class="string">"date_histogram"</span>:&#123;</span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"date"</span>,</span><br><span class="line">    <span class="string">"interval"</span>:<span class="string">"month"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"aggs"</span>:&#123;</span><br><span class="line">    <span class="string">"sales"</span>:&#123;</span><br><span class="line">     <span class="string">"sum"</span>:&#123;</span><br><span class="line">      <span class="string">"field"</span>:<span class="string">"price"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"avg_monthly_sales"</span>:&#123;</span><br><span class="line">   <span class="string">"avg_bucket"</span>:&#123;    <span class="comment"># bucket类型</span></span><br><span class="line">    <span class="string">"buckets_path"</span>:<span class="string">"sales_per_month&gt;sales"</span>    <span class="comment"># 使用buckets_path参数，表明是pipeline</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pipeline</code>的分析结果会输出到原结果中，由输出位置不同，分为两类：<code>Parent</code>和<code>Sibling</code>。</p><ol><li><code>Sibling</code>。结果与现有聚合分析结果同级，如：Max/Min/Sum/Avg Bucket、Stats/Extended Stats Bucket、Percentiles Bucket</li><li><code>Parent</code>。结果内嵌到现有聚合分析结果中，如：Derivate、Moving Average、Cumulative Sum</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sibling聚合分析(min_bucket)</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>: 0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"jobs"</span>:&#123;</span><br><span class="line">   <span class="string">"terms"</span>:&#123;    <span class="comment"># 根据job.keyword进行分桶</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"job.keyword"</span>,    </span><br><span class="line">    <span class="string">"size"</span>:10</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"aggs"</span>:&#123;</span><br><span class="line">    <span class="string">"avg_salary"</span>:&#123;</span><br><span class="line">     <span class="string">"avg"</span>:&#123;    <span class="comment"># 之后Metric中求工资的平均数</span></span><br><span class="line">      <span class="string">"field"</span>:<span class="string">"salary"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"min_salary_by_job"</span>:&#123;</span><br><span class="line">   <span class="string">"min_bucket"</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">"buckets_path"</span>:<span class="string">"jobs&gt;avg_salary"</span>    <span class="comment"># 按工资平均数，排列每个桶中的job</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parent聚合分析(Derivate)</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"bitrh"</span>:&#123;</span><br><span class="line">   <span class="string">"date_histogram"</span>:&#123;</span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"birth"</span>,</span><br><span class="line">    <span class="string">"interval"</span>:<span class="string">"year"</span>,</span><br><span class="line">    <span class="string">"min_doc_count"</span>:0</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"aggs"</span>:&#123;</span><br><span class="line">    <span class="string">"avg_salary"</span>:&#123;</span><br><span class="line">     <span class="string">"avg"</span>:&#123;</span><br><span class="line">      <span class="string">"field"</span>:<span class="string">"salary"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"derivative_avg_salary"</span>:&#123;</span><br><span class="line">     <span class="string">"derivative"</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">      <span class="string">"buckets_path"</span>:<span class="string">"avg_salary"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-聚合分析的作用范围"><a href="#1-5-聚合分析的作用范围" class="headerlink" title="1.5 聚合分析的作用范围"></a>1.5 聚合分析的作用范围</h4><p>ES聚合分析默认作用范围是<code>query的结果集</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES中聚合分析的默认作用范围是query的结果集</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"jobs"</span>:&#123;</span><br><span class="line">   <span class="string">"terms"</span>:&#123;</span><br><span class="line">    <span class="string">"match"</span>:&#123;    <span class="comment"># 此时，只在username字段中包含alfred的文档中进行分桶</span></span><br><span class="line">     <span class="string">"field"</span>:<span class="string">"job.keyword"</span>,    </span><br><span class="line">     <span class="string">"size"</span>:10</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过以下方式修改：<code>filter</code>、<code>post_filter</code>、<code>global</code></p><ol><li>filter: 为某个结合分析设定过滤条件，从而在不改变整体query语句的情况下修改范围</li><li>post_filter，作用于文档过滤，但在聚合分析之后才生效</li><li>global，无视query条件，基于所有文档进行分析</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用filter进行过滤</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"jobs_salary_small"</span>:&#123;</span><br><span class="line">   <span class="string">"filter"</span>:&#123;</span><br><span class="line">    <span class="string">"range"</span>:&#123;</span><br><span class="line">     <span class="string">"salary"</span>:&#123;</span><br><span class="line">      <span class="string">"to"</span>:10000</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"aggs"</span>:&#123;</span><br><span class="line">    <span class="string">"jobs"</span>:&#123;</span><br><span class="line">     <span class="string">"terms"</span>:&#123;    <span class="comment"># 在salary小于10000的文档中对工作进行分桶</span></span><br><span class="line">      <span class="string">"field"</span>:<span class="string">"job.keyword"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用post_filter进行过滤</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"jobs"</span>:&#123;</span><br><span class="line">   <span class="string">"terms"</span>:&#123;    <span class="comment"># 在salary小于10000的文档中对工作进行分桶</span></span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"job.keyword"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"post_filter"</span>:&#123;    <span class="comment"># 在集合分析之后才生效</span></span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"job.keyword"</span>:<span class="string">"java engineer"</span>   </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用global进行过滤</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"job.keyword"</span>:<span class="string">"java engineer"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"java_avg_salary"</span>:&#123;</span><br><span class="line">   <span class="string">"avg"</span>:&#123;</span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"salary"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"all"</span>:&#123;</span><br><span class="line">   <span class="string">"global"</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">"aggs"</span>:&#123;</span><br><span class="line">     <span class="string">"avg_salary"</span>:&#123;</span><br><span class="line">      <span class="string">"avg"</span>:&#123;</span><br><span class="line">       <span class="string">"field"</span>:<span class="string">"salary"</span>    <span class="comment"># 依然是对所有的文档进行查询，而不会去管query   </span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-聚合分析中的排序"><a href="#1-6-聚合分析中的排序" class="headerlink" title="1.6 聚合分析中的排序"></a>1.6 聚合分析中的排序</h4><ol><li>可使用自带的关键数据排序，如：<code>_count</code>文档数、<code>_key</code>按key值</li><li>也可使用聚合结果进行排序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用自带的数据进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"jobs"</span>:&#123;</span><br><span class="line">   <span class="string">"terms"</span>:&#123;</span><br><span class="line">    <span class="string">"field"</span>:<span class="string">"job.keyword"</span>,</span><br><span class="line">    <span class="string">"size"</span>:10,</span><br><span class="line">    <span class="string">"order"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"_count"</span>:<span class="string">"asc"</span>    <span class="comment"># 默认按_count倒叙排列</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"_key"</span>:<span class="string">"desc"</span>    使用多个排序值，从上往下的顺序进行排列</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用聚合结果进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:0,</span><br><span class="line"> <span class="string">"aggs"</span>:&#123;</span><br><span class="line">  <span class="string">"salary_hist"</span>:&#123;</span><br><span class="line">   <span class="string">"histogram"</span>:&#123;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"aggs"</span>:&#123;</span><br><span class="line">    <span class="string">"age"</span>:&#123;</span><br><span class="line">     <span class="string">"filter"</span>:&#123;</span><br><span class="line">      <span class="string">"range"</span>:&#123;</span><br><span class="line">       <span class="string">"age"</span>:&#123;</span><br><span class="line">        <span class="string">"gte"</span>:10</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">"aggs"</span>:&#123;</span><br><span class="line">      <span class="string">"avg_age"</span>:&#123;</span><br><span class="line">       <span class="string">"field"</span>:<span class="string">"age"</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-计算精准度问题"><a href="#1-7-计算精准度问题" class="headerlink" title="1.7 计算精准度问题"></a>1.7 计算精准度问题</h4><p>ES聚合的执行流程：每个<code>Shard</code>上分别计算，由<code>coordinating Node</code>做聚合。</p><ul><li><code>Terms</code>计算不准确原因：数据分散在多个<code>Shard</code>上，<code>coordinating Node</code>无法得悉数据全貌，那么在取数据的时候，造成精准度不准确。</li><li>如下图：正确结果应该为<code>a,b,c</code>,而返回的是a,b,d</li></ul><p><img src="http:%5Ccdn.chaooo.top/Java/elastic-hits.jpg" alt></p><ul><li><p>解决办法有两种：</p><ol><li>直接设置<code>shard</code>数量为1；消除数据分散问题，但无法承载大数据量。</li><li>设置<code>shard_size</code>大小，即每次从<code>shard</code>上额外多获取数据，从而提升精准度</li></ol></li><li><p>terms聚合返回结果中有两个统计值：</p><ol><li><code>doc_count_error_upper_bound</code>：被遗漏的term可能的最大值；</li><li><code>sum_other_doc_count</code>：返回结果bucket的term外其他term的文档总数。</li></ol></li><li><p>设定<code>show_term_doc_count_error</code>可以查看每个bucket误算的最大值(<code>doc_count_error_upper_bound</code>,为<code>0</code>表示计算准确)</p></li><li><p>Shard_Size默认大小：<code>(size*1.5)+10</code></p><ul><li>通过调整Shard_Size的大小降低<code>doc_count_error_upper_bound</code>来提升准确度</li><li>增大了整体的计算量，从而降低了响应时间</li></ul></li><li><p>权衡 <strong><code>海量数据</code>、<code>精准度</code>、<code>实时性</code></strong> 三者只能取其二。</p></li><li><p>Elasticsearch目前支持两种近似算法：cardinality(度量) 和 percentiles(百分位数度量)</p><ul><li>结果近似准确，但不一定精准</li><li>可通过参数的调整使其结果精准，但同时消耗更多时间和性能</li></ul></li></ul><h3 id="2-ElasticSearch的数据建模"><a href="#2-ElasticSearch的数据建模" class="headerlink" title="2. ElasticSearch的数据建模"></a>2. ElasticSearch的数据建模</h3><p>数据建模(Data Modeling)大致分为三个阶段：概念建模、逻辑建模、物理建模</p><ol><li>概念模型：时间占比<code>10%</code><ul><li>基础。确定系统的核心需求和范围边界，实际实体与实体之间的关系。</li></ul></li><li>逻辑模型：时间占比<code>60-70%</code><ul><li>核心。确定系统的核心需求和范围边界，实际实体与实体之间的关系。</li></ul></li><li>物理模型：时间占比<code>20-30%</code><ul><li>落地实现。结合具体的数据库产品，在满足业务读写性能等需求的前提下确定最终的定义。</li></ul></li></ol><h4 id="2-1-ES中的数据建模"><a href="#2-1-ES中的数据建模" class="headerlink" title="2.1 ES中的数据建模"></a>2.1 ES中的数据建模</h4><p>ES是基于Luence以倒排索引为基础实现的存储体系，不遵循关系型数据库中的范式约定。<br><img src="http:%5Ccdn.chaooo.top/Java/elastic-md.jpg" alt></p><h4 id="2-2-Mapping字段相关设置"><a href="#2-2-Mapping字段相关设置" class="headerlink" title="2.2 Mapping字段相关设置"></a>2.2 Mapping字段相关设置</h4><ol><li><strong><code>enabled</code></strong>:<code>true/false</code>。<code>false</code>表示 仅存储，不做搜索或聚合分析。</li><li>**<code>index</code>:<code>true/false</code>。是否构建倒排索引。不需进行字段的检索的时候设为false。</li><li><strong><code>index_options</code></strong>:<code>docs/freqs/positions/offsets</code>。确定存储倒排索引的哪些信息。</li><li><strong><code>norms</code></strong>:<code>true/false</code>。是否存储归一化相关系数，若字段仅用于过滤和聚合分析，则可关闭。</li><li><strong><code>doc_values</code></strong>:<code>true/false</code>。是否启用doc_values，用于排序和聚类分析。默认开启。</li><li><strong><code>field_data</code></strong>:<code>true/false</code>。是否设text类型为fielddata，实现排序和聚合分析。默认关闭。</li><li><strong><code>store</code></strong>:<code>true/false</code>。是否存储该字段。</li><li><strong><code>coerce</code></strong>:<code>true/false</code>。 是否开启数值类型转换功能，如：字符串转数字等。</li><li><strong><code>multifields</code></strong>:<code>多字段</code>。灵活使用多字段特性来解决多样业务需求。</li><li><strong><code>dynamic</code></strong>:<code>true/false/strict</code>。控制mapping自动更新。</li><li><strong><code>date_detection</code></strong>:<code>true/false</code>。是否启用自定识别日期类型，一般设为false，避免不必要的识别字符串中的日期。</li></ol><h4 id="2-3-Mapping字段属性设定流程"><a href="#2-3-Mapping字段属性设定流程" class="headerlink" title="2.3 Mapping字段属性设定流程"></a>2.3 Mapping字段属性设定流程</h4><p><code>判断类型</code>—&gt;<code>是否需要检索</code>—&gt;<code>是否需要排序和聚合分析</code>—&gt;<code>是否需要另行存储</code></p><ol><li>判断类型<ul><li>字符串类型：需要分词，则设为text，否则设为keyword。</li><li>枚举类型：基于性能考虑，设为keyword，即便该数据为整型。</li><li>数值类型：尽量选择贴近的类型，如byte即可表示所有数值时，即用byte，而不是所有都用long。</li><li>其他类型：布尔型，日期类型，地理位置类型等。</li></ul></li><li>是否需要检索<ul><li>完全不需要检索、排序、聚合分析的字段<code>enabled设为false</code>。</li><li>不需检索的字段<code>index设为false</code>。</li><li>需检索的字段，可通过如下配置设定需要的存储粒度:<ul><li><code>index_options</code> 结合需要设定。</li><li><code>norms</code> 不需归一化数据时可关闭。</li></ul></li></ul></li><li>是否需要排序和聚合分析<ul><li>当不需要排序和聚合分析功能时：<ul><li><code>doc_values设为false</code>。</li><li><code>field_data设为false</code>。</li></ul></li></ul></li><li>是否需要另行存储<ul><li><code>store设为true</code>即可存储该字段的原始内容(且与<code>_source</code>无关)，一般结合<code>_source</code>的<code>enabled设为false</code>时使用。</li></ul></li></ol><h4 id="2-4-ES建模实例"><a href="#2-4-ES建模实例" class="headerlink" title="2.4 ES建模实例"></a>2.4 ES建模实例</h4><ul><li>针对博客文章设定索引blog_index，包含字段：<ul><li>标题：title</li><li>发布日期：publish_data</li><li>作者：author</li><li>摘要：abstract</li><li>网址：url</li></ul></li><li><strong>简易的数据模型</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简易模型blog_index</span></span><br><span class="line">PUT blog_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">    <span class="string">"properties"</span>:&#123;</span><br><span class="line">      <span class="string">"title"</span>:&#123;</span><br><span class="line">          <span class="comment">#title设为text，包含自字段keyword。支持检索、排序、聚合分析</span></span><br><span class="line">          <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">          <span class="string">"fields"</span>:&#123;</span><br><span class="line">            <span class="string">"keyword"</span>:&#123;<span class="string">"type"</span>:<span class="string">"keyword"</span>&#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,<span class="comment">#publish_data设为date，支持检索、排序、聚合分析</span></span><br><span class="line">      <span class="string">"publish_data"</span>:&#123;<span class="string">"type"</span>:<span class="string">"date"</span>&#125;,</span><br><span class="line">      <span class="comment"># author设为keyword，支持检索、排序、聚合分析</span></span><br><span class="line">      <span class="string">"author"</span>:&#123;<span class="string">"type"</span>:<span class="string">"keyword"</span>&#125;,</span><br><span class="line">      <span class="comment"># abstract设为text，支持检索、排序、聚合分析</span></span><br><span class="line">      <span class="string">"abstract"</span>:&#123;<span class="string">"type"</span>:<span class="string">"text"</span>&#125;,</span><br><span class="line">      <span class="comment"># url设为date，不需进行检索</span></span><br><span class="line">      <span class="string">"url"</span>:&#123;<span class="string">"enabled"</span>:<span class="literal">false</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>如果在<code>blog_index</code>中加入一个内容字段<code>content</code></strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为blog_index增加content字段</span></span><br><span class="line">PUT blog_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">    <span class="string">"doc"</span>:&#123;</span><br><span class="line">     <span class="comment">#关闭，不存原始内容到_source</span></span><br><span class="line">     <span class="string">"_source"</span>:&#123;<span class="string">"enabled"</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">     <span class="string">"properties"</span>:&#123;</span><br><span class="line">        <span class="comment">#title设为text，包含自字段keyword。支持检索、排序、聚合分析</span></span><br><span class="line">        <span class="string">"title"</span>:&#123;</span><br><span class="line">            <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"fields"</span>:&#123;</span><br><span class="line">              <span class="string">"keyword"</span>:&#123;</span><br><span class="line">               <span class="string">"type"</span>:<span class="string">"keyword"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"store"</span>:<span class="literal">true</span> <span class="comment">#对数据进行存储</span></span><br><span class="line">        &#125;,<span class="comment">#publish_data设为date，支持检索、排序、聚合分析</span></span><br><span class="line">        <span class="string">"publish_data"</span>:&#123;</span><br><span class="line">            <span class="string">"type"</span>:<span class="string">"date"</span>,</span><br><span class="line">            <span class="string">"store"</span>:<span class="literal">true</span> <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"author"</span>:&#123;<span class="comment"># author设为keyword，支持检索、排序、聚合分析</span></span><br><span class="line">            <span class="string">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">            <span class="string">"store"</span>:<span class="literal">true</span>    <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"abstract"</span>:&#123;<span class="comment"># abstract设为text，支持检索、排序、聚合分析</span></span><br><span class="line">            <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"store"</span>:<span class="literal">true</span>    <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"content"</span>:&#123;<span class="comment"># content设为text，支持检索、排序、聚合分析</span></span><br><span class="line">            <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"store"</span>:<span class="literal">true</span>    <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"url"</span>:&#123;</span><br><span class="line">            <span class="string">"type"</span>:<span class="string">"keyword"</span>,   <span class="comment"># url设为keyword</span></span><br><span class="line">            <span class="string">"doc_values"</span>:<span class="literal">false</span>, <span class="comment"># url不支持排序和聚合分析</span></span><br><span class="line">            <span class="string">"norms"</span>:<span class="literal">false</span>,      <span class="comment"># url也不需要归一化数据</span></span><br><span class="line">            <span class="string">"ignore_above"</span>:100, <span class="comment"># 预设内容长度为100</span></span><br><span class="line">            <span class="string">"store"</span>:<span class="literal">true</span>        <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>在搜索时增加高亮</strong>: 在此时，<code>content</code>里面的数据会存储大量的内容数据，数据量可能达到上千、上万，甚至几十万。那么在搜索的时候，根据<code>search</code>机制，如果还是像之前一样进行<code>_search</code>搜索，并只显示其他字段的话，其实依然还是每次获取了<code>content</code>字段的内容，影响性能，所以，使用<code>stored_fields</code>参数，控制返回的字段。节省了大量资源：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用stored_fields返回指定的存储后的字段</span></span><br><span class="line">GET blog_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"stored_fields"</span>:[<span class="string">"title"</span>,<span class="string">"publish_data"</span>,<span class="string">"author"</span>,<span class="string">"Abstract"</span>,<span class="string">"url"</span>],</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"content"</span>:<span class="string">"world"</span><span class="comment">#依然进行content搜索，但是不返回所有的content字段</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"highlight"</span>:&#123; <span class="comment">#针对content字段进行高亮显示</span></span><br><span class="line">  <span class="string">"fields"</span>:&#123;</span><br><span class="line">     <span class="string">"content"</span>:&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>GET blog_index/_search?_source=title</code> 虽然只显示了<code>title</code>，但是<code>search</code>机制决定了，会把所有<code>_source</code>内容获取到，但只是显示<code>title</code>。</p></blockquote><h4 id="2-5-ES中关联关系处理"><a href="#2-5-ES中关联关系处理" class="headerlink" title="2.5 ES中关联关系处理"></a>2.5 ES中关联关系处理</h4><p><code>ES</code>不擅长处理关系型数据库中的关联关系，因为底层使用的倒排索引，如：文章表<code>blog</code>和评论表<code>comment</code>之间通过<code>blog_id</code>关联。<br>目前ES主要有以下4种常用的方法来处理关联关系：</p><ol><li><strong><code>Nested Object</code></strong>:嵌套文档</li><li><strong><code>Parent/Child</code></strong>:父子文档</li><li><code>Data denormalization</code>:数据的非规范化</li><li><code>Application-side joins</code>:服务端Join或客户端Join</li></ol><h5 id="2-5-1-Application-side-joins（服务端Join或客户端Join）"><a href="#2-5-1-Application-side-joins（服务端Join或客户端Join）" class="headerlink" title="2.5.1 Application-side joins（服务端Join或客户端Join）"></a>2.5.1 Application-side joins（服务端Join或客户端Join）</h5><p>索引之间完全独立（利于对数据进行标准化处理，如便于上述两种增量同步的实现），由应用端的多次查询来实现近似关联关系查询。</p><ul><li>适用于第一个实体只有少量的文档记录的情况（使用<code>ES</code>的<code>terms</code>查询具有上限，默认<code>1024</code>，具体可在<code>elasticsearch.yml</code>中修改），并且最好它们很少改变。这将允许应用程序对结果进行缓存，并避免经常运行第一次查询。</li></ul><h5 id="2-5-2-Data-denormalization（数据的非规范化）"><a href="#2-5-2-Data-denormalization（数据的非规范化）" class="headerlink" title="2.5.2 Data denormalization（数据的非规范化）"></a>2.5.2 Data denormalization（数据的非规范化）</h5><p>通俗点就是通过字段冗余，以一张大宽表来实现粗粒度的<code>index</code>，这样可以充分发挥扁平化的优势。但是这是以牺牲索引性能及灵活度为代价的。</p><ul><li>使用的前提：冗余的字段应该是很少改变的；比较适合与一对少量关系的处理。当业务数据库并非采用非规范化设计时，这时要将数据同步到作为二级索引库的ES中，就很难使用上述增量同步方案，必须进行定制化开发，基于特定业务进行应用开发来处理<code>join</code>关联和实体拼接。<blockquote><p>宽表处理在处理一对多、多对多关系时，会有字段冗余问题，适合“一对少量”且这个“一”更新不频繁的应用场景。</p></blockquote></li></ul><h5 id="2-5-3-Nested-objects（嵌套文档）"><a href="#2-5-3-Nested-objects（嵌套文档）" class="headerlink" title="2.5.3 Nested objects（嵌套文档）"></a>2.5.3 Nested objects（嵌套文档）</h5><p>索引性能和查询性能二者不可兼得，必须进行取舍。<br>嵌套文档将实体关系嵌套组合在单文档内部（类似与json的一对多层级结构），这种方式牺牲索引性能（文档内任一属性变化都需要重新索引该文档）来换取查询性能，可以同时返回关系实体，比较适合于一对少量的关系处理。</p><ul><li>当使用嵌套文档时，使用通用的查询方式是无法访问到的，必须使用合适的查询方式（nested query、nested filter、nested facet等），很多场景下，使用嵌套文档的复杂度在于索引阶段对关联关系的组织拼装。</li></ul><h5 id="2-5-4-Parent-Child（父子文档）"><a href="#2-5-4-Parent-Child（父子文档）" class="headerlink" title="2.5.4 Parent/Child（父子文档）"></a>2.5.4 Parent/Child（父子文档）</h5><p>父子文档牺牲了一定的查询性能来换取索引性能，适用于一对多的关系处理。其通过两种type的文档来表示父子实体，父子文档的索引是独立的。父-子文档ID映射存储在 Doc Values 中。当映射完全在内存中时， Doc Values 提供对映射的快速处理能力，另一方面当映射非常大时，可以通过溢出到磁盘提供足够的扩展能力。</p><ul><li><p>在查询parent-child替代方案时，发现了一种filter-terms的语法，要求某一字段里有关联实体的ID列表。基本的原理是在terms的时候，对于多项取值，如果在另外的index或者type里已知主键id的情况下，某一字段有这些值，可以直接嵌套查询。具体可参考官方文档的示例：通过用户里的粉丝关系，微博和用户的关系，来查询某个用户的粉丝发表的微博列表。</p><blockquote><p>父子文档相比嵌套文档较灵活，但只适用于“一对大量”且这个“一”不是海量的应用场景，该方式比较耗内存和CPU，这种方式查询比嵌套方式慢5~10倍，且需要使用特定的has_parent和has_child过滤器查询语法，查询结果不能同时返回父子文档（一次join查询只能返回一种类型的文档）。</p></blockquote></li><li><p>而受限于父子文档必须在同一分片上，ES父子文档在滚动索引、多索引场景下对父子关系存储和联合查询支持得不好，而且子文档type删除比较麻烦（子文档删除必须提供父文档ID）。</p></li><li><p>如果业务端对查询性能要求很高的话，还是建议使用宽表化处理的方式，这样也可以比较好地应对聚合的需求。在索引阶段需要做join处理，查询阶段可能需要做去重处理，分页方式可能也得权衡考虑下。</p></li></ul><h4 id="2-6-ES中的reindex"><a href="#2-6-ES中的reindex" class="headerlink" title="2.6 ES中的reindex"></a>2.6 ES中的reindex</h4><p><code>reindex</code>：指重建所有数据的过程，一般发生在一下情况：</p><ol><li><code>mapping</code>设置变更，如：字段类型变化，分词器字典更新等；</li><li><code>index</code>设置变更，如：分片数变化；</li><li>迁移数据。</li></ol><ul><li>ES提供了线程的api用于完成数据重建：<ul><li><code>_update_by_query</code>：在现有索引上重建；</li><li><code>_reindex</code>：在其他索引上重建。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将blog_index中所有文档重建一遍：</span></span><br><span class="line"><span class="comment"># 如果遇到版本冲突，依然执行。</span></span><br><span class="line">POST blog_index/_update_by_query?conflicts=proceed    </span><br><span class="line"><span class="comment"># 此时如果blog_index中没有store的数据，则会报错</span></span><br></pre></td></tr></table></figure><h5 id="2-6-1-使用-update-by-query，更新文档的字段值和部分文档："><a href="#2-6-1-使用-update-by-query，更新文档的字段值和部分文档：" class="headerlink" title="2.6.1 使用_update_by_query，更新文档的字段值和部分文档："></a>2.6.1 使用<code>_update_by_query</code>，更新文档的字段值和部分文档：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新文档的字段值及部分文档</span></span><br><span class="line">POST blog_index/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"script"</span>:&#123;    <span class="comment"># 更新文档的字段值</span></span><br><span class="line">  <span class="string">"source"</span>:<span class="string">"ctx._source.likes++"</span>,    <span class="comment"># 代码</span></span><br><span class="line">  <span class="string">"lang"</span>:<span class="string">"painless"</span>    <span class="comment"># ES自带script语法</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"query"</span>:&#123;    <span class="comment"># 更新部分文档</span></span><br><span class="line">  <span class="string">"term"</span>:&#123;</span><br><span class="line">   <span class="string">"user"</span>:<span class="string">"tom"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在reindex发起后进入的文档，不会参与重建，类似于快照的机制。因此：一般在文档不再发生变更时，进行文档的reindex。</p><h5 id="2-6-2-使用-reindex，重建数据："><a href="#2-6-2-使用-reindex，重建数据：" class="headerlink" title="2.6.2 使用_reindex，重建数据："></a>2.6.2 使用<code>_reindex</code>，重建数据：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用_reindex：</span></span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"source"</span>:&#123;    <span class="comment"># 被重建索引</span></span><br><span class="line">  <span class="string">"index"</span>:<span class="string">"blog_index"</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"dest"</span>:&#123;    <span class="comment"># 目标索引</span></span><br><span class="line">  <span class="string">"index"</span>:<span class="string">"blog_new_index"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据重建时间，受到索引文档规模的影响，此时设定<code>url</code>参数<code>wait_for_completion</code>为<code>false</code>，来异步执行。</li><li><code>ES</code>通过<code>task</code>来描述此类执行任务，并提供了<code>task api</code>来查看任务的执行进度和相关数据：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用task api</span></span><br><span class="line">POST blog_index/_update_by_query?comflicts=proceed&amp;wait_for_completion=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 使用返回的taskid，查看任务的执行进度和相关数据</span></span><br><span class="line">GET _tasks/&lt;返回的task id&gt;</span><br></pre></td></tr></table></figure><h4 id="2-7-其他建议："><a href="#2-7-其他建议：" class="headerlink" title="2.7 其他建议："></a>2.7 其他建议：</h4><ol><li>对mapping进行版本管理：<ul><li>要么写文件/注释，加入到<code>Git</code>仓库，一眼可见；</li><li>要么增加<code>metadata</code>字段，维护版本，并在每次更新<code>mapping</code>设置的时候加<code>1</code>。</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"metadata"</span>:&#123;</span><br><span class="line"> <span class="string">"version"</span>:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>防止字段过多：<ul><li><code>index.mapping.total_fields_limit</code>，默认<code>1000</code>个。一般是因为没有高质量的数据建模导致，如：<code>dynamic</code>设为<code>true</code>。此时考虑查分多个索引来解决问题。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ElasticSearch中的聚合分析&quot;&gt;&lt;a href=&quot;#1-ElasticSearch中的聚合分析&quot; class=&quot;headerlink&quot; title=&quot;1. ElasticSearch中的聚合分析&quot;&gt;&lt;/a&gt;1. ElasticSearch中的聚合分析&lt;/h3&gt;&lt;p&gt;聚合分析，英文&lt;code&gt;Aggregation&lt;/code&gt;，是ES除了搜索功能之外提供的针对ES数据进行统计分析的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：&lt;ul&gt;
&lt;li&gt;①功能丰富，可满足大部分分析需求；&lt;/li&gt;
&lt;li&gt;②实时性高，所有计算结果实时返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于分析规则的不同，ES将聚合分析主要划分为以下4种：&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Metric&lt;/code&gt;&lt;/strong&gt;: 指标分析类型，如：计算最值，平均值等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Bucket&lt;/code&gt;&lt;/strong&gt;: 分桶类型，类似于&lt;code&gt;group by&lt;/code&gt;语法，根据一定规则划分为若干个桶分类；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Pipeline&lt;/code&gt;&lt;/strong&gt;: 管道分析类型，基于上一级的聚合分析结果进行再分析；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Matrix&lt;/code&gt;: 矩阵分析类型。
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【ElasticStack】ElasticSearch分布式特性 与 Search机制</title>
    <link href="http://chaooo.github.io/article/20191120.html"/>
    <id>http://chaooo.github.io/article/20191120.html</id>
    <published>2019-11-20T12:44:13.000Z</published>
    <updated>2020-02-14T11:17:37.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ElasticSearch的分布式特性"><a href="#1-ElasticSearch的分布式特性" class="headerlink" title="1. ElasticSearch的分布式特性"></a>1. ElasticSearch的分布式特性</h3><h4 id="1-1-分布式介绍"><a href="#1-1-分布式介绍" class="headerlink" title="1.1 分布式介绍"></a>1.1 分布式介绍</h4><ol><li><code>ES</code>支持<strong>集群模式</strong>，即一个分布式系统。其好处主要有以下2个:<ol><li><strong>可增大系统容量</strong>。比如：内存、磁盘的增加使得<code>ES</code>能够支持<code>PB</code>级别的数据；</li><li><strong>提高了系统可用性</strong>。即使一部分节点停止服务，集群依然可以正常对外服务。</li></ol></li><li><code>ES</code>集群由多个<code>ES实例</code>构成。<ul><li>不同集群通过<strong>集群名字</strong>来区分，通过配置文件<code>elasticsearch.yml</code>中的<code>cluster.name</code>可以修改，默认为<code>elasticsearch</code></li><li>每个<code>ES实例</code>的本质，其实是一个<code>JVM进程</code>，且有自己的名字，通过配置文件中的<code>node.name</code>可以修改。<a id="more"></a></li></ul></li></ol><h4 id="1-2-构建ES集群"><a href="#1-2-构建ES集群" class="headerlink" title="1.2 构建ES集群"></a>1.2 构建ES集群</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个本地化集群my_cluster</span></span><br><span class="line">bin/elasticsearch -Epath.data=node1 -Ecluster.name=my_cluster -Enode.name=node1 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2 -Ecluster.name=my_cluster -Enode.name=node2 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3 -Ecluster.name=my_cluster -Enode.name=node3 -d</span><br></pre></td></tr></table></figure><blockquote><p>可以通过cerebro插件可以看到，集群<code>my_cluster</code>中存在三个节点，分别为：<code>node1</code>、<code>node2</code>、<code>node3</code></p></blockquote><ol><li><strong><code>Cluster State</code></strong>：ES集群相关的数据，主要记录如下信息：<ul><li>节点信息：如节点名称、连接地址等</li><li>索引信息：如索引名称、配置等</li></ul></li><li><strong><code>Master Node</code></strong>：<strong>主节点</strong>，可修改<code>cluster state</code>的节点。一个集群<strong>只能有一个</strong>。<ul><li><code>cluster state</code>存储于每个节点上，<code>master</code>维护最新版本并向其他从节点同步。</li><li>master节点是通过集群中所有节点<strong>选举</strong>产生的，可被选举的节点称为<strong><code>master-eligible节点</code></strong></li><li>通过配置<code>node.master:true</code>设置节点为可被选举节点(默认为true)</li></ul></li><li><strong><code>Cordinating Node</code></strong>：处理请求的节点。是所有节点的默认角色，且不能取消。<ul><li>路由请求到正确的节点处理，如：创建索引的请求到master节点。</li></ul></li><li><strong><code>Data Node</code></strong>：存储数据的节点，默认节点都是<code>data</code>类型。配置<code>node.data:true</code>。</li></ol><h4 id="1-3-副本与分片"><a href="#1-3-副本与分片" class="headerlink" title="1.3 副本与分片"></a>1.3 副本与分片</h4><ul><li><p>提高系统可用性：</p><ol><li>服务可用性：集群</li><li>数据可用性：<strong>副本</strong>(Replication)</li></ol></li><li><p>增大系统容量：<strong>分片</strong>(Shard)</p></li><li><p><strong>分片</strong>是<code>ES</code>能支持<code>PB级别数</code>据的基石：可在创建索引时指定</p><ol><li>分片存储部分数据，可以分布于任意节点；</li><li>分片数在索引创建时指定，且后续不能更改，默认为5个；</li><li>有主分片和副本分片之分，以实现数据的高可用；</li><li>副本分片由主分片同步数据，可以有多个，从而提高数据吞吐量。</li></ol></li><li><p><strong>分片数的设定</strong>很重要，需要提前规划好</p><ul><li><strong>过小</strong>会导致后续无法通过增加节点实现水平扩容</li><li><strong>过大</strong>会导致一个节点分片过多，造成资源浪费，同时会影响查询性能</li></ul></li><li><p>例如：在3个节点的集群中配置索引指定3个分片和1个副本（<code>index.number_of_shards:3</code>,<br><code>index.number_of_replicas:1</code>），分布如下：<br><img src="http:%5Ccdn.chaooo.top/Java/es_shard.jpg" alt></p></li><li><p>怎样增加节点或副本提高索引的吞吐量</p><ul><li><strong>同时</strong>增加新的节点<strong>和</strong>加新的副本，这样把新的副本放在新的节点上，进行索引数据读取的时候，并且读取，就会提升索引数据读取的吞吐量。</li></ul></li></ul><h4 id="1-4-ES集群状态-与-故障转移"><a href="#1-4-ES集群状态-与-故障转移" class="headerlink" title="1.4 ES集群状态 与 故障转移"></a>1.4 ES集群状态 与 故障转移</h4><ul><li>ES的<strong>健康状态(<code>Cluster Health</code>)</strong>分为三种：<ol><li><code>Greed</code>，绿色。表示所有主分片和副本分片都正常分配；</li><li><code>Yellow</code>，黄色。表示所有主分片都正常分配，但有副本分片未分配；</li><li><code>Red</code>，红色。表示有主分片未分配。</li></ol></li><li>可通过<code>GET _cluster/health</code>查看集群状态<ul><li>返回<strong>集群名称</strong>，<strong>集群状态</strong>，<strong>节点数</strong>，<strong>活跃分片数</strong>等信息。</li><li>如果此时磁盘空间不够，name在创建新的索引的时候，主副分片都不会再分配，此时的集群状态会直接飙红，但此时依然可以访问集群和索引，也可以正常进行搜索。</li><li>所以：<strong>ES的集群状态为红色，不一定就不能正常服务</strong>。</li></ul></li></ul><ul><li><strong>故障转移 <code>Failover</code></strong><ol><li>当其余节点发现定时ping主节点master无响应的时候，集群状态转为Red。此时会发起master选举。</li><li>新master节点发现若有主分片未分配，会将副本分片提升为主分片，此时集群状态转为Yellow。</li><li>新master节点会将提升后的主分片生成新的副本，此时集群状态转为Green。整个故障转移过程结束。</li></ol></li></ul><h4 id="1-5-文档分布式存储"><a href="#1-5-文档分布式存储" class="headerlink" title="1.5 文档分布式存储"></a>1.5 文档分布式存储</h4><p>通过文档到分片的<strong>映射算法</strong>，使文档<strong>均匀分布</strong>到所有分片上，以充分利用资源。</p><ul><li><p>文档对应分片计算公式：<code>shard = hash(routing)%number_of_primary_shards</code></p><ul><li><code>hash</code>保证数据均匀分布在分片中</li><li><code>routing</code>作为关键参数，默认为文档ID，也可自行指定</li><li><code>number_of_primary_shards</code>为主分片数</li></ul></li><li><p><strong>主分片数一旦设定，不能更改</strong>：<code>为了保证文档对应的分片不会发生改变</code>。</p></li><li><p>文档<strong>创建</strong>流程:<br><img src="http:%5Ccdn.chaooo.top/Java/elastic1.jpg" alt></p></li><li><p>文档<strong>读取</strong>流程<br><img src="http:%5Ccdn.chaooo.top/Java/elastic2.jpg" alt></p></li><li><p>文档<strong>批量创建</strong>流程<br><img src="http:%5Ccdn.chaooo.top/Java/elastic3.jpg" alt></p></li><li><p>文档<strong>批量读取</strong>流程<br><img src="http:%5Ccdn.chaooo.top/Java/elastic4.jpg" alt></p></li></ul><h4 id="1-6-脑裂问题"><a href="#1-6-脑裂问题" class="headerlink" title="1.6 脑裂问题"></a>1.6 脑裂问题</h4><ul><li>在分布式系统中一个经典的网络问题<ul><li>当一个集群在运行时，作为<code>master</code>节点的<code>node1</code>的网络突然出现问题，无法和其他节点通信，出现网络隔离情况。那么<code>node1</code>自己会组成一个单节点集群，并更新<code>cluster state</code>；同时作为<code>data</code>节点的<code>node2</code>和<code>node3</code>因为无法和<code>node1</code>通信，则通过选举产生了一个新的<code>master</code>节点<code>node2</code>，也更新了<code>cluster state</code>。那么当<code>node1</code>的网络通信恢复之后，集群无法选择正确的<code>master</code>。</li></ul></li><li>解决方案也很简单：<ul><li>仅在可选举的<code>master-eligible</code>节点数<code>&gt;=quorum</code>的时候才进行<code>master</code>选举。</li><li><code>quorum(至少为2)=master-eligible数量/2 + 1</code>。</li><li>通过<code>discovery.zen.minimum_master_nodes</code>为<code>quorum</code>即可避免脑裂。</li></ul></li></ul><h4 id="1-7-Shards分片详解"><a href="#1-7-Shards分片详解" class="headerlink" title="1.7 Shards分片详解"></a>1.7 Shards分片详解</h4><ol><li>倒排索引一旦生成，不能更改。<ul><li>优点：<ol><li>不用考虑并发写文件的问题，杜绝了锁机制带来的性能问题</li><li>文件不在更改，则可以利用文件系统缓存，只需载入一次，只要内存足够，直接从内存中读取该文件，性能高；</li><li>利于生成缓存数据(且不需更改)；</li><li>利于对文件进行压缩存储，节省磁盘和内存存储空间。</li></ol></li><li>缺点：在写入新的文档时，必须重构倒排索引文件，然后替换掉老倒排索引文件后，新文档才能被检索到，导致实时性差。</li></ul></li><li>解决文档搜索的实时性问题的方案：<ul><li>新文档直接生成新待排索引文件，查询时同时查询所有倒排索引文件，然后做结果的汇总即可，从而提升了实时性。</li></ul></li><li><code>Segment</code><ul><li><code>Lucene</code>就采用了上述方案，构建的单个倒排索引称为<code>Segment</code>，多个<code>Segment</code>合在一起称为<code>Index</code>(<code>Lucene</code>中的<code>Index</code>)。在<code>ES</code>中的一个<code>shard</code>分片，对应一个<code>Lucene</code>中的<code>Index</code>。且<code>Lucene</code>有一个专门记录所有<code>Segment</code>信息的文件叫做<code>Commit Point</code>。</li><li><code>Segment</code>写入磁盘的过程依然很耗时，可以借助文件系统缓存的特性。【先将<code>Segment</code>在内存中创建并开放查询，来进一步提升实时性】，这个过程在<code>ES</code>中被称为：<code>refresh</code>。</li><li>在<code>refresh</code>之前，文档会先存储到一个缓冲队列<code>buffer</code>中，<code>refresh</code>发生时，将<code>buffer</code>中的所有文档清空，并生成<code>Segment</code>。</li><li><code>ES</code>默认每<code>1s</code>执行一次<code>refresh</code>操作，因此实时性提升到了<code>1s</code>。这也是<code>ES</code>被称为近实时的原因（<code>Near Real Time</code>）。</li></ul></li><li><code>translog</code>文件<ul><li><code>translog</code>机制：当文档写入<code>buffer</code>时，同时会将该操作写入到<code>translog</code>中，这个文件会即时将数据写入磁盘，在6.0版本之后默认每个要求都必须落盘，这个操作叫做<code>fsync</code>操作。这个时间也是可以通过配置：<code>index.translog.*</code>进行修改的。比如每五秒进行一次<code>fdync</code>操作，那么风险就是丢失这<code>5s</code>内的数据。</li></ul></li><li>文档搜索实时性——<code>flush</code>(十分重要)<ul><li><code>flush</code>的功能，就是：将内存中的<code>Segment</code>写入磁盘，主要做如下工作：<ol><li>将<code>translog</code>写入磁盘；</li><li>将<code>index bufffer</code>清空，其中的文档生成一个新的<code>Segment</code>，相当于触发一次<code>refresh</code>；</li><li>更新<code>Commit Point</code>文件并写入磁盘；</li><li>执行<code>fsync</code>落盘操作，将内存中的<code>Segment</code>写入磁盘；</li><li>删除旧的<code>translog</code>文件。</li></ol></li></ul></li><li><code>refresh</code>与<code>flush</code>的发生时机<ul><li><code>refresh</code>：发生时机主要有以下几种情况：<ol><li>间隔时间达到。<ul><li>通过<code>index.settings.refresh_interval</code>设置，默认为<code>1s</code>。</li></ul></li><li><code>index.buffer</code>占满时。<ul><li>通过<code>indices.memory.index_buffer_size</code>设置，默认<code>JVM heap</code>的<code>10%</code>，且所有<code>shard</code>共享。</li></ul></li><li><code>flush</code>发生时。会触发一次<code>refresh</code>。</li></ol></li><li><code>flush</code>：发生时机主要有以下几种情况：<ol><li>间隔时间达到。<ul><li>5.x版本之前，通过<code>index.translog.flush_threshold_period</code>设置，默认30min。</li><li>5.x版本之后，<strong>ES强制每30min执行一次flush，不能再进行更改</strong>。</li></ul></li><li><code>translog</code>占满时。<ul><li>通过<code>index.translog.flush_threshold_size</code>设置，默认<code>512m</code>。且每个<code>Index</code>有自己的<code>translog</code>。</li></ul></li></ol></li></ul></li><li>删除和更新文档：<ul><li>删除：<ul><li><code>Segment</code>一旦生成，就不能更改，删除的时候，<code>Lucene</code>专门维护一个<code>.del</code>文件，记录所有已删除的文档。</li><li><code>.del</code>文件上记录的是文档在<code>Lucene</code>中的<code>ID</code>，在查询结果返回之前，会过滤掉<code>.del</code>文件中的所有文档。</li></ul></li><li>更新：<ul><li>先删除老文档，再创建新文档，两个文档的<code>ID</code>在<code>Lucene</code>中的<code>ID</code>不同，但是在<code>ElasticSearch</code>中<code>ID</code>相同。</li></ul></li></ul></li><li><code>Segment Merging</code>(合并)<ol><li>随着<code>Segment</code>的增多，由于每次查询的<code>Segment</code>数量也增多，导致查询速度变慢；</li><li><code>ES</code>会定时在后台进行<code>Segment merge</code>的操作，减少<code>Segment</code>数量；</li><li>通过<code>force_merge api</code>可以手动强制做<code>Segment</code>的合并操作。</li></ol></li></ol><h3 id="2-ElasticSearch的集群优化"><a href="#2-ElasticSearch的集群优化" class="headerlink" title="2. ElasticSearch的集群优化"></a>2. ElasticSearch的集群优化</h3><h4 id="2-1-生产环境部署"><a href="#2-1-生产环境部署" class="headerlink" title="2.1 生产环境部署"></a>2.1 生产环境部署</h4><ol><li>遵照官方建议设置所有系统参数。<ul><li>在ES的配置文件中elasticsearch.yml中，尽量只写必备的参数，其他可通过api进行动态设置，随着ES版本的不断升级，很多网上流传的参数，现在已经不再适用，所以不要胡乱复制。</li><li>建议设置的基本参数有：<ol><li><code>cluster.name</code></li><li><code>node.name</code></li><li><code>node.master/node.data/node.ingest</code></li><li><code>network.host</code>: 建议显示指定为服务器的内网<code>ip</code>，切勿直接指定<code>0.0.0.0</code>，很容易直接从外部被修改<code>ES</code>数据。</li><li><code>discovery.zen.ping.unicast.hosts</code>: 设置集群其他节点地址，一般设置选举节点即可</li><li><code>discovery.zen.minimum_master_nodes</code>: 一般设置为<code>2</code>，有<code>3</code>个即可。</li><li><code>path.data/path.log</code></li><li>除上述参数外，再根据需要增加其他的静态配置参数，如：<code>refresh</code>优化参数，<code>indices.memory.index_buffer_size</code>。</li></ol></li><li>动态设定的参数有transient(短暂的)和persistent(持续的)两种，前者在集群重启后会丢失，后者在集群重启后依然# 生效。二者都覆盖了yml中的配置，举例：</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用transient和persistent动态设置ES集群参数</span></span><br><span class="line">PUT /_cluster/Settings</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"persistent"</span>:&#123;    <span class="comment"># 永久</span></span><br><span class="line">  <span class="string">"discovery.zen.minimum_master_nodes:2</span></span><br><span class="line"><span class="string"> &#125;,</span></span><br><span class="line"><span class="string"> "</span>transient<span class="string">":&#123;   # 临时</span></span><br><span class="line"><span class="string">  "</span>indices.store.throttle.max_bytes_per_sec<span class="string">":"</span>50mb<span class="string">"</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>关于JVM内存设定<ul><li>每个节点尽量不要超多<code>31GB</code>。</li><li>预留一半内存给操作系统，用来做文件缓存。ES的具体内存大小根据node要存储的数据量来估算，为了保证性能<ul><li>搜索类项目中：内存：数据量   ===&gt;   1：16；</li><li>日志类项目中：内存：数据量   ===&gt;   1：48/96。</li></ul></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设现有数据1TB，3个node，1个副本，那么：</span><br><span class="line">每个node存储(1+1)*1024 / 3 = 666GB,即700GB左右，做20%预留空间，每个node约存850GB数据。</span><br><span class="line">此时：</span><br><span class="line">如果是搜索类项目，每个node内存约为850/16=53GB，已经超过31GB最大限制；</span><br><span class="line">而：31*16 = 496，意味着每个node最大只能存496GB的数据，则：2024/496=4.08...即至少需要5个节点。</span><br><span class="line">如果是日志类项目，每个node最大能存:31*48=1488GB,则：2024/1488=1.36...，则三个节点已经够了。</span><br></pre></td></tr></table></figure><h4 id="2-2-写性能优化"><a href="#2-2-写性能优化" class="headerlink" title="2.2 写性能优化"></a>2.2 写性能优化</h4><p>在写上面的优化，主要是增大写的吞吐量——<code>EPS(Event Per Second)</code></p><ul><li>优化方案：<ol><li><code>Client</code>：多线程写，批量写<code>bulk</code>；</li><li><code>ES</code>：在高质量数据建模的前提下，主要在<code>refresh</code>、<code>translig</code>和<code>flush</code>之间做文章。</li></ol></li></ul><ol><li>降低<code>refresh</code>写入内存的频率：<ol><li>增大<code>refresh_interval</code>，降低实时性，增大每次<code>refresh</code>处理的文件数，默认1s。可以设为-1s，禁止自动<code>refresh</code>。</li><li>增大<code>index</code> <code>buffer</code>大小，参数为：<code>indices.memory.index_buffer_size</code>。此为静态参数，需设定在<code>elasticsea.yml</code>中，默认<code>10%</code></li></ol></li><li>降低translog写入磁盘频率，同时会降低容灾能力：<ol><li><code>index.translog.durability</code>：设为<code>async</code>；</li><li><code>index.translog.sync_interval</code>。设置需要的大小如：120s  =&gt;  每120s才写一次磁盘。</li><li><code>index.translog.flush_threshold_size</code>。默认512m。即当<code>translog</code>大小超过此值，会触发一次<code>flush</code>，可以调大避免<code>flush</code>过早触发。</li></ol></li><li>在<code>flush</code>方面，从6.x开始，ES固定每30min执行一次，所以优化点不多，一般都是ES自动完成。</li><li>其他：<ol><li>将副本数设置为0，在文档全部写完之后再加副本；</li><li>合理设计<code>shard</code>数，保证<code>shard</code>均匀地分布在所有<code>node</code>上，充分利用<code>node</code>资源：<ul><li><code>index.routing.allocation.total_shards_per_node</code>：限定每个索引在每个<code>node</code>上可分配的主副分片数，</li><li>如：有<code>5</code>个<code>node</code>，某索引有<code>10</code>个主分片，<code>1</code>个副本(<code>10</code>个副分片)，则：<code>20/5=45</code>,但是实际要设置为<code>5</code>，预防某个<code>node</code>下线后分片迁移失败。</li></ul></li></ol></li></ol><blockquote><p>写性能优化，主要还是index级别的设置优化。<br>一般在refresh、translog、flush三个方面进行优化；</p></blockquote><h4 id="2-3-读性能优化"><a href="#2-3-读性能优化" class="headerlink" title="2.3 读性能优化"></a>2.3 读性能优化</h4><ul><li>主要受以下几方面影响：<ol><li>数据模型是否符合业务模型？</li><li>数据规模是否过大？</li><li>索引配置是否优化？</li><li>查询运距是否优化？</li></ol></li></ul><ol><li>高质量的数据建模<ol><li>将需通过<code>cripte</code>脚本动态计算的值，提前计算好作为字段存入文档中；</li><li>尽量使数据模型贴近业务模型</li></ol></li><li>根据不同数据规模设定不同的<code>SLA</code>(服务等级协议)，万级数据和千万级数据和亿万级数据性能上肯定有差异；</li><li>索引配置优化<ol><li>根据数据规模设置合理的分片数，可通过测试得到最适合的分片数；</li><li>分片数并不是越多越好</li></ol></li><li>查询语句优化<ol><li>尽量使用<code>Filter</code>上下文，减少算分场景(<code>Filter</code>有缓存机制，能极大地提升查询性能)；</li><li>尽量不用<code>cript</code>进行字段计算或算分排序等；</li><li>结合<code>profile</code>、<code>explain API</code>分析慢查询语句的症结所在，再去优化数据模型。</li></ol></li></ol><h4 id="2-4-其他优化点"><a href="#2-4-其他优化点" class="headerlink" title="2.4 其他优化点"></a>2.4 其他优化点</h4><ol><li>如何设定<code>shard</code>数？<ul><li><code>ES</code>的性能基本是线性扩展的，因此，只需测出一个<code>shard</code>的性能指标，然后根据实际的性能需求就可算出所需的<code>shard</code>数。</li><li>测试一个<code>shard</code>的流程如下：<ol><li>搭建与生产环境相同配置的单节点集群；</li><li>设定一个单分片<code>0</code>副本的索引；</li><li>写入实际生产数据进行测试，获取（写性能指标）；</li><li>针对数据进行查询操作，获取（读性能指标）。</li></ol></li></ul></li><li>压力测试工具，可以采用<code>ES</code>自带的<code>esrally</code>，从经验上讲：<ul><li>如果是搜索引擎场景，单<code>shard</code>大小不超过<code>15GB</code>；</li><li>如果是日志分析场景，单<code>shard</code>大小不超过<code>50GB</code>；</li><li>估算索引的总数据大小，除以上述单<code>shard</code>大小，也可得到经验上的分片数。</li></ul></li></ol><h4 id="2-5-ES集群监控"><a href="#2-5-ES集群监控" class="headerlink" title="2.5 ES集群监控"></a>2.5 ES集群监控</h4><p>使用官方免费插件<code>X-pack</code>。</p><ol><li>安装与启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X-pack的安装</span></span><br><span class="line"><span class="built_in">cd</span> ~/elasticsearch-6.1.1</span><br><span class="line">bin/elasticsearch-plugin install x-pack</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">cd</span> ~/kibana-6.1.1</span><br><span class="line">bin/kibana-plugin indtall x-pack</span><br></pre></td></tr></table></figure><p>之后重启<code>ES</code>集群即可。<br>在<code>kibana</code>的界面可以看到新增了工具，使用<code>Monitoring</code>进行集群监控。</p><h3 id="3-ElasticSearch中Search的运行机制"><a href="#3-ElasticSearch中Search的运行机制" class="headerlink" title="3. ElasticSearch中Search的运行机制"></a>3. ElasticSearch中Search的运行机制</h3><ul><li><code>Search</code>执行的时候，实际分为两个步骤执行：<ol><li><code>Query</code>阶段：搜索</li><li><code>Fetch</code>阶段：获取</li></ol></li></ul><h4 id="3-1-Query—Then—Fetch："><a href="#3-1-Query—Then—Fetch：" class="headerlink" title="3.1 Query—Then—Fetch："></a>3.1 Query—Then—Fetch：</h4><p>若集群<code>my_cluster</code>中存在三个节点node1、node2、node3，其中<code>master</code>为node1，其余的为<code>data</code>节点。</p><ul><li><p><code>Query</code>阶段:<br><img src="http:%5Ccdn.chaooo.top/Java/elastic-q.jpg" alt></p></li><li><p><code>Fetch</code>阶段:<br><img src="http:%5Ccdn.chaooo.top/Java/elastic-f.jpg" alt></p></li></ul><h4 id="3-2-相关性算分："><a href="#3-2-相关性算分：" class="headerlink" title="3.2 相关性算分："></a>3.2 相关性算分：</h4><p><strong>相关性算分在<code>shard</code>和<code>shard</code>之间是相互独立的</strong>。也就意味着：同一个单词<code>term</code>在不同的<code>shard</code>上的<code>TDF</code>等值也可能是不同的。得分与<code>shard</code>有关。<br>当文档数量不多时，会导致相关性算分严重不准的情况发生。</p><ul><li>解决方案：<ol><li>设置分片数为<code>1</code>个，从根本上排除问题。（此方案只适用于百万/少千万级的少量数据）</li><li>使用<code>DFS Query-then-Fetch</code>查询方式。</li></ol></li><li><code>DFS Query-then-Fecth</code>：<ul><li>在拿到所有文档后，再重新进行完整的计算一次相关性得分，耗费更多的CPU和内存，<strong>执行性能也较低</strong>。所以也不推荐。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用DLS Query-then-Fetch进行查询：</span></span><br><span class="line">GET my_index/_search？search_type=dfs_query_then_fetch</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-排序相关："><a href="#3-3-排序相关：" class="headerlink" title="3.3 排序相关："></a>3.3 排序相关：</h4><p>默认采用相关性算分结果进行排序。可通过<code>sort</code>参数自定义排序规则，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用sort关键词进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"sort"</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">  <span class="string">"birth"</span>:<span class="string">"desc"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 或使用数组形式定义多字段排序规则</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"sort"</span>:[    <span class="comment"># 使用数组</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">"birth"</span>:&#123;</span><br><span class="line">    <span class="string">"order"</span>:<span class="string">"asc"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">"age"</span>:&#123;</span><br><span class="line">    <span class="string">"order"</span>:<span class="string">"desc"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>直接按数字/日期排序，如上例中<code>birth</code></li><li>按字符串进行排序：字符串排序较特殊，因为在<code>ES</code>中有<code>keyword</code>和<code>text</code>两种：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接对text类型进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"sort"</span>:&#123;</span><br><span class="line">  <span class="string">"username"</span>:<span class="string">"desc"</span>    <span class="comment"># 针对username字段进行倒序排序</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 针对keyword进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"sort"</span>:&#123;</span><br><span class="line">  <span class="string">"username.keyword"</span>:<span class="string">"desc"</span>    <span class="comment"># 针对username的子类型keyword类型进行倒叙排序</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-1-关于fielddata和docvalues"><a href="#3-3-1-关于fielddata和docvalues" class="headerlink" title="3.3.1 关于fielddata和docvalues:"></a>3.3.1 关于fielddata和docvalues:</h5><p>排序的实质是对字段的原始内容排序的过程，此过程中<strong>倒排索引无法发挥作用</strong>，需要用到<strong>正排索引</strong>。即：通过文档<code>ID</code>和字段得到原始内容。</p><ul><li>ES提供2中实现方式：<ul><li><code>Fielddata</code>。    默认禁用。</li><li><code>DocValues</code>。    默认启用，除了text类型。</li></ul></li></ul><table><thead><tr><th>对比</th><th>Fielddata</th><th>DocValues</th></tr></thead><tbody><tr><td>创建时机</td><td>搜索时即时创建</td><td>创建索引时创建，和倒排索引创建时间一致</td></tr><tr><td>创建位置</td><td>JVM Heap</td><td>磁盘</td></tr><tr><td>优点</td><td>不占用额外磁盘空间</td><td>不占用Heap内存</td></tr><tr><td>缺点</td><td>文档较多时，同时创建会花费过多时间，占用过多Heap内存</td><td>减慢索引的速度，占用额外的磁盘空间</td></tr></tbody></table><h5 id="3-3-2-Fielddata的开启"><a href="#3-3-2-Fielddata的开启" class="headerlink" title="3.3.2 Fielddata的开启:"></a>3.3.2 Fielddata的开启:</h5><p><code>Fielddata</code><strong>默认关闭</strong>，可通过如下api进行开启，且在后续使用时随时可以开启/关闭：</p><ul><li>使用场景：<strong>一般在对分词做聚合分析的时候开启</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启字段的fielddata设置</span></span><br><span class="line">PUT my_index/_mapping/doc</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"properties"</span>:&#123;</span><br><span class="line">  <span class="string">"username"</span>:&#123;</span><br><span class="line">   <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">   <span class="string">"fielddata"</span>:<span class="literal">true</span>    <span class="comment"># 关键词</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-Docvalues的关闭"><a href="#3-3-3-Docvalues的关闭" class="headerlink" title="3.3.3 Docvalues的关闭"></a>3.3.3 Docvalues的关闭</h4><p><code>Docvalues</code><strong>默认开启</strong>，可在创建索引时关闭，且之后不能再打开，要打开只能做reindex操作。</p><ul><li>使用场景：当明确知道，不会使用这个字段排序或者不做聚合分析的时候，可关闭doc_values，减少磁盘空间的占用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭字段的docvalues设置</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"properties"</span>:&#123;</span><br><span class="line">    <span class="string">"username"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">     <span class="string">"doc_values"</span>:<span class="literal">false</span>    <span class="comment"># 关键词</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-分页与遍历"><a href="#3-4-分页与遍历" class="headerlink" title="3.4 分页与遍历"></a>3.4 分页与遍历</h4><p>ES提供了三种方式来解决分页和遍历的问题： <code>from/size</code>，<code>scroll</code>，<code>search_after</code>。</p><h5 id="3-4-1-from-size"><a href="#3-4-1-from-size" class="headerlink" title="3.4.1 from/size"></a>3.4.1 from/size</h5><ul><li><code>from</code>：指明开始位置；</li><li><code>size</code>：指明获取总数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用from——size</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"from"</span>:1,    <span class="comment"># 从第2个开始搜索</span></span><br><span class="line"> <span class="string">"size"</span>:2     <span class="comment"># 获取2个长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>经典问题：<strong>深度分页</strong>。<ul><li>问题：如何在数据分片存储的情况下， 获取前1000个文档？</li><li>答案：<ul><li>先从每个分片上获取前1000个文档， 然后由处理节点聚合所有分片的结果之后，再排序获取前1000个文档。</li><li>此时页数越深，处理的文档就越多，占用的内存就越大，耗时就越长。这就是深度分页问题。</li><li>为了尽量避免深度分页为题，ES通过设定<code>index.max_result_window</code>限定最多到10000条数据。</li></ul></li></ul></li><li>在设计分页系统时，有一个分页数十分重要：<ul><li><code>total_page=(total + page_size -1) / page_size</code></li><li>总分页数= (文档总数+认为设定的文档大小-1) / 人为设定的文档大小</li><li>但是在搜索引擎中的意义并不大，因为如果排在前面的结果都不能让用户满意，那么越往后，越不能让用户满意。</li></ul></li></ol><h5 id="3-4-2-scroll"><a href="#3-4-2-scroll" class="headerlink" title="3.4.2 scroll"></a>3.4.2 scroll</h5><ul><li>遍历文档集的<code>API</code>，以快照的方式来避免深度分页问题。<ol><li>不能用来做实时搜索，因为数据不是实时的；</li><li>尽量不用复杂的<code>sort</code>条件，使用<code>_doc</code>最高效；</li><li>使用比较复杂。</li></ol></li><li>步骤：<ol><li>发起一个<code>scroll search</code>，会返回后续会用到的<code>_scroll_id</code></li><li>调用<code>scroll search</code>的<code>api</code>，获取文档集合，不断迭代至返回<code>hits</code>数组为空时停止</li><li>之后不断返回新的<code>_scroll_id</code>，使用新的<code>_scroll_id</code>进行查询，直到返回数组为空。</li><li>当不断的进行迭代，会产生很多<code>scroll</code>，导致大量内存被占用，可以通过<code>clear api</code>进行删除</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发起一个scroll search</span></span><br><span class="line">GET my_index/_search?scroll=5m <span class="comment"># 该快照的有效时间为5min</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>1    <span class="comment"># 指明每次scroll返回的文档数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 调用scroll search 的api，获取文档集合</span></span><br><span class="line">POST _search/scroll</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"scroll"</span>:<span class="string">"5m"</span>,    <span class="comment"># 指明有效时间</span></span><br><span class="line"> <span class="string">"scroll_id"</span>:<span class="string">"xxxxxx"</span>    <span class="comment"># 上一步返回的_scroll_id</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用clear api对scroll进行删除</span></span><br><span class="line">DELETE /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"scroll_id"</span>:[</span><br><span class="line">   <span class="string">"xxxxxx"</span>,    <span class="comment"># _scroll_id</span></span><br><span class="line">   <span class="string">"xxxxxx"</span>,    <span class="comment"># _scroll_id</span></span><br><span class="line">   ......</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 删除所有的scroll</span></span><br><span class="line">DELETE /_search/scroll/_all</span><br></pre></td></tr></table></figure><h5 id="3-4-3-search-after"><a href="#3-4-3-search-after" class="headerlink" title="3.4.3 search_after"></a>3.4.3 search_after</h5><p>避免深度分页的性能问题，提供实时的下一页文档获取功能。</p><ul><li>缺点：不能使用from参数，即：不能指定页数。且只能下一页，不能上一页。</li><li>使用步骤：<ol><li>第一步：正常搜索，但是要指定sort值，并保证值唯一：</li><li>第二步：使用上一步最后一个文档的sort值进行查询：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步，正常搜索</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:1,</span><br><span class="line"> <span class="string">"sort"</span>:&#123;</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"desc"</span>,</span><br><span class="line">  <span class="string">"_id"</span>:<span class="string">"desc"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 第二步，使用sort值进行查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"size"</span>:1,</span><br><span class="line"> <span class="string">"search_after"</span>:[28,<span class="string">"2"</span>],<span class="comment"># 28,"2"，是上一次搜索返回的sort值</span></span><br><span class="line"> <span class="string">"sort"</span>:&#123;</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"desc"</span>,</span><br><span class="line">  <span class="string">"_id"</span>:<span class="string">"desc"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-4-4-如何避免深度分页问题"><a href="#3-4-4-如何避免深度分页问题" class="headerlink" title="3.4.4 如何避免深度分页问题:"></a>3.4.4 如何避免深度分页问题:</h5><p>这个问题目前连google都没能解决，所以只能最大程度避免，通过唯一排序值定位每次要处理的文档数都控制在size内：</p><ul><li>应用场景：<ol><li>from/size:需实时获取顶部的部分文档，且需自由翻页（实时）；</li><li>scroll:需全部文档，如：导出所有数据的功能（非实时）；</li><li>search_after:需全部文档，不需自由翻页（实时）。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ElasticSearch的分布式特性&quot;&gt;&lt;a href=&quot;#1-ElasticSearch的分布式特性&quot; class=&quot;headerlink&quot; title=&quot;1. ElasticSearch的分布式特性&quot;&gt;&lt;/a&gt;1. ElasticSearch的分布式特性&lt;/h3&gt;&lt;h4 id=&quot;1-1-分布式介绍&quot;&gt;&lt;a href=&quot;#1-1-分布式介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 分布式介绍&quot;&gt;&lt;/a&gt;1.1 分布式介绍&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ES&lt;/code&gt;支持&lt;strong&gt;集群模式&lt;/strong&gt;，即一个分布式系统。其好处主要有以下2个:&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;可增大系统容量&lt;/strong&gt;。比如：内存、磁盘的增加使得&lt;code&gt;ES&lt;/code&gt;能够支持&lt;code&gt;PB&lt;/code&gt;级别的数据；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高了系统可用性&lt;/strong&gt;。即使一部分节点停止服务，集群依然可以正常对外服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ES&lt;/code&gt;集群由多个&lt;code&gt;ES实例&lt;/code&gt;构成。&lt;ul&gt;
&lt;li&gt;不同集群通过&lt;strong&gt;集群名字&lt;/strong&gt;来区分，通过配置文件&lt;code&gt;elasticsearch.yml&lt;/code&gt;中的&lt;code&gt;cluster.name&lt;/code&gt;可以修改，默认为&lt;code&gt;elasticsearch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;ES实例&lt;/code&gt;的本质，其实是一个&lt;code&gt;JVM进程&lt;/code&gt;，且有自己的名字，通过配置文件中的&lt;code&gt;node.name&lt;/code&gt;可以修改。
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【ElasticStack】ElasticSearch入门</title>
    <link href="http://chaooo.github.io/article/20191119.html"/>
    <id>http://chaooo.github.io/article/20191119.html</id>
    <published>2019-11-19T12:42:59.000Z</published>
    <updated>2020-02-14T11:19:30.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-ElasticStack特点"><a href="#1-1-ElasticStack特点" class="headerlink" title="1.1 ElasticStack特点"></a>1.1 ElasticStack特点</h4><ol><li>使用门槛低，开发周期短，上线快</li><li>性能好，查询快，实时展示结果</li><li>扩容方便，快速支撑增长迅猛的数据<a id="more"></a></li></ol><h4 id="1-2-ElasticStack各组件作用"><a href="#1-2-ElasticStack各组件作用" class="headerlink" title="1.2 ElasticStack各组件作用"></a>1.2 ElasticStack各组件作用</h4><ol><li><strong><code>Beats</code></strong>：数据采集</li><li><strong><code>LogStash</code></strong>: 数据处理</li><li><strong><code>ElasticSearch</code></strong>(核心引擎): 数据存储、查询和分析</li><li><strong><code>Kibana</code></strong>: 数据探索与可视化分析<!-- more --></li></ol><h4 id="1-3-ElasticStack使用场景"><a href="#1-3-ElasticStack使用场景" class="headerlink" title="1.3 ElasticStack使用场景"></a>1.3 ElasticStack使用场景</h4><ul><li>搜索引擎、日志分析、指标分析</li></ul><h4 id="1-4-ElasticStack安装启动"><a href="#1-4-ElasticStack安装启动" class="headerlink" title="1.4 ElasticStack安装启动"></a>1.4 ElasticStack安装启动</h4><ol><li><code>ElasticSearch</code>启动：解压到安装目录，启动<code>bin/elasticsearch</code>（默认端口:<code>http:\\localhost:9200</code>, 加参数<code>-d</code>后台启动）</li><li><code>ElasticSearch</code>集群：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch -d </span><br><span class="line">bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3 -d</span><br></pre></td></tr></table></figure><ol start="3"><li>Kibana启动：解压到安装目录，启动<code>bin/kibana</code>（默认端口:<code>http:\\localhost:5601</code>）</li></ol><h4 id="1-5-ElasticSearch常见术语"><a href="#1-5-ElasticSearch常见术语" class="headerlink" title="1.5 ElasticSearch常见术语"></a>1.5 ElasticSearch常见术语</h4><ol><li><code>Document</code>(文档)：用户存储在ES中的数据文档</li><li><code>Index</code>(索引)：由具有相同字段的文档列表组成</li><li><code>field</code>(字段)：包含具体数据</li><li><code>Node</code>(节点)：一个ES的实例，构成clister的单元</li><li><code>Cluster</code>(集群)：对外服务的一个/多个节点</li></ol><h4 id="1-6-Document介绍"><a href="#1-6-Document介绍" class="headerlink" title="1.6 Document介绍"></a>1.6 Document介绍</h4><ol><li>常用数据类型：字符串、数值型、布尔型、日期型、二进制、范围类型</li><li>每个文档都有一个唯一<code>ID</code>标识。（可以自行指定，也可由ES自动生成）</li><li>元数据，用于标注文档的相关信息：<ul><li><code>_index</code>：文档所在的索引名</li><li><code>_type</code>：文档所在的类型名(后续的版本中type这个概念将会被移除，也不允许一个索引中有多个类型)</li><li><code>_id</code>：文档唯一标识</li><li><code>_source</code>：文档的原始JSON数据，可从这获取每个字段的内容</li><li><code>_all</code>：整合所有字段内容到该字段。（默认禁用）</li><li><code>_version</code>：文档字段版本号，标识被操作了几次</li></ul></li><li><code>Index</code>介绍：<ul><li>索引中存储相同结构的文档，且每个index都有自己的Mapping定义，用于定义字段名和类型；</li><li>一个集群中可以有多个inex，类似于可以有多个table。</li></ul></li><li><code>RESTful API</code>两种交互方式：<ol><li>CURL命令行：curl -XPUT xxx</li><li>Kibana DevTools————PUT xxx{ }</li></ol></li><li><code>Index API</code>： 用户创建、删除、获取索引配置等。<ol><li>创建索引：<ul><li><code>PUT /test_index</code> #创建一个名为<code>test_index</code>的索引</li></ul></li><li>查看索引：<ul><li><code>GET _cat/indices</code> #查看所有的索引</li></ul></li><li>删除索引：<ul><li><code>DELETE /test_index</code> #删除名为<code>test_index</code>的索引</li></ul></li></ol></li></ol><h4 id="1-7-CRUD操作（交互基于Kibana-DevTools）"><a href="#1-7-CRUD操作（交互基于Kibana-DevTools）" class="headerlink" title="1.7 CRUD操作（交互基于Kibana DevTools）"></a>1.7 CRUD操作（交互基于Kibana DevTools）</h4><ol><li>创建文档</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建ID为1的Document</span></span><br><span class="line">PUT /test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"username"</span>:<span class="string">"alfred"</span>,</span><br><span class="line"> <span class="string">"age"</span>:<span class="string">"24"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 不指定ID创建Document(ID会自动生成)</span></span><br><span class="line">POST /test_index/doc</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"username"</span>:<span class="string">"buzhiding"</span>,</span><br><span class="line"> <span class="string">"age"</span>:<span class="string">"1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>查询文档：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看名为test_index的索引中id为1的文档</span></span><br><span class="line">GET /test_index/doc/1</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 查询所有文档：</span></span><br><span class="line"><span class="comment"># 查询名为test_index的索引中所有文档,用到endpoint：_search，默认返回符合的前10条</span></span><br><span class="line"><span class="comment"># term和match的区别：term完全匹配，不进行分词器分析；match模糊匹配，进行分词器分析，包含即返回</span></span><br><span class="line">GET /test_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"term"</span>:&#123;</span><br><span class="line">   <span class="string">"_id"</span>:<span class="string">"1"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>批量操作文档：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量创建文档，用到endpoint：_bulk</span></span><br><span class="line"><span class="comment"># index和create的区别，如果文档存在时，使用create会报错，而index会覆盖</span></span><br><span class="line">POST _bulk</span><br><span class="line">&#123;<span class="string">"index"</span>:&#123;<span class="string">"_index"</span>:<span class="string">"test_index"</span>,<span class="string">"_type"</span>:<span class="string">"doc"</span>,<span class="string">"_id"</span>:<span class="string">"3"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"username"</span>:<span class="string">"alfred"</span>,<span class="string">"age"</span>:<span class="string">"20"</span>&#125;</span><br><span class="line">&#123;<span class="string">"delete"</span>:&#123;<span class="string">"_index"</span>:<span class="string">"test_index"</span>,<span class="string">"_type"</span>:<span class="string">"doc"</span>,<span class="string">"_id"</span>:<span class="string">"1"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"update"</span>:&#123;<span class="string">"_id"</span>:<span class="string">"2"</span>,<span class="string">"_index"</span>:<span class="string">"test_index"</span>,<span class="string">"_type"</span>:<span class="string">"doc"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">"doc"</span>:&#123;<span class="string">"age"</span>:<span class="string">"30"</span>&#125;&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 批量查询文档，使用endpoint:_mget</span></span><br><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"doc"</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">"_index"</span>:<span class="string">"test_index"</span>,</span><br><span class="line">   <span class="string">"_type"</span>:<span class="string">"doc"</span>,</span><br><span class="line">   <span class="string">"_id"</span>:<span class="string">"1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">"_index"</span>:<span class="string">"test_index"</span>,</span><br><span class="line">   <span class="string">"_type"</span>:<span class="string">"doc"</span>,</span><br><span class="line">   <span class="string">"_id"</span>:<span class="string">"2"</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>删除文档：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据搜索内容删除文档,使用endpoint:_delete_by_query</span></span><br><span class="line">POST /test_index/doc/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:<span class="string">"buzhiding"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 删除整个test_index的索引中的文档,依然使用endpoint:_delete_by_query</span></span><br><span class="line">POST /test_index/doc/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match_all"</span>:&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ElasticSearch倒排索引与分词"><a href="#2-ElasticSearch倒排索引与分词" class="headerlink" title="2. ElasticSearch倒排索引与分词"></a>2. ElasticSearch倒排索引与分词</h3><h4 id="2-1-倒排索引"><a href="#2-1-倒排索引" class="headerlink" title="2.1 倒排索引"></a>2.1 倒排索引</h4><ol><li>正排索引和倒排索引<ul><li>正排索引：文档ID —&gt; 文档内容</li><li>倒排索引：单词—&gt; 文档ID列表</li></ul></li><li>倒排索引组成：（单词词典，倒排列表）<ol><li>单词词典（<code>Term Dictionary</code>）<ul><li>记录所有文档的单词，记录了单词到倒排列表的关联信息，一般使用<code>B+Tree</code>实现。</li></ul></li><li>倒排列表（<code>Posting List</code>）<ul><li>记录单词对应的文档集合，由倒排索引项<code>Posting List</code>组成。</li><li>倒排索引项：<ol><li>文档<code>ID</code>：用于获取原始信息。</li><li>词频<code>TF</code>：记录该单词在该文档中的出现次数，用于计算相关性得分。</li><li>位置<code>Position</code>：记录单词在文档中的分词位置(多个)，用于词语搜索。</li><li>偏移<code>Offset</code>：记录单词在文档的开始和结束位置，用于高亮显示。</li></ol></li></ul></li></ol></li></ol><h4 id="2-2-分词Analysis"><a href="#2-2-分词Analysis" class="headerlink" title="2.2 分词Analysis"></a>2.2 分词Analysis</h4><p>分词：将文本转换成一系列单词<code>Term/Token</code>的过程，也可称作文本分析，ES中叫作：Analysis。</p><ul><li>一些概念：<ol><li><code>Token</code>(词元)：全文搜索引擎会用某种算法对要建索引的文档进行分析， 从文档中提取出若干Token(词元)。</li><li><code>Tokenizer</code>(分词器)：这些算法叫做Tokenizer(分词器)</li><li><code>Token Filter</code>(词元处理器)：这些Token会被进一步处理， 比如转成小写等， 这些处理算法被称为TokenFilter(词元处理器)</li><li><code>Term</code>(词)：被处理后的结果被称为Term(词)</li><li><code>Character Filter</code>(字符过滤器)：文本被Tokenizer处理前可能要做一些预处理， 比如去掉里面的HTML标记， 这些处理的算法被称为Character Filter(字符过滤器)</li><li><code>Analyzer</code>(分析器)：这整个的分析算法被称为Analyzer(分析器)，由Tokenizer(分词器)和Filter(过滤器)组成</li></ol></li><li>ES有很多<strong>内置<code>Analyzer</code></strong>,比如：<ol><li><code>standard</code>：按单词边界划分、支持多语言、小写处理、移除大部分标点符号，支持停用词</li><li><code>whitespace</code>：空格为分隔符</li><li><code>simple</code>：按非字母划分、小写处理</li><li><code>stop</code>：类似简单分词器，同时支持移除停用词(the、an、的、这等)</li><li><code>keyword</code>：不分词</li><li><code>pattern</code>：通过正则表达式自定义分隔符，默认\w+，即：非字词的符号作为分隔符</li></ol></li><li>第三方analyzer插件：常用的<strong>中文分词器</strong>有：<ol><li>IK：实现中英文分词，支持多模式，可自定义词库，支持热更新分词词典。</li><li>jieba。python中流行，支持繁体分词、并行分词，可自定义词典、词性标记等。</li></ol></li><li>ES提供了一个测试分词的API接口，使用<code>endpoint：_analyze</code>，不指定分词时，会使用默认的<code>standard</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定分词器进行分词测试</span></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"analyzer"</span>:<span class="string">"standard"</span>,</span><br><span class="line"> <span class="string">"text"</span>:<span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 直接指定索引中字段：使用username字段的分词方式对text进行分词。</span></span><br><span class="line">POST test_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"field"</span>:<span class="string">"username"</span>,</span><br><span class="line"> <span class="string">"text"</span>:<span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 自定义分词器，自定义Tokenizer、filter、等进行分词：</span></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"tokenizer"</span>:<span class="string">"standard"</span>,</span><br><span class="line"> <span class="string">"filter"</span>:[<span class="string">"lowercase"</span>],</span><br><span class="line"> <span class="string">"text"</span>:<span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ElasticSearch的Mapping"><a href="#3-ElasticSearch的Mapping" class="headerlink" title="3. ElasticSearch的Mapping"></a>3. ElasticSearch的Mapping</h3><h4 id="3-1-Mapping简介"><a href="#3-1-Mapping简介" class="headerlink" title="3.1 Mapping简介"></a>3.1 Mapping简介</h4><p>Mapping：类似于数据库中的表结构</p><ol><li>主要作用如下：<ol><li>定义<code>Index</code>下的<code>Field Name</code>；</li><li>定义<code>Field</code>的类型，如：数值型、字符串型、布尔型等；</li><li>定义倒排索引的相关配置，如：是否有索引，记录position等。</li></ol></li><li>获取一个<code>mapping</code>，使用<code>endpoint：_mapping</code>，例如：<ul><li><code>GET /test_index/_mapping</code></li></ul></li></ol><h4 id="3-2-自定义Mapping"><a href="#3-2-自定义Mapping" class="headerlink" title="3.2 自定义Mapping"></a>3.2 自定义Mapping</h4><ol><li>使用<code>mappings</code>进行自定义<code>mapping</code>。</li><li><code>Mapping</code>中的字段类型一旦设定之后，<strong>禁止直接修改</strong>。<ul><li>因为<code>Luence</code>事先的倒排索引生成后不能修改。</li><li>如果一定要改，可以重新建立新的索引，然后对应修改<code>mapping</code>，之后将之前的数据进行<code>reindex</code>操作，导入新的文档。</li></ul></li><li>自定义<code>mapping</code>时允许新增字段。通过<code>dynamic</code>参数进行控制字段的新增，<code>dynamic</code>有三种配置：<ul><li><code>true</code>：默认配置，允许自动新增字段；</li><li><code>false</code>：不允许自动新增字段，文档可以正常写入，但不能进行查询等操作；</li><li><code>strict</code>：严格模式。文档不能写入，写入会报错。</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为my_index的索引，并自定义mapping</span></span><br><span class="line"><span class="comment"># 使用dynamic参数控制字段的新增</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;        <span class="comment"># 关键字</span></span><br><span class="line">  <span class="string">"doc"</span>:&#123;            <span class="comment"># 类型名</span></span><br><span class="line">   <span class="string">"dynamic"</span>:<span class="literal">false</span>,  <span class="comment"># 设置为false，索引不允许新增字段</span></span><br><span class="line">   <span class="string">"properties"</span>:&#123;    <span class="comment"># 字段名称及类型定义</span></span><br><span class="line">    <span class="string">"title"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"text"</span>   <span class="comment"># 字段类型</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"name"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"keyword"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"age"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"integer"</span></span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-copy-to的使用"><a href="#3-3-copy-to的使用" class="headerlink" title="3.3 copy_to的使用"></a>3.3 copy_to的使用</h4><p>将该字段的值复制到目标字段，类似于6.0版本之前的<code>_all</code>的作用。且不会出现在<code>_source</code>，一般只用来进行搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy_to的使用</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"properties"</span>:&#123;</span><br><span class="line">    <span class="string">"first_name"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="string">"copy_to"</span>:<span class="string">"full_name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"last_name"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="string">"copy_to"</span>:<span class="string">"full_name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"full_name"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"text"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 向索引写入数据</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"first_name"</span>:<span class="string">"John"</span>,</span><br><span class="line"> <span class="string">"last_name"</span>:<span class="string">"Smith"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查询索引my_index中full_name同时包含John 和 Smith的数据</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"full_name"</span>:&#123;</span><br><span class="line">    <span class="string">"query"</span>:<span class="string">"John Smith"</span>,</span><br><span class="line">    <span class="string">"operator"</span>:<span class="string">"and"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-index参数的使用"><a href="#3-4-index参数的使用" class="headerlink" title="3.4 index参数的使用"></a>3.4 index参数的使用</h4><p>控制当前字段是否为索引，默认<code>true</code>，当设置为<code>false</code>的时候，不进行记录，此时该字段不能被搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index参数的使用</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"properties"</span>:&#123;</span><br><span class="line">    <span class="string">"cookie"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="string">"index"</span>:<span class="literal">false</span>    <span class="comment"># 设置为false，该字段不能被搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在进行数据写入和查询，不能进行该字段搜索。一般用来进行不想被查询的私密信息设置，如身份证号，电话号码等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向使用了index参数的字段写入信息</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"cookie"</span>:<span class="string">"name=alfred"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-index-options参数的使用："><a href="#3-5-index-options参数的使用：" class="headerlink" title="3.5 index_options参数的使用："></a>3.5 index_options参数的使用：</h4><p>控制倒排索引记录的内容，有如下四种配置：</p><ol><li><code>docs</code>：只记录文档ID</li><li><code>freqs</code>：记录文档ID和词频TF</li><li><code>positions</code>：记录文档ID、词频TF和分词位置</li><li><code>offsets</code>：记录文档ID、词频TF、分词位置和偏移<blockquote><p>其中：text类型默认的配置是positions，其他的比如integer等类型默认为docs，目的是为了节省空间。</p></blockquote></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index_options参数的使用</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"properties"</span>:&#123;</span><br><span class="line">    <span class="string">"cookie"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="string">"index_options"</span>:<span class="string">"offsets"</span>  <span class="comment"># 记录文档ID、词频TF、分词位置和偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-null-value参数的使用："><a href="#3-6-null-value参数的使用：" class="headerlink" title="3.6 null_value参数的使用："></a>3.6 null_value参数的使用：</h4><p>当字段遇到空值<code>null</code>时的处理策略。默认为<code>null</code>，即跳过。此时ES会忽略该值，可通过修改进行默认值的修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用null_value修改ES遇到null值时的默认返回值</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"properties"</span>:&#123;</span><br><span class="line">    <span class="string">"cookie"</span>:&#123;</span><br><span class="line">     <span class="string">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">     <span class="string">"null_value"</span>:<span class="string">"NULL"</span>    <span class="comment"># 当遇到空值null的时候，返回一个字符串形式的NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-Field字段的数据类型："><a href="#3-7-Field字段的数据类型：" class="headerlink" title="3.7 Field字段的数据类型："></a>3.7 Field字段的数据类型：</h4><ol><li>核心数据类型<ol><li>字符串型：<code>text</code>(分词)，<code>keyword</code>(不分词)</li><li>数值型：<code>long,integer,short,byte,double,float,half_float,scaled_float</code></li><li>日期类型：<code>date</code></li><li>布尔类型：<code>boolean</code></li><li>二进制类型：binary</li><li>范围类型：<code>integer_range,float_range,long_range,double_range,date_range</code></li></ol></li><li>复杂数据类型<ol><li>数组类型：<code>array</code></li><li>对象类型：<code>object</code></li><li>嵌套类型：<code>nested object</code></li></ol></li><li>地理位置数据类型<ol><li>点：<code>geo-point</code></li><li>形状：<code>geo-shape</code></li></ol></li><li>专用类型<ol><li>记录ip地址：<code>ip</code></li><li>实现自动补全：<code>completion</code></li><li>记录分词数：<code>token_count</code></li><li>记录字符串hash值：<code>murmur3</code></li><li><code>perclator</code></li><li><code>join</code></li></ol></li><li>多字段特性：<ul><li>ES允许对同一个字段采用不同的配置，如：分词。举例：对一个人名实现拼音搜索，只需要在人名字段中新增一个子字段pinyin即可。</li></ul></li></ol><h4 id="3-8-ES的自动类型识别："><a href="#3-8-ES的自动类型识别：" class="headerlink" title="3.8 ES的自动类型识别："></a>3.8 ES的自动类型识别：</h4><ol><li>Dynamic Mapping：<ul><li>ES可以自动识别文档字段类型，从而降低用户使用成本。</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES的自动类型识别</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"username"</span>:<span class="string">"alfred"</span>,    <span class="comment"># username字段自动识别为text类型</span></span><br><span class="line"> <span class="string">"age"</span>:20                <span class="comment"># age字段自动识别为long类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>ES依靠JSON文档的字段类型实现自动识别字段类型：</li></ol><table><thead><tr><th>JSON类型</th><th>ElasticSearch类型</th></tr></thead><tbody><tr><td>null</td><td>忽略</td></tr><tr><td>boolean</td><td>boolean</td></tr><tr><td>浮点类型</td><td>float</td></tr><tr><td>整数类型</td><td>long</td></tr><tr><td>object</td><td>object</td></tr><tr><td>array</td><td>由第一个非null的值的类型决定</td></tr><tr><td>String</td><td>匹配为日期，则为date类型(默认开启)<br>匹配为数字，则为long类型/float类型(默认关闭)<br>都未匹配，则设为text类型，并附带keyword子字段</td></tr></tbody></table><ol start="3"><li>验证ES的字段类型自动识别：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证ES的字段类型自动识别</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"username"</span>:<span class="string">"alfred"</span>,    <span class="comment"># 字符串类型text</span></span><br><span class="line"> <span class="string">"age"</span>:20,               <span class="comment"># 整数long</span></span><br><span class="line"> <span class="string">"bitrh"</span>:<span class="string">"1998-10-10"</span>,   <span class="comment"># 默认识别日期date</span></span><br><span class="line"> <span class="string">"married"</span>:<span class="literal">false</span>,        <span class="comment"># 布尔类型boolean</span></span><br><span class="line"> <span class="string">"year"</span>:<span class="string">"18"</span>             <span class="comment"># 默认不识别数字text</span></span><br><span class="line"> <span class="string">"tags"</span>:[<span class="string">"boy"</span>,<span class="string">"fashion"</span>],<span class="comment"># 数组中第一个不为null的元素为字符串类型，所以为text</span></span><br><span class="line"> <span class="string">"money"</span>:100.1           <span class="comment"># 浮点类型float</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#  再对my_index进行mapping查询，就会获得每个字段的类型：</span></span><br></pre></td></tr></table></figure><h4 id="3-9-ES中日期类型和数字的自动识别："><a href="#3-9-ES中日期类型和数字的自动识别：" class="headerlink" title="3.9 ES中日期类型和数字的自动识别："></a>3.9 ES中日期类型和数字的自动识别：</h4><p>ES中可自行配置日期的格式，默认：[“<code>strict_date_optional_time</code>“,”<code>yyyy/MM/dd HH:mm:ss Z</code>|| <code>yyyy/MM/dd z</code>“]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用dynamic_date_formats自定义日期格式</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"dynamic_date_formats"</span>:[<span class="string">"MM/dd/yyyy"</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 写入符合自定义格式的日期数据，可识别为date类型</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"create_time"</span>:<span class="string">"01/01/2019"</span>    <span class="comment"># create_time字段识别为date类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#  2. 使用date_detection可以关闭自动识别日期格式：</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"date_detection"</span>:<span class="literal">false</span> </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"create_time"</span>:<span class="string">"01/01/2019"</span>    <span class="comment"># create_time字段是text类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># ES中可配置数字是否识别，默认关闭：</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"numeric_detection"</span>:<span class="literal">true</span>    <span class="comment"># 开启数字自动识别</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 写入数字数据，ES可以自动识别其类型</span></span><br><span class="line">PUT mu_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"year"</span>:<span class="string">"18"</span>,    <span class="comment"># year字段自动识别为long类型</span></span><br><span class="line"> <span class="string">"money"</span>:<span class="string">"100.1"</span>    <span class="comment"># money字段自动识别为float类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-ES中根据自动识别的数据类型，动态生成字符类型"><a href="#3-10-ES中根据自动识别的数据类型，动态生成字符类型" class="headerlink" title="3.10 ES中根据自动识别的数据类型，动态生成字符类型"></a>3.10 ES中根据自动识别的数据类型，动态生成字符类型</h4><p>例: </p><ol><li>字符串类型都设为keyword类型（不分词）</li><li>以message开头的字段都设为text类型（分词）</li><li>以long_开头的字段都设为long类型</li><li>自动匹配为double的类型都设为float类型。（为了节省空间）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES根据自动识别的数据类型、字段名等动态设定字符类型</span></span><br><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>:&#123;</span><br><span class="line">  <span class="string">"doc"</span>:&#123;</span><br><span class="line">   <span class="string">"dynamic_template"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"strings"</span>:&#123;</span><br><span class="line">      <span class="comment"># 匹配到所有的字符串类型，全部设为keyword类型</span></span><br><span class="line">      <span class="string">"match_mapping_type"</span>:<span class="string">"string"</span>,</span><br><span class="line">      <span class="string">"mapping"</span>:&#123;</span><br><span class="line">       <span class="string">"type"</span>:<span class="string">"keyword"</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配规则</strong>的参数：</p><ol><li><code>match_mapping_type</code>：匹配ES自动识别的字段类型，如boolean、long、string等</li><li><code>match</code>、<code>unmatch</code>：匹配字段名，比如”match”:”message*” ===&gt;以message开头的数据</li><li><code>path_match</code>、<code>path_unmatch</code>：匹配路径</li></ol><h4 id="3-11-自定义mapping的操作步骤"><a href="#3-11-自定义mapping的操作步骤" class="headerlink" title="3.11 自定义mapping的操作步骤"></a>3.11 自定义mapping的操作步骤</h4><ol><li>写入一条文档到ES的临时索引中，获取(复制)ES自动生成的mapping</li><li>修改获得的mapping，并在其中自定义相关配置</li><li>使用修改后的mapping创建实际所需索引。</li></ol><h3 id="4-ElasticSearch的Search-API"><a href="#4-ElasticSearch的Search-API" class="headerlink" title="4. ElasticSearch的Search API"></a>4. ElasticSearch的Search API</h3><p>在ES中，为了实现对存储的数据进行查询分析，使用<code>endpoint</code>：<strong><code>_search</code></strong>。</p><ol><li>实现对所有索引的泛查询：<code>GET /_search</code></li><li>实现对一个索引的单独查询：<code>GET /my_index/_search</code></li><li>实现对多个索引的指定查询：<code>GET /my_index1,my_index2/_search</code></li><li>实现对符合指定要求的索引进行查询：<code>GET /my_*/_search</code></li></ol><p>在进行查询的时候，主要有两种方式：(<code>URI Search</code>，<code>Request Body Search</code>)</p><ol><li><strong><code>URI Search</code></strong>：操作简单，直接通过命令行方便测试，但仅包含部分查询语法；<ul><li>如：<code>GET /my_index/_search?q=username:alfred</code></li></ul></li><li><strong><code>Request Body Search</code></strong>：ES提供的完备查询语法，使用<code>Query DSL(Domain Specific Language)</code>进行查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如：Request Body Search方式进行查询</span></span><br><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-URI-Search"><a href="#4-1-URI-Search" class="headerlink" title="4.1 URI Search"></a>4.1 URI Search</h4><ol><li>通过<code>url query</code>参数实现搜索，常用参数有：<ol><li><strong><code>q</code></strong>：指定查询的语句，使用query string syntax语法</li><li><strong><code>df</code></strong>：q中不指定字段时默认查询的字段（在不指定的时候默认查询所有字段）</li><li><strong><code>sort</code></strong>：排序</li><li><strong><code>timeout</code></strong>：指定超时时间，默认不超时 </li><li><strong><code>from,size</code></strong>：用于分页</li></ol><ul><li>举例：<ul><li><code>GET my_index/_search?q=alfred&amp;df=username&amp;sort=age:asc&amp;from=4&amp;size=10&amp;timeout=1s</code></li><li>解释：查询索引<code>my_index</code>中<code>username</code>字段中包含<code>alfred</code>的文档，结果按<code>age</code>字段<code>升序排列</code>，返回第<code>5-14</code>个文档，若超过<code>1s</code>未结束，则以超时结束。</li></ul></li></ul></li><li><code>query string syntax</code>语法<ul><li>前置内容：<code>term:单词</code>，<code>phrase:词语</code>。</li><li>单词与词语语法：<ul><li>单词：<code>alfred way</code>等价于<code>alfred</code> OR <code>way</code></li><li>词语：<code>&quot;alfred way&quot;</code>语句查询，要求先后顺序</li><li>泛查询：不指定字段，会在所有字段中去匹配其单词</li><li>指定字段查询：指定字段，在指定字段中匹配单词</li></ul></li><li>Group分组设定，使用括号指定匹配的规则<ul><li>举例：<code>GET my_index/_search?q=username:(alfred OR way)AND lee</code></li></ul></li></ul></li></ol><h5 id="4-1-1-URI-Search-API"><a href="#4-1-1-URI-Search-API" class="headerlink" title="4.1.1 URI Search API"></a>4.1.1 URI Search API</h5><ol><li>泛查询：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search?q=alfred</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"profile"</span>:<span class="literal">true</span> <span class="comment">#使用profile参数，可以明确地看到ES如何执行的查询条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>指定字段查询：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.查询字段username中包含alfred的文档</span></span><br><span class="line">GET my_index/_search?q=username:alfred</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># b.查询字段username中包含alfred或way的文档</span></span><br><span class="line">GET my_index/_search?q=username:alfred way</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># c.查询字段username为"alfred way"的文档</span></span><br><span class="line">GET my_index/_search?q=username:<span class="string">"alfred way"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># d.分组后，查询字段username中包含alfred，包含way的文档</span></span><br><span class="line">GET my_index/_search?q=username:(alfred way)</span><br><span class="line"><span class="comment"># 这个和b的结果一样，但是区别在于使用分组之后，不进行泛查询。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>布尔操作符AND(&amp;&amp;)、OR(||)、NOT(!)、+(must)、-(must_not)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询索引my_index中username包含alfred但是不包含way的文档</span></span><br><span class="line">GET my_index/_search?q=username:(alfred NOT way)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 查询索引my_index中一定包含lee，一定不含alfred，可能有way的文档</span></span><br><span class="line">GET my_index/_search?q=username:(way +lee -alfred)</span><br><span class="line"><span class="comment"># 或写成</span></span><br><span class="line">GET my_index/_search?q=username:((lee &amp;&amp; !alfred) || (way &amp;&amp; lee &amp;&amp; !alfred))</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 注意：url中，+(加号)会被解析成空格，所以要用 %2B ：</span></span><br><span class="line"><span class="comment"># 查询索引my_index中一定包含lee，一定不包含alfred，可能包含way的文档</span></span><br><span class="line">GET my_index/_search?q=username:(way %2Blee -alfred)</span><br></pre></td></tr></table></figure><ol start="4"><li>范围查询（支持数值和日期）<ul><li>区间写法：闭区间使用<code>[]</code>，开区间使用<code>{}</code><ol><li><code>age:[1 TO 10]</code>  # 1&lt;= age &lt;=10</li><li><code>age:[1 TO 10}</code>  # 1&lt;= age &lt;10</li><li><code>age:[1 TO ]</code>    # age &gt;=1</li><li><code>age:[* TO 10]</code>  # age &lt;=10</li></ol></li><li>算数符号写法：<ol><li><code>age:&gt;=1</code></li><li><code>age:(&gt;=1 &amp;&amp; &lt;= 10) / age:(+ &gt;= 1 + &lt;= 10)</code></li></ol></li><li>还可以对日期进行范围查询，注意：年/月是从1月1号/1号开始算的：</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.查询索引my_index中username字段包含alfred_或_年龄大于20的文档</span></span><br><span class="line">GET my_index/_search?q=username:alfred age&gt;20</span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># b.查询索引my_index中username字段包含alfred_且_年龄大于20的文档</span></span><br><span class="line">GET my_index/_search?q=username:alfred AND age&gt;20</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查询索引my_index中birth字段在1985和1990之间的文档</span></span><br><span class="line">GET my_index/_search?q=birth:(&gt;1985 AND &lt; 1990)</span><br></pre></td></tr></table></figure><ol start="5"><li><p>通配符查询</p><ul><li><code>?</code>代表一个字符，<code>*</code>代表0个或多个字符，如：<code>name:a?lfred</code>或<code>name:a*d</code>或<code>name:alfred*</code></li><li>注意：通配符匹配的执行效率较低，且占用内存较多，不建议使用，如果没有特殊要求，也不要将?或者*放在最前面，因为意味着要匹配所有文档，可能会造成OOM。</li></ul></li><li><p>正则表达式/模糊匹配/近似度查询</p><ul><li>正则表达式：举例：<code>/[a]?l.*/</code></li><li>模糊匹配：<code>fuzzy query</code></li><li>近似度查询：<code>proximity search</code></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模糊匹配。匹配与alfred差一个字符的词，比如：alfreds、alfret等</span></span><br><span class="line">GET my_index/_search?q=username:alfred~1</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 近似度查询，查询字段username和"alfred way"差n个单词的文档</span></span><br><span class="line">GET my_index/_search?q=username:<span class="string">"alfred way"</span> ~5</span><br></pre></td></tr></table></figure><blockquote><p>使用场景常见于用户输入词的纠错中。</p></blockquote><h4 id="4-2-Request-Body-Search"><a href="#4-2-Request-Body-Search" class="headerlink" title="4.2 Request Body Search"></a>4.2 Request Body Search</h4><p>ES自带的完备查询语句，将查询语句通过<code>http request body</code>发送到ES，主要参数有：</p><ol><li><code>query</code>：符合<code>Query DSL</code>语法的查询条件</li><li><code>from，size</code></li><li><code>timeout</code></li><li><code>sort</code></li></ol><ul><li><code>Query DSL</code>语法：<ul><li>基于<code>JSON</code>定义的查询语言，主要包含两个类型：<ol><li>字段类查询————如：<code>term</code>，<code>match</code>，<code>range</code>等。只针对一个字段进行查询</li><li>复合查询————如：<code>bool</code>查询等。包含一个/多个字段类查询/符合查询语句</li></ol></li></ul></li></ul><h5 id="4-2-1-字段类查询-全文匹配"><a href="#4-2-1-字段类查询-全文匹配" class="headerlink" title="4.2.1 字段类查询-全文匹配"></a>4.2.1 字段类查询-全文匹配</h5><p>针对<code>text</code>类型的字段进行全文检索，会对查询语句进行“先分词再查询”处理，如：<code>match</code>、<code>match_phrase</code>等</p><h6 id="4-2-1-1-match-query"><a href="#4-2-1-1-match-query" class="headerlink" title="4.2.1.1 match query"></a>4.2.1.1 match query</h6><ol><li>对字段进行全文检索(最基本和最常用的查询类型)，举例：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>:&#123;  </span><br><span class="line">   <span class="string">"match"</span>:&#123;                 <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">"username"</span>:<span class="string">"alfred way"</span>  <span class="comment"># 字段名和查询语句</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从结果，可以返回匹配文件总数，返回文档列表，_score相关性得分等。<br>一般的执行流程为： 1.对查询语句分词==&gt;2.根据字段的倒排索引列表，进行匹配算分==&gt;3.汇总得分==&gt;4.根据得分排序，返回匹配文档</p></blockquote><ol start="2"><li>使用<code>operator</code>参数，可以控制单词间关系，有<code>and/or</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用operator参数控制单词间关系</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:<span class="string">"alfred way"</span>,</span><br><span class="line">   <span class="string">"operator"</span>:<span class="string">"and"</span>    <span class="comment"># and，同时包含alfred和way</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<code>minimum_should_match</code>参数控制需匹配的单词数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用minimum_should_match参数控制需匹配的单词数</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:<span class="string">"alfred way"</span>,</span><br><span class="line">   <span class="string">"minimum_should_match"</span>:<span class="string">"2"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-1-2-相关性算分，其本质就是一个排序问题"><a href="#4-2-1-2-相关性算分，其本质就是一个排序问题" class="headerlink" title="4.2.1.2 相关性算分，其本质就是一个排序问题"></a>4.2.1.2 相关性算分，其本质就是一个排序问题</h6><ul><li>计算文档与待查询语句之间的相关度，一般有四个重要概念：<ol><li><code>Term Frequency</code> 词频(正相关)</li><li><code>Document Frequency</code> 文档频率(负相关)</li><li><code>Inverse Term Frequency</code> 逆文本频率(正相关)</li><li><code>Field-length Norm</code> 文档长度(负相关)</li></ol></li><li>目前ES有两个相关性算分的模型：<ol><li><code>TF/IDF</code>模型：经典模型。</li><li><code>BM25</code>模型：5.x版本后的默认模型，是对TF/IDF的优化模型。</li></ol></li></ul><ol><li><code>TF/IDF</code>模型：在使用kibana进行查询时，使用explain参数，可以查看具体的计算方法。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用explain参数，可以查看具体的相关性的得分是如何计算的</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"explain"</span>:<span class="literal">true</span>,    <span class="comment"># 设置为true</span></span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：ES计算相关性得分是根据<code>shard</code>进行的，即分片的分数计算相互独立，所以在使用的时候要注意分片数，可以通过设定分片数为1来避免这个问题，主要是为了观察，不代表之后所有的分片全都设为1。一般放在创建索引后，未加数据之前。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定shards数量为1</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"settings"</span>:&#123;</span><br><span class="line">  <span class="string">"number_of_shards"</span>:<span class="string">"1"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>BM25模型。5.x版本后的默认模型，是对TF/IDF的优化模型。<ul><li><code>best match，25</code>指：迭代了25次才计算。BM25的使用，降低了TF/IDF中因为TF过大导致的负面影响，在BM25中，一个单词的TF一直增长，到一定程度就趋于0变化。</li></ul></li></ol><h6 id="4-2-1-3-match-phrase-query"><a href="#4-2-1-3-match-phrase-query" class="headerlink" title="4.2.1.3 match phrase query"></a>4.2.1.3 match phrase query</h6><p>对字段做全文检索，有顺序要求。</p><ol><li>使用<code>match——phrase</code>查询词语</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match_phrase"</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">   <span class="string">"job"</span>:<span class="string">"java engineer"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过使用<code>slop</code>参数，可以控制单词间间隔：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match_phrase"</span>:&#123;</span><br><span class="line">   <span class="string">"job"</span>:&#123;</span><br><span class="line">    <span class="string">"query"</span>:<span class="string">"java engineer"</span>,</span><br><span class="line">    <span class="string">"slop"</span>:<span class="string">"1"</span>    <span class="comment"># 关键词，设定单词间隔</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-1-4-query-string-query"><a href="#4-2-1-4-query-string-query" class="headerlink" title="4.2.1.4 query string query"></a>4.2.1.4 query string query</h6><p>类似于<code>URI Search</code>中的q参数查询，举例：</p><ol><li>使用<code>query_string</code>查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"query_string"</span>:&#123;</span><br><span class="line">   <span class="string">"default_field"</span>:<span class="string">"username"</span>,</span><br><span class="line">   <span class="string">"query"</span>:&#123;alfred AND way<span class="string">"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#* 或 */</span></span><br><span class="line"><span class="string">GET my_index/_search</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> "</span>query<span class="string">":&#123;</span></span><br><span class="line"><span class="string">  "</span>query_string<span class="string">":&#123;</span></span><br><span class="line"><span class="string">   "</span>fileds<span class="string">":["</span>username<span class="string">","</span>job<span class="string">"],</span></span><br><span class="line"><span class="string">   "</span>query<span class="string">":"</span>alfred OR (java AND ruby)<span class="string">"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h6 id="4-2-1-5-simple-query-string-query"><a href="#4-2-1-5-simple-query-string-query" class="headerlink" title="4.2.1.5 simple query string query"></a>4.2.1.5 simple query string query</h6><p>类似于<code>query string</code>，但会忽略错误的查询语法，且仅支持部分查询语句。使用<code>+，|，-</code>分别代替<code>AND，OR，NOT</code>。</p><ol><li>使用simple query string query<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"simple_query_string"</span>:&#123;</span><br><span class="line">   <span class="string">"fields"</span>:[username],</span><br><span class="line">   <span class="string">"query"</span>:<span class="string">"alfred +way"</span>    <span class="comment">#等价于 "query":"alfred AND way"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="4-2-2-字段类查询-单词匹配"><a href="#4-2-2-字段类查询-单词匹配" class="headerlink" title="4.2.2 字段类查询-单词匹配"></a>4.2.2 字段类查询-单词匹配</h5><h6 id="4-2-2-1-term-terms-query"><a href="#4-2-2-1-term-terms-query" class="headerlink" title="4.2.2.1 term/terms query"></a>4.2.2.1 term/terms query</h6><p>将待查询语句作为整个单词进行查询，不做分词处理，举例：</p><ol><li>使用term进行单查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"term"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用terms进行多查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"terms"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:[<span class="string">"alfred"</span>,<span class="string">"way"</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此时如果直接使用<code>alfred way</code>作为<code>username</code>查询条件，是不会返回任何文档的。因为在<code>username</code>的倒排索引列表中，存在<code>&quot;alfred&quot;</code>和<code>&quot;way&quot;</code>的索引，但是不存在<code>&quot;alfred way&quot;</code>的索引。</p></blockquote><h6 id="4-2-2-2-range-query"><a href="#4-2-2-2-range-query" class="headerlink" title="4.2.2.2 range query"></a>4.2.2.2 range query</h6><ul><li>范围查询，主要针对数值类型和日期类型。<ul><li><strong><code>gt</code></strong>: greater than 大于</li><li><strong><code>gte</code></strong>: greate than or equal to 大于等于</li><li><strong><code>lt</code></strong>: less than 小于</li><li><strong><code>lte</code></strong>: less than or equal to 小于等于</li></ul></li></ul><ol><li>对数值的查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range query对数值的查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"range"</span>:&#123;</span><br><span class="line">   <span class="string">"age"</span>:&#123;</span><br><span class="line">    <span class="string">"gte"</span>:10,</span><br><span class="line">    <span class="string">"lte"</span>:20</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对日期的查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range query对日期的查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"range"</span>:&#123;</span><br><span class="line">   <span class="string">"birth"</span>:&#123;</span><br><span class="line">    <span class="string">"lte"</span>:<span class="string">"1988-01-01"</span> </span><br><span class="line">    <span class="comment"># 或者使用"lte":"now-30y",这种Date Math类型</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>Date Math</code>类型</strong>：针对日期提供的一种更友好的计算方式。<br>当前时间用<code>now</code>代替，具体时间的引用，需要使用<code>||</code>间隔。年、月、日、时、分、秒跟<code>date</code>一致：<code>y、M、w、d、h、m、s</code>。<br>举例：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设当前时间为2019-01-02 12:00:00</span></span><br><span class="line">now+1h   =&gt;   2019-01-02 13:00:00</span><br><span class="line">now-1h   =&gt;   2019-01-02 11:00:00</span><br><span class="line">now-1h/d =&gt;   2019-01-02 00:00:00</span><br><span class="line">2019-01-01||+1M/d  =&gt; 2019-02-01 00:00:00</span><br></pre></td></tr></table></figure><h5 id="4-2-3-复合查询"><a href="#4-2-3-复合查询" class="headerlink" title="4.2.3 复合查询"></a>4.2.3 复合查询</h5><p>包含一个/多个字段类查询/符合查询语句</p><h6 id="4-2-3-1-constant-score-query"><a href="#4-2-3-1-constant-score-query" class="headerlink" title="4.2.3.1 constant_score query"></a>4.2.3.1 constant_score query</h6><ol><li><code>constant_score query</code>: 将内部的查询结果文档得分全部设定为1或boost的值。返回的相关性得分全部为1或boost</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用constant_score query</span></span><br><span class="line">GET my_index/_Search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"constant_score"</span>:&#123;    <span class="comment">#关键词</span></span><br><span class="line">   <span class="string">"match"</span>:&#123;</span><br><span class="line">    <span class="string">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-2-bool-query"><a href="#4-2-3-2-bool-query" class="headerlink" title="4.2.3.2 bool query"></a>4.2.3.2 bool query</h6><p><code>bool query</code>: 由一个/多个布尔子句组成，主要包含以下四个：</p><ol><li><code>filter</code>: 只过滤符合条件的文档，不计算相关性得分，返回的相关性得分全部为0；<ul><li><code>ES</code>会对<code>filter</code>进行智能缓存，因此执行效率较高，在做简单匹配查询且不考虑得分的时候没推荐使用<code>filter</code>代替<code>query</code></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用filter查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"bool"</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">   <span class="string">"filter"</span>:[</span><br><span class="line">    <span class="string">"term"</span>:&#123;</span><br><span class="line">     <span class="string">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>must</code>: 文档必须符合<code>must</code>中的所有条件，影响相关性得分；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用must进行查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"bool"</span>:&#123;</span><br><span class="line">   <span class="string">"must"</span>:[    </span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"match"</span>:&#123;</span><br><span class="line">      <span class="string">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"match"</span>:&#123;</span><br><span class="line">      <span class="string">"job"</span>:<span class="string">"specialist"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>must_not</code>: 文档必须排除must_not中的所有条件； </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用must_not进行查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"bool"</span>:&#123;</span><br><span class="line">   <span class="string">"must"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"match"</span>:&#123;</span><br><span class="line">     <span class="string">"job"</span>:<span class="string">"java"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"must_not"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"match"</span>:&#123;</span><br><span class="line">     <span class="string">"job"</span>:<span class="string">"ruby"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>should</code>: 文档可以符合<code>should</code>中的条件，影响相关性得分，分为两种情况：同时配合<code>minimum_should_match</code>控制满足调价你的个数/百分比。<ol><li><code>bool</code>查询中只有<code>should</code>，不包含<code>must</code>的情况</li><li>bool查询中既有should，又包含must的情况，文档不必满足should中的条件，但是如果满足的话则会增加相关性得分。</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bool查询中只有should的情况</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"bool"</span>:&#123;</span><br><span class="line">   <span class="string">"should"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"term"</span>:&#123;<span class="string">"job"</span>:<span class="string">"java"</span>&#125;    <span class="comment"># 条件1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"term"</span>:&#123;<span class="string">"job"</span>:<span class="string">"ruby"</span>&#125;    <span class="comment"># 条件3</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">"term"</span>:&#123;<span class="string">"job"</span>:<span class="string">"specialist"</span>&#125;    <span class="comment"># 条件3</span></span><br><span class="line">    &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"minimum_should_match"</span>:2    <span class="comment"># 至少需要满足两个条件</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># bool查询中同时包含should和must</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"bool"</span>:&#123;</span><br><span class="line">   <span class="string">"should"</span>:[    <span class="comment"># 同时包含should</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"term"</span>:&#123;<span class="string">"job"</span>:<span class="string">"ruby"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"must"</span>:[    <span class="comment"># 同时包含must</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"term"</span>:&#123;<span class="string">"usernmae"</span>:<span class="string">"alfred"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当一个查询语句位于query或filter上下文的时候，ES的执行结果也不同。</p></blockquote><table><thead><tr><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>query</td><td>查找和查询语句最匹配的文档，<br>并对所有文档计算相关性得分</td><td>query<br>bool中的：must/should</td></tr><tr><td>filter</td><td>查找和查询语句最匹配的文档</td><td>bool中的：filter/must_not<br>constant_score中的：filter</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># query和filter上下文</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"bool"</span>:&#123;</span><br><span class="line">   <span class="string">"must"</span>:[    <span class="comment"># query上下文</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"term"</span>:&#123;<span class="string">"title"</span>:<span class="string">"Search"</span>&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"term"</span>:&#123;<span class="string">"content"</span>:<span class="string">"ElasticSearch"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"filter"</span>:[    <span class="comment"># filter上下文</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"term"</span>:&#123;<span class="string">"status"</span>:<span class="string">"published"</span>&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"range"</span>:&#123;</span><br><span class="line">     <span class="string">"publish_date"</span>:&#123;</span><br><span class="line">      <span class="string">"gte"</span>:<span class="string">"2015-01-01"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-3-count-API"><a href="#4-2-3-3-count-API" class="headerlink" title="4.2.3.3 count API"></a>4.2.3.3 count API</h6><p><code>count API</code>: 获取符合条件的文档书，使用<code>endpoint：_count</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用_count获取符合条件的文档数</span></span><br><span class="line">GET my_index/_count    <span class="comment"># 关键词</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"query"</span>:&#123;</span><br><span class="line">  <span class="string">"match"</span>:&#123;</span><br><span class="line">   <span class="string">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-4-Source-Filtering"><a href="#4-2-3-4-Source-Filtering" class="headerlink" title="4.2.3.4 Source Filtering"></a>4.2.3.4 Source Filtering</h6><p><code>Source Filtering</code>: 过滤返回结果中的<code>_source</code>中的字段，主要由以下两种方式：</p><ol><li>GET my_index/_search?_source=username #url参数</li><li>使用Request Body Search：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不返回_source</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"_source"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 返回_source部分字段</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"_source"</span>:[<span class="string">"username"</span>,<span class="string">"age"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 通配符匹配返回_source部分字段</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"_source"</span>:&#123;</span><br><span class="line">  <span class="string">"includes"</span>:<span class="string">"*I*"</span>,</span><br><span class="line">  <span class="string">"encludes"</span>:<span class="string">"birth"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;h4 id=&quot;1-1-ElasticStack特点&quot;&gt;&lt;a href=&quot;#1-1-ElasticStack特点&quot; class=&quot;headerlink&quot; title=&quot;1.1 ElasticStack特点&quot;&gt;&lt;/a&gt;1.1 ElasticStack特点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用门槛低，开发周期短，上线快&lt;/li&gt;
&lt;li&gt;性能好，查询快，实时展示结果&lt;/li&gt;
&lt;li&gt;扩容方便，快速支撑增长迅猛的数据
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】NIO、Netty及websocket实现</title>
    <link href="http://chaooo.github.io/article/20191020.html"/>
    <id>http://chaooo.github.io/article/20191020.html</id>
    <published>2019-10-20T15:34:31.000Z</published>
    <updated>2019-11-16T15:11:33.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-BIO-NIO-AIO演变"><a href="#1-BIO-NIO-AIO演变" class="headerlink" title="1. BIO/NIO/AIO演变"></a>1. BIO/NIO/AIO演变</h3><p>Java IO 方式有很多种，基于不同的IO抽象模型和交互方式，可以进行简单区分。</p><table><thead><tr><th>IO类型</th><th>模型</th><th>客户端:线程数</th><th>API使用难度</th><th>调试难度</th><th>可靠性</th><th>吞吐量</th></tr></thead><tbody><tr><td>BIO</td><td>流，同步阻塞</td><td>1:1</td><td>简单</td><td>简单</td><td>很差</td><td>非常低</td></tr><tr><td>伪异步IO</td><td>同步阻塞</td><td>M:N</td><td>简单</td><td>简单</td><td>较差</td><td>中等</td></tr><tr><td>NIO</td><td>同步非阻塞</td><td>M:1</td><td>复杂</td><td>复杂</td><td>较高</td><td>高</td></tr><tr><td>AIO</td><td>异步非阻塞</td><td>M:0,被动回调</td><td>复杂</td><td>复杂</td><td>高</td><td>高</td></tr></tbody></table><ol><li>区分同步(synchronous)或异步(asynchronous)<ul><li>同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；</li><li>异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li></ul></li><li>区分阻塞(blocking)与非阻塞(non-blocking)<ul><li>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；</li><li>非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理</li></ul></li></ol><ul><li>传统的java.io包，它基于流模型实现，<strong>同步阻塞</strong>的交互方式，如File抽象、输入输出流等。好处是代码简单、直观，缺点是IO效率和扩展性局限性</li><li>很多时候，也把java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库，因为网络通信同样是IO行为。</li><li>伪异步IO：后端通过维护一个消息队列和N个活跃线程, 通过一个<strong>线程池</strong>来处理多个客户端的请求接入，通过线程池，可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入而导致的线程耗尽和宕机。</li><li>JDK4引入了NIO框架(java.nio)，提供了Channel、Selector、Buffer等新的抽象，可以构建<strong>多路复用</strong>的、<strong>同步非阻塞</strong>IO程序，同时提供了更接近操作系统底层的高性能数据操作方式。</li><li>JDK7中，NIO有了进一步的改进，引入了异步非阻塞IO方式，也叫AIO(Asynchronous IO)。异步IO操作基于事件和<strong>回调机制</strong>，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</li></ul><h4 id="1-1-NIO的主要组成部分："><a href="#1-1-NIO的主要组成部分：" class="headerlink" title="1.1 NIO的主要组成部分："></a>1.1 NIO的主要组成部分：</h4><ol><li>Buffer(缓冲区)，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现。<ul><li>Buffer最常见的类型是ByteBuffer，另外还有CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。</li></ul></li><li>Channel(通道)，是NIO中被用来支持批量式IO操作的一种抽象。<ul><li>和流不同，通道是双向的。数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</li></ul></li><li>Selector(多路复用器)，是NIO实现多路复用的基础，它允许单线程处理多个Channel。<ul><li>Selector是基于底层操作系统机制，不同模式、不同版本都存在区别。</li><li>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</li></ul></li></ol><h4 id="1-2-NIO多路复用的过程"><a href="#1-2-NIO多路复用的过程" class="headerlink" title="1.2 NIO多路复用的过程"></a>1.2 NIO多路复用的过程</h4><ol><li>通过Selector.open()创建一个Selector，作为类似调度员的角色。</li><li>创建一个ServerSocketChannel，并绑定监听端口，设置为非阻塞模式</li><li>将Channel向Selector注册，通过指定SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。</li><li>Selector循环阻塞在select操作，当有Channel发生接入请求，就会被唤醒。</li><li>调用selectedKeys方法获取就绪channel集合</li><li>通过SocketChannel和Buffer进行数据操作。</li></ol><h4 id="1-3-AIO"><a href="#1-3-AIO" class="headerlink" title="1.3 AIO"></a>1.3 AIO</h4><ul><li>AIO也叫NIO2.0 是一种非阻塞异步的通信模式。在NIO的基础上引入了新的<strong>异步通道</strong>的概念，并提供了异步文件通道和异步套接字通道的实现。<ul><li>没有采用NIO的多路复用器，而是使用异步通道的概念。</li><li>其read，write方法的返回类型都是Future对象。而Future模型是异步的，其核心思想是：去主函数等待时间。</li><li>AIO模型中通过AsynchronousSocketChannel和AsynchronousServerSocketChannel完成套接字通道的实现。非阻塞，异步。</li></ul></li></ul><h3 id="2-Netty框架"><a href="#2-Netty框架" class="headerlink" title="2. Netty框架"></a>2. Netty框架</h3><p>Netty是一个高性能事件驱动，异步非阻塞的IO开源框架，由Jboss提供，用于建立Tcp等底层的链接，基于Netty可以建立高性能的Http服务器，快速开发高性能、高可靠的网络服务器和客户端程序。支持Http、websocket，tcp，udp等协议。</p><ul><li>Netty使用场景：高性能领域（游戏，大数据分布式计算等）、多线程并发领域（多路复用模型，多线程模型，主从多线程模型）、异步通信领域</li><li>Netty 是一个吸收了多种协议（包括FTP、SMTP、HTTP等各种二进制文本协议）的实现经验，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。</li></ul><h4 id="2-1-Netty的核心概念"><a href="#2-1-Netty的核心概念" class="headerlink" title="2.1 Netty的核心概念"></a>2.1 Netty的核心概念</h4><ol><li>ServerBootstrap，服务器端程序的入口，这是 Netty 为简化网络程序配置和关闭等生命周期管理，所引入的 Bootstrapping 机制。我们通常要做的创建 Channel、绑定端口、注册 Handler 等，都可以通过这个统一的入口，以<strong>Fluent API</strong>等形式完成，相对简化了 API 使用。与之相对应， Bootstrap则是 Client 端的通常入口。</li><li>Channel，作为一个基于 NIO 的扩展框架，Channel 和 Selector 等概念仍然是 Netty 的基础组件，但是针对应用开发具体需求，提供了相对易用的抽象。</li><li>EventLoop，这是 Netty 处理事件的核心机制。例子中使用了 EventLoopGroup。我们在 NIO 中通常要做的几件事情，如注册感兴趣的事件、调度相应的 Handler 等，都是 EventLoop 负责。</li><li>ChannelFuture，这是 Netty 实现异步 IO 的基础之一，保证了同一个 Channel 操作的调用顺序。Netty 扩展了 Java 标准的 Future，提供了针对自己场景的特有Future定义。</li><li>ChannelHandler，这是应用开发者<strong>放置业务逻辑的主要地方</strong>，也是我上面提到的“Separation Of Concerns”原则的体现。</li><li>ChannelPipeline，它是 ChannelHandler 链条的容器，每个 Channel 在创建后，自动被分配一个 ChannelPipeline。在上面的示例中，我们通过 ServerBootstrap 注册了 ChannelInitializer，并且实现了 initChannel 方法，而在该方法中则承担了向 ChannelPipleline 安装其他 Handler 的任务。</li></ol><h4 id="2-2-对比-Java-标准-NIO-类库，Netty是如何实现更高性能的？"><a href="#2-2-对比-Java-标准-NIO-类库，Netty是如何实现更高性能的？" class="headerlink" title="2.2 对比 Java 标准 NIO 类库，Netty是如何实现更高性能的？"></a>2.2 对比 Java 标准 NIO 类库，Netty是如何实现更高性能的？</h4><p>单独从性能角度，Netty 在基础的 NIO 等类库之上进行了很多改进，例如：</p><ol><li>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</li><li>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</li><li>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li><li>在通信协议、序列化等其他角度的优化。</li></ol><p>Netty 的设计强调了 “Separation Of Concerns”，通过精巧设计的事件机制，将业务逻辑和无关技术逻辑进行隔离，并通过各种方便的抽象，一定程度上填补了了基础平台和业务开发之间的鸿沟，更有利于在应用开发中普及业界的最佳实践。另外，Netty &gt; java.nio + java. net！</p><p>除了核心的事件机制等，Netty 还额外提供了很多功能，例如：</p><ol><li>从网络协议的角度，Netty 除了支持传输层的 UDP、TCP、SCTP协议，也支持 HTTP(s)、WebSocket 等多种应用层协议，它并不是单一协议的 API。</li><li>在应用中，需要将数据从 Java 对象转换成为各种应用协议的数据格式，或者进行反向的转换，Netty 为此提供了一系列扩展的编解码框架，与应用开发场景无缝衔接，并且性能良好。</li><li>它扩展了 Java NIO Buffer，提供了自己的 ByteBuf 实现，并且深度支持 Direct Buffer 等技术，甚至 hack 了 Java 内部对 Direct Buffer 的分配和销毁等。同时，Netty 也提供了更加完善的 Scatter/Gather 机制实现。</li></ol><h3 id="3-基于Netty搭建简单的Http服务"><a href="#3-基于Netty搭建简单的Http服务" class="headerlink" title="3. 基于Netty搭建简单的Http服务"></a>3. 基于Netty搭建简单的Http服务</h3><ol><li>环境准备：<code>jdk1.8</code>、<code>Netty4.1.43.Final</code></li><li>代码编写：<code>MyChannelInitializer.java</code>、<code>MyClientHandler.java</code>、<code>NettyServer.java</code></li></ol><blockquote><p>MyChannelInitializer.java：添加了Http的处理协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据解码操作</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line">        <span class="comment">// 数据编码操作</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的接收数据实现方法</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MyServerHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            DefaultHttpRequest request = (DefaultHttpRequest) msg;</span><br><span class="line">            System.out.println(<span class="string">"URI:"</span> + request.getUri());</span><br><span class="line">            System.err.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpContent) &#123;</span><br><span class="line">            LastHttpContent httpContent = (LastHttpContent) msg;</span><br><span class="line">            ByteBuf byteData = httpContent.content();</span><br><span class="line">            <span class="keyword">if</span> (!(byteData <span class="keyword">instanceof</span> EmptyByteBuf)) &#123;</span><br><span class="line">                <span class="comment">//接收msg消息</span></span><br><span class="line">                <span class="keyword">byte</span>[] msgByte = <span class="keyword">new</span> <span class="keyword">byte</span>[byteData.readableBytes()];</span><br><span class="line">                byteData.readBytes(msgByte);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(msgByte, StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String sendMsg = <span class="string">"不平凡的岁月终究来自你每日不停歇的刻苦拼搏，每一次真正成长都因看清脚下路而抉择出的生活。"</span>;</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                HttpVersion.HTTP_1_1,</span><br><span class="line">                HttpResponseStatus.OK,</span><br><span class="line">                Unpooled.wrappedBuffer(sendMsg.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">"text/plain;charset=UTF-8"</span>);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line">        ctx.write(response);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NettyServer().bing(<span class="number">7397</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bing</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置服务端NIO线程组</span></span><br><span class="line">        EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(parentGroup, childGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)<span class="comment">//非阻塞模式</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyChannelInitializer());</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">"http-netty server start done. "</span>);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            childGroup.shutdownGracefully();</span><br><span class="line">            parentGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>启动<code>NettyServer</code>，<code>Postman</code>访问<code>http://localhost:7397</code>并设置参数</p></blockquote><h3 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a>4. WebSocket</h3><p>WebSocket是一种H5协议规范，通过握手机制客户端与服务器之间就能够建立一个类似Tcp的连接，从而方便客户端与服务器之间的通信。</p><ul><li>它是一种解决客户端与服务端实时通信而产生的技术：WebSocket本质是一种基于TCP协议，先通过Http/Https发一个特殊的Http请求进行握手，握手后会创建一个用于交换数据的TCP链接，之后客户端和服务端使用该TCP链接进行实时通信。当WebSocket的客户端和服务端握手后 建立通信后，就不再需要之前的http请求参与。</li></ul><h4 id="4-1-WebSocket的优点："><a href="#4-1-WebSocket的优点：" class="headerlink" title="4.1 WebSocket的优点："></a>4.1 WebSocket的优点：</h4><ul><li>节省通信开销，之前WebServer实现通信，都使用轮询，需要不停的向服务器发送请求，而HttpRequest的handler很长，请求包含真正的数据可能很小，会占用很多额外的带宽和服务器资源。</li><li>建立连接后，服务器可主动传数据给客户端，客户端也可以随意向服务端传数据。交换数据时所携带的头信息很小。浏览器（客户端）和服务器只需要做一个握手的动作。</li><li>实时通信：WebSocket不仅限于Ajax方式通信。ajax方式需要浏览器发起请求。而WebSocket技术 服务端和客户端可以彼此相互推送信息，从而实现实时通信。</li></ul><h4 id="4-2-WebSocket建立连接过程："><a href="#4-2-WebSocket建立连接过程：" class="headerlink" title="4.2 WebSocket建立连接过程："></a>4.2 WebSocket建立连接过程：</h4><p><code>客户端发起握手请求 ---&gt; 服务端响应请求 ---&gt; 建立连接</code></p><ul><li>详细流程：建立一个WebSocket连接，客户端或浏览器首先向服务器发送一个特殊的Http请求(携带一些附加头信息)Upgrade:websocket，服务端解析附加头信息，产生应答消息，然后响应给客户端，之后客户端就与服务端建立响应的链接。</li></ul><h4 id="4-3-WebSocket生命周期："><a href="#4-3-WebSocket生命周期：" class="headerlink" title="4.3 WebSocket生命周期："></a>4.3 WebSocket生命周期：</h4><ol><li>打开事件：端点上建立新链接时，该事件是先于其他任何事件发生之前。该事件发生会产生三部分信息。<ol><li>创建WebSocket Session对象：用于表示已经建立好的链接</li><li>配置对象：包含配置端点的信息。</li><li>一组路径参数，用于打开节点握手时，WebSocket端入栈匹配的URI</li></ol></li><li>消息事件：主要是接收WebSocket对话中，另一端发送的消息。链接上的消息将会有三种形式抵达客户端。<ol><li>文本消息 用String处理</li><li>二进制消息 用byteBuffer或者byte[]处理</li><li>pong消息 用Java WebSocket API中的pong.message接口的实例来处理</li></ol></li><li>错误事件：WebSocket链接或者端点发生错误时产生。可以处理入栈消息时发生的各种异常。入栈消息可能产生的三种异常。<ol><li>WebSocket建立链接时发生错误：SessionException类型</li><li>WebSocket试图将入栈消息解码成开发人员使用的对象时 EncodeException类型</li><li>WebSocket端点的其他方法运行时产生的错误，WebSocket实现将记录端点操作过程中产生的任何异常</li></ol></li><li>关闭事件：WebSocket链接端点关闭，做一些清理工作，可以由参与连接的任意一个端点发出。</li></ol><h4 id="4-4-WebSocket如何关闭链接："><a href="#4-4-WebSocket如何关闭链接：" class="headerlink" title="4.4 WebSocket如何关闭链接："></a>4.4 WebSocket如何关闭链接：</h4><p>流程：当服务器被指示关闭WebSocket链接时，服务端会发起一个TCP Close操作， 客户端应该等待服务器的TCP Close</p><ul><li>关闭WebSocket连接，端点需关闭底层TCP连接。</li><li>底层TCP连接，在大多数正常情况下，应该首先被服务器关闭，服务器持有TIME_WAIT状态（因为这会防止它在2个报文最大生存时间（2MLS）内重新打开连接，然而当一个新的带有更高的seq number的SYN时没有对应的服务器影响TIME_WAIT连接被立即重新打开）。</li><li>在异常情况下（例如在一个合理的时间量后没有接收到服务器的TCP Close）,客户端可以发起<code>TCP Close</code>。</li></ul><h3 id="5-基于Netty搭建WebSocket多人聊天室"><a href="#5-基于Netty搭建WebSocket多人聊天室" class="headerlink" title="5. 基于Netty搭建WebSocket多人聊天室"></a>5. 基于Netty搭建WebSocket多人聊天室</h3><ol><li>使用SpringBoot+Netty+WebSocket搭建功能。</li><li>使用Netty提供的HttpServerCodec、HttpObjectAggregator、ChunkedWriteHandler进行编码解码处理。</li><li>环境准备：<code>jdk1.8</code>、<code>Netty4.1.43.Final</code>、<code>spring-boot-starter-web</code></li></ol><blockquote><p>目录结构</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">└── src.main</span><br><span class="line">       ├── java</span><br><span class="line">       │   └── top.chaooo.hellonetty</span><br><span class="line">       │       ├── domain</span><br><span class="line">       │       │    ├── ClientMsgProtocol.java</span><br><span class="line">       │       │    └── ServerMsgProtocol.java</span><br><span class="line">       │       ├── server</span><br><span class="line">       │       │    ├── MyChannelInitializer.java</span><br><span class="line">       │       │    ├── MyServerHandler.java</span><br><span class="line">       │       │    └── NettyServer.java</span><br><span class="line">       │       ├── util</span><br><span class="line">       │       │    ├── ChannelHandler.java</span><br><span class="line">       │       │    └── MsgUtil.java</span><br><span class="line">       │       ├── controller</span><br><span class="line">       │       │    └── NettyController.java    </span><br><span class="line">       │       └── NettyApplication.java</span><br><span class="line">       └── resources</span><br><span class="line">            ├── static(js,img)</span><br><span class="line">            ├── templates</span><br><span class="line">            │    └── index.html</span><br><span class="line">            └── application.yml</span><br></pre></td></tr></table></figure><blockquote><p>resources/application.yml：基础配置信息，包括了；应用端口、netty服务端端口等</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">netty:</span></span><br><span class="line"><span class="attr">  host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">7397</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  thymeleaf:</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">HTML5</span></span><br><span class="line"><span class="attr">    encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">    content-type:</span> <span class="string">text/html</span></span><br><span class="line"><span class="attr">    cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><blockquote><p>server/MyChannelInitializer.java：websocket处理协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"http-codec"</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"http-chunked"</span>, <span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的接收数据实现方法</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server/MyServerHandler.java：处理websocket消息信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> WebSocketServerHandshaker handshaker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端主动链接服务端的链接后，这个通道就是活跃的了。</span></span><br><span class="line"><span class="comment">     * 也就是客户端与服务端建立了通信通道并且可以传输数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) ctx.channel();</span><br><span class="line">        logger.info(<span class="string">"链接报告开始"</span>);</span><br><span class="line">        logger.info(<span class="string">"链接报告信息：有一客户端链接到本服务端"</span>);</span><br><span class="line">        logger.info(<span class="string">"链接报告IP:&#123;&#125;"</span>, channel.localAddress().getHostString());</span><br><span class="line">        logger.info(<span class="string">"链接报告Port:&#123;&#125;"</span>, channel.localAddress().getPort());</span><br><span class="line">        logger.info(<span class="string">"链接报告完毕"</span>);</span><br><span class="line">        ChannelUtil.channelGroup.add(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端主动断开服务端的链接后，这个通道就是不活跃的。</span></span><br><span class="line"><span class="comment">     * 也就是说客户端与服务端的关闭了通信通道并且不可以传输数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"客户端断开链接&#123;&#125;"</span>, ctx.channel().localAddress().toString());</span><br><span class="line">        ChannelUtil.channelGroup.remove(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//http</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest) &#123;</span><br><span class="line">            FullHttpRequest httpRequest = (FullHttpRequest) msg;</span><br><span class="line">            <span class="keyword">if</span> (!httpRequest.decoderResult().isSuccess()) &#123;</span><br><span class="line">                DefaultFullHttpResponse httpResponse = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST);</span><br><span class="line">                <span class="comment">// 返回应答给客户端</span></span><br><span class="line">                <span class="keyword">if</span> (httpResponse.status().code() != <span class="number">200</span>) &#123;</span><br><span class="line">                    ByteBuf buf = Unpooled.copiedBuffer(httpResponse.status().toString(), CharsetUtil.UTF_8);</span><br><span class="line">                    httpResponse.content().writeBytes(buf);</span><br><span class="line">                    buf.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是非Keep-Alive，关闭连接</span></span><br><span class="line">                ChannelFuture f = ctx.channel().writeAndFlush(httpResponse);</span><br><span class="line">                <span class="keyword">if</span> (httpResponse.status().code() != <span class="number">200</span>) &#123;</span><br><span class="line">                    f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            WebSocketServerHandshakerFactory wsFactory = <span class="keyword">new</span> WebSocketServerHandshakerFactory(<span class="string">"ws:/"</span> + ctx.channel() + <span class="string">"/websocket"</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            handshaker = wsFactory.newHandshaker(httpRequest);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == handshaker) &#123;</span><br><span class="line">                WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handshaker.handshake(ctx.channel(), httpRequest);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ws</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> WebSocketFrame) &#123;</span><br><span class="line">            WebSocketFrame webSocketFrame = (WebSocketFrame) msg;</span><br><span class="line">            <span class="comment">//关闭请求</span></span><br><span class="line">            <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> CloseWebSocketFrame) &#123;</span><br><span class="line">                handshaker.close(ctx.channel(), (CloseWebSocketFrame) webSocketFrame.retain());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ping请求</span></span><br><span class="line">            <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> PingWebSocketFrame) &#123;</span><br><span class="line">                ctx.channel().write(<span class="keyword">new</span> PongWebSocketFrame(webSocketFrame.content().retain()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只支持文本格式，不支持二进制消息</span></span><br><span class="line">            <span class="keyword">if</span> (!(webSocketFrame <span class="keyword">instanceof</span> TextWebSocketFrame)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"仅支持文本格式"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String request = ((TextWebSocketFrame) webSocketFrame).text();</span><br><span class="line">            System.out.println(<span class="string">"服务端收到："</span> + request);</span><br><span class="line">            ClientMsgProtocol clientMsgProtocol = JSON.parseObject(request, ClientMsgProtocol.class);</span><br><span class="line">            <span class="comment">//1请求个人信息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == clientMsgProtocol.getType()) &#123;</span><br><span class="line">                ctx.channel().writeAndFlush(MsgUtil.buildMsgOwner(ctx.channel().id().toString()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//群发消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> == clientMsgProtocol.getType()) &#123;</span><br><span class="line">                TextWebSocketFrame textWebSocketFrame = MsgUtil.buildMsgAll(ctx.channel().id().toString(), clientMsgProtocol.getMsgInfo());</span><br><span class="line">                ChannelUtil.channelGroup.writeAndFlush(textWebSocketFrame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抓住异常，当发生异常的时候，可以做一些相应的处理，比如打印日志、关闭链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        logger.info(<span class="string">"异常信息：\r\n"</span> + cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server/NettyServer.java：主服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"nettyServer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line">    <span class="comment">//配置服务端NIO线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bing</span><span class="params">(InetSocketAddress address)</span> </span>&#123;</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(parentGroup, childGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)    <span class="comment">//非阻塞模式</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyChannelInitializer());</span><br><span class="line">            channelFuture = b.bind(address).syncUninterruptibly();</span><br><span class="line">            channel = channelFuture.channel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != channelFuture &amp;&amp; channelFuture.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">"demo-netty server start done"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"demo-netty server start error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channelFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == channel) <span class="keyword">return</span>;</span><br><span class="line">        channel.close();</span><br><span class="line">        parentGroup.shutdownGracefully();</span><br><span class="line">        childGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>util/MsgUtil.java：消息构建工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title">buildMsgAll</span><span class="params">(String channelId, String msgInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟头像</span></span><br><span class="line">        <span class="keyword">int</span> i = Math.abs(channelId.hashCode()) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        ServerMsgProtocol msg = <span class="keyword">new</span> ServerMsgProtocol();</span><br><span class="line">        msg.setType(<span class="number">2</span>); <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        msg.setChannelId(channelId);</span><br><span class="line">        msg.setUserHeadImg(<span class="string">"head"</span> + i + <span class="string">".jpg"</span>);</span><br><span class="line">        msg.setMsgInfo(msgInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title">buildMsgOwner</span><span class="params">(String channelId)</span> </span>&#123;</span><br><span class="line">        ServerMsgProtocol msg = <span class="keyword">new</span> ServerMsgProtocol();</span><br><span class="line">        msg.setType(<span class="number">1</span>); <span class="comment">//链接信息;1链接信息、2消息信息</span></span><br><span class="line">        msg.setChannelId(channelId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>util/ChannelUtil.java：存储每一个客户端接入进来时的channel对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于存放用户Channel信息，也可以建立map结构模拟不同的消息群</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>domain/*MsgProtocol.java：省略get/set</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMsgProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;             <span class="comment">//链接信息;1:自发信息、2:群发消息</span></span><br><span class="line">    <span class="keyword">private</span> String channelId;     <span class="comment">//通信管道ID，实际使用中会映射成用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userHeadImg;   <span class="comment">//用户头像[模拟分配]</span></span><br><span class="line">    <span class="keyword">private</span> String msgInfo;       <span class="comment">//通信消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMsgProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;       <span class="comment">//1:请求个人信息，2:发送聊天信息</span></span><br><span class="line">    <span class="keyword">private</span> String msgInfo; <span class="comment">//消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>controller/NettyController.java：路由控制层</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>, <span class="string">"Dear"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>js逻辑：依赖jquery.min.js、jquery.serialize-object.min.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript Document</span></span><br><span class="line"><span class="keyword">var</span> socket;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;</span><br><span class="line">        <span class="built_in">window</span>.WebSocket = <span class="built_in">window</span>.MozWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;</span><br><span class="line">        alert(<span class="string">"您的浏览器不支持WebSocket协议！推荐使用谷歌浏览器进行测试。"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:7397/websocket"</span>);</span><br><span class="line">    socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> msg = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">        <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == msg.type)&#123;</span><br><span class="line">            jQuery.data(<span class="built_in">document</span>.body, <span class="string">'channelId'</span>, msg.channelId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> == msg.type)&#123;</span><br><span class="line">            <span class="keyword">var</span> channelId =    msg.channelId;</span><br><span class="line">            <span class="comment">//自己</span></span><br><span class="line">            <span class="keyword">if</span>(channelId == jQuery.data(<span class="built_in">document</span>.body, <span class="string">'channelId'</span>))&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = $(<span class="string">".msgBlockOwnerClone"</span>).clone();</span><br><span class="line">                <span class="built_in">module</span>.removeClass(<span class="string">"msgBlockOwnerClone"</span>).addClass(<span class="string">"msgBlockOwner"</span>).css(&#123;<span class="attr">display</span>: <span class="string">"block"</span>&#125;);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".headPoint"</span>).attr(<span class="string">"src"</span>, <span class="string">"res/img/"</span>+msg.userHeadImg);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_msgInfo .msgPoint"</span>).text(msg.msgInfo);</span><br><span class="line">                $(<span class="string">"#msgPoint"</span>).before(<span class="built_in">module</span>);</span><br><span class="line">                util.divScroll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//好友</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = $(<span class="string">".msgBlockFriendClone"</span>).clone();</span><br><span class="line">                <span class="built_in">module</span>.removeClass(<span class="string">"msgBlockFriendClone"</span>).addClass(<span class="string">"msgBlockFriend"</span>).css(&#123;<span class="attr">display</span>: <span class="string">"block"</span>&#125;);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".headPoint"</span>).attr(<span class="string">"src"</span>, <span class="string">"res/img/"</span>+msg.userHeadImg);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_channelId"</span>).text(<span class="string">"ID："</span>+msg.channelId);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_msgInfo .msgPoint"</span>).text(msg.msgInfo);</span><br><span class="line">                $(<span class="string">"#msgPoint"</span>).before(<span class="built_in">module</span>);</span><br><span class="line">                util.divScroll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">"打开WebSoket 服务正常，浏览器支持WebSoket!"</span>);</span><br><span class="line">        <span class="keyword">var</span> clientMsgProtocol = &#123;&#125;;</span><br><span class="line">        clientMsgProtocol.type = <span class="number">1</span>;</span><br><span class="line">        clientMsgProtocol.msgInfo = <span class="string">"请求个人信息"</span>;</span><br><span class="line">        socket.send(<span class="built_in">JSON</span>.stringify(clientMsgProtocol));</span><br><span class="line">     &#125;;</span><br><span class="line">    socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">"WebSocket 关闭"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">13</span> == e.keyCode &amp;&amp; e.ctrlKey)&#123;</span><br><span class="line">            util.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">util = &#123;</span><br><span class="line">    send: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">            <span class="keyword">var</span> clientMsgProtocol = &#123;&#125;;</span><br><span class="line">            clientMsgProtocol.type = <span class="number">2</span>;</span><br><span class="line">            clientMsgProtocol.msgInfo = $(<span class="string">"#sendBox"</span>).val();</span><br><span class="line">            socket.send(<span class="built_in">JSON</span>.stringify(clientMsgProtocol));</span><br><span class="line">            $(<span class="string">"#sendBox"</span>).val(<span class="string">""</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">"WebSocket 连接没有建立成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    divScroll: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>); </span><br><span class="line">        div.scrollTop = div.scrollHeight; </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>主要Html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span> <span class="attr">xmlns:sec</span>=<span class="string">"http://www.thymeleaf.org/extras/spring-security"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/jquery.serialize-object.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chatDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chat"</span> <span class="attr">style</span>=<span class="string">"width:529px; height:667px; background-color:#F5F5F5; float:right;"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 会话区域 begin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"show"</span> <span class="attr">style</span>=<span class="string">"width:529px; height:450px; float:left;overflow-y:scroll;"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息块；好友 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlockFriendClone"</span> <span class="attr">style</span>=<span class="string">" display:none; margin-left:30px; margin-top:15px; width:340px; height:auto; margin-bottom:15px; float:left;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_userHeadImg"</span> <span class="attr">style</span>=<span class="string">"float:left; width:35px; height:35px;border-radius:3px;-moz-border-radius:3px; background-color:#FFFFFF;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"headPoint"</span> <span class="attr">src</span>=<span class="string">"/img/head5.jpg"</span> <span class="attr">width</span>=<span class="string">"35px"</span> <span class="attr">height</span>=<span class="string">"35px"</span> <span class="attr">style</span>=<span class="string">"border-radius:3px;-moz-border-radius:3px;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_channelId"</span> <span class="attr">style</span>=<span class="string">"float:left; width:100px; margin-top:-5px; margin-left:10px; padding-bottom:2px; font-size:10px;"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 名称 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_msgInfo"</span> <span class="attr">style</span>=<span class="string">"height:auto;width:280px;float:left;margin-left:12px; margin-top:4px;border-radius:3px;-moz-border-radius:3px; "</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:4px; height:20px; background-color:#CC0000; float:left;border-radius:3px;-moz-border-radius:3px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgPoint"</span> <span class="attr">style</span>=<span class="string">"float:left;width:260px; padding:7px; background-color:#FFFFFF; border-radius:3px;-moz-border-radius:3px; height:auto; font-size:12px;display:block;word-break: break-all;word-wrap: break-word;"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息块；自己 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlockOwnerClone"</span> <span class="attr">style</span>=<span class="string">" display:none; margin-right:30px; margin-top:15px; width:340px; height:auto; margin-bottom:15px; float:right;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:right; width:35px; height:35px;border-radius:3px;-moz-border-radius:3px; background-color:#FFFFFF;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"headPoint"</span> <span class="attr">src</span>=<span class="string">"/img/head3.jpg"</span> <span class="attr">width</span>=<span class="string">"35px"</span> <span class="attr">height</span>=<span class="string">"35px"</span> <span class="attr">style</span>=<span class="string">"border-radius:3px;-moz-border-radius:3px;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_msgInfo"</span> <span class="attr">style</span>=<span class="string">"height:auto;width:280px;float:left;margin-left:12px; margin-top:4px;border-radius:3px;-moz-border-radius:3px; "</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgPoint"</span> <span class="attr">style</span>=<span class="string">"float:left;width:260px; padding:7px; background-color:#FFFFFF; border-radius:3px;-moz-border-radius:3px; height:auto; font-size:12px;display:block;word-break: break-all;word-wrap: break-word;"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:4px; height:20px; background-color:#CC0000; float:right;border-radius:3px;-moz-border-radius:3px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"msgPoint"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 会话区域 end --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:100%; height:2px; float:left; background-color:#CCCCCC;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin:0 auto; width:100%; height:149px; margin-top:5px;  background-color:#FFFFFF; float:left;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"sendBox"</span> <span class="attr">style</span>=<span class="string">"font-size:14px; border:0; width:499px; height:80px; outline:none; padding:15px;font-family:”微软雅黑”;resize: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:20px; float:right; margin-right:35px; padding:5px; padding-left:15px; padding-right:15px; font-size:12px; background-color:#F5F5F5;border-radius:3px;-moz-border-radius:3px; cursor:pointer;"</span> <span class="attr">onclick</span>=<span class="string">"javascript:util.send();"</span>&gt;</span>发送(S)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动SpringBoot，Netty会随着启动；</li><li>用不同浏览器访问 <code>http://localhost:8080/index</code> 测试多人实时聊天。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-BIO-NIO-AIO演变&quot;&gt;&lt;a href=&quot;#1-BIO-NIO-AIO演变&quot; class=&quot;headerlink&quot; title=&quot;1. BIO/NIO/AIO演变&quot;&gt;&lt;/a&gt;1. BIO/NIO/AIO演变&lt;/h3&gt;&lt;p&gt;Java IO 方式有很多种，基
      
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】阻塞队列 与 线程池</title>
    <link href="http://chaooo.github.io/article/20191014.html"/>
    <id>http://chaooo.github.io/article/20191014.html</id>
    <published>2019-10-14T15:04:54.000Z</published>
    <updated>2019-11-20T14:53:44.150Z</updated>
    
    <content type="html"><![CDATA[<ul><li>池和队列的关系<ul><li>线程池或者数据库连接池，都有最大限制。如果超出了限制数量，则新进来的申请连接都要放入额外的<strong>队列里</strong>，等到池空出来时，从队列中取出连接放进池里。<a id="more"></a></li></ul></li></ul><h3 id="1-BlockingQueue（阻塞队列）"><a href="#1-BlockingQueue（阻塞队列）" class="headerlink" title="1. BlockingQueue（阻塞队列）"></a>1. BlockingQueue（阻塞队列）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue接口</span><br><span class="line">    |———— BlockingQueue接口</span><br><span class="line">        |———— ArrayBlockingQueue类</span><br><span class="line">        |———— DelayQueue类</span><br><span class="line">        |———— LinkedBlockingQueue类</span><br><span class="line">        |———— PriorityBlockingQueue类</span><br><span class="line">        |———— SynchronousQueue类</span><br></pre></td></tr></table></figure><ul><li><code>BlockingQueue</code>继承了<code>Queue</code>接口，提供了一些阻塞方法，主要作用如下：<ul><li>当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）；</li><li>当线程从队列中取元素（删除队列元素）时，如果队列为空，则阻塞线程，直到队列有元素；</li></ul></li><li><code>BlockingQueue</code>在<code>Queue</code>方法基础上增加了两类和阻塞相关的方法：<code>put(e)</code>、<code>take()</code>；<code>offer(e, time, unit)</code>、<code>poll(time, unit)</code>。</li></ul><table><thead><tr><th>操作类型</th><th>抛出异常</th><th>返回特殊值</th><th>阻塞线程</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>读取</td><td>element()</td><td>peek()</td><td>/</td><td>/</td></tr></tbody></table><ul><li><strong><code>put(e)</code></strong>和<strong><code>take()</code></strong>方法会一直阻塞调用线程，直到线程被中断或队列状态可用；</li><li><strong><code>offer(e, time, unit)</code></strong>和<strong><code>poll(time, unit)</code></strong>方法会限时阻塞调用线程，直到超时或线程被中断或队列状态可用。</li><li>阻塞队列主要用在生产者/消费者的场景</li></ul><h4 id="1-1-ArrayBlockingQueue"><a href="#1-1-ArrayBlockingQueue" class="headerlink" title="1.1 ArrayBlockingQueue"></a>1.1 ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code>是一个有边界的阻塞队列，它的内部实现是一个数组。</p><ul><li>有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</li><li><code>ArrayBlockingQueue</code>是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</li></ul><h4 id="1-2-DelayQueue"><a href="#1-2-DelayQueue" class="headerlink" title="1.2 DelayQueue"></a>1.2 DelayQueue</h4><p><code>DelayQueue</code>阻塞的是其内部元素，<code>DelayQueue</code>中的元素必须实现<code>java.util.concurrent.Delayed</code>接口，<code>Delayed</code>接口继承了<code>Comparable</code>接口，这是因为<code>DelayedQueue</code>中的元素需要进行排序，一般情况，我们都是按元素过期时间的优先级进行排序。</p><ul><li><code>DelayQueue</code>应用场景：定时关闭连接、缓存对象，超时处理等</li></ul><h4 id="1-3-LinkedBlockingQueue"><a href="#1-3-LinkedBlockingQueue" class="headerlink" title="1.3 LinkedBlockingQueue"></a>1.3 LinkedBlockingQueue</h4><p><code>LinkedBlockingQueue</code>阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。</p><ul><li>说是无边界，其实是采用了默认大小为<code>Integer.MAX_VALUE</code>的容量 。它的内部实现是一个链表。</li><li>和<code>ArrayBlockingQueue</code>一样，<code>LinkedBlockingQueue</code> 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</li></ul><h4 id="1-4-PriorityBlockingQueue"><a href="#1-4-PriorityBlockingQueue" class="headerlink" title="1.4 PriorityBlockingQueue"></a>1.4 PriorityBlockingQueue</h4><p><code>PriorityBlockingQueue</code>是一个没有边界的队列，它的排序规则和<code>java.util.PriorityQueue</code>一样。需要注意，<code>PriorityBlockingQueue</code>中允许插入null对象。</p><ul><li>所有插入<code>PriorityBlockingQueue</code>的对象必须实现<code>java.lang.Comparable</code>接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。</li><li>从<code>PriorityBlockingQueue</code>获得一个迭代器<code>Iterator</code>，但这个迭代器并不保证按照优先级顺序进行迭代。</li></ul><h4 id="1-5-SynchronousQueue"><a href="#1-5-SynchronousQueue" class="headerlink" title="1.5 SynchronousQueue"></a>1.5 SynchronousQueue</h4><p><code>SynchronousQueue</code>队列内部仅允许容纳一个元素。</p><ul><li>当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</li></ul><h3 id="2-Callable-amp-Future"><a href="#2-Callable-amp-Future" class="headerlink" title="2. Callable &amp; Future"></a>2. Callable &amp; Future</h3><p><code>Callable</code>与<code>Runnable</code>的功能大致相似，<code>Callable</code>功能强大一些，就是被线程执行后，可以返回值，并且能抛出异常。</p><ul><li><code>Runnable</code>接口只有一个<code>run()</code>方法，实现类重写<code>run</code>方法，把一些费时操作写在其中，然后使用某个线程去执行该<code>Runnable</code>实现类即可实现多线程。</li><li><code>Callable</code>是一个泛型接口只有一个<code>call()</code>方法，返回的类型就是创建<code>Callable</code>传进来的V类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Callable</code>一般是和<code>ExecutorService</code>配合来使用的，在<code>ExecutorService</code>接口中声明了若干个<code>submit</code>方法的重载版本</p></blockquote><h4 id="2-1-Future-amp-FutureTask"><a href="#2-1-Future-amp-FutureTask" class="headerlink" title="2.1 Future &amp; FutureTask"></a>2.1 Future &amp; FutureTask</h4><p><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的<strong>执行结果</strong>进行取消、查询是否完成、获取结果。必要时可以通过<code>get</code>方法获取执行结果，该方法会阻塞直到任务返回结果。</p><ul><li>也就是说<code>Future</code>提供了三种功能：<ol><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ol></li><li>在<code>Future</code>接口中声明了5个方法：<strong><code>cancel</code></strong>、<strong><code>isCancelled</code></strong>、<strong><code>isDone</code></strong>、<strong><code>get</code></strong><ul><li><code>boolean</code> <strong><code>cancel(boolean mayInterruptIfRunning)</code></strong>;//用来取消任务，参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务。<ul><li>如果取消已经完成的任务会返回<code>false</code>；如果任务还没有执行会返回<code>true</code>；</li><li>如果任务正在执行，则返回<code>mayInterruptIfRunning</code>设置的值(<code>true/false</code>)；</li></ul></li><li><code>boolean</code> <strong><code>isCancelled()</code></strong>;//任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li><code>boolean</code> <strong><code>isDone()</code></strong>;//任务是否已经完成，若任务完成，则返回true；</li><li><code>V</code> <strong><code>get()</code></strong>;//获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li><code>V</code> <strong><code>get(long timeout, TimeUnit unit)</code></strong>;//获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul></li></ul><blockquote><p><code>Future</code>可以得到别的线程任务方法的返回值。<code>Future</code>是一个接口,引用对象指向的实际是<strong>FutureTask</strong>。</p></blockquote><h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3. FutureTask"></a>3. FutureTask</h3><p><strong><code>FutureTask</code></strong>的父类是<code>RunnableFuture</code>，而<code>RunnableFuture</code>继承了<code>Runnbale</code>和<code>Futrue</code>这两个接口</p><ul><li>从<code>FutureTask</code>构造方法可以了解到：<ol><li><code>FutureTask</code>最终都是执行<code>Callable</code>类型的任务。</li><li>如果构造函数参数是<code>Runnable</code>，会被<code>Executors.callable</code>方法转换为<code>Callable</code>类型。</li><li><code>Executors.callable</code>方法直接返回一个<code>RunnableAdapter</code>实例。</li><li><code>RunnableAdapter</code>是<code>FutureTask</code>的一个静态内部类并且实现了<code>Callable</code>，也就是说<code>RunnableAdapter</code>是<code>Callable</code>子类。</li><li><code>RunnableAdapter</code>的<code>call</code>方法实现代码是，执行<code>Runnable</code>的<code>run</code>方法，并返回构造<code>FutureTask</code>传入<code>result</code>参数。</li></ol></li><li><code>FutureTask</code>总结：<ul><li><code>FutureTask</code>实现了两个接口，<code>Runnable</code>和<code>Future</code>，所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值，这个组合的好处：假设有一个很费时逻辑需要计算并且返回这个值，同时这个值不是马上需要，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过<code>Future</code>得到！</li></ul></li></ul><blockquote><p>注意：</p><ul><li>通过<code>Executor</code>执行线程任务都是以<code>Callable</code>形式，如果传入<code>Runnable</code>都会转化为<code>Callable</code>。</li><li>通过<code>new Thread(runnable)</code>，只能是<code>Runnable</code>子类形式。</li></ul></blockquote><h3 id="4-Fork-Join"><a href="#4-Fork-Join" class="headerlink" title="4. Fork/Join"></a>4. Fork/Join</h3><p>从<code>JDK1.7</code>开始，Java提供<code>Fork/Join</code>框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。</p><ul><li>主要有两步：任务切分 -&gt; 结果合并<ol><li>第一步<strong><code>分割任务</code></strong>。首先我们需要有一个 <code>fork</code> 类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</li><li>第二步执行任务并<strong><code>合并结果</code></strong>。分割的子任务分别放在<strong>双端队列</strong>里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li></ol></li><li>工作窃取算法（<code>work-stealing</code>）是指某个线程从其他队列里窃取任务来执行。</li><li><code>Fork/Join</code> 使用两个类来完成以上两个步骤：<ol><li><strong><code>ForkJoinTask</code></strong>：我们要使用 <code>ForkJoin</code> 框架，必须首先创建一个 <code>ForkJoin</code> 任务。它提供在任务中执行 <code>fork()</code> 和 <code>join()</code> 操作的机制，通常情况下我们不需要直接继承 <code>ForkJoinTask</code> 类，而只需要继承它的子类，<code>Fork/Join</code> 框架提供了以下两个子类：<ul><li><code>RecursiveAction</code>：用于没有返回结果的任务。</li><li><code>RecursiveTask</code>：用于有返回结果的任务。</li></ul></li><li><strong><code>ForkJoinPool</code></strong>：<code>ForkJoinTask</code> 需要通过 <code>ForkJoinPool</code> 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li></ol></li></ul><h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5. 线程池"></a>5. 线程池</h3><p>线程池可以看作是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。</p><ul><li>一个线程池包括以下四个基本组成部分：<ol><li>线程池管理器（<code>ThreadPool</code>）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li><li>工作线程（<code>PoolWorker</code>）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li><li>任务接口（<code>Task</code>）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li><li>任务队列（<code>taskQueue</code>）：用于存放没有处理的任务。提供一种缓冲机制。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Executor接口</span><br><span class="line">    |———— ExecutorService接口</span><br><span class="line">        |———— AbstractExecutorService抽象类</span><br><span class="line">            |———— ForkJoinPool类</span><br><span class="line">            |———— ThreadPoolExecutor类</span><br><span class="line">        |———— ScheduledExecutorService接口</span><br><span class="line">            |———— ScheduledThreadPoolExecutor类</span><br><span class="line">Executors类</span><br></pre></td></tr></table></figure><h4 id="5-1-通过Executors工厂类中的六个静态方法创建线程池"><a href="#5-1-通过Executors工厂类中的六个静态方法创建线程池" class="headerlink" title="5.1 通过Executors工厂类中的六个静态方法创建线程池"></a>5.1 通过Executors工厂类中的六个静态方法创建线程池</h4><p>六大静态方法创建的<code>ThreadPoolExecutor</code>对象，返回的父接口的引用，即返回的<code>ExecutorService</code>的引用。六大静态方法内部都是直接或间接调用<code>ThreadPoolExecutor</code>类的构造方法创建线程池对象。</p><ol><li><code>newCachedThreadPool(ThreadPoolExecutor)</code>：创建一个可缓存的线程池<ul><li>如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）,<code>maximumPoolSize</code>最大可以至(<code>Integer.MAX_VALUE</code>),若达到该上限,直接OOM。</li></ul></li><li><code>newFixedThreadPool(ThreadPoolExecutor)</code>：创建固定大小的线程池。<ul><li>每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li></ul></li><li><code>newSingleThreadExecutor(ThreadPoolExecutor)</code>：创建一个单线程的线程池。<ul><li>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务,保证按任务的提交顺序依次执行。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li></ul></li><li><code>newScheduledThreadPool(ScheduledThreadPoolExecutor)</code>：创建一个支持定时及周期性任务执行的线程池。<ul><li>线程数最大至<code>Integer.MAX_ VALUE</code>,存在OOM风险,不回收工作线程.</li></ul></li><li><code>newSingleThreadScheduledExecutor(ScheduledThreadPoolExecutor)</code>：创建一个单线程用于定时以及周期性执行任务的需求。</li><li><code>newWorkStealingPool(ForkJoinPool)</code>：创建一个工作窃取<ul><li>JDK8 引入,创建持有足够线程的线程池支持给定的并行度;并通过使用多个队列减少竞争;</li></ul></li></ol><blockquote><p>Executors返回的线程池对象的弊端：</p><ol><li><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>：<ul><li>允许的<strong>请求队列长度</strong>为<code>Integer.MAX_VALUE</code>，可能会<strong>堆积大量的请求</strong>，从而导致OOM。</li></ul></li><li><code>CachedThreadPool</code>：<ul><li>允许的<strong>创建线程数量</strong>为<code>Integer.MAX_VALUE</code>，可能会<strong>创建大量的线程</strong>，从而导致OOM。</li></ul></li></ol></blockquote><h4 id="5-2-通过ThreadPoolExecutor构造方法创建线程池"><a href="#5-2-通过ThreadPoolExecutor构造方法创建线程池" class="headerlink" title="5.2 通过ThreadPoolExecutor构造方法创建线程池"></a>5.2 通过<code>ThreadPoolExecutor</code>构造方法创建线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,   //核心线程数，包括空闲线程</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, //线程空闲时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,      //时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//缓存队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,      //线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler  //拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? </span><br><span class="line">        <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-1-corePoolSize-核心线程数量"><a href="#5-2-1-corePoolSize-核心线程数量" class="headerlink" title="5.2.1 corePoolSize(核心线程数量)"></a>5.2.1 corePoolSize(核心线程数量)</h5><ul><li><code>corePoolSize</code>的设置非常关键：<ul><li><code>=0</code>：则任务执行完之后,没有任何请求进入时销毁线程池的线程</li><li><code>&gt;0</code>：即使本地任务执行完毕,核心线程也不会被销毁</li><li>设置过大会浪费资源; 设置过小会导致线程频繁地创建或销毁</li></ul></li><li>若设置了<code>allowCoreThreadTimeOut</code>这个参数,当提交一个任务到线程池时,若<code>线程数量(包括空闲线程)小于corePoolSize</code>,线程池会创建一个新线程放入<code>works(一个HashSet)</code>中执行任务,等到需要执行的任务数大于线程池基本大小时就不再创建,会尝试放入等待队列<code>workQueue</code>；如果调用线程池的<code>prestartAllCoreThreads()</code>,线程池会提前创建并启动所有核心线程</li></ul><h5 id="5-2-2-maximumPoolSize（线程池最大线程数）"><a href="#5-2-2-maximumPoolSize（线程池最大线程数）" class="headerlink" title="5.2.2 maximumPoolSize（线程池最大线程数）"></a>5.2.2 maximumPoolSize（线程池最大线程数）</h5><ul><li><code>maximumPoolSize</code>表示线程池能够容纳同时执行的最大线程数,必须&gt;=1.</li><li>若队列满,并且已创建的线程数小于最大线程数,则线程池会再创建新的线程放入<code>works</code>中执行任务,<code>CashedThreadPool</code>的关键,固定线程数的线程池无效</li><li>如果<code>maximumPoolSize = corePoolSize</code>,即是固定大小线程池.</li><li>若使用了无界任务队列,这个参数就没什么效果</li></ul><h5 id="5-2-3-keepAliveTime（线程池中的线程空闲时间）"><a href="#5-2-3-keepAliveTime（线程池中的线程空闲时间）" class="headerlink" title="5.2.3 keepAliveTime（线程池中的线程空闲时间）"></a>5.2.3 keepAliveTime（线程池中的线程空闲时间）</h5><ul><li>线程没有任务执行时最多保持多久时间终止（线程池的工作线程空闲后，保持存活的时间)</li><li>如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率</li><li>当空闲时间达到<code>keepAliveTime</code>时,线程会被销毁,直到只剩下<code>corePoolSize</code>个线程;避免浪费内存和句柄资源.</li><li>在默认情况下,当线程池的线程数大于<code>corePoolSize</code>时,<code>keepAliveTime</code>才起作用.</li><li>但是当<code>ThreadPoolExecutor</code>的<code>allowCoreThreadTimeOut=true</code>时,核心线程超时后也会被回收.</li></ul><h5 id="5-2-4-TimeUnit（时间单位）"><a href="#5-2-4-TimeUnit（时间单位）" class="headerlink" title="5.2.4 TimeUnit（时间单位）"></a>5.2.4 TimeUnit（时间单位）</h5><ul><li>keepAliveTime的时间单位通常是<code>TimeUnit.SECONDS</code></li><li>可选的单位：天(<code>DAYS</code>)、小时(<code>HOURS</code>)、分钟(<code>MINUTES</code>)、毫秒(<code>MILLISECONDS</code>)、微秒(<code>MICROSECONDS</code>，千分之一毫秒) 和 纳秒(<code>NANOSECONDS</code>，千分之一微秒)</li></ul><h5 id="5-2-5-workQueue（缓存队列）"><a href="#5-2-5-workQueue（缓存队列）" class="headerlink" title="5.2.5 workQueue（缓存队列）"></a>5.2.5 workQueue（缓存队列）</h5><ul><li>存储待执行任务的阻塞队列，这些任务必须是<code>Runnable</code>的对象（如果是<code>Callable</code>对象，会在<code>submit</code>内部转换为<code>Runnable</code>对象） </li><li>当请求的线程数大于<code>maximumPoolSize</code>时,线程进入<code>BlockingQueue</code>.</li><li>可以选择以下几个阻塞队列:<ul><li><code>LinkedBlockingQueue</code>:一个基于链表结构的阻塞队列,此队列按<code>FIFO</code>排序元素,吞吐量通常要高于<code>ArrayBlockingQueue</code>.静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列</li><li><code>SynchronousQueue</code>:一个不存储元素的阻塞队列.每个插入操作必须等到另一个线程调用移除操作,否则插入操作一直处于阻塞状态,吞吐量通常要高于<code>LinkedBlockingQueue</code>,静态工厂方法<code>Executors.newCachedThreadPoo</code>l使用了这个队列</li></ul></li></ul><h5 id="5-2-6-threadFactory-（线程工厂）"><a href="#5-2-6-threadFactory-（线程工厂）" class="headerlink" title="5.2.6 threadFactory （线程工厂）"></a>5.2.6 threadFactory （线程工厂）</h5><ul><li>用于设置创建线程的工厂;</li><li>线程池的命名是通过增加组名前缀来实现的，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li><li>在虚拟机栈分析时,就可以知道线程任务是由哪个线程工厂产生的.</li></ul><h5 id="5-2-7-RejectedExecutionHandler（拒绝策略）"><a href="#5-2-7-RejectedExecutionHandler（拒绝策略）" class="headerlink" title="5.2.7 RejectedExecutionHandler（拒绝策略）"></a>5.2.7 RejectedExecutionHandler（拒绝策略）</h5><ul><li>当队列和线程池都满,说明线程池饱和,必须采取一种策略处理提交的新任务；策略默认<strong><code>AbortPolicy</code></strong>,表无法处理新任务时抛出异常</li><li>当超过参数<code>workQueue</code>的任务缓存区上限的时候,就可以通过该策略处理请求,这是一种简单的限流保护.</li><li>友好的拒绝策略可以是如下三种:<ol><li>保存到数据库进行削峰填谷;在空闲时再提取出来执行</li><li>转向某个提示页面</li><li>打印日志</li></ol></li><li><code>AbortPolicy</code>：丢弃任务，抛出<code>RejectedExecutionException</code></li><li><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务,有反馈机制，使任务提交的速度变慢）。</li><li><code>DiscardOldestPolicy</code>：若没有发生shutdown,尝试丢弃队列里最近的一个任务,并执行当前任务, 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务</li><li><code>DiscardPolicy</code>:不处理,丢弃掉, 拒绝执行，不抛异常 </li><li>当然,也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略.如记录日志或持久化存储不能处理的任务</li></ul><h4 id="5-3-自定义一个ThreadPoolExecutor线程池"><a href="#5-3-自定义一个ThreadPoolExecutor线程池" class="headerlink" title="5.3 自定义一个ThreadPoolExecutor线程池"></a>5.3 自定义一个ThreadPoolExecutor线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">5</span>, <span class="comment">//核心线程数</span></span><br><span class="line">    Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="number">60</span>,<span class="comment">//线程空闲时间</span></span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.setName(<span class="string">"order-thread"</span>);<span class="comment">//设置有意义的线程名字</span></span><br><span class="line">            <span class="keyword">if</span>(t.isDaemon()) &#123;<span class="comment">//若是守护线程将其释放</span></span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.NORM_PRIORITY != t.getPriority()) &#123;</span><br><span class="line">                <span class="comment">//恢复线程优先级</span></span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            System.err.println(<span class="string">"拒绝策略:"</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><h4 id="5-3-1-线程池执行流程"><a href="#5-3-1-线程池执行流程" class="headerlink" title="5.3.1 线程池执行流程"></a>5.3.1 线程池执行流程</h4><ul><li>要求 线程池有上限，使用有限队列</li></ul><ol><li>当线程池核心线程数量用完，先扔进队列</li><li>队列也用完后，看最大线程数量</li><li>最大线程数量用完后，走拒绝策略</li><li>拒绝策略可以打印一些日志，做一些补偿</li><li>线程池用完一定要优雅的关闭</li></ol><blockquote><p>线程池要统一管理，不要用Executors工厂类，要用ThreadPoolExecutor自定义线程池</p></blockquote><h4 id="5-3-2-线程池配置-核心线程数量"><a href="#5-3-2-线程池配置-核心线程数量" class="headerlink" title="5.3.2 线程池配置-核心线程数量"></a>5.3.2 线程池配置-核心线程数量</h4><p>线程CPU时间所占比例越高，需要越少线程(CPU密集)。线程等待时间所占比例越高，需要越多线程(IO密集)。</p><ol><li><strong>CPU密集型</strong>：内存运算、不涉及IO操作等<ul><li>设置线程数为：<code>CPU核数+1</code> </li></ul></li><li><strong>IO密集型</strong>：数据读取、存取、数据库操作、持久化操作等<ul><li>最佳线程数目：<code>CPU核数/(1-阻塞系数)</code> 这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9。</li></ul></li></ol><blockquote><p>java.lang.<code>Runtime.availableProcessors()</code> 方法返回到Java虚拟机的可用的处理器数量(CPU核数)。此值可能会改变在一个特定的虚拟机调用。应用程序可用处理器的数量是敏感的，因此偶尔查询该属性，并适当地调整自己的资源使用情况.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;池和队列的关系&lt;ul&gt;
&lt;li&gt;线程池或者数据库连接池，都有最大限制。如果超出了限制数量，则新进来的申请连接都要放入额外的&lt;strong&gt;队列里&lt;/strong&gt;，等到池空出来时，从队列中取出连接放进池里。
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】AQS框架 与 锁框架（JUC.locks）</title>
    <link href="http://chaooo.github.io/article/20191010.html"/>
    <id>http://chaooo.github.io/article/20191010.html</id>
    <published>2019-10-10T15:00:24.000Z</published>
    <updated>2019-11-07T13:55:58.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-AQS（队列同步器）"><a href="#1-AQS（队列同步器）" class="headerlink" title="1. AQS（队列同步器）"></a>1. AQS（队列同步器）</h3><p><code>AbstractQueuedSynchronizer</code>：队列同步器，简称<code>AQS</code>。</p><ul><li><code>AQS</code>维护了一个<code>volatile int</code><strong><code>state</code></strong>(代表资源共享变量) 和一个<strong><code>FIFO</code>线程等待队列</strong>(多线程争用资源被阻塞时会进入此队列)。</li><li><code>AQS</code>定义了两种资源共享方式：<code>Exclusive</code>(独占)，<code>Share</code>(共享)<a id="more"></a></li><li><code>isHeldExclusively</code>方法：该线程是否正在独占资源</li><li><code>tryAcquire</code>/<code>tryRelease</code>：独占的方式尝试获取和释放资源</li><li><code>tryAcquireShared</code>/<code>tryReleaseShared</code>：共享的方式尝试获取和释放资源</li></ul><p>整个框架的核心就是<strong>如何管理线程阻塞队列</strong>，该队列是严格的<code>FIFO</code>队列，因此不支持线程优先级的同步。</p><ul><li><code>AQS</code>只有一个同步队列，可以有多个条件队列。<ul><li>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，同步队列选择了<strong><code>CLH</code></strong>作为实现的基础。</li><li>条件队列：<code>AQS</code>框架提供了一个<code>ConditionObject</code>类，给维护独占同步的类以及实现<code>Lock</code>接口的类使用。</li></ul></li><li>使用<code>Node</code>实现<strong><code>FIFO</code>双向队列</strong>，可以用于构建锁 或 其他同步装置的基础框架</li><li>内部有一个int变量表示的<strong><code>同步状态</code></strong>(同步状态通过<strong><code>getState</code></strong>、<strong><code>setState</code></strong>、<strong><code>compareAndSetState</code></strong>来维护，同时这三个方法能够保证线程安全)</li><li><code>AQS</code>是个<strong>抽象类</strong>（但没有抽象方法），同步组件一般通过维护<code>AQS</code>的<strong>继承子类来实现</strong>。</li><li><code>AQS</code><strong>既</strong>支持独占地获取同步状态(<strong>排它锁</strong>)，<strong>又</strong>支持共享地获取同步状态(<strong>共享锁</strong>)，从而实现不同类型的组件。</li><li><code>AQS</code>是<strong>基于模板方法</strong>，同步组件需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</li></ul><blockquote><p><code>Synchronizer</code>(同步器)：是一个对象，它根据本身的状态调节线程的控制流。常见类型的<code>Synchronizer</code>包括信号量、关卡和闭锁。</p></blockquote><h3 id="2-CountDownLatch（倒计时闭锁）"><a href="#2-CountDownLatch（倒计时闭锁）" class="headerlink" title="2. CountDownLatch（倒计时闭锁）"></a>2. CountDownLatch（倒计时闭锁）</h3><ul><li>闭锁(<code>latch</code>)是一种<code>Synchronizer</code>，它可以延迟线程的进度直到线程达到<strong>终止状态</strong>。</li><li><strong><code>CountDownLatch</code></strong>(倒计时闭锁)是一个灵活的闭锁实现。</li><li><code>CountDownLatch</code>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。</li><li><code>CountDownLatch</code><strong>原理</strong>：是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得<code>减1</code>。当计数器到达<code>0</code>时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。<ul><li><code>await()</code>，阻塞程序继续执行</li><li><code>countDown()</code>，计数器的值<code>减1</code>，当计数器值减至<code>零</code>时，所有因调用<code>await()</code>方法而处于等待状态的线程就会继续往下执行。</li></ul></li><li>计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用<code>CycliBarrier</code></li></ul><blockquote><p><code>CountDownLatch</code>使用场景：应用初始化</p></blockquote><h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><ul><li><strong><code>Semaphore</code></strong>(信号量)：用来<strong>控制同时访问</strong>特定资源的线程<strong>数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。</li><li><code>Semaphore</code><strong>原理</strong>：线程需要通过<code>acquire()</code>方法获取许可，而<code>release()</code>释放许可。如果许可数达到最大活动数，那么调用<code>acquire()</code>之后，便进入等待队列，等待已获得许可的线程释放许可，从而使得多线程能够合理的运行。<ul><li><code>acquire()</code>：获取权限，其底层实现与<code>CountDownLatch.countdown()</code>类似;</li><li><code>release()</code>：释放权限，其底层实现与<code>acquire()</code>是一个互逆的过程。</li></ul></li></ul><blockquote><p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。</p></blockquote><h3 id="4-CyclicBarrier（同步屏障）"><a href="#4-CyclicBarrier（同步屏障）" class="headerlink" title="4. CyclicBarrier（同步屏障）"></a>4. CyclicBarrier（同步屏障）</h3><ul><li><strong><code>CyclicBarrier</code></strong>(同步屏障)：可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所有被阻塞的线程才能继续执行。</li><li><code>CyclicBarrier</code>类似于<code>CountDownLatch</code>，它也是通过计数器来实现的。但是相比于<code>CountDownLatch</code>功能更加强大。</li><li><code>CyclicBarrier</code><strong>原理</strong>：当某个线程调用<code>await</code>方法时，该线程进入等待状态，且计数器加1，当计数器的值达到设置的初始值时，所有因调用<code>await</code>进入等待状态的线程被唤醒，继续执行后续操作。因为<code>CycliBarrier</code>在释放等待线程后可以重用，所以称为循环<code>barrier</code>。</li></ul><h4 id="4-1-CountDownLatch-和-CyclicBarrier-对比"><a href="#4-1-CountDownLatch-和-CyclicBarrier-对比" class="headerlink" title="4.1 CountDownLatch 和 CyclicBarrier 对比"></a>4.1 CountDownLatch 和 CyclicBarrier 对比</h4><ol><li><code>CountDownLatch</code>描述的是线程(1个或多个)等待其他线程的关系；<code>CyclicBarrier</code>描述的是多个线程相互等待的关系。</li><li><code>CountDownLatch</code>的计数器只能使用一次。而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置并复用。</li><li><code>CountDownLatch</code>方法比较少，操作比较简单，而<code>CyclicBarrier</code>提供的方法更多，比如：<ul><li><code>getNumberWaiting()</code>：获取阻塞的线程数量。</li><li><code>isBroken()</code>：获取阻塞线程的状态，被中断返回<code>true</code>，否则返回<code>false</code>。</li><li><code>CyclicBarrier</code>的构造方法可以传入<code>barrierAction</code>，指定当所有线程都到达时执行的业务功能；</li></ul></li></ol><blockquote><p><code>CyclicBarrier</code>可以用于多线程计算数据，最后合并计算结果的应用场景</p></blockquote><h3 id="5-JUC-locks-锁框架"><a href="#5-JUC-locks-锁框架" class="headerlink" title="5. JUC.locks 锁框架"></a>5. JUC.locks 锁框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks</span><br><span class="line">    |———— Lock接口</span><br><span class="line">        |———— ReentrantLock类</span><br><span class="line">            |———— ReentrantReadWriteLock.ReadLock内部类</span><br><span class="line">            |———— ReentrantReadWriteLock.WriteLock内部类</span><br><span class="line">    |———— Condition接口</span><br><span class="line">    |———— ReadWriteLock接口</span><br><span class="line">        |———— ReentrantReadWriteLock类</span><br><span class="line">    |———— LockSupport类</span><br></pre></td></tr></table></figure><ul><li><strong><code>Lock</code>接口</strong>核心方法：<code>lock()</code>，<code>unlock()</code>，<code>lockInterruptibly()</code>，<code>newCondition()</code>，<code>tryClock()</code><ul><li><code>lock()</code>方法类似于使用<code>synchronized</code>关键字加锁，如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</li><li><code>lockInterruptibly()</code>方法顾名思义，就是如果锁不可用，那么当前正在等待的线程是可以被中断的，这比<code>synchronized</code>关键字更加灵活。</li></ul></li><li><strong><code>Condition</code>接口</strong>核心方法：<code>awit()</code>，<code>signal()</code>，<code>signalAll()</code><ul><li>可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用</li></ul></li><li><strong><code>ReadWriteLock</code>接口</strong>核心方法：<code>readLock()</code>，<code>writeLock()</code><ul><li>获取读锁和写锁，注意除非使用<code>Java8</code>新锁，否则读读不互斥，读写是互斥的</li></ul></li></ul><h3 id="6-ReentrantLock（可重入锁）"><a href="#6-ReentrantLock（可重入锁）" class="headerlink" title="6. ReentrantLock（可重入锁）"></a>6. ReentrantLock（可重入锁）</h3><p><strong><code>ReentrantLock</code>重入锁</strong>使用<strong><code>AQS</code>同步状态</strong>来保存锁重复持有的次数</p><ul><li>底层代码分析：<ul><li><strong><code>state</code></strong>初始化为0，表示未锁定状态</li><li>A线程<code>lock()</code>时，会调用<code>tryAcquire(</code>)独占该锁并将<strong><code>state+1</code></strong></li><li>此后，其他线程再<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到<code>state=0</code>(即释放锁)为止，其他线程才有机会获取该锁</li><li>当然，锁释放之前，A线程自己是可以重复获取此锁的(<code>state</code>会累加)，这就是可重入的概念</li></ul></li></ul><p><code>synchronized</code>实现的锁的重入依赖于<code>JVM</code>，是一种重量级锁。<br><code>ReentrantLock</code>实现了在内存语义上的<code>synchronized</code>，使用<strong><code>AQS</code>同步状态</strong>来保存锁重复持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code>也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。</p><ul><li>公平锁和非公平锁<ul><li>公平锁还是非公平锁取决于<code>ReentrantLock</code>的构造方法，<strong>默认</strong>无参为<strong>非公平锁</strong>(<code>NonfairSync</code>)；含参构造方法，入参<code>true</code>为<code>FairSync</code>，入参<code>false</code>为<code>NonfairSync</code>。</li></ul></li><li>非公平锁中，抢到<code>AQS</code>的同步状态的未必是同步队列的首节点，只要线程通过<code>CAS</code>抢到了同步状态或者在<code>acquire</code>中抢到同步状态，就优先占有锁（插队），而相对同步队列这个严格的<code>FIFO</code>队列来说，所以会被认为是非公平锁。</li><li>公平锁的实现直接调用<code>AQS</code>的<code>acquire</code>方法，<code>acquire</code>中调用<code>tryAcquire</code>。和非公平锁相比，这里不会执行一次<code>CAS</code>，接下来在<code>tryAcquire</code>去抢占锁的时候，也会先调用<code>hasQueuedPredecessors</code>看看前面是否有节点已经在等待获取锁了，如果存在则同步队列的前驱节点优先（排队<code>FIFO</code>）。</li></ul><blockquote><p>虽然公平锁看起来在公平性上比非公平锁好，但是公平锁为此付出了大量线程切换的代价，而非公平锁在锁的获取上不能保证公平，就有可能出现锁饥饿，即有的线程多次获取锁而有的线程获取不到锁，没有大量的线程切换保证了非公平锁的吞吐量。</p></blockquote><h3 id="7-读写锁RRW（ReentrantReadWriteLock）"><a href="#7-读写锁RRW（ReentrantReadWriteLock）" class="headerlink" title="7. 读写锁RRW（ReentrantReadWriteLock）"></a>7. 读写锁RRW（ReentrantReadWriteLock）</h3><p><code>ReentrantLock</code>是独占锁，<code>ReentrantReadWriteLock</code>是读写锁。</p><ul><li>独占锁通过<code>state</code>变量的<code>0</code>和<code>1</code>两个状态来控制是否有线程占有锁，共享锁通过<code>state</code>变量<code>0</code>或者<code>非0</code>来控制多个线程访问。</li><li>读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</li><li><code>ReentrantReadWriteLock</code>的特殊之处其实就是用一个<code>int</code>值表示两种不同的状态（<code>低16</code>位表示写锁的重入次数，<code>高16</code>位表示读锁的使用次数），并通过两个内部类同时实现了<code>AQS</code>的两套<code>API</code>，核心部分与共享/独占锁并无什么区别。</li></ul><blockquote><p><code>ReentrantReadWriteLock</code>也会发生<strong>写请求饥饿</strong>的情况，因为写请求一样会排队，不管是公平锁还是非公平锁，在有读锁的情况下，都<strong>不能保证写锁</strong>一定能获取到，这样只要读锁一直占用，就会发生写饥饿的情况。<code>JDK8</code>中新增的改进读写锁<code>StampedLock</code>可解决饥饿问题</p></blockquote><h3 id="8-LockSupport工具类"><a href="#8-LockSupport工具类" class="headerlink" title="8. LockSupport工具类"></a>8. LockSupport工具类</h3><p>归根结底，<code>LockSupport</code>调用的<code>Unsafe</code>中的<code>native</code>代码：<code>park()</code>，<code>unpark()</code>；</p><ul><li><code>park</code>函数是将当前<code>Thread</code>阻塞，而<code>unpark</code>函数则是将另一个<code>Thread</code>唤醒。</li><li>与<code>Object</code>类的<code>wait/notify</code>机制相比，<code>park/unpark</code>有两个优点：<ol><li>以<code>thread</code>为操作对象更符合阻塞线程的直观定义；</li><li>操作更精准，可以准确地唤醒某一个线程（<code>Object</code>类的<code>notify</code>随机唤醒一个线程，<code>notifyAll</code>唤醒所有等待的线程），增加了灵活性</li></ol></li></ul><blockquote><p><code>park</code>方法的调用一般要在方法一个循环判断体里面。之所以这样做，是为了防止线程被唤醒后，不进行判断而意外继续向下执行，这其实是一种的多线程设计模式-Guarded Suspension。</p></blockquote><h3 id="9-StampedLock（Java8新型锁）"><a href="#9-StampedLock（Java8新型锁）" class="headerlink" title="9. StampedLock（Java8新型锁）"></a>9. StampedLock（Java8新型锁）</h3><p><code>ReentrantReadWriteLock</code>锁具有读写锁，问题在于<code>ReentrantReadWriteLock</code>使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的 ，很容易造成写锁获取不到资源(写请求饥饿)。</p><ul><li><code>Java8</code>引入了一个新的读写锁叫<code>StampedLock</code>. 不仅这个锁更快，而且它提供强大的乐观锁API。这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会阻塞写线程。</li><li><code>StampedLock</code>的主要特点：<ol><li>所有<strong>获取锁</strong>的方法，都返回一个邮戳（<code>Stamp</code>），<code>Stamp</code>为0表示获取失败，其余都表示成功；</li><li>所有<strong>释放锁</strong>的方法，都需要一个邮戳（<code>Stamp</code>），这个<code>Stamp</code>必须是和成功获取锁时得到的<code>Stamp</code>一致；</li><li><code>StampedLock</code>是<strong>不可重入</strong>的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li><li><code>StampedLock</code>有<strong>三种访问模式</strong>：<ul><li><code>Reading</code>（读模式）：功能和ReentrantReadWriteLock的读锁类似</li><li><code>Writing</code>（写模式）：功能和ReentrantReadWriteLock的写锁类似</li><li><code>Optimistic reading</code>（乐观读模式）：这是一种优化的读模式。</li></ul></li><li><code>StampedLock</code>支持读锁和写锁的相互转换</li><li><code>RRW</code>(ReentrantReadWriteLock)中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的；<code>StampedLock</code>提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</li><li>无论写锁还是读锁，都不支持<code>Conditon</code>等待</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-AQS（队列同步器）&quot;&gt;&lt;a href=&quot;#1-AQS（队列同步器）&quot; class=&quot;headerlink&quot; title=&quot;1. AQS（队列同步器）&quot;&gt;&lt;/a&gt;1. AQS（队列同步器）&lt;/h3&gt;&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;：队列同步器，简称&lt;code&gt;AQS&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AQS&lt;/code&gt;维护了一个&lt;code&gt;volatile int&lt;/code&gt;&lt;strong&gt;&lt;code&gt;state&lt;/code&gt;&lt;/strong&gt;(代表资源共享变量) 和一个&lt;strong&gt;&lt;code&gt;FIFO&lt;/code&gt;线程等待队列&lt;/strong&gt;(多线程争用资源被阻塞时会进入此队列)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AQS&lt;/code&gt;定义了两种资源共享方式：&lt;code&gt;Exclusive&lt;/code&gt;(独占)，&lt;code&gt;Share&lt;/code&gt;(共享)
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】JUC并发容器类</title>
    <link href="http://chaooo.github.io/article/20191006.html"/>
    <id>http://chaooo.github.io/article/20191006.html</id>
    <published>2019-10-06T15:04:22.000Z</published>
    <updated>2019-11-07T13:49:18.769Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>java.util.concurrent</code>包中，提供了两种类型的并发集合：一种是阻塞式，另一种是非阻塞式。</p><ul><li>阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程将被阻塞，一直等到该方法可以被成功执行</li><li>非阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程不会被阻塞，而是直接则返回null或抛出异常。<a id="more"></a></li></ul><h3 id="1-线程安全相关容器"><a href="#1-线程安全相关容器" class="headerlink" title="1. 线程安全相关容器"></a>1. 线程安全相关容器</h3><h4 id="1-1-线程安全-同步容器："><a href="#1-1-线程安全-同步容器：" class="headerlink" title="1.1 线程安全-同步容器："></a>1.1 线程安全-同步容器：</h4><ol><li><code>ArrayList</code> –&gt; <code>Vector,Stack</code></li><li><code>HashMap</code> –&gt; <code>HashTable</code>(key、value不能为null)</li><li><code>Collections.synchronizedXXX</code>(List/Set/Map) //本质是对相应的容器进行包装，通过在方法中加synchronized同步锁来实现</li></ol><ul><li>同步容器的同步原理就是在方法上用<code>synchronized</code>修饰。<strong>性能开销大</strong>。</li><li>在<strong>单独</strong>使用里面的方法的时候，可以保证线程安全，但是，<strong>复合操作需要额外加锁</strong>来保证线程安全。</li></ul><h4 id="1-2-线程安全-并发容器："><a href="#1-2-线程安全-并发容器：" class="headerlink" title="1.2 线程安全-并发容器："></a>1.2 线程安全-并发容器：</h4><ol><li><code>ArrayList</code> –&gt; <strong><code>CopyOnWriteArrayList</code></strong>：保证<strong><code>最终一致性</code></strong>，写时复制，适用于<strong><code>读多写少</code></strong>的并发场景</li><li><code>HashSet</code>、<code>TreeSet</code> –&gt; <code>CopyOnWriteArraySet</code>、<code>ConcurrentSkipListSet</code>：</li><li><code>HashMap</code>、<code>TreeMap</code> –&gt; <strong><code>ConcurrentHashMap</code></strong>、<code>ConcurrentSkipListMap</code>：</li></ol><h4 id="1-3-安全共享对象策略"><a href="#1-3-安全共享对象策略" class="headerlink" title="1.3 安全共享对象策略"></a>1.3 安全共享对象策略</h4><ol><li>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有者修改</li><li>共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但不能修改</li><li>线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，其他线程无需额外的同步就可以通过公共接口随意访问它</li><li>被守护对象：被守护对象只能通过获取特定的锁来访问</li></ol><h3 id="2-CopyOnWrite机制"><a href="#2-CopyOnWrite机制" class="headerlink" title="2. CopyOnWrite机制"></a>2. CopyOnWrite机制</h3><p><code>CopyOnWrite</code>（简称COW），是计算机程序设计领域中的一种优化策略，也是一种思想–即<strong>写入时复制思想</strong>。</p><ul><li>在<code>CopyOnWrite</code>中，对容器的修改操作加锁后，通过copy一个新的容器副本来进行修改，修改完毕后将容器替换为新的容器即可。<ul><li>这种方式的好处显而易见：通过copy一个新的容器来进行修改，这样读操作就不需要加锁，可以并发读，因为在读的过程中是采用的旧的容器，即使新容器做了修改对旧容器也没有影响，同时也很好的解决了迭代过程中其他线程修改导致的并发问题。</li></ul></li><li>从JDK1.5开始，<code>java.util.concurrent</code>包中提供了两个<code>CopyOnWrite</code>机制容器，分别为<strong><code>CopyOnWriteArrayList</code></strong>和<strong><code>CopyOnWriteArraySet</code></strong></li><li><code>CopyOnWriteArrayList</code>通过使用<strong><code>ReentrantLock</code>锁</strong>来实现线程安全：<ul><li>在添加、获取元素时，使用<code>getArray()</code>获取底层数组对象，获取此时集合中的数组对象；使用<code>setArray()</code>设置底层数组，将原有数组对象指针指向新的数组对象—-实以此来实现<code>CopyOnWrite</code>副本概念</li><li><strong>添加元素</strong>: 在添加元素之前进行加锁操作，保证数据的原子性。在添加过程中，进行数组复制，修改操作，再将新生成的数组复制给集合中的<code>array</code>属性。最后，释放锁；<ul><li>由于<code>array</code>属性被<code>volatile</code>修饰，所以当添加完成后，其他线程就可以立刻查看到被修改的内容。</li></ul></li><li><strong>获取元素</strong>：在获取元素时，由于<code>array</code>属性被<code>volatile</code>修饰，所以每当获取线程执行时，都会拿到最新的数据。此外，添加线程在进行添加元素时，会将新的数组赋值给<code>array</code>属性，所以在获取线程中并不会因为元素的添加而导致本线程的执行异常。因为获取线程中的<code>array</code>和被添加后的<code>array</code>指向了不同的内存区域。</li></ul></li></ul><blockquote><p>在执行<code>add()</code>时，为什么还要在加锁的同时又copy了一分新的数组对象?</p><ul><li>因为，在<code>add()</code>时候加了锁，首先不会有多个线程同时进到<code>add</code>中去，这一点保证了数组的安全。当在一个线程执行<code>add</code>时，又进行了数组的复制操作，生成了一个新的数组对象，在<code>add</code>后又将新数组对象的指针指向了旧的数组对象指针，注意此时是指针的替换，原来旧的数组对象还存在。这样就实现了，添加方法无论如何操作数组对象，获取方法在获取到集合后，都不会受到其他线程添加元素的影响。</li></ul></blockquote><ul><li><code>CopyOnWrite</code>机制的优缺点<ul><li>优点: <code>CopyOnWriteArrayList</code>保证了数据在多线程操作时的<strong>最终一致性</strong>。</li><li>缺点: 缺点也同样显著，那就是内存空间的浪费：因为在写操作时，进行数组复制，在内存中产生了两份相同的数组。如果数组对象比较大，那么就会造成频繁的GC操作，进而影响到系统的性能；</li></ul></li></ul><blockquote><p>适用场景：<strong>读多写少</strong>的并发场景</p></blockquote><h3 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3. ConcurrentHashMap"></a>3. ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code>容器相较于CopyOnWrite容器在并发加锁粒度上有了更大一步的优化，它通过修改对<strong>单个hash桶元素加锁</strong>的达到了更细粒度的并发控制。</p><ul><li>在底层数据结构上，<code>ConcurrentHashMap</code>和<code>HashMap</code>都使用了数组+链表+红黑树的方式，只是在HashMap的基础上添加了并发相关的一些控制。</li><li>JDK1.8中<strong>取消</strong>了segment分段锁，而采用<code>CAS和synchronized</code>来保证并发安全。<code>synchronized</code>只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。并且初始化操作大大简化，修改为<code>lazy-load</code>形式。</li></ul><h4 id="3-1-put方法过程"><a href="#3-1-put方法过程" class="headerlink" title="3.1 put方法过程"></a>3.1 put方法过程</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>判断键值是否为<code>null</code>，为null抛出异常</li><li>调用<code>spread()</code>方法计算key的<code>hashCode()</code>获得哈希地址</li><li>判断<code>Node[]</code>数组(<code>table</code>)是否为空，若空则进行初始化操作<ul><li>需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong><code>尝试</code></strong>初始化<code>table</code>，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程</li></ul></li><li>使用<code>(容量大小-1 &amp; 哈希地址)</code>计算下标，如果没有碰撞，使用<code>CAS</code>原子性操作放入桶中；插入失败(被别的线程抢先插入了)则进入下次循环。</li><li>如果该下标上的节点(头节点)的哈希地址为<code>-1</code>，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果碰撞了(<code>bucket</code>不为空)且又不需要扩容，则进入到<code>bucket</code>中，且锁住该<code>bucket</code>，其他<code>bucket</code>不影响。</li><li>进入到<code>bucket</code>里面，首先判断这个<code>bucket</code>存储的是红黑树(哈希地址小于0)还是链表。</li><li>如果是链表，则遍历链表，若节点已经存在(<code>key</code>相同)就覆盖旧值，没有找到相同的节点就将新增的节点插入到链表尾部。如果是红黑树，则将节点插入。到这里释放锁。</li><li>判断该<code>bucket</code>上的链表长度是否链表长度超过阀值<code>（TREEIFY_THRESHOLD==8）</code>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树。</li><li>调用<code>addCount()</code>方法，作用是将<code>ConcurrentHashMap</code>的键值对数量+1，还有另一个作用是检查<code>ConcurrentHashMap</code>是否需要扩容。</li></ol><blockquote><p>总结：</p><ul><li>JDK8中的实现也是锁分离的思想，它把锁分的比<code>segment（JDK1.5）</code>更细一些，只要hash不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作<code>CAS</code>插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过<code>synchronized</code>获得头结点锁，进行后续的操作。<strong>性能比segment分段锁又再次提升</strong>。</li></ul></blockquote><h4 id="3-2-ConcurrentHashMap多线程环境下扩容"><a href="#3-2-ConcurrentHashMap多线程环境下扩容" class="headerlink" title="3.2 ConcurrentHashMap多线程环境下扩容"></a>3.2 ConcurrentHashMap多线程环境下扩容</h4><ul><li><code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持<strong>多线程扩容</strong>，而且也<strong>没有进行加锁</strong>，所以实现会变得有点儿复杂。整个扩容操作分为两步：<ul><li>构建一个<code>nextTable</code>，其大小为原来大小的两倍，这个步骤是在单线程环境下完成的</li><li>将原来<code>table</code>里面的内容复制到<code>nextTable</code>中，这个步骤是允许多线程操作的，所以性能得到提升，减少了扩容的时间消耗。</li></ul></li><li>扩容的时机：<ol><li>如果新增节点之后，所在链表的元素个数达到了阈值 8，则会调用treeifyBin方法把链表转换成红黑树，不过在结构转换之前，会对数组长度进行判断：<ul><li>如果数组长度n小于阈值<code>MIN_TREEIFY_CAPACITY</code>，默认是64，则会调用<code>tryPresize</code>方法把数组长度扩大到原来的两倍，并触发<code>transfer</code>方法，重新调整节点的位置。</li></ul></li><li>新增节点之后，会调用<code>addCount</code>方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发<code>transfer</code>方法，重新调整节点的位置。</li></ol></li><li>JDK8的源码里面就引入了一个<strong><code>ForwardingNode</code></strong>类，在一个线程发起扩容的时候，就会改变<code>sizeCtl</code>这个值，其含义如下： <ul><li><code>sizeCtl</code> ：默认为0，用来控制<code>table</code>的初始化和扩容操作，具体应用在后续会体现出来。</li><li><code>-1</code> 代表<code>table</code>正在初始化</li><li><code>-N</code> 表示有<code>N-1</code>个线程正在进行扩容操作</li><li>其余情况：  <ol><li>如果<code>table</code>未初始化，表示<code>table</code>需要初始化的大小。  </li><li>如果<code>table</code>初始化完成，表示<code>table</code>的容量，默认是<code>table</code>大小的<code>0.75</code>倍</li></ol></li></ul></li><li>扩容时候会判断<code>sizeCtl</code>的值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用<code>tabAt</code>方法获得i位置的元素f，初始化一个<code>forwardNode</code>实例<code>fwd</code>，如果<code>f == null</code>，则在<code>table</code>中的i位置放入<code>fwd</code>，否则采用头插法的方式把当前旧<code>table</code>数组的指定任务范围的数据给迁移到新的数组中，然后给旧<code>table</code>原位置赋值<code>fwd</code>。直到遍历过所有的节点以后就完成了复制工作，把<code>table</code>指向<code>nextTable</code>，并更新<code>sizeCtl</code>为新数组大小的<code>0.75</code>倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断<code>head</code>节点是否为<code>forwardNode</code>节点，如果是就<strong>帮助扩容</strong>。</li><li>在<strong>扩容时读写操作</strong>如何进行<ol><li>对于<code>get</code>读操作，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。如果当前链表已经迁移完成，那么头节点会被设置成<code>fwd</code>节点，此时<code>get</code>线程会帮助扩容。</li><li>对于<code>put</code>/<code>remove</code>写操作，如果当前链表已经迁移完成，那么头节点会被设置成<code>fwd</code>节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。 </li></ol></li></ul><blockquote><p>总结: <code>ConcurrentHashMap</code>扩容的原理是新生成原来<code>2倍</code>的数组，然后拷贝旧数组数据到新的数组里面，在多线程情况下，这里面如果注意线程安全问题，在解决安全问题的同时，我们也要关注其效率，这才是并发容器类的最出色的地方。 </p></blockquote><h4 id="3-3-size、mappingCount方法"><a href="#3-3-size、mappingCount方法" class="headerlink" title="3.3 size、mappingCount方法"></a>3.3 size、mappingCount方法</h4><ul><li><code>size</code>和<code>mappingCount</code>方法都是用来统计table的<code>size</code>的</li><li>这两者不同的地方在<code>size</code>返回的是一个<code>int类型</code>，即可以表示<code>size</code>的范围是<code>[-2^31，2^31-1]</code>，超过这个范围就返回int能表示的最大值</li><li><code>mappingCount</code>返回的是一个<code>long类型</code>，即可以表示<code>size</code>的范围是<code>[-2^63，2^63-1]</code>。</li><li>这两个方法都是调用的<code>sumCount()</code>方法实现统计。</li><li><strong>对于<code>size</code>和迭代器是弱一致性</strong><ul><li><code>volatile</code>修饰的数组引用是强可见的，但是其元素却不一定，所以，这导致<code>size</code>的根据<code>sumCount</code>的方法<strong>并不准确</strong>。</li><li>同理<code>Iteritor</code>的迭代器也一样，并不能准确反映最新的实际情况 </li></ul></li></ul><h3 id="4-ConcurrentSkipListMap"><a href="#4-ConcurrentSkipListMap" class="headerlink" title="4. ConcurrentSkipListMap"></a>4. ConcurrentSkipListMap</h3><p><code>ConcurrentSkipListMap</code>内部使用<strong>跳表（<code>SkipList</code>）</strong>这种数据结构来实现，他的结构相对红黑树来说非常简单理解，实现起来也相对简单，而且在理论上它的查找、插入、删除时间复杂度都为<code>log(n)</code>。在并发上，<code>ConcurrentSkipListMap</code>采用无锁的<strong><code>CAS+自旋</code></strong>来控制。</p><ul><li>跳表简单来说就是一个多层的链表，底层是一个普通的链表，然后逐层减少，通常通过一个简单的算法实现每一层元素是下一层的元素的二分之一，这样当搜索元素时从最顶层开始搜索，可以说是另一种形式的二分查找。</li><li><code>ConcurrentSkipListMap</code>的<strong><code>put</code></strong>(插入)：<ul><li>调用<code>doPut()</code>方法，可以分为3大步来理解：</li><li>第一步获取前继节点后通过<code>CAS</code>来插入节点；</li><li>第二步对<code>level</code>层数进行判断，如果大于最大层数，则插入一层；</li><li>第三步插入对应层的数据。整个插入过程全部通过<code>CAS</code>自旋的方式保证并发情况下的数据正确性。</li></ul></li></ul><h3 id="5-volatile-amp-Atmoic-amp-UnSafe"><a href="#5-volatile-amp-Atmoic-amp-UnSafe" class="headerlink" title="5. volatile &amp; Atmoic &amp; UnSafe"></a>5. volatile &amp; Atmoic &amp; UnSafe</h3><ul><li><strong><code>volatile</code></strong>作用：①多线程间的可见性、②阻止指令重排序</li><li><strong><code>Atmoic系列类</code></strong>提供了原子性操作，保障多线程下的安全</li><li><strong><code>UnSafe类</code></strong>的作用：①内存操作、②字段的定位与修改(底层)、③线程挂起与恢复、④<code>CAS</code>操作(乐观锁)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;java.util.concurrent&lt;/code&gt;包中，提供了两种类型的并发集合：一种是阻塞式，另一种是非阻塞式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程将被阻塞，一直等到该方法可以被成功执行&lt;/li&gt;
&lt;li&gt;非阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程不会被阻塞，而是直接则返回null或抛出异常。
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】常见集合类 的 数据结构</title>
    <link href="http://chaooo.github.io/article/20191003.html"/>
    <id>http://chaooo.github.io/article/20191003.html</id>
    <published>2019-10-03T14:53:06.000Z</published>
    <updated>2019-10-30T13:58:11.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合-Collection-Map"><a href="#集合-Collection-Map" class="headerlink" title="集合(Collection/Map)"></a>集合(Collection/Map)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection接口</span><br><span class="line">    |———— List接口</span><br><span class="line">        |———— ArrayList类</span><br><span class="line">        |———— Vector类</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">        |———— Stack类</span><br><span class="line">    |———— Set接口</span><br><span class="line">        |———— HashSet类</span><br><span class="line">        |———— TreeSet类</span><br><span class="line">        |———— LinkedHashSet类</span><br><span class="line">    |———— Queue接口</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">Map接口</span><br><span class="line">    |———— HashMap类</span><br><span class="line">    |———— TreeMap类</span><br><span class="line">    |———— LinkedHashMap类</span><br><span class="line">    |———— Hashtable类</span><br></pre></td></tr></table></figure><h4 id="0-1-List"><a href="#0-1-List" class="headerlink" title="0.1 List"></a>0.1 List</h4><ul><li><strong>Arraylist</strong>： 动态数组</li><li>Vector： 动态数组(线程安全)</li><li><strong>LinkedList</strong>： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><h4 id="0-2-Set"><a href="#0-2-Set" class="headerlink" title="0.2 Set"></a>0.2 Set</h4><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li><li>TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树)</li></ul><h4 id="0-3-Map"><a href="#0-3-Map" class="headerlink" title="0.3 Map"></a>0.3 Map</h4><ul><li><strong>HashMap</strong>： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间</li><li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，<strong>增加了一条双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>Hashtable： 数组+链表(线程安全)，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h4 id="0-4-如何选用集合"><a href="#0-4-如何选用集合" class="headerlink" title="0.4 如何选用集合"></a>0.4 如何选用集合</h4><p>主要根据集合的特点来选用：</p><ul><li>键值对就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.</li><li>只需要存放元素值时，就选用Collection接口下的集合，需要保证元素唯一时选择实现Set接口的集合（TreeSet或HashSet），不需要就选择实现List接口的ArrayList或LinkedList</li></ul><h4 id="0-5-对数公式log-与-时空复杂度"><a href="#0-5-对数公式log-与-时空复杂度" class="headerlink" title="0.5 对数公式log 与 时空复杂度"></a>0.5 对数公式log 与 时空复杂度</h4><ul><li>若<code>a^n = b</code> (a&gt;0,a≠1) 则 <code>n = log(a)b</code> , 如<code>log(2)8 = 3</code>; Java数据结构中log默认以2为底(个人理解,有待考证)</li><li>常用O(1), O(n), O(logn)表示对应算法的时间复杂度, 也用于表示空间复杂度。<ul><li><strong><code>O(1)</code></strong>: 最低的时空复杂度, 无论数据规模多大，都可以在一次计算后找到目标</li><li><strong><code>O(n)</code></strong>: 数据量增大n倍时，耗时增大n倍; 比如常见的遍历算法</li><li><strong><code>O(n^2)</code></strong>: 数据量增大n倍时，耗时增大n的平方倍; 比如冒泡排序，对n个数排序，需要扫描n×n次</li><li><strong><code>o(logn)</code></strong>: 当数据增大n倍时，耗时增大logn倍; 二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标(2^8=256)</li><li><strong><code>O(nlogn)</code></strong>: 同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度</li></ul></li></ul><h4 id="0-6-移位运算符"><a href="#0-6-移位运算符" class="headerlink" title="0.6  移位运算符"></a>0.6  移位运算符</h4><p>按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移) 和 &gt;&gt;&gt;(无符号右移)</p><ul><li><code>左移 &lt;&lt;</code> : 丢弃最高位,0补最低位；左移n位就相当于乘以2的n次方</li><li><code>右移 &gt;&gt;</code> : 符号位不变,高位补上符号位(正数0, 负数1)；右移n位相当于除以2的n次方</li><li><code>无符号右移 &gt;&gt;&gt;</code> : 忽略符号位，0补最高位(补码移位所得)</li></ul><blockquote><ul><li>正数的左移与右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。</li><li>负数的右移，就是补码高位补1,然后按位取反加1即可。</li></ul></blockquote><ul><li>运算规则：<ul><li>左移：高位移出(舍弃)，低位的空位补零；int类型时，每移动1位它的第31位就要被移出并且丢弃；long类型时，每移动1位它的第63位就要被移出并且丢弃；byte和short类型时，将自动把这些类型扩大为int型。</li><li>右移：低位移出(舍弃)，高位的空位补符号位，即正数补0，负数补1；当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。</li><li>无符号右移：补码移位，高位补0；正数和右移表现一致，负数变成了很大的正数；</li></ul></li></ul><h3 id="1-Arraylist"><a href="#1-Arraylist" class="headerlink" title="1. Arraylist"></a>1. Arraylist</h3><p>ArrayList的底层是数组队列，相当于<strong>动态数组</strong>。与数组相比，它的容量能动态增长。在添加大量元素前，应用程序使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p><ul><li><strong>数组</strong>时间复杂度: <strong>插入/删除:O(n)</strong>，<strong>增加(末尾)/随机访问: O(1)</strong></li><li>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的<strong>添加、删除、修改、遍历</strong>等功能</li><li>ArrayList 实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是<strong>快速随机访问</strong></li><li>ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，<strong>能被克隆</strong>。</li><li>ArrayList 实现java.io.Serializable 接口，这意味着ArrayList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>和 Vector 不同，ArrayList 中的操作<strong>不是线程安全的</strong>！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li></ul><h4 id="1-1-ArrayList扩容机制-（重点）"><a href="#1-1-ArrayList扩容机制-（重点）" class="headerlink" title="1.1 ArrayList扩容机制*（重点）"></a>1.1 ArrayList扩容机制*（重点）</h4><ul><li>以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组；当add第一个元素时，才真正分配容量(<strong>默认10</strong>)</li><li>ArrayList在每次增加元素(1个或一组)时，都要调用<code>ensureCapacityInternal()</code>方法来确保足够的容量</li><li>当容量不足以容纳当前的元素个数时，进入<code>grow()</code>方法进行扩容，首先设置新的容量为旧容量的<strong>1.5倍</strong></li><li>若设置后的新容量还不够，则设置新容量为<code>minCapacity</code>(所需最小容量)</li><li>比较新容量是否大于<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)，若大于，再比较<code>minCapacity</code>是否大于<code>MAX_ARRAY_SIZE</code>，若大于，设置新的容量为<code>Integer.MAX_VALUE</code>(Integer最大值)，否则设置新的容量为<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)</li><li>最后用<code>Arrays.copyof()</code>方法将元素拷贝到新的数组</li><li>(第<code>Integer.MAX_VALUE+1</code>次添加元素时，抛出<code>OutOfMemoryError</code>异常)</li></ul><blockquote><p><strong>System.arraycopy()和Arrays.copyOf()方法</strong><br>通过源码发现这两个实现数组复制的方法被广泛使用, 比如插入操作add(int index, E element)方法就很巧妙的用到了 System.arraycopy()方法让数组自己复制自己实现让index开始之后的所有成员后移一个位置</p><ul><li>Arrays.copyOf()内部也是调用了System.arraycopy()方法 </li><li>Arrays.copyOf()是系统自动在内部新建一个数组，并返回该数组</li><li>System.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li></ul></blockquote><h4 id="1-2-ensureCapacity"><a href="#1-2-ensureCapacity" class="headerlink" title="1.2 ensureCapacity"></a>1.2 ensureCapacity</h4><p>ArrayList对外提供了一个<code>ensureCapacity(int n)</code>方法</p><ul><li>最好在<code>add</code>大量元素之前用ensureCapacity方法，以<strong>减少增量重新分配的次数</strong></li><li>ensureCapacity一次性扩容到位，否则在添加大量元素的过程中，一点一点的进行扩容</li></ul><h4 id="1-3-内部类"><a href="#1-3-内部类" class="headerlink" title="1.3 内部类"></a>1.3 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span></span>&#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>ArrayList有四个内部类</p><ul><li>Itr 实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；</li><li>ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法</li><li>Iterator和ListIterator的区别: <ul><li>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</li></ul></li></ul><h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h3><p>LinkedList是基于<strong>双向链表</strong>实现的, 可以在任何位置进行高效地插入和移除操作的有序序列。</p><ul><li>复杂度: <strong>增加(末尾)/删除:O(1)</strong>，<strong>插入/获取: O(n)</strong></li><li>LinkedList 继承AbstractSequentialList的<strong>双向链表</strong>。它也可以被当作堆栈、队列或双端队列进行操作。</li><li>LinkedList 实现 List 接口，能对它进行<strong>队列操作</strong>。</li><li>LinkedList 实现 Deque 接口，即能将LinkedList当作<strong>双端队列</strong>使用。</li><li>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，<strong>能克隆</strong>。</li><li>LinkedList 实现java.io.Serializable接口，这意味着LinkedList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>LinkedList <strong>不是线程安全的</strong>，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法</li></ul><h4 id="2-1-LinkedList底层分析"><a href="#2-1-LinkedList底层分析" class="headerlink" title="2.1 LinkedList底层分析:"></a>2.1 LinkedList底层分析:</h4><p>LinkedList的底层是一个双向链表，链表中挂载着一个个的Node元素；可以从LinkedList的Node内部类看出奥秘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//尾指针</span></span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 数据域（当前节点的值）</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 后继（指向当前一个节点的后一个节点）</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 前驱（指向当前节点的前一个节点）</span></span><br><span class="line">    <span class="comment">// 构造函数，赋值前驱后继</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LinkedList 是基于链表结构实现，所以在类中包含了 first 和 last 两个指针(Node)。</li><li>Node 中包含了上一个节点和下一个节点的引用，这样就构成了双向的链表。</li></ul><h4 id="2-2-LinkedList增删改查"><a href="#2-2-LinkedList增删改查" class="headerlink" title="2.2 LinkedList增删改查"></a>2.2 LinkedList增删改查</h4><ul><li>链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。增加一定会修改modCount。</li><li>通过下标获取某个node的时候(add select)，会根据index处于前半段还是后半段<strong>进行一个折半</strong>，以提升查询效率</li><li>删也一定会修改modCount。 <ul><li>按下标删，也是先根据index找到Node，然后去链表上unlink掉这个Node。 </li><li>按元素删，会先去遍历链表寻找是否有该Node，如果有，去链表上unlink掉这个Node。</li></ul></li><li>改也是先根据index找到Node，然后替换值。不修改modCount。</li><li>CRUD操作里，都涉及到根据index去找到Node的操作。</li></ul><h4 id="2-2-unlink原理"><a href="#2-2-unlink原理" class="headerlink" title="2.2 unlink原理"></a>2.2 unlink原理</h4><ul><li>先判断该节点是否存在上一个节点，即是否有前驱节点。<ul><li>无前驱节点则说明要删除的节点为链表的第一节点，那么只需要把该节点的下一个节点设置为链表的第一个节点。</li><li>有前驱节点则需要把前驱节点的尾部引用指向该节点的下一个节点。</li></ul></li><li>再判断该节点是否存在下一个节点，即是否有后继节点。<ul><li>无后继节点则说明该节点是链表的最后一个节点，那么只需要把该节点前驱节点设置成链表的最后一个节点即可。</li><li>有后继节点则需要把后继节点的头部引用指向该节点的上一个节点。</li></ul></li><li>核心就是在于将要删除的节点的前驱节点尾部指向该节点的后继节点，将要删除的节点的后继节点的头部指向该节点的前驱节点。这样便完成了链表的删除操作。</li></ul><blockquote><p>删除和新增方法的实现基本是对该节点的上一个节点和下一个节点的引用设置，不需要操作其他节点，效率相对较高</p></blockquote><h4 id="2-3-offer与add的区别"><a href="#2-3-offer与add的区别" class="headerlink" title="2.3 offer与add的区别"></a>2.3 offer与add的区别</h4><ul><li>offer属于 offer in interface <strong>Deque</strong>。</li><li>add 属于 add in interface <strong>Collection</strong>。</li><li>当队列为空时候，使用add方法会报错，而offer方法会返回false。</li><li>作为List使用时,一般采用add / get方法来 压入/获取对象。</li><li>作为Queue使用时,才会采用 offer/poll/take等方法作为链表对象时,offer等方法相对来说没有什么意义这些方法是用于支持队列应用的。</li></ul><h4 id="2-2-对比Vector、ArrayList、LinkedList有何区别"><a href="#2-2-对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="2.2 对比Vector、ArrayList、LinkedList有何区别"></a>2.2 对比Vector、ArrayList、LinkedList有何区别</h4><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全</strong>的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据扩容为旧容量的<strong>2倍</strong>。</li><li>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。ArrayList 也是可以根据需要调整容量，在扩容为旧容量的<strong>1.5倍</strong>。</li><li>LinkedList 顾名思义是 Java 提供的双向链表，<strong>不需要扩容</strong>，它也不是线程安全的。LinkedList不支持高效的随机元素访问。</li></ul><h3 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3. HashMap"></a>3. HashMap</h3><p>HashMap是<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的, 用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。</p><ul><li>HashMap继承了AbstractMap类，实现了Map，Cloneable，Serializable接口</li><li>继承 abstractMap，也就是用来减轻实现Map接口的编写负担。</li><li>实现 Cloneable：能够使用Clone()方法，在HashMap中，实现的是<strong>浅层次拷贝</strong>，即对拷贝对象的改变会影响被拷贝的对象。</li><li>实现 Serializable：能够使之<strong>序列化</strong>，即可以将HashMap对象保存至本地，之后可以恢复状态。</li></ul><blockquote><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>，以实现O(logn)时间复杂读查找。</p></blockquote><p>HashMap类中有一个非常重要的字段，就是 Node[] table，即<strong>哈希桶数组</strong>，明显它是一个Node的数组。</p><ul><li>HashMap的实例有两个参数影响其性能:<ul><li>初始容量(默认16)：哈希表中桶的数量</li><li>加载因子(默认0.75)：哈希表在其容量自动增加之前可以达到多满的一种尺度</li></ul></li><li>当哈希表中条目数超出了当前容量*加载因子(其实就是HashMap的实际容量)时，则对该哈希表进行rehash操作，将哈希表扩充至两倍的桶数。</li></ul><h4 id="3-1-HashMap的-put-方法过程-（重点）"><a href="#3-1-HashMap的-put-方法过程-（重点）" class="headerlink" title="3.1 HashMap的 put 方法过程*（重点）"></a>3.1 HashMap的 put 方法过程*（重点）</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>对 Key 求 Hash 值，然后再计算下标。</li><li>如果没有碰撞，直接放入桶中，</li><li>如果碰撞了，若是树节点，就<code>putTreeVal</code>添加元素，若不是就遍历链表插入。</li><li>如果链表长度超过阀值（TREEIFY_THRESHOLD==8），就把链表转成红黑树。</li><li>如果节点已经存在就替换旧值，若未找到则继续</li><li>如果桶满了（容量 * 加载因子），就需要 resize(扩容为原来2倍并重新散列,元素的下标要么不变，要么变为【原下标+原容量】)。</li></ol><h4 id="3-2-HashMap-桶下标计算"><a href="#3-2-HashMap-桶下标计算" class="headerlink" title="3.2 HashMap 桶下标计算"></a>3.2 HashMap 桶下标计算</h4><ul><li><strong>下标</strong>：<code>hash(key) &amp; (table.length - 1)</code></li><li>扰动函数<strong>hash(key)</strong>：(key==null) ? 0 : <code>(key.hashCode()^(key.hashCode() &gt;&gt;&gt; 16))</code></li><li>低16位 和 高 16位 做了一个<strong>异或</strong>得到 hash值 与 (容器长度-1)进行<strong>取模(%)</strong>运算,得到下标。<ul><li>利用位运算代替取模运算，提高程序的计算效率：（当 b=2^n 时，a%b = a &amp; (b-1) ），也是因此，HashMap 才将初始长度设置为 16，且扩容只能是以 2 的倍数（2^n）扩容。</li></ul></li><li>有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以尽可能有效的避免哈希碰撞。</li></ul><blockquote><p>HashMap 的性能表现非常依赖于哈希码的有效性: equals相等，hashCode一定要相等。重写了 hashCode 也要重写 equals。hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</p></blockquote><h4 id="3-3-HashMap-容量、负载因子和树化"><a href="#3-3-HashMap-容量、负载因子和树化" class="headerlink" title="3.3 HashMap 容量、负载因子和树化"></a>3.3 HashMap 容量、负载因子和树化</h4><ul><li>容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。</li><li>如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。</li><li>计算条件：<strong>负载因子 * 容量 &gt; 元素数量</strong>；所以，预先设置的容量需要满足，大于“预估元素数量/负载因子”，同时它是<strong>2的幂数</strong></li><li>容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 <strong>1&lt;&lt;30</strong>，也就是2的30次方</li></ul><h5 id="3-3-1-HashMap-负载因子loadFactor"><a href="#3-3-1-HashMap-负载因子loadFactor" class="headerlink" title="3.3.1 HashMap 负载因子loadFactor"></a>3.3.1 HashMap 负载因子loadFactor</h5><ul><li>loadFactor加载因子是控制数组存放数据的疏密程度，越大越密，越小越稀疏。</li><li>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的<strong>默认值为0.75f</strong>是官方给出的一个比较好的临界值。</li><li>给定的默认容量为16，负载因子为0.75。当数量达到了 16*0.75 = 12 就需要将当前16的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li><li>而对于负载因子，建议：<ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</li><li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul></li></ul><h5 id="3-3-2-HashMap-门限值threshold"><a href="#3-3-2-HashMap-门限值threshold" class="headerlink" title="3.3.2 HashMap 门限值threshold"></a>3.3.2 HashMap 门限值threshold</h5><p><code>threshold = capacity * loadFactor</code>，当<code>Size&gt;=threshold</code>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</p><ul><li>门限值等于(负载因子 x 容量)，如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。</li><li>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="3-3-2-HashMap-树化改造"><a href="#3-3-2-HashMap-树化改造" class="headerlink" title="3.3.2 HashMap 树化改造"></a>3.3.2 HashMap 树化改造</h5><p>树化改造逻辑主要在 putVal 和 <code>treeifyBin</code> 中。</p><ul><li>链表结构（这里叫 bin）的数量大于 <code>TREEIFY_THRESHOLD</code>(默认为8) 时：<ul><li>如果容量小于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64) ，只会进行简单的扩容。</li><li>如果容量大于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64)，则会进行树化改造。</li></ul></li></ul><h4 id="3-4-HashMap-扩容resize"><a href="#3-4-HashMap-扩容resize" class="headerlink" title="3.4 HashMap 扩容resize"></a>3.4 HashMap 扩容resize</h4><ul><li>HashMap扩容条件：<ul><li>元素个数超出了加载因子与当前容量的乘积，并且发生了Hash碰撞</li></ul></li><li>HashMap扩容步骤：<ol><li>创建一个新的Entry空数组，长度是原来的2倍。</li><li>遍历原Entry数组，把所有的Entry重新Hash到新数组里。</li><li>重新散列的元素下标要么【不变】，要么变为【原下标+原容量】，取决于位运算((n - 1) &amp; hash)</li></ol></li></ul><blockquote><p>经过一次扩容处理后，元素会更加均匀的分布在各个桶中，会提升访问效率。<br>但会遍历所有的元素，时间复杂度很高；遍历元素所带来的坏处大于元素在桶中均匀分布所带来的好处。<br>尽量避免进行扩容处理。</p></blockquote><h4 id="3-5-常见的hash算法及冲突的解决"><a href="#3-5-常见的hash算法及冲突的解决" class="headerlink" title="3.5 常见的hash算法及冲突的解决"></a>3.5 常见的hash算法及冲突的解决</h4><p>hash函数，即散列函数。它可以将不定长的输入，通过散列算法转换成一个定长的输出，这个输出就是散列值(不保证唯一)。</p><ul><li>常见Hash算法：<ol><li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址（H(k)=ak+b）。</li><li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址（如一组出生日期，相较于年-月，月-日的差别要大得多，可以降低冲突概率）</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li><li>伪随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</li><li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址（H(k)=k%p, p&lt;=m; p一般取m或素数）。</li></ol></li><li>常见解决hash冲突的方法<ol><li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li><li>开放定址法：即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。</li><li>再哈希法：即发生冲突时，由其他的函数再计算一次哈希值。</li><li>建立公共溢出区：将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。</li></ol></li></ul><blockquote><p>HashMap就是使用链地址法来解决冲突的（JDK1.8增加了红黑树）</p></blockquote><h4 id="3-6-对比Hashtable、HashMap、TreeMap有什么不同"><a href="#3-6-对比Hashtable、HashMap、TreeMap有什么不同" class="headerlink" title="3.6 对比Hashtable、HashMap、TreeMap有什么不同"></a>3.6 对比Hashtable、HashMap、TreeMap有什么不同</h4><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</li><li>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</li><li>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O(log(n))的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集合-Collection-Map&quot;&gt;&lt;a href=&quot;#集合-Collection-Map&quot; class=&quot;headerlink&quot; title=&quot;集合(Collection/Map)&quot;&gt;&lt;/a&gt;集合(Collection/Map)&lt;/h3&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】Redis穿透、击穿、雪崩和数据一致性</title>
    <link href="http://chaooo.github.io/article/20190927.html"/>
    <id>http://chaooo.github.io/article/20190927.html</id>
    <published>2019-09-27T11:15:31.000Z</published>
    <updated>2019-11-04T07:25:49.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。</p><ul><li>解决方案：<ol><li>采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；</li><li>访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</li><li>接口限流与熔断、降级</li><li>使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））</li></ol></li></ul><h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><ul><li>解决方案<ol><li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li><li>建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</li><li>加锁排队，实现同上;</li></ol></li></ul><h3 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h3><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p><ul><li>解决方案<ul><li>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</li></ul></li></ul><h3 id="4-缓存并发竞争"><a href="#4-缓存并发竞争" class="headerlink" title="4. 缓存并发竞争"></a>4. 缓存并发竞争</h3><p>多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）</p><ul><li>解决方案<ol><li>如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。</li><li>如果对这个key操作，要求顺序：<ol><li>分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了）</li><li>利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）</li></ol></li></ol></li></ul><h3 id="5-缓存和数据库一致性解决方案"><a href="#5-缓存和数据库一致性解决方案" class="headerlink" title="5. 缓存和数据库一致性解决方案"></a>5. 缓存和数据库一致性解决方案</h3><h4 id="5-1-并发量、一致性要求都不是很高的场景"><a href="#5-1-并发量、一致性要求都不是很高的场景" class="headerlink" title="5.1 并发量、一致性要求都不是很高的场景"></a>5.1 并发量、一致性要求都不是很高的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，之后再<strong>异步将数据刷回缓存</strong></li><li>读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：实现起来简单，异步刷新，补缺补漏</li><li>缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</li></ol><h4 id="5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）"><a href="#5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）" class="headerlink" title="5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）"></a>5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，监听从库binlog，通过<strong>解析binlog来刷新缓存</strong></li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：容灾</li><li>缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读/写的时候，缓存中的数据已失效，此时又发生了更新）</li></ol><h4 id="5-3-业务只需要达到“最终一致性”要求的场景"><a href="#5-3-业务只需要达到“最终一致性”要求的场景" class="headerlink" title="5.3 业务只需要达到“最终一致性”要求的场景"></a>5.3 业务只需要达到“最终一致性”要求的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的<strong>数据标识</strong>，然后将<strong>数据标识写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：只能达到”最终一致性”</li></ol><h4 id="5-4-强一致性的场景"><a href="#5-4-强一致性的场景" class="headerlink" title="5.4 强一致性的场景"></a>5.4 强一致性的场景</h4><ul><li>写流程：我们把<strong>修改的数据通过Cache_0标记</strong>“正在被修改”，如果<strong>标记成功，写数据库，删除缓存，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识<strong>写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。</li><li>读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-缓存穿透&quot;&gt;&lt;a href=&quot;#1-缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;1. 缓存穿透&quot;&gt;&lt;/a&gt;1. 缓存穿透&lt;/h3&gt;&lt;p&gt;访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Redis" scheme="http://chaooo.github.io/categories/Redis/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】深入学习Redis及集群</title>
    <link href="http://chaooo.github.io/article/20190920.html"/>
    <id>http://chaooo.github.io/article/20190920.html</id>
    <published>2019-09-20T08:19:26.000Z</published>
    <updated>2020-02-14T10:32:51.411Z</updated>
    
    <content type="html"><![CDATA[<p>Redis本质上是一个Key-Value类型的<strong>内存数据库</strong>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。<a id="more"></a>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="1-Redis数据结构及命令操作"><a href="#1-Redis数据结构及命令操作" class="headerlink" title="1. Redis数据结构及命令操作"></a>1. Redis数据结构及命令操作</h3><h4 id="1-1-基本概念及操作"><a href="#1-1-基本概念及操作" class="headerlink" title="1.1 基本概念及操作"></a>1.1 基本概念及操作</h4><ul><li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库；</li><li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；</li><li>select命令切换数据库：select 0-15；</li><li>dbsize：查看当前数据库的key的数量；</li><li>flushdb：清空当前库；</li><li>flushall；通杀全部库；</li></ul><h4 id="1-2-Redis数据结构"><a href="#1-2-Redis数据结构" class="headerlink" title="1.2 Redis数据结构"></a>1.2 Redis数据结构</h4><p>redis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)</p><ol><li>String：set, get, del, append, strlen</li><li>Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall</li><li>List：lpush, rpush, lrange, lpop(删除), rpop, lindex</li><li>Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)</li><li>ZSet：zadd, zrange, zrem</li></ol><h4 id="1-3-Redis键-key-–常用命令介绍"><a href="#1-3-Redis键-key-–常用命令介绍" class="headerlink" title="1.3 Redis键(key)–常用命令介绍"></a>1.3 Redis键(key)–常用命令介绍</h4><ul><li>keys *：查看所有 key ；</li><li>exists key的名字：判断某个 key 是否存在；</li><li>move key dbID（0-15）： 当前库就没有了，被移除了；</li><li>expire key 秒钟： 为给定的 key 设置过期时间；</li><li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；</li><li>type key： 查看你的 key 是什么类型；</li></ul><h3 id="2-Redis持久化"><a href="#2-Redis持久化" class="headerlink" title="2. Redis持久化"></a>2. Redis持久化</h3><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。</p><h4 id="2-1-RDB（Redis-DataBase）"><a href="#2-1-RDB（Redis-DataBase）" class="headerlink" title="2.1 RDB（Redis DataBase）"></a>2.1 RDB（Redis DataBase）</h4><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p><ul><li>开启RDB持久化方式一：save命令，或bgsave(异步)</li><li>开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：<code>redis-server redis.conf</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1     # 900s内至少达到一条写命令</span><br><span class="line">save 300 10    # 300s内至少达至10条写命令</span><br><span class="line">save 60 10000  # 60s内至少达到10000条写命令</span><br></pre></td></tr></table></figure><ul><li><p>RDB的几个优点</p><ul><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li></ul></li><li><p>RDB的几个缺点</p><ul><li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ul></li></ul><h4 id="2-2-AOF-Append-only-file"><a href="#2-2-AOF-Append-only-file" class="headerlink" title="2.2 AOF(Append-only file)"></a>2.2 AOF(Append-only file)</h4><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><ul><li>开启方式：在Redis配置文件redis.conf配置</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes                  # 开启aof机制</span><br><span class="line">appendfilename "appendonly.aof" # aof文件名</span><br><span class="line"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec(每秒写入一次)或no(操作系统处理)</span><br><span class="line">appendfsync always</span><br><span class="line">no-appendfsync-on-rewrite no    # 默认不重写aof文件</span><br><span class="line">dir ~/redis/                    # 保存目录</span><br></pre></td></tr></table></figure><ul><li>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令</li></ul><ul><li>AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li><li>AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。</li><li>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</li></ul><h5 id="2-2-1-AOF文件修复"><a href="#2-2-1-AOF文件修复" class="headerlink" title="2.2.1 AOF文件修复"></a>2.2.1 AOF文件修复</h5><ol><li>备份被写坏的AOF文件</li><li>运行redis-check-aof –fix进行修复</li><li>用diff -u来看下两个文件的差异，确认问题点</li><li>重启redis，加载修复后的AOF文件</li></ol><h3 id="3-Redis的高并发和快速原因"><a href="#3-Redis的高并发和快速原因" class="headerlink" title="3. Redis的高并发和快速原因"></a>3. Redis的高并发和快速原因</h3><ol><li>redis是基于内存的，内存的读写速度非常快；</li><li>redis是单线程的，省去了很多上下文切换线程的时间；</li><li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</li><li>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li><li>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li></ol><h3 id="4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用"><a href="#4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用" class="headerlink" title="4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用"></a>4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用</h3><ol><li>哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。<ol><li>集群监控：负责监控Redis master和slave进程是否正常工作</li><li>消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li><li>故障转移：如果master node挂掉了，会自动转移到slave node上</li><li>配置中心：如果故障转移发生了，通知client客户端新的master地址</li></ol></li><li>复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。<ol><li>从数据库向主数据库发送sync(数据同步)命令。</li><li>主数据库接收同步命令后，会保存快照，创建一个RDB文件。</li><li>当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。</li><li>主数据库将缓冲区的所有写命令发给从服务器执行。</li><li>以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。</li></ol></li></ol><h3 id="5-Redis-主从复制、哨兵和集群这三个有什么区别"><a href="#5-Redis-主从复制、哨兵和集群这三个有什么区别" class="headerlink" title="5. Redis 主从复制、哨兵和集群这三个有什么区别"></a>5. Redis 主从复制、哨兵和集群这三个有什么区别</h3><p>主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。</p><ol><li>主从模式：读写分离，备份，一个Master可以有多个Slaves。</li><li>哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li><li>集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li></ol><h3 id="6-Redis-Cluster集群"><a href="#6-Redis-Cluster集群" class="headerlink" title="6. Redis Cluster集群"></a>6. Redis Cluster集群</h3><p>Redis Cluster，是Redis 3.0开始引入的分布式存储方案。<br>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p><ul><li>集群的作用：<ol><li>数据分区：数据分区(或称数据分片)是集群最核心的功能。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</li></ol></li></ul><h4 id="6-1-Redis-Cluster集群的搭建可以分为四步："><a href="#6-1-Redis-Cluster集群的搭建可以分为四步：" class="headerlink" title="6.1 Redis Cluster集群的搭建可以分为四步："></a>6.1 Redis Cluster集群的搭建可以分为四步：</h4><ol><li><strong>启动节点</strong>：将节点以集群模式启动，此时节点是独立的，并没有建立联系；</li><li><strong>节点握手</strong>：让独立的节点连成一个网络；</li><li><strong>分配槽</strong>：将16384个槽分配给主节点；</li><li><strong>指定主从关系</strong>：为从节点指定主节点。</li></ol><h4 id="6-2-Redis-Cluster工作原理"><a href="#6-2-Redis-Cluster工作原理" class="headerlink" title="6.2 Redis Cluster工作原理"></a>6.2 Redis Cluster工作原理</h4><ul><li>客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点</li><li>根据公式<code>HASH_SLOT=CRC16(key) mod 16384</code>，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         CRC16(key)    |  0~5460   | &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">         mode 16384    |</span><br><span class="line">Client --------------&gt; | 5461~10922| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">                       |</span><br><span class="line">                       |10923~10383| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br></pre></td></tr></table></figure><h4 id="6-3-Redis-Cluster优点"><a href="#6-3-Redis-Cluster优点" class="headerlink" title="6.3 Redis Cluster优点:"></a>6.3 Redis Cluster优点:</h4><ol><li>无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master</li><li>可以进行水平扩容</li><li>支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。</li></ol><h4 id="6-4-Redis-Cluster缺点"><a href="#6-4-Redis-Cluster缺点" class="headerlink" title="6.4 Redis Cluster缺点:"></a>6.4 Redis Cluster缺点:</h4><ol><li>批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）</li><li>资源隔离性较差，容易出现相互影响的情况。</li></ol><h4 id="6-5-Redis-Cluster总结："><a href="#6-5-Redis-Cluster总结：" class="headerlink" title="6.5 Redis Cluster总结："></a>6.5 Redis Cluster总结：</h4><ol><li>Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。</li><li>单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。</li><li>不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。</li><li>如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。</li><li>Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。</li><li>Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis本质上是一个Key-Value类型的&lt;strong&gt;内存数据库&lt;/strong&gt;，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。
    
    </summary>
    
      <category term="Redis" scheme="http://chaooo.github.io/categories/Redis/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL事务处理与并发控制</title>
    <link href="http://chaooo.github.io/article/20190907.html"/>
    <id>http://chaooo.github.io/article/20190907.html</id>
    <published>2019-09-07T15:31:48.000Z</published>
    <updated>2019-11-03T15:42:24.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MySQL事务"><a href="#1-MySQL事务" class="headerlink" title="1. MySQL事务"></a>1. MySQL事务</h3><ol><li>事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；<a id="more"></a></li><li>事务的特性(ACID)：<ul><li><strong>原子性</strong>（Atomicity，或称不可分割性）：最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚</li><li><strong>一致性</strong>（Consistency）：事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则， 不会因为出现系统意外等原因导致状态的不一致</li><li><strong>隔离性</strong>（Isolation，又称独立性）：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）</li><li><strong>持久性</strong>（Durability）：事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失</li></ul></li><li>事务的开启与提交模式<ul><li>若参数autocommit=0，自动开启<strong>手动提交</strong></li><li>若参数autocommit=1（系统默认值），又分为两种状态：<ul><li><strong>自动开启自动提交</strong>：用户的每一个操作都是一个完整的事务周期。</li><li><strong>手动开启手动提交</strong>：从用户执行<code>start transaction</code>命令到用户执行<code>commit</code>命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。<ul><li><code>begin</code> 或者 <code>start transaction</code>   – 开启事务</li><li><code>commit</code> 或者 <code>rollback</code>           – 事务提交或回滚</li></ul></li></ul></li></ul></li></ol><h4 id="1-1-事务的隔离级别"><a href="#1-1-事务的隔离级别" class="headerlink" title="1.1 事务的隔离级别"></a>1.1 事务的隔离级别</h4><ul><li>查看/设置隔离级别<ul><li>查看：<code>SELECT @@tx_isolation</code></li><li>设置：<code>set tx_isolation=&#39;xxx&#39;</code></li></ul></li></ul><ol><li><strong>读未提交</strong>（Read Uncommitted）<ul><li>事务未提交对其他事务也是可见的，脏读（dirty read）</li></ul></li><li><strong>读提交</strong>（Read Committed）–解决脏读问题 <ul><li>一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）</li></ul></li><li><strong>可重复读</strong>（Repeatable Read）–解决不可重复读问题<ul><li>在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题</li></ul></li><li><strong>串行化</strong>（Serializable）–解决所有问题<ul><li>最高的隔离级别，通过强制事务的串行执行，但是会导致大量超时以及锁争用问题</li></ul></li></ol><blockquote><p>Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别。<br>事务的隔离级别的实现：锁、MVCC（多版本并发控制 Multiversion Currency Control）。</p></blockquote><h4 id="1-2-事务的七大传播行为"><a href="#1-2-事务的七大传播行为" class="headerlink" title="1.2 事务的七大传播行为"></a>1.2 事务的七大传播行为</h4><p>Spring在TransactionDefinition接口中规定了<strong>7种</strong>类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。</p><ul><li>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时<strong>事务如何传播</strong>。<ul><li><code>@Transactional(propagation = Propagation.REQUIRED)</code></li></ul></li></ul><ol><li>第一类：运行在同一个事务<ul><li><strong><code>REQUIRED</code></strong>（required）：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li><li><code>SUPPORTS</code>（supports）：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li><li><code>MANDATORY</code>（mandatory）：支持当前事务，如果当前没有事务，就抛出异常</li></ul></li><li>第二类：运行在不同事务<ul><li><strong><code>REQUIRES_NEW</code></strong>（requires new）：新建事务，如果当前存在事务，把当前事务挂起</li><li><code>NOT_SUPPORTED</code>(not supported)：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li><code>NEVER</code>（never）：以非事务方式执行，如果当前存在事务，则抛出异常</li></ul></li><li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul><li><strong><code>NESTED</code></strong>（nested）：如果当前事务存在，则嵌套事务执行</li></ul></li></ol><h3 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h3><p>锁是用于管理不同事务对共享资源的并发访问，InnoDB存储引擎支持行锁和表锁（InnoDB表锁是另类的行锁）</p><ul><li>InnoDB行锁<ul><li>共享锁（读锁）：Shared Locks</li><li>排它锁（写锁）：Exclusive Locks</li></ul></li><li>InnoDB表锁<ul><li>意向锁共享锁（IS）：Intention Shared Locks</li><li>意向锁排它锁（IX）：Intention Exclusive Locks</li><li>自增锁：AUTO-INC Locks</li></ul></li><li>行锁的算法<ul><li>记录锁 Record Locks</li><li>间隙锁 Gap Locks</li><li>临键锁 Next-key Locks</li></ul></li></ul><h4 id="2-1-共享锁-Shared-amp-排他锁-Exclusive"><a href="#2-1-共享锁-Shared-amp-排他锁-Exclusive" class="headerlink" title="2.1 共享锁(Shared) &amp; 排他锁(Exclusive)"></a>2.1 共享锁(Shared) &amp; 排他锁(Exclusive)</h4><p>它们都是标准的<strong>行级锁</strong>。</p><ul><li>共享锁（S锁）：读锁，读锁允许多个连接可以同一时刻<strong>并发的读</strong>取同一资源,互不干扰，但是只能读不能修改;<ul><li>加锁： <code>select * from users WHERE id=1</code><strong><code>LOCK IN SHARE MODE</code></strong>; </li><li>解锁：<strong><code>commit</code></strong>或<strong><code>rollback</code></strong></li></ul></li><li>排他锁（X锁）：写锁，一个写锁会<strong>阻塞</strong>其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。<ul><li>加锁： <code>select * from users WHERE id=1</code><strong><code>FOR UPDATE</code></strong>; </li><li><strong><code>delete/update/insert 默认上 X 锁</code></strong></li><li>解锁：<strong><code>commit</code></strong>或<strong><code>rollback</code></strong></li></ul></li></ul><blockquote><p>注意：所谓共享锁、排他锁其实均是<strong>锁机制本身的策略</strong>，通过这两种策略对锁做了区分。</p><ul><li>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的。</li><li>只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）</li></ul></blockquote><h4 id="2-2-意向锁-Intention-amp-自增锁-AUTO-INC"><a href="#2-2-意向锁-Intention-amp-自增锁-AUTO-INC" class="headerlink" title="2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)"></a>2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)</h4><p>它们都是标准的<strong>表级锁</strong>。</p><ul><li><strong>意向锁</strong>（Intention Locks）：表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，才被允许对该表加行锁(S或X)。(即一个数据行加锁前必须先取得该表的意向锁)<ul><li>意向锁(IS、IX)是InnoDB数据操作之前<strong>自动加的</strong>，不需要用户干预 </li><li>意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li></ul></li><li><strong>自增锁</strong>（AUTO-INC Locks）：针对自增列自增长的一个特殊的表级别锁<ul><li><code>show variables like &#39;innodb_autoinc_lock_mode&#39;</code>;</li><li>默认取值1，代表连续，事务未提交ID永久丢失</li></ul></li></ul><h4 id="2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key"><a href="#2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key" class="headerlink" title="2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)"></a>2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)</h4><ul><li><strong>临键锁 Next-key locks</strong>： <ul><li><strong>锁住记录+区间（左开右闭）</strong></li><li>Innodb<strong>默认</strong>行锁算法</li><li>当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、&lt;、&gt;等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，<strong>锁住索引的记录+区间（左开右闭）</strong></li></ul></li><li><strong>间隙锁 Gap locks</strong>：<ul><li><strong>锁住数据不存在的区间（左开右开）</strong></li><li>当记录不存在，临键锁<strong>退化</strong>为Gap锁</li><li>当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，Gap只在RR事务隔离级别存在，<strong>锁住索引不存在的区间（左开右开</strong>） </li></ul></li><li><strong>记录锁 Record locks</strong>： <ul><li><strong>锁住具体的索引项</strong></li><li>唯一性(主键/唯一)索引，条件为<strong>精准匹配，退化</strong>成Record锁</li><li>当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，<strong>锁住具体的索引项</strong></li></ul></li></ul><h4 id="2-4-死锁的产生与避免"><a href="#2-4-死锁的产生与避免" class="headerlink" title="2.4 死锁的产生与避免"></a>2.4 死锁的产生与避免</h4><ul><li>死锁<ul><li>在InnoDB中，锁是逐步获得的，就造成了死锁的可能（2个或以上并发事务）</li><li>每个事务都持有锁（或者是已经在等待锁）; </li><li>每个事务都需要再继续持有锁；<strong>事务之间产生加锁的循环等待</strong>，形成死锁。</li></ul></li><li>死锁的产生与避免<ol><li>类似的业务逻辑以固定的<strong>顺序访问</strong>表和行。</li><li>大事务拆小。大事务更倾向于死锁，如果业务允许，将<strong>大事务拆小</strong>。</li><li>在同<strong>一个事务</strong>中，尽可能做到<strong>一次锁定</strong>所需要的所有资源，减少死锁概 率。</li><li>降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择</li><li>为表添加<strong>合理的索引</strong>。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）</li></ol></li></ul><h3 id="3-MVCC-多版本并发控制"><a href="#3-MVCC-多版本并发控制" class="headerlink" title="3. MVCC(多版本并发控制)"></a>3. MVCC(多版本并发控制)</h3><p>Multiversion concurrency control (多版本并发控制)：</p><ul><li><strong>MVCC</strong> 就是 <strong>同一份数据临时保留多版本的一种方式，进而实现并发控制</strong></li><li>是行级锁的变种，它在普通读情况下<strong>避免了加锁操作</strong>，因此<strong>开销更低</strong>。</li><li>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用<strong>时间戳或者事务ID</strong>去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。<strong>读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据</strong>。</li></ul><h4 id="3-1-MVCC逻辑流程"><a href="#3-1-MVCC逻辑流程" class="headerlink" title="3.1 MVCC逻辑流程"></a>3.1 MVCC逻辑流程</h4><ul><li>在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列<ul><li><code>DB_TRX_ID</code>：数据行的版本号</li><li><code>DB_ROLL_PT</code>：删除版本号</li></ul></li></ul><ol><li>MVCC逻辑流程-插入<ul><li>在插入数据的时候，会把全局事务ID记录到列<code>DB_TRX_ID</code>中去</li></ul></li><li>MVCC逻辑流程-删除<ul><li>执行完删除SQL之后数据并没有被真正删除，而是对删除版本号(<code>DB_ROLL_PT</code>)做改变</li></ul></li><li>MVCC逻辑流程-修改<ul><li>修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前事务ID，最后把旧数据的删除版本号标记为新数据行版本号的值(即当前事务ID)。</li></ul></li><li>MVCC逻辑流程-查询<ul><li>查找数据行版本号早于当前事务ID的数据行记录</li><li>也就是说，数据行的版本号要小于或等于 当前事务ID，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据</li><li>查找删除版本号要么为NULL，要么大于当前事务版本号的记录</li><li>这样确保查询出来的数据行记录在事务开启之前没有被删除</li></ul></li></ol><blockquote><p>MySQL解决不可重复读和脏读并不是单纯利用 MVCC 机制来实现的。</p></blockquote><h3 id="4-MySQL事务日志-Undo-Log和Redo-Log"><a href="#4-MySQL事务日志-Undo-Log和Redo-Log" class="headerlink" title="4. MySQL事务日志(Undo Log和Redo Log)"></a>4. MySQL事务日志(Undo Log和Redo Log)</h3><p>innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。<br>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：</p><ol><li>redo log通常是<strong>物理日志</strong>，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</li><li>undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，根据每行记录进行记录。</li></ol><p>s</p><h4 id="4-1-Undo-Log"><a href="#4-1-Undo-Log" class="headerlink" title="4.1 Undo Log"></a>4.1 Undo Log</h4><ul><li>Undo Log定义：<ul><li>undo意为取消，以撤销操作为目的，返回指定某个状态的操作</li><li>undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log) </li></ul></li><li><strong>UndoLog是为了实现事务的原子性而出现的产物</strong></li><li>Undo Log实现事务原子性：<ul><li>事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份 将数据恢复到事务开始之前的状态</li></ul></li><li><strong>UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制</strong></li><li>Undo log实现多版本并发控制：<ul><li>事务未提交之前，Undo保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供 其他并发事务进行快照读</li></ul></li></ul><h4 id="4-2-当前读-amp-快照读"><a href="#4-2-当前读-amp-快照读" class="headerlink" title="4.2 当前读 &amp; 快照读"></a>4.2 当前读 &amp; 快照读</h4><ul><li>快照读：<ul><li>SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读 innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成 </li></ul></li><li>当前读：<ul><li>SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改 UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读</li></ul></li></ul><h4 id="4-3-Redo-Log"><a href="#4-3-Redo-Log" class="headerlink" title="4.3 Redo Log"></a>4.3 Redo Log</h4><ul><li>Undo Log定义： <ul><li>Redo，顾名思义就是重做。以恢复操作为目的，重现操作；</li><li>Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)</li></ul></li><li>Redo log的持久： <ul><li>不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体 的落盘策略可以进行配置</li></ul></li><li><strong>RedoLog是为了实现事务的持久性而出现的产物</strong></li><li>Redo Log实现事务持久性： <ul><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</li></ul></li><li>一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所 以Redo log的写入是日志文件循环写入的</li></ul><h3 id="附-58同城数据库设计30条军规"><a href="#附-58同城数据库设计30条军规" class="headerlink" title="附: 58同城数据库设计30条军规"></a>附: 58同城数据库设计30条军规</h3><ul><li>军规适用场景：并发量大、数据量大的互联网业务 </li><li>解读：讲解原因，<strong>解读比军规更重要</strong> </li></ul><h4 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h4><ol><li>必须使用InnoDB存储引擎<ul><li>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</li></ul></li><li>必须使用UTF8字符集 UTF-8MB4<ul><li>解读：万国码，无需转码，无乱码风险，节省空间</li></ul></li><li>数据表、数据字段必须加入中文注释<ul><li>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</li></ul></li><li>禁止使用存储过程、视图、触发器、Event<ul><li>解读：<strong>高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务 层”</strong>，并发量大的情况下，这些功能很可能将数据库拖死，<strong>业务逻辑放到服务层具备更好的 扩展性，能够轻易实现“增机器就加性能”</strong>。数据库擅长存储与索引，CPU计算还是上移吧</li></ul></li><li>禁止存储大文件或者大照片<ul><li>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI 多好</li></ul></li></ol><h4 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h4><ol start="6"><li>只允许<strong>使用内网域名，而不是ip连接数据库</strong></li><li>线上环境、开发环境、测试环境数据库内网域名遵循命名规范<ul><li>业务名称：xxx，线上环境：xxx.db，开发环境：xxx.rdb，测试环境：xxx.tdb </li><li>从库在名称后加-s标识，备库在名称后加-ss标识 线上从库：xxx-s.db 线上备库：xxx-sss.db</li></ul></li><li>库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止 拼音英文混用</li><li>表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</li></ol><h4 id="三、表设计规范"><a href="#三、表设计规范" class="headerlink" title="三、表设计规范"></a>三、表设计规范</h4><ol start="10"><li>单实例表数目必须小于500</li><li>单表列数目必须小于30</li><li>表必须有主键，例如自增主键<ul><li>解读：<ol><li>主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和 内存的使用</li><li>主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类 型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li><li>无主键的表删除，在row模式的主从架构，会导致备库夯住</li></ol></li></ul></li><li>禁止使用外键，如果有外键完整性约束，需要应用程序控制<ul><li>解读：<strong>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响 sql 的性能</strong>，甚至会造成死锁。高并发情况下容易造成数据库性能，<strong>大数据高并发业务场景 数据库使用以性能优先</strong></li></ul></li></ol><h4 id="四、字段设计规范"><a href="#四、字段设计规范" class="headerlink" title="四、字段设计规范"></a>四、字段设计规范</h4><ol start="14"><li>必须把字段定义为NOT NULL并且提供默认值<ul><li>解读： <ol><li>null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</li><li>null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条 件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li><li>null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标 识</li><li>对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、 not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记 录，查询结果就不会包含name为null值的记录</li></ol></li></ul></li><li>禁止使用TEXT、BLOB类型<ul><li>解读：会浪费更多的磁盘和内存空间，<strong>非必要的大量的大字段查询会淘汰掉热数据，导致内 存命中率急剧降低，影响数据库性能</strong></li></ul></li><li>禁止使用小数存储货币<ul><li>解读：使用整数吧，小数容易导致钱对不上</li></ul></li><li>必须使用varchar(20)存储手机号<ul><li>解读：<ol><li>涉及到区号或者国家代号，可能出现+-()</li><li>手机号会去做数学运算么？</li><li>varchar可以支持模糊查询，例如：like“138%”</li></ol></li></ul></li><li>禁止使用ENUM，可使用TINYINT代替<ul><li>解读：<ol><li>增加新的ENUM值要做DDL操作</li><li>ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</li></ol></li></ul></li></ol><h4 id="五、索引设计规范"><a href="#五、索引设计规范" class="headerlink" title="五、索引设计规范"></a>五、索引设计规范</h4><ol start="19"><li>单表索引建议控制在5个以内</li><li>单索引字段数不允许超过5个<ul><li>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</li></ul></li><li>禁止在更新十分频繁、区分度不高的属性上建立索引<ul><li>解读：<ol><li>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</li><li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性 能与全表扫描类似</li></ol></li></ul></li><li>建立组合索引，必须把区分度高的字段放在前面<ul><li>解读：能够更加有效的过滤数据</li></ul></li></ol><h4 id="六、SQL使用规范"><a href="#六、SQL使用规范" class="headerlink" title="六、SQL使用规范"></a>六、SQL使用规范</h4><ol start="23"><li>禁止使用SELECT *，只获取必要的字段，需要显示说明列属性<ul><li>解读：<ol><li>读取不需要的列会增加CPU、IO、NET消耗</li><li>不能有效的利用覆盖索引</li></ol></li></ul></li><li>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性<ul><li>解读：容易在增加或者删除字段后出现程序BUG</li></ul></li><li>禁止使用属性隐式转换<ul><li>解读：SELECT uid FROM t_user WHERE phone=13812345678 <strong>会导致全表扫描</strong>，而不 能命中phone索引</li></ul></li><li>禁止在WHERE条件的属性上使用函数或者表达式<ul><li>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全 表扫描 正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</li></ul></li><li>禁止负向查询，以及%开头的模糊查询<ul><li>解读：<ol><li>负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</li><li>%开头的模糊查询，会导致全表扫描</li></ol></li></ul></li><li>禁止大表使用JOIN查询，禁止大表使用子查询<ul><li>解读：<strong>会产生临时表</strong>，消耗较多内存与CPU，极大影响数据库性能</li></ul></li><li>禁止使用OR条件，必须改为IN查询<ul><li>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费 更多的CPU帮助实施查询优化呢？</li></ul></li><li>应用程序必须捕获SQL异常，并有相应处理</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-MySQL事务&quot;&gt;&lt;a href=&quot;#1-MySQL事务&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL事务&quot;&gt;&lt;/a&gt;1. MySQL事务&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL索引的使用及优化</title>
    <link href="http://chaooo.github.io/article/20190905.html"/>
    <id>http://chaooo.github.io/article/20190905.html</id>
    <published>2019-09-05T09:04:12.000Z</published>
    <updated>2019-11-02T05:51:22.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-索引的基本概念"><a href="#1-索引的基本概念" class="headerlink" title="1. 索引的基本概念"></a>1. 索引的基本概念</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><ul><li>索引意义：<ol><li>索引能极大的减少存储引擎需要扫描的数据量</li><li>索引可以把随机IO变成顺序IO</li><li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表<a id="more"></a></li></ol></li><li>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引。</li></ul><h3 id="2-索引的适用场景"><a href="#2-索引的适用场景" class="headerlink" title="2. 索引的适用场景"></a>2. 索引的适用场景</h3><h4 id="2-1-适合建索引的场景"><a href="#2-1-适合建索引的场景" class="headerlink" title="2.1 适合建索引的场景"></a>2.1 适合建索引的场景</h4><ol><li>表的主键自动建立唯一索引</li><li>表的字段唯一约束</li><li>直接条件查询的字段（在SQL中用于条件约束的字段）</li><li>查询中与其它表关联的字段</li><li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li><li>查询中统计或分组统计的字段</li><li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li><li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li><li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li><li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li></ol><h4 id="2-2-不适合建索引的场景"><a href="#2-2-不适合建索引的场景" class="headerlink" title="2.2 不适合建索引的场景"></a>2.2 不适合建索引的场景</h4><ol><li>表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）</li><li>经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。</li><li>数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）</li></ol><h3 id="3-MySQl中索引的结构（B-树）"><a href="#3-MySQl中索引的结构（B-树）" class="headerlink" title="3. MySQl中索引的结构（B+树）"></a>3. MySQl中索引的结构（B+树）</h3><h4 id="3-1-基本概念："><a href="#3-1-基本概念：" class="headerlink" title="3.1 基本概念："></a>3.1 基本概念：</h4><ol><li>二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；</li><li>B树：多路搜索树，每个节点存储M/2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；</li><li>B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；</li><li>B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1/2提高到2/3；</li></ol><h4 id="3-2-B-树的特性："><a href="#3-2-B-树的特性：" class="headerlink" title="3.2 B+树的特性："></a>3.2 B+树的特性：</h4><ol><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>不可能在非叶子结点命中；</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>更适合文件索引系统；</li></ol><h4 id="3-3-B-树的三个特点："><a href="#3-3-B-树的三个特点：" class="headerlink" title="3.3 B+树的三个特点："></a>3.3 B+树的三个特点：</h4><ol><li>关键字数和子树相同<ul><li>在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</li></ul></li><li>非叶子节点仅用作索引，它的关键字和子节点有重复元素<ul><li>除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</li><li>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</li></ul></li><li>叶子节点用指针连在一起<ul><li>叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</li></ul></li></ol><blockquote><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。<br>B+ 树的查找必会查到叶子节点，更加稳定。<br>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p></blockquote><h4 id="3-4-B-树的三个优点："><a href="#3-4-B-树的三个优点：" class="headerlink" title="3.4 B+ 树的三个优点："></a>3.4 B+ 树的三个优点：</h4><ul><li>层级更低，IO 次数更少</li><li>每次都需要查询到叶子节点，查询性能稳定</li><li>叶子节点形成有序链表，范围查询方便</li></ul><h3 id="4-索引的优化"><a href="#4-索引的优化" class="headerlink" title="4. 索引的优化"></a>4. 索引的优化</h3><h4 id="4-1-优化法则（口诀）："><a href="#4-1-优化法则（口诀）：" class="headerlink" title="4.1 优化法则（口诀）："></a>4.1 优化法则（口诀）：</h4><ul><li>全值匹配我最爱，最左前缀要遵守</li><li>带头大哥不能死，中间兄弟不能断</li><li>索引列上无计算，范围之后全失效</li><li>like百分写最右，覆盖索引不写星</li><li>不等控制还有or，索引失效要少用</li><li>var引号不能丢，SQL优化也不难</li></ul><h4 id="4-2-具体描述"><a href="#4-2-具体描述" class="headerlink" title="4.2 具体描述"></a>4.2 具体描述</h4><ol><li>全值匹配<ul><li>怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多</li></ul></li><li>最佳左前缀法则<ul><li>指的是查询从索引的最左前列开始并且不跳过索引中的列。</li><li>例如：复合索引<code>A-&gt;B-&gt;C</code>，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。</li></ul></li><li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右面的列<ul><li>例如：<code>select t from test where A=1 and B&gt;2 and C=3</code>，那么B&gt;2后的查询条件失效。</li></ul></li><li>尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 <code>SELECT *</code>。</li><li>MySQL在使用不等于(<code>!=</code> 或<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描</li><li><code>is null</code>，<code>is not null</code> 也无法使用索引</li><li>like以通配符开头<code>(&#39;%abc...&#39;)</code>mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面<code>(&#39;abc...%&#39;)</code>的才能避免索引失效。</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li></ol><h3 id="5-in-和-exists区别及应用场景"><a href="#5-in-和-exists区别及应用场景" class="headerlink" title="5. in 和 exists区别及应用场景"></a>5. in 和 exists区别及应用场景</h3><h4 id="5-1-in-和-exists的区别"><a href="#5-1-in-和-exists的区别" class="headerlink" title="5.1 in 和 exists的区别:"></a>5.1 in 和 exists的区别:</h4><ul><li>如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。</li><li>其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</li><li>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</li></ul><h4 id="5-2-not-in-和not-exists"><a href="#5-2-not-in-和not-exists" class="headerlink" title="5.2 not in 和not exists"></a>5.2 not in 和not exists</h4><ul><li>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；</li><li>而not extsts 的子查询依然能用到表上的索引。</li><li>所以无论那个表大，用not exists都比not in要快</li></ul><h3 id="6-order-by-和-group-by-优化"><a href="#6-order-by-和-group-by-优化" class="headerlink" title="6. order by 和 group by 优化"></a>6. order by 和 group by 优化</h3><p>索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。</p><h4 id="6-1-提高ORDER-BY速度的技巧"><a href="#6-1-提高ORDER-BY速度的技巧" class="headerlink" title="6.1 提高ORDER BY速度的技巧"></a>6.1 提高ORDER BY速度的技巧</h4><ol><li>ORDER BY时不要使用SELECT *，只查需要的字段。</li><li>增大<code>sort_buffer_size</code>参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）</li><li>增大<code>max_length_for_sort_data</code>参数大小</li></ol><h4 id="6-2-GROUP-BY的优化"><a href="#6-2-GROUP-BY的优化" class="headerlink" title="6.2 GROUP BY的优化"></a>6.2 GROUP BY的优化</h4><ol><li>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。</li><li>当无法使用索引列，考虑增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>的参数设置。</li><li>WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。</li></ol><blockquote><p>注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)</p></blockquote><p>一般性建议：</p><ul><li>对于单值索引，尽量选择针对query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。</li><li>在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li></ul><blockquote><p>参考链接：<a href="https://www.zhihu.com/people/hen-six-49/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/hen-six-49/activities</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-索引的基本概念&quot;&gt;&lt;a href=&quot;#1-索引的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 索引的基本概念&quot;&gt;&lt;/a&gt;1. 索引的基本概念&lt;/h3&gt;&lt;p&gt;索引是为了加速对表中数据行的检索而创建的一种分散存储的&lt;strong&gt;数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引意义：&lt;ol&gt;
&lt;li&gt;索引能极大的减少存储引擎需要扫描的数据量&lt;/li&gt;
&lt;li&gt;索引可以把随机IO变成顺序IO&lt;/li&gt;
&lt;li&gt;索引可以帮助我们在进行分组、排序等操作时，避免使用临时表
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
</feed>
