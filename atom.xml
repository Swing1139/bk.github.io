<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路，走过去，前面是个天！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chaooo.github.io/"/>
  <updated>2020-01-05T15:26:19.438Z</updated>
  <id>http://chaooo.github.io/</id>
  
  <author>
    <name>郑超(Charles·Zheng)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于前后端分离的权限控制(Spring Boot/Vue/JWT/Shiro)</title>
    <link href="http://chaooo.github.io/article/20200105.html"/>
    <id>http://chaooo.github.io/article/20200105.html</id>
    <published>2020-01-05T15:26:02.000Z</published>
    <updated>2020-01-05T15:26:19.438Z</updated>
    
    <content type="html"><![CDATA[<p>基于前后端分离的开发模式中，权限控制分为<strong>前端可见性</strong>权限与<strong>后端<code>API</code>接口可访问性</strong>权限。<br>前端的权限控制 主要围绕在菜单是否对该角色可见，以及是否具有操作该按钮的权限两方面展开的</p><h3 id="1-前端可见性-权限-实现思路"><a href="#1-前端可见性-权限-实现思路" class="headerlink" title="1. 前端可见性 权限 实现思路"></a>1. 前端可见性 权限 实现思路</h3><p>在<code>vue</code>工程中，菜单可以简单的理解为<code>vue</code>中的路由，只需要根据登录用户的权限信息动态的加载路由列表就可以动态的构造出访问菜单。</p><ol><li>登录成功后获取用户信息，包含权限列表（菜单权限，按钮权限）</li><li>根据用户菜单权限列表，动态构造路由（根据路由名称和权限标识比较）</li><li>页面按钮权限通过自定义方法控制可见性<br><img src="http://cdn.chaooo.top/Java/vue-ctrl.png" alt></li></ol><h4 id="1-1-路由钩子函数"><a href="#1-1-路由钩子函数" class="headerlink" title="1.1 路由钩子函数"></a>1.1 路由钩子函数</h4><p><code>vue</code>路由提供的钩子函数（<code>beforeEach</code>）主要用来在加载之前拦截导航，让它完成跳转或取消。可以在路由钩子函数中进行校验是否对某个路由具有访问权限</p><figure class="highlight javascript"><figcaption><span>router\index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  NProgress.start() <span class="comment">//loading start</span></span><br><span class="line">  <span class="keyword">if</span> (getToken()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.path === <span class="string">'/login'</span>) &#123;</span><br><span class="line">      next(&#123;<span class="attr">path</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">      NProgress.done()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (store.getters.roles.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前用户是否已拉取完user_info信息</span></span><br><span class="line">        store.dispatch(<span class="string">'GetUserInfo'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 拉取user_info: ['editor','develop']</span></span><br><span class="line">            <span class="keyword">const</span> roles = res.data.data.roles</span><br><span class="line">            store.dispatch(<span class="string">'GenerateRoutes'</span>, &#123;roles&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// 根据roles权限生成可访问的路由表</span></span><br><span class="line">              <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">              router.addRoutes(store.getters.addRouters)</span><br><span class="line">              <span class="comment">// hack方法 确保addRoutes已完成 </span></span><br><span class="line">              next(&#123;...to, <span class="attr">replace</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            store.dispatch(<span class="string">'FedLogOut'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              Message.error(<span class="string">'验证失败, 请重新登录'</span>)</span><br><span class="line">              next(&#123;<span class="attr">path</span>: <span class="string">'/login'</span>&#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* has no token */</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.indexOf(to.path) !== <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 在免登录白名单，直接进入</span></span><br><span class="line">      next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next(<span class="string">'/login'</span>) <span class="comment">// 否则全部重定向到登录页</span></span><br><span class="line">      NProgress.done()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="1-2-配置菜单权限"><a href="#1-2-配置菜单权限" class="headerlink" title="1.2 配置菜单权限"></a>1.2 配置菜单权限</h4><figure class="highlight javascript"><figcaption><span>store\permission.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查是否有权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPermission</span>(<span class="params">roles, route</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (roles.menus &amp;&amp; route.name) &#123;</span><br><span class="line">    <span class="keyword">return</span> roles.menus.some(<span class="function"><span class="params">role</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> route.name.toLowerCase() === role.toLowerCase()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归过滤异步路由表，返回符合用户角色权限的路由表</span></span><br><span class="line"><span class="comment"> * @param asyncRouterMap</span></span><br><span class="line"><span class="comment"> * @param roles</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterAsyncRouter</span>(<span class="params">asyncRouterMap, roles</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> accessedRouters = asyncRouterMap.filter(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasPermission(roles, route)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> accessedRouters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> permission = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    routers: constantRouterMap,</span><br><span class="line">    addRouters: []</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    SET_ROUTERS: <span class="function">(<span class="params">state, routers</span>) =&gt;</span> &#123;</span><br><span class="line">      state.addRouters = routers</span><br><span class="line">      state.routers = constantRouterMap.concat(routers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    GenerateRoutes(&#123; commit &#125;, data) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; roles &#125; = data</span><br><span class="line">        <span class="comment">//动态构造权限列表</span></span><br><span class="line">        <span class="comment">// 调试开启全部路由</span></span><br><span class="line">        commit(<span class="string">'SET_ROUTERS'</span>, asyncRouterMap) </span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-后端API接口可访问性-权限-实现思路"><a href="#2-后端API接口可访问性-权限-实现思路" class="headerlink" title="2. 后端API接口可访问性 权限 实现思路"></a>2. 后端API接口可访问性 权限 实现思路</h3><p>服务端首先需要接受跨域请求，客户端登录时签发<code>Token</code>令牌给客户端，此后客户端在请求受保护的资源时携带这个<code>Token</code>，服务端进行验证再从这个<code>Token</code>中解析出用户的身份信息。<br>具体权限流程：</p><ol><li>用户使用username和password登陆，将password通过<code>MD5加密</code>，通过username查询库中是否有该条记录，并比较加密后的密码是否相同，登陆成功后利用<code>JwtUtil</code>生成带过期时间的<code>token</code>，以后发送请求时都需要在<code>header</code>中添加Authorization字段附加该token信息；</li><li>结合程序实现一个<code>JwtUtil</code>，在其中实现利用登陆信息生成token，根据token获取username，token验证等方法；</li><li>实现一个<code>JWTFilter</code>继承BasicHttpAuthenticationFilter类,该拦截器需要拦截所有请求除(除登陆、注册等请求)，用于判断请求是否带有token，并获取token的值传递给<code>shiro</code>的登陆认证方法作为参数，用于获取token；</li><li>定义<code>ShiroRealm</code>继承AuthorizingRealm类，在其中实现登陆验证及权限获取的方法；</li><li>定义<code>ShiroConfig</code>配置类，用于生成ShiroManage及将shiroRealm付给ShiroManage，并将jwtFilter添加进shiro的拦截器链中</li><li>controller中可以使用@RequiresPermissions来对用户权限进行拦截；</li></ol><h4 id="2-1-JwtUtil"><a href="#2-1-JwtUtil" class="headerlink" title="2.1 JwtUtil"></a>2.1 JwtUtil</h4><figure class="highlight java"><figcaption><span>JwtUtil.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置过期时间，这里设置15分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">15</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//服务端的私钥secret,在任何场景都不应该流露出去</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_SECRET = <span class="string">"zhengchao"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **User**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **password**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createToken</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">            <span class="comment">// 私钥和加密算法</span></span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">// 设置头部信息</span></span><br><span class="line">            Map&lt;String, Object&gt; header = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            header.put(<span class="string">"typ"</span>, <span class="string">"JWT"</span>);</span><br><span class="line">            header.put(<span class="string">"alg"</span>, <span class="string">"HS256"</span>);</span><br><span class="line">            <span class="comment">// 返回token字符串</span></span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">"aud"</span>, user.getName())</span><br><span class="line">                    .withClaim(<span class="string">"uid"</span>, user.getId())</span><br><span class="line">                    .withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验token是否正确</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **token**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVerify</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出uid信息,用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseTokenUid</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"uid"</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出aud信息,用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseTokenAud</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"aud"</span>).asString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-JWTFilter"><a href="#2-2-JWTFilter" class="headerlink" title="2.2 JWTFilter"></a>2.2 JWTFilter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class JWTFilter extends BasicHttpAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TOKEN = &quot;Authentication&quot;;</span><br><span class="line"></span><br><span class="line">    private AntPathMatcher pathMatcher = new AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws UnauthorizedException &#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        String[] anonUrl = StringUtils.splitByWholeSeparatorPreserveAllTokens(BraveConstant.ANON_URL, StringPool.COMMA);</span><br><span class="line"></span><br><span class="line">        boolean match = false;</span><br><span class="line">        for (String u : anonUrl) &#123;</span><br><span class="line">            if (pathMatcher.match(u, httpServletRequest.getRequestURI()))</span><br><span class="line">                match = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (match) return true;</span><br><span class="line">        if (isLoginAttempt(request, response)) &#123;</span><br><span class="line">            return executeLogin(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        String token = req.getHeader(TOKEN);</span><br><span class="line">        return token != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean executeLogin(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        String token = httpServletRequest.getHeader(TOKEN);</span><br><span class="line">        JWTToken jwtToken = new JWTToken(BraveUtil.decryptToken(token));</span><br><span class="line">        try &#123;</span><br><span class="line">            //将token传递给shiroRealm</span><br><span class="line">            getSubject(request, response).login(jwtToken);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对跨域提供支持</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse) response;</span><br><span class="line">        httpServletResponse.setHeader(&quot;Access-control-Allow-Origin&quot;, httpServletRequest.getHeader(&quot;Origin&quot;));</span><br><span class="line">        httpServletResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET,POST,OPTIONS,PUT,DELETE&quot;);</span><br><span class="line">        httpServletResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, httpServletRequest.getHeader(&quot;Access-Control-Request-Headers&quot;));</span><br><span class="line">        // 跨域时会首先发送一个 option请求，这里我们给 option请求直接返回正常状态</span><br><span class="line">        if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;</span><br><span class="line">            httpServletResponse.setStatus(HttpStatus.OK.value());</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.preHandle(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-ShiroRealm"><a href="#2-3-ShiroRealm" class="headerlink" title="2.3 ShiroRealm"></a>2.3 ShiroRealm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BrUserManager brUserManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> JWTToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**`</span></span><br><span class="line"><span class="comment">     * 授权模块，获取用户角色和权限</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AuthorizationInfo 权限信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> userId = JWTUtil.getUserTokenDto(token.toString()).getUserId();</span><br><span class="line">        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户权限集</span></span><br><span class="line">        Set&lt;String&gt; permissionSet = brUserManager.getUserPermissions(userId);</span><br><span class="line">        simpleAuthorizationInfo.setStringPermissions(permissionSet);</span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户认证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationToken 身份认证 token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AuthenticationInfo 身份认证信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException 认证相关异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的 token是从 JWTFilter 的 executeLogin 方法传递过来的</span></span><br><span class="line">        String token = (String) authenticationToken.getCredentials();</span><br><span class="line"></span><br><span class="line">        TokenDto tokenDto = JWTUtil.getUserTokenDto(token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokenDto == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"token校验不通过"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过用户名查询用户信息</span></span><br><span class="line">        BrUser user = brUserManager.getUser(tokenDto.getUserId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">        TokenDto tokenDtoNew = <span class="keyword">new</span> TokenDto();</span><br><span class="line">        tokenDtoNew.setUserName(user.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (!JWTUtil.verify(token, tokenDtoNew,user.getPassword()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"token校验不通过"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(token, token, <span class="string">"shiro_realm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-ShiroConfig"><a href="#2-4-ShiroConfig" class="headerlink" title="2.4 ShiroConfig"></a>2.4 ShiroConfig</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 设置 securityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 Shiro过滤器链上加入 JWTFilter</span></span><br><span class="line">        LinkedHashMap&lt;String, Filter&gt; filters = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        filters.put(<span class="string">"jwt"</span>, <span class="keyword">new</span> JWTFilter());</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filters);</span><br><span class="line"></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 所有请求都要经过 jwt过滤器</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"jwt"</span>);</span><br><span class="line"></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        <span class="comment">// 配置 SecurityManager，并注入 shiroRealm</span></span><br><span class="line">        securityManager.setRealm(shiroRealm());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroRealm <span class="title">shiroRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置 Realm</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShiroRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启注解</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于前后端分离的开发模式中，权限控制分为&lt;strong&gt;前端可见性&lt;/strong&gt;权限与&lt;strong&gt;后端&lt;code&gt;API&lt;/code&gt;接口可访问性&lt;/strong&gt;权限。&lt;br&gt;前端的权限控制 主要围绕在菜单是否对该角色可见，以及是否具有操作该按钮的权限两方面展开的
      
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】Shiro安全框架入门</title>
    <link href="http://chaooo.github.io/article/20191222.html"/>
    <id>http://chaooo.github.io/article/20191222.html</id>
    <published>2019-12-22T12:44:40.000Z</published>
    <updated>2019-12-29T15:22:40.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-初识Shiro"><a href="#1-初识Shiro" class="headerlink" title="1. 初识Shiro"></a>1. 初识Shiro</h3><p><code>Apache Shiro</code>是一个强大易用的Java安全框架，提供了认证、授权、加密、会话管理、与Web集成、缓存等。</p><ul><li><p>具体来说，满足对如下元素的支持：</p><ul><li>用户，角色，权限(仅仅是操作权限，数据权限必须与业务需求紧密结合)，资源(url)。</li><li>用户分配角色，角色定义权限。</li><li>访问授权时支持角色或者权限，并且支持多级的权限定义。<a id="more"></a></li></ul></li><li><p>Shiro作为一个完善的权限框架，可以应用在多种需要进行身份认证和访问授权的场景，例如：<code>独立应用</code>、<code>web应用</code>、<code>spring框架中集成</code>等。</p></li></ul><h3 id="2-Shiro整体架构"><a href="#2-Shiro整体架构" class="headerlink" title="2. Shiro整体架构"></a>2. Shiro整体架构</h3><p>在shiro架构中，有3个最主要的组件：<code>Subject</code>，<code>SecurityManager</code>，<code>Realm</code>。</p><p><img src="http://cdn.chaooo.top/Java/Shiro.png" alt></p><ol><li><strong><code>Subject</code></strong>(如图上层部分)：”操作用户(<strong>主体</strong>)”，本质上就是当前访问用户的抽象描述。</li><li><strong><code>SecurityManager</code></strong>(如图中层部分)：是Shiro架构中最核心的组件(<strong>控制器</strong>)，通过它可以协调其他组件完成用户认证和授权。<ul><li><code>Authenticator</code>：认证器，协调一个或者多个Realm，从Realm指定的数据源取得数据之后进行执行具体的认证。</li><li><code>Authorizer</code>：授权器，用户访问控制授权，决定用户是否拥有执行指定操作的权限。</li><li><code>Session Manager</code>：Session管理器，Shiro自己实现了一套Session管理机制。</li><li><code>Session DAO</code>：实现了Session的操作，主要有增删改查。</li><li><code>CacheManager</code>：缓存管理器，缓存角色数据和权限数据等。</li><li><code>Pluggable Realms</code>：数据库与数据源之间的一个桥梁。Shiro获取认证信息、权限数据、角色数据 通过Realms来获取。</li><li><code>Cryptography</code>：是用来做加解密，能非常快捷的实现数据加密。</li></ul></li><li><strong><code>Realm</code></strong>(如图下层部分)：定义了访问数据的方式，用来连接不同的<strong>数据源</strong>，如：LDAP，关系数据库，配置文件等等。</li></ol><h3 id="3-Shiro认证与授权"><a href="#3-Shiro认证与授权" class="headerlink" title="3. Shiro认证与授权"></a>3. Shiro认证与授权</h3><h4 id="3-1-Shiro认证"><a href="#3-1-Shiro认证" class="headerlink" title="3.1 Shiro认证"></a>3.1 Shiro认证</h4><p>【创建<code>SecurityManager</code>】&gt;【主体提交请求】&gt;【<code>SecurityManager</code>调用<code>Authenticator</code>去认证】&gt;【<code>Realm</code>验证】</p><ul><li>操作用户（主体）提交请求到Security Manager调用Authenticator去认证,Authenticator通过Pluggable Realms去获取认证信息，Pluggable Realms是从下面的数据源（数据库）中去获取的认证信息，然后用通过Pluggable Realms从数据库中获取的认证信息和主体提交过来的认证数据做比对。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shiro认证 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建一个简单的数据源</span></span><br><span class="line">    SimpleAccountRealm simpleAccountRealm = <span class="keyword">new</span> SimpleAccountRealm();</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 参数分别为：用户名，密码，权限...</span></span><br><span class="line">        simpleAccountRealm.addAccount(<span class="string">"chaooo"</span>, <span class="string">"123456"</span>, <span class="string">"admin"</span>,<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAuthentication</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1.构建SecurityManager环境</span></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        defaultSecurityManager.setRealm(simpleAccountRealm);</span><br><span class="line">        <span class="comment">// 2. 主体提交认证请求</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 3. 调用Subject.login(token)方法开始用户认证流程</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"chaooo"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        　　subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">"用户不存在: %s"</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">"密码不正确: %s"</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConcurrentAccessException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">"用户重复登录: %s"</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccountException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">"其他账户异常: %s"</span>, username), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-Shiro授权"><a href="#3-2-Shiro授权" class="headerlink" title="3.2 Shiro授权"></a>3.2 Shiro授权</h4><p>shiro访问授权有3种实现方式：<strong><code>api</code>调用</strong>，<strong><code>java</code>注解</strong>，<strong><code>jsp</code>标签</strong>。</p><ol><li>通过api调用实现:【创建<code>SecurityManager</code>】&gt;【主体授权】&gt;【<code>SecurityManager</code>调用<code>Authorizer</code>授权】&gt;【<code>Realm</code>获取角色权限数据】<ul><li>大体上和认证操作一样，也是通过Pluggable Realms从下面的数据源（数据库）中去获取权限数据,角色数据。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在执行访问授权验证之前，必须执行用户认证</span></span><br><span class="line"><span class="comment">// 角色验证</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">　　<span class="comment">//用户属于角色admin</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　<span class="comment">//用户不属于角色admin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// subject.checkRoles("admin","user");同时check多个角色</span></span><br><span class="line"><span class="comment">// 权限验证</span></span><br><span class="line">String perm = <span class="string">"log:manage:*"</span>;</span><br><span class="line"><span class="keyword">if</span>(subject.isPermitted(perm)) &#123;</span><br><span class="line">　　logger.info(String.format(<span class="string">"用户： %s 拥有权限：%s"</span>, name, perm));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">　　logger.error(String.format(<span class="string">"用户：%s 没有权限：%s"</span>, name, perm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在spring框架中可以通过java注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions</span>(value=&#123;<span class="string">"log:manage:*"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">home</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">　　ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"home"</span>);</span><br><span class="line">　　<span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在JSP页面中还可以直接使用jsp标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用shiro标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"log:manage:*"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%=request.getContextPath()%&gt;/user/home"</span>&gt;</span>操作日志审计<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-Quickstart"><a href="#3-3-Quickstart" class="headerlink" title="3.3 Quickstart"></a>3.3 Quickstart</h4><ol><li>新建一个<code>Maven</code>项目，<code>pom</code>导入<code>jar</code>包:<code>shiro-all</code>、<code>slf4j-api</code>、<code>slf4j-log4j12</code>、<code>log4j</code>;</li><li><code>classpath</code>下新建<code>shiro.ini</code>配置文件:</li></ol><figure class="highlight ini"><figcaption><span>shiro.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Users and their assigned roles</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each line conforms to the format defined in the</span></span><br><span class="line"><span class="comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="comment"># user 'root' with password 'secret' and the 'admin' role</span></span><br><span class="line"><span class="attr">root</span> = secret, admin</span><br><span class="line"><span class="comment"># user 'guest' with the password 'guest' and the 'guest' role</span></span><br><span class="line"><span class="attr">guest</span> = guest, guest</span><br><span class="line"><span class="comment"># user 'chaooo' with password '123456' and roles 'user' and 'guest'</span></span><br><span class="line"><span class="attr">chaooo</span> = <span class="number">123456</span>, user, guest</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Roles with assigned permissions</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Each line conforms to the format defined in the</span></span><br><span class="line"><span class="comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="comment"># 'admin' role has all permissions, indicated by the wildcard '*'</span></span><br><span class="line"><span class="attr">admin</span> = *</span><br><span class="line"><span class="comment"># The 'schwartz' role can do anything (*) with any lightsaber:</span></span><br><span class="line"><span class="attr">user</span> = user:*</span><br><span class="line"><span class="comment"># The 'goodguy' role is allowed to 'query' (action) the user (type) with license plate 'zhangsan' (instance specific id)</span></span><br><span class="line"><span class="attr">guest</span> = user:query:zhangsan</span><br></pre></td></tr></table></figure><ol start="3"><li>启动运行Quickstart</li></ol><figure class="highlight java"><figcaption><span>Quickstart.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quickstart</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger log = LoggerFactory.getLogger(Quickstart.class);</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建SecurityManager环境</span></span><br><span class="line">        DefaultSecurityManager securityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        IniRealm iniRealm = <span class="keyword">new</span> IniRealm(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">        securityManager.setRealm(iniRealm);</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get the currently executing user:</span></span><br><span class="line">        <span class="comment">// 获取当前的 Subject</span></span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Do some stuff with a Session (no need for a web or EJB container!!!)</span></span><br><span class="line">        <span class="comment">// 测试使用 shiro的Session</span></span><br><span class="line">        Session session = currentUser.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">"someKey"</span>, <span class="string">"aValue"</span>);</span><br><span class="line">        String value = (String) session.getAttribute(<span class="string">"someKey"</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">"aValue"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"---&gt; Retrieved the correct value! ["</span> + value + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// let's login the current user so we can check against roles and permissions:</span></span><br><span class="line">        <span class="comment">// 测试当前的用户是否已经被认证. 即是否已经登录.</span></span><br><span class="line">        <span class="comment">// 调动 Subject 的 isAuthenticated()</span></span><br><span class="line">        <span class="keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">            <span class="comment">// 把用户名和密码封装为 UsernamePasswordToken 对象</span></span><br><span class="line">            UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"chaooo"</span>, <span class="string">"123456"</span>);</span><br><span class="line">            <span class="comment">// rememberme</span></span><br><span class="line">            token.setRememberMe(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行登录.</span></span><br><span class="line">                currentUser.login(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若没有指定的账户, 则 shiro 将会抛出 UnknownAccountException 异常.</span></span><br><span class="line">            <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">                log.info(<span class="string">"----&gt; There is no user with username of "</span> + token.getPrincipal());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若账户存在, 但密码不匹配, 则 shiro 会抛出 IncorrectCredentialsException 异常。</span></span><br><span class="line">            <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">                log.info(<span class="string">"----&gt; Password for account "</span> + token.getPrincipal() + <span class="string">" was incorrect!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用户被锁定的异常 LockedAccountException</span></span><br><span class="line">            <span class="keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">                log.info(<span class="string">"The account for username "</span> + token.getPrincipal() + <span class="string">" is locked.  "</span> +</span><br><span class="line">                        <span class="string">"Please contact your administrator to unlock it."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span></span><br><span class="line">            <span class="comment">// 所有认证时异常的父类.</span></span><br><span class="line">            <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">                <span class="comment">//unexpected condition?  error?</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//say who they are:</span></span><br><span class="line">        <span class="comment">//print their identifying principal (in this case, a username):</span></span><br><span class="line">        log.info(<span class="string">"----&gt; User ["</span> + currentUser.getPrincipal() + <span class="string">"] logged in successfully."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test a role:</span></span><br><span class="line">        <span class="comment">// 测试是否有某一个角色. 调用 Subject 的 hasRole 方法.</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.hasRole(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"----&gt; May the Admin be with you!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"----&gt; Hello, mere mortal."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//test a typed permission (not instance-level)</span></span><br><span class="line">        <span class="comment">// 测试用户是否具备某一个行为. 调用 Subject 的 isPermitted() 方法。</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">"user:query, edit"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"----&gt; You are permitted to 'query' and 'edit' 'user'"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Sorry, you don't have permission"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//a (very powerful) Instance Level permission:</span></span><br><span class="line">        <span class="comment">// 测试用户是否具备某一个行为. 资源标识符:操作:对象实例ID</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">"user:query:zhangsan"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"----&gt; You are permitted to 'delete' 'user' 'zhangsan'"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Sorry, you don't have permission!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//all done - log out!</span></span><br><span class="line">        <span class="comment">// 执行登出. 调用 Subject 的 Logout() 方法.</span></span><br><span class="line">        System.out.println(<span class="string">"----&gt;"</span> + currentUser.isAuthenticated());</span><br><span class="line">        currentUser.logout();</span><br><span class="line">        System.out.println(<span class="string">"----&gt;"</span> + currentUser.isAuthenticated());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-在SpringMVC框架中集成Shiro"><a href="#4-在SpringMVC框架中集成Shiro" class="headerlink" title="4. 在SpringMVC框架中集成Shiro"></a>4. 在SpringMVC框架中集成Shiro</h3><h4 id="4-1-配置Maven依赖"><a href="#4-1-配置Maven依赖" class="headerlink" title="4.1 配置Maven依赖"></a>4.1 配置Maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables support for web-based applications. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables AspectJ support for Shiro AOP and Annotations. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables Ehcache-based famework caching. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables Spring Framework integration. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>Shiro</code>使用了日志框架<code>slf4j</code>，因此需要对应配置指定的日志实现组件，如：<code>log4j</code>，<code>logback</code>等。<ul><li>在此，以使用<code>log4j</code>为日志实现为例：</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">shiro使用slf4j作为日志框架，所以必需配置slf4j。</span></span><br><span class="line"><span class="comment">同时，使用log4j作为底层的日志实现框架。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-集成Shiro"><a href="#4-2-集成Shiro" class="headerlink" title="4.2 集成Shiro"></a>4.2 集成Shiro</h4><p>在<code>Spring</code>框架中集成<code>Shiro</code>，本质上是与<code>Spring IoC</code>容器和<code>Spring MVC</code>框架集成。</p><h5 id="4-2-1-Shiro与Spring-IoC容器集成"><a href="#4-2-1-Shiro与Spring-IoC容器集成" class="headerlink" title="4.2.1 Shiro与Spring IoC容器集成"></a>4.2.1 <code>Shiro</code>与<code>Spring IoC</code>容器集成</h5><ul><li><code>Spring IoC</code>容器提供了一个非常重要的功能，就是依赖注入，将<code>Bean</code>的定义以及<code>Bean</code>之间关系的耦合通过容器来处理。</li><li>也就是说，在<code>Spring</code>中集成<code>Shiro</code>时，<code>Shiro</code>中的相应<code>Bean</code>的定义以及他们的关系也需要通过<code>Spring IoC</code>容器实现。</li><li><code>Shiro</code>提供了与<code>Web</code>集成的支持，其通过一个<code>ShiroFilter</code>入口来拦截需要安全控制的<code>URL</code>，然后进行相应的控制。</li><li><code>ShiroFilter</code>类是安全控制的入口点，其负责读取配置（如<code>ini</code>配置文件），然后判断<code>URL</code> 是否需要登录/权限等工作。<ul><li>[urls] 部分的配置，其格式是：<code>url = 拦截器[参数], 拦截器[参数]</code></li></ul></li><li><code>shiro</code>中默认的过滤器：</li></ul><table><thead><tr><th>默认拦截器名</th><th>拦截器类与说明（括号里的表示默认值）</th></tr></thead><tbody><tr><td><span style="white-space:nowrap;">身份验证相关</span></td><td></td></tr><tr><td>authc</td><td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter<br>基于表单的拦截器；如”/**=authc”，如果没有登录会跳到相应的登录页面登录；主要属性：usernameParam：表单提交的用户名参数名（ username）；  passwordParam：表单提交的密码参数名（password）； rememberMeParam：表单提交的密码参数名（rememberMe）；  loginUrl：登录页面地址（/login.jsp）；successUrl：登录成功后的默认重定向地址； failureKeyAttribute：登录失败后错误信息存储key（shiroLoginFailure）；</td></tr><tr><td>authcBasic</td><td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter<br>Basic HTTP身份验证拦截器，主要属性：applicationName：弹出登录框显示的信息（application）；</td></tr><tr><td>logout</td><td>org.apache.shiro.web.filter.authc.LogoutFilter<br>退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/）;示例”/logout=logout”</td></tr><tr><td>user</td><td>org.apache.shiro.web.filter.authc.UserFilter<br>用户拦截器，用户已经身份验证/记住我登录的都可；示例”/**=user”</td></tr><tr><td>anon</td><td>org.apache.shiro.web.filter.authc.AnonymousFilter<br>匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例”/static/**=anon”</td></tr><tr><td>授权相关</td><td></td></tr><tr><td>roles</td><td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter<br>角色授权拦截器，验证用户是否拥有所有角色；主要属性：loginUrl：登录页面地址（/login.jsp）；unauthorizedUrl：未授权后重定向的地址；示例”/admin/**=roles[admin]”</td></tr><tr><td>perms</td><td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter<br>权限授权拦截器，验证用户是否拥有所有权限；属性和roles一样；示例”/user/**=perms[“user:create”]”</td></tr><tr><td>port</td><td>org.apache.shiro.web.filter.authz.PortFilter<br>端口拦截器，主要属性：port（80）：可以通过的端口；示例”/test= port[80]”，如果用户访问该页面是非80，将自动将请求端口改为80并重定向到该80端口，其他路径/参数等都一样</td></tr><tr><td>rest</td><td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter<br>rest风格拦截器，自动根据请求方法构建权限字符串（GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create）构建权限字符串；示例”/users=rest[user]”，会自动拼出”user:read,user:create,user:update,user:delete”权限字符串进行权限匹配（所有都得匹配，isPermittedAll）；</td></tr><tr><td>ssl</td><td>org.apache.shiro.web.filter.authz.SslFilter<br>SSL拦截器，只有请求协议是https才能通过；否则自动跳转会https端口（443）；其他和port拦截器一样；</td></tr><tr><td>其他</td><td></td></tr><tr><td>noSessionCreation</td><td>org.apache.shiro.web.filter.session.NoSessionCreationFilter<br>不创建会话拦截器，调用 subject.getSession(false)不会有什么问题，但是如果 subject.getSession(true)将抛出 DisabledSessionException异常；</td></tr></tbody></table><ul><li><code>URL</code>匹配模式：url模式使用Ant 风格模式<ul><li>Ant 路径通配符支持<code>?</code>、<code>*</code>、<code>**</code>，注意通配符匹配不包括目录分隔符“/”：</li><li><code>?</code>：匹配一个字符，如/admin? 将匹配/admin1，但不匹配/admin 或/admin/；</li><li><code>*</code>：匹配零个或多个字符串，如/admin 将匹配/admin、/admin123，但不匹配/admin/1；</li><li><code>**</code>：匹配路径中的零个或多个路径，如/admin/** 将匹配/admin/a 或/admin/a/b</li></ul></li><li><code>URL</code>匹配顺序：URL 权限采取<strong>第一次匹配优先</strong>的方式，即从头开始使用第一个匹配的url模式对应的拦截器链。如：<ul><li>/bb/**=filter1</li><li>/bb/aa=filter2</li><li>/**=filter3</li><li>如果请求的url是“/bb/aa”，因为按照声明顺序进行匹配，那么将使用filter1 进行拦截，所以通配符一般写在靠后。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/index"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"successUrl"</span> <span class="attr">value</span>=<span class="string">"/home"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/unauthorized.jsp"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- The 'filters' property is not necessary since any declared javax.servlet.Filter bean  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- defined will be automatically acquired and available via its beanName in chain        --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- definitions, but you can perform instance overrides or name aliases here if you like: --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;property name="filters"&gt;</span></span><br><span class="line"><span class="comment">      &lt;util:map&gt;</span></span><br><span class="line"><span class="comment">          &lt;entry key="logout" value-ref="logoutFilter" /&gt;</span></span><br><span class="line"><span class="comment">      &lt;/util:map&gt;</span></span><br><span class="line"><span class="comment">  &lt;/property&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">          # some example chain definitions:</span><br><span class="line">          # /admin/** = authc, roles[admin]</span><br><span class="line">          # /docs/** = authc, perms[document:read]</span><br><span class="line">          /login = anon</span><br><span class="line">          /logout = anon</span><br><span class="line">          /error = anon</span><br><span class="line">          /** = user</span><br><span class="line">          # more URL-to-FilterChain definitions here</span><br><span class="line">      <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"myRealm"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- By default the servlet container sessions will be used.  Uncomment this line</span></span><br><span class="line"><span class="comment">       to use shiro's native sessions (see the JavaDoc for more): --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;property name="sessionMode" value="native"/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Define the Shiro Realm implementation you want to use to connect to your back-end --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- security datasource: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myRealm"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.realm.jdbc.JdbcRealm"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"permissionsLookupEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enable Shiro Annotations for Spring-configured beans.  Only run after --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- the lifecycleBeanProcessor has run: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span> <span class="attr">depends-on</span>=<span class="string">"lifecycleBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-2-与Spring-MVC集成"><a href="#4-2-2-与Spring-MVC集成" class="headerlink" title="4.2.2 与Spring MVC集成"></a>4.2.2 与<code>Spring MVC</code>集成</h5><ul><li>跟在普通<code>Java Web</code>应用中使用<code>Shiro</code>一样，集成<code>Shiro</code>到<code>Spring MVC</code>时，实际上就是通过在<code>web.xml</code>中添加指定<code>Filter</code>实现。配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The filter-name matches name of a 'shiroFilter' bean inside applicationContext.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- DelegatingFilterProxy作用是自动到Spring 容器查找名字为shiroFilter（filter-name）的bean并把所有Filter 的操作委托给它。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Make sure any request you want accessible to Shiro is filtered. /* catches all --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- requests.  Usually this filter mapping is defined first (before all others) to --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ensure that Shiro works in subsequent filters in the filter chain:             --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Spring</code>中集成<code>Shiro</code>的原理就是：通过在<code>web.xml</code>中配置的<code>Shiro Filter</code>与<code>Spring IoC</code>中定义的相应的<code>Shiro Bean</code>定义建立关系，从而实现在<code>Spring</code>框架集成<code>Shiro</code>。</p></blockquote><h4 id="4-3-数据源配置"><a href="#4-3-数据源配置" class="headerlink" title="4.3 数据源配置"></a>4.3 数据源配置</h4><p>在<code>Shiro</code>中，<code>Realm</code>定义了访问数据的方式，用来连接不同的数据源，如：LDAP，关系数据库，配置文件等。</p><ul><li>以<code>org.apache.shiro.realm.jdbc.JdbcRealm</code>为例，将用户信息存放在关系型数据库中。</li><li>在使用<code>JdbcRealm</code>时，必须要在关系型数据库中存在3张表，分别是<ul><li><code>users</code>表，存放认证用户基本信息，在该表中必须存在2个字段：<code>username</code>，<code>password</code>。</li><li><code>roles_permissions</code>表，存放角色和权限定义，在该表中必须存在2个字段：<code>role_name</code>，<code>permission</code>。</li><li><code>user_roles</code>表，存放用户角色对应关系，在该表中必须存在2个字段：<code>username</code>，<code>role_name</code>。</li></ul></li><li>实际上，在更加复杂的应用场景下，通常需要扩展<code>JdbcRealm</code>。</li></ul><h4 id="4-4-认证"><a href="#4-4-认证" class="headerlink" title="4.4 认证"></a>4.4 认证</h4><p>在<code>Shiro</code>中，认证即执行用户登录，读取指定<code>Realm</code>连接的数据源，以验证用户身份的有效性与合法性。</p><ul><li>在shiro中，用户需要提供principals （身份）和credentials（证明）给shiro，从而应用能验证用户身份：<ul><li>principals：身份，即主体的标识属性，可以是任何属性，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/邮箱/手机号。</li><li>credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</li><li>最常见的principals 和credentials 组合就是用户名/密码了</li></ul></li><li>身份认证流程：<ol><li>首先调用Subject.login(token) 进行登录，其会自动委托给SecurityManager</li><li>SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator 进行身份验证；</li><li>Authenticator 才是真正的身份验证者，ShiroAPI 中核心的身份认证入口点，此处可以自定义插入自己的实现；</li><li>Authenticator 可能会委托给相应的AuthenticationStrategy进行多Realm 身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm 身份验证；</li><li>Authenticator 会把相应的token 传入Realm，从Realm 获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。<ul><li>Realm：一般继承AuthorizingRealm（授权）即可；其继承了AuthenticatingRealm（即身份验证），而且也间接继承了CachingRealm（带有缓存实现）</li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(!subject.isAuthenticated()) &#123;</span><br><span class="line">　　UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(name, password);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    　　subject.login(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">"用户不存在: %s"</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">"密码不正确: %s"</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConcurrentAccessException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">"用户重复登录: %s"</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AccountException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">"其他账户异常: %s"</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-授权"><a href="#4-5-授权" class="headerlink" title="4.5 授权"></a>4.5 授权</h4><p>Shiro作为权限框架，仅仅只能控制对资源的操作权限，并不能完成对数据权限的业务需求。</p><ul><li>而对于Java Web环境下Shiro授权，包含两个方面的含义。<ul><li>其一，对于前端来说，用户只能看到他对应访问权限的元素。</li><li>其二，当用户执行指定操作（即：访问某个uri资源）时，需要验证用户是否具备对应权限。</li></ul></li><li>对于第一点，在Java Web环境下，通过Shiro提供的JSP标签实现。</li><li>对于第二点，与在非Java Web环境下一样，需要在后端调用API进行权限（或者角色）检验。</li><li>在Spring框架中集成Shiro，还可以直接通过Java注解方式实现</li><li><code>Permissions</code>：<ul><li>规则：<code>资源标识符：操作：对象实例ID</code>,即对哪个资源的哪个实例可以进行什么操作.其默认支持通配符权限字符串，: 表示资源/操作/实例的分割；, 表示操作的分割，* 表示任意资源/操作/实例。如：<code>user:edit:manager</code><ul><li>也可以使用通配符来定义，如：<code>user:edit:*</code>、<code>user:*:*</code>、<code>user:*:manager</code></li><li>部分省略通配符：缺少的部件意味着用户可以访问所有与之匹配的值，比如：<code>user:edit</code>等价于<code>user:edit:*</code>、<code>user</code>等价于<code>user:*:*</code></li><li>注意：通配符只能从字符串的结尾处省略部件，也就是说<code>user:edit</code>并<strong>不等价</strong>于<code>user:*:edit</code></li></ul></li></ul></li><li>授权流程:<ol><li>首先调用Subject.isPermitted<em>/hasRole</em> 接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer；</li><li>Authorizer是真正的授权者，如果调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission 实例；</li><li>在进行授权之前，其会调用相应的Realm 获取Subject 相应的角色/权限用于匹配传入的角色/权限；</li><li>Authorizer 会判断Realm 的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted<em>/hasRole</em> 会返回true，否则返回false表示授权失败。<ul><li><code>ModularRealmAuthorizer</code>进行多Realm 匹配流程：<ol><li>首先检查相应的Realm 是否实现了实现了Authorizer；</li><li>如果实现了Authorizer，那么接着调用其相应的<code>isPermitted*/hasRole*</code>接口进行匹配；</li><li>如果有一个Realm匹配那么将返回true，否则返回false。</li></ol></li></ul></li></ol></li></ul><h5 id="4-5-1-Shiro标签"><a href="#4-5-1-Shiro标签" class="headerlink" title="4.5.1 Shiro标签"></a>4.5.1 Shiro标签</h5><ol><li><code>&lt;shiro:guest&gt;&lt;/shiro:guest&gt;</code>:用户没有身份验证时显示相应信息，即游客访问信息</li><li><code>&lt;shiro:user&gt;&lt;/shiro:user&gt;</code>:用户已经经过认证/记住我登录后显示相应的信息。</li><li><code>&lt;shiro:authenticated&gt;&lt;/shiro:authenticated&gt;</code>:用户已经身份验证通过，即Subject.login登录成功，<strong>不是记住我登录的</strong></li><li><code>&lt;shiro:notAuthenticated&gt;&lt;/shiro:notAuthenticated&gt;</code>标签：用户未进行身份验证，即没有调用Subject.login进行登录，<strong>包括记住我自动登录</strong>的也属于未进行身份验证。</li><li><code>&lt;shiro:pincipal&gt;&lt;/shiro:pincipal&gt;</code>：<strong>显示用户身份信息</strong>，默认调用<code>Subject.getPrincipal()</code>获取，即Primary Principal。</li><li><strong><code>&lt;shiro:hasRole&gt;&lt;/shiro:hasRole&gt;</code></strong>标签：如果当前Subject 有角色将显示body 体内容</li><li><code>&lt;shiro:hasAnyRoles&gt;&lt;/shiro:hasAnyRoles&gt;</code>标签：如果当前Subject有任意一个角色（或的关系）将显示body体内容</li><li><code>&lt;shiro:lacksRole&gt;&lt;/shiro:lacksRole&gt;</code>：如果当前Subject 没有角色将显示body 体内容</li><li><strong><code>&lt;shiro:hasPermission&gt;&lt;/shiro:hasPermission&gt;</code></strong>：如果当前Subject 有权限将显示body体内容</li><li><code>&lt;shiro:lacksPermission&gt;&lt;/shiro:lacksPermission&gt;</code>：如果当前Subject没有权限将显示body体内容</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在jsp页面中引入shiro标签库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> <span class="attr">uri</span>=<span class="string">"http://shiro.apache.org/tags"</span> %&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 权限控制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"winnebago:drive:eagle5"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span>&gt;</span>操作审计<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-5-2-调用API进行权限（或者角色）检验"><a href="#4-5-2-调用API进行权限（或者角色）检验" class="headerlink" title="4.5.2 调用API进行权限（或者角色）检验"></a>4.5.2 调用API进行权限（或者角色）检验</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String roleAdmin = <span class="string">"admin"</span>;</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(!currentUser.hasRole(roleAdmin)) &#123;</span><br><span class="line">　　<span class="comment">//todo something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-5-3-Shiro权限注解"><a href="#4-5-3-Shiro权限注解" class="headerlink" title="4.5.3 Shiro权限注解"></a>4.5.3 Shiro权限注解</h5><ul><li><code>@RequiresAuthentication</code>：表示当前Subject已经通过login 进行了身份验证；即Subject. isAuthenticated() 返回true</li><li><code>@RequiresUser</code>：表示当前Subject 已经身份验证或者通过记住我登录的。</li><li><code>@RequiresGuest</code>：表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。</li><li><code>@RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)</code>：表示当前Subject 需要角色admin 和user</li><li><code>@RequiresPermissions(value={“user:a”, “user:b”}, logical= Logical.OR)</code>：表示当前Subject 需要权限user:a或user:b。</li><li>通过自定义拦截器可以扩展功能，例如：动态url-角色/权限访问控制的实现、根据Subject 身份信息获取用户信息绑定到Request（即设置通用数据）、验证码验证、在线用户信息的保存等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">　　<span class="meta">@RequestMapping</span>(<span class="string">"/home"</span>)</span><br><span class="line">　　<span class="meta">@RequiresPermissions</span>(value=&#123;<span class="string">"log:manage:*"</span>&#125;)</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">home</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">　　　　ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"home"</span>);</span><br><span class="line">　　　　<span class="keyword">return</span> mv;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-Spring集成Shiro注意事项"><a href="#4-6-Spring集成Shiro注意事项" class="headerlink" title="4.6 Spring集成Shiro注意事项"></a>4.6 Spring集成Shiro注意事项</h4><ol><li><code>Spring 4.2.0 RELEASE</code><strong><code>+</code></strong> 与 <code>Spring 4.1.9 RELEASE</code><strong><code>-</code></strong>版本，配置方式有所不同。</li><li>虽然<code>shiro</code>的注解定义是在<code>Class</code>级别的，但是实际验证只能支持方法级别：<code>@RequiresAuthentication</code>、<code>@RequiresPermissions</code>、<code>@RequiresRoles</code>。</li></ol><h3 id="5-Shiro会话管理"><a href="#5-Shiro会话管理" class="headerlink" title="5. Shiro会话管理"></a>5. Shiro会话管理</h3><p>Shiro提供了完整的企业级会话管理功能，不依赖于底层容器（如web容器tomcat），不管JavaSE还是JavaEE环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对Web 的透明支持、SSO 单点登录的支持等特性。</p><h4 id="5-1-会话相关的API"><a href="#5-1-会话相关的API" class="headerlink" title="5.1 会话相关的API"></a>5.1 会话相关的API</h4><ul><li>Subject.getSession()：即可获取会话；其等价于Subject.getSession(true)，即如果当前没有创建Session 对象会创建一个；Subject.getSession(false)，如果当前没有创建Session 则返回null</li><li>session.getId()：获取当前会话的唯一标识</li><li>session.getHost()：获取当前Subject的主机地址</li><li>session.getTimeout() &amp; session.setTimeout(毫秒)：获取/设置当前Session的过期时间</li><li>session.getStartTimestamp() &amp; session.getLastAccessTime()：获取会话的启动时间及最后访问时间；如果是 JavaSE 应用需要自己定期调用 session.touch() 去更新最后访问时间；如果是 Web 应用，每次进入 ShiroFilter 都会自动调用 session.touch() 来更新最后访问时间。</li><li>session.touch() &amp; session.stop()：更新会话最后访问时间及销毁会话；当Subject.logout()时会自动调用 stop 方法来销毁会话。如果在web中，调用 HttpSession. invalidate()也会自动调用Shiro Session.stop 方法进行销毁Shiro 的会话</li><li>session.setAttribute(key, val) &amp; session.getAttribute(key) &amp; session.removeAttribute(key)：设置/获取/删除会话属性；在整个会话范围内都可以对这些属性进行操作</li></ul><h4 id="5-2-会话监听器"><a href="#5-2-会话监听器" class="headerlink" title="5.2 会话监听器"></a>5.2 会话监听器</h4><p>会话监听器(SessionListiner):会话监听器用于监听会话创建、过期及停止事件</p><h4 id="5-3-SessionDao"><a href="#5-3-SessionDao" class="headerlink" title="5.3 SessionDao"></a>5.3 SessionDao</h4><ul><li>AbstractSessionDAO 提供了 SessionDAO 的基础实现，如生成会话ID等</li><li>CachingSessionDAO 提供了对开发者透明的会话缓存的功能，需要设置相应的 CacheManager</li><li>MemorySessionDAO 直接在内存中进行会话维护</li><li>EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用ConcurrentHashMap 保存缓存的会话。 </li></ul><h4 id="5-4-数据表"><a href="#5-4-数据表" class="headerlink" title="5.4 数据表"></a>5.4 数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sessions (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">session</span> <span class="built_in">varchar</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">constraint</span> pk_sessions primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><h4 id="5-5-会话验证"><a href="#5-5-会话验证" class="headerlink" title="5.5 会话验证"></a>5.5 会话验证</h4><ul><li>Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话</li><li>出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 web 环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器SessionValidationScheduler</li><li>Shiro 也提供了使用Quartz会话验证调度器：QuartzSessionValidationScheduler</li></ul><h3 id="6-Shiro缓存"><a href="#6-Shiro缓存" class="headerlink" title="6. Shiro缓存"></a>6. Shiro缓存</h3><ul><li>CacheManagerAware 接口<ul><li>Shiro 内部相应的组件（DefaultSecurityManager）会自动检测相应的对象（如Realm）是否实现了CacheManagerAware 并自动注入相应的CacheManager。</li></ul></li><li>Realm 缓存<ul><li>Shiro 提供了 CachingRealm，其实现了CacheManagerAware 接口，提供了缓存的一些基础实现；</li><li>AuthenticatingRealm 及 AuthorizingRealm 也分别提供了对AuthenticationInfo 和 AuthorizationInfo 信息的缓<br>存。</li></ul></li><li>Session 缓存<ul><li>如 SecurityManager 实现了 SessionSecurityManager，其会判断 SessionManager 是否实现了acheManagerAware 接口，如果实现了会把CacheManager 设置给它。</li><li>SessionManager 也会判断相应的 SessionDAO（如继承自CachingSessionDAO）是否实现了CacheManagerAware，如果实现了会把 CacheManager设置给它</li><li>设置了缓存的 SessionManager，查询时会先查缓存，如果找不到才查数据库。</li></ul></li><li>RememberMe<ul><li>Shiro 提供了记住我（RememberMe）的功能，比如访问如淘宝等一些网站时，关闭了浏览器，下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问，基本流程如下：<ol><li>首先在登录页面选中 RememberMe 然后登录成功；如果是浏览器登录，一般会把 RememberMe 的Cookie 写到客户端并保存下来；</li><li>关闭浏览器再重新打开；会发现浏览器还是记住你的；</li><li>访问一般的网页服务器端还是知道你是谁，且能正常访问；</li><li>但是比如我们访问淘宝时，如果要查看我的订单或进行支付时，此时还是需要再进行身份认证的，以确保当前用户还是你。</li></ol></li></ul></li><li>认证和记住我<ul><li>subject.isAuthenticated() 表示用户进行了身份验证登录的，即使有 Subject.login 进行了登录；</li><li>subject.isRemembered()：表示用户是通过记住我登录的，此时可能并不是真正的你（如你的朋友使用你的电脑，或者你的cookie 被窃取）在访问的</li><li>两者二选一，即 subject.isAuthenticated()==true，则subject.isRemembered()==false；反之一样。</li></ul></li><li>建议<ul><li>访问一般网页：如个人在主页之类的，我们使用user 拦截器即可，user 拦截器只要用户登录(isRemembered() || isAuthenticated())过即可访问成功；</li><li>访问特殊网页：如我的订单，提交订单页面，我们使用authc 拦截器即可，authc 拦截器会判断用户是否是通过Subject.login（isAuthenticated()==true）登录的，如果是才放行，否则会跳转到登录页面叫你重新登录。</li></ul></li><li>实现<ul><li>如果要自己做RememeberMe，需要在登录之前这样创建Token：UsernamePasswordToken(用户名，密码，是否记住我)，且调用UsernamePasswordToken 的：token.setRememberMe(true); 方法</li></ul></li></ul><blockquote><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/nuccch/p/6775855.html" target="_blank" rel="noopener">细说shiro之一：shiro简介</a></li><li><a href="https://www.cnblogs.com/nuccch/p/6775855.html" target="_blank" rel="noopener">细说shiro之五：在spring框架中集成shiro</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-初识Shiro&quot;&gt;&lt;a href=&quot;#1-初识Shiro&quot; class=&quot;headerlink&quot; title=&quot;1. 初识Shiro&quot;&gt;&lt;/a&gt;1. 初识Shiro&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Apache Shiro&lt;/code&gt;是一个强大易用的Java安全框架，提供了认证、授权、加密、会话管理、与Web集成、缓存等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;具体来说，满足对如下元素的支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户，角色，权限(仅仅是操作权限，数据权限必须与业务需求紧密结合)，资源(url)。&lt;/li&gt;
&lt;li&gt;用户分配角色，角色定义权限。&lt;/li&gt;
&lt;li&gt;访问授权时支持角色或者权限，并且支持多级的权限定义。
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】基于Redis的分布式锁实现</title>
    <link href="http://chaooo.github.io/article/20191208.html"/>
    <id>http://chaooo.github.io/article/20191208.html</id>
    <published>2019-12-08T08:04:23.000Z</published>
    <updated>2019-12-08T08:26:49.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SETNX命令简介"><a href="#SETNX命令简介" class="headerlink" title="SETNX命令简介"></a>SETNX命令简介</h3><ul><li><code>SETNX key value</code>返回(<code>1:key</code>的值被设置，<code>0:key</code>的值没被设置)，将<code>key</code>的值设为<code>value</code>，并且仅当<code>key</code>不存在。</li><li>锁的<code>key</code>为目标数据的唯一键，<code>value</code>为锁的期望超时时间点；</li><li>基于<code>Redis</code>实现的分布式锁，主要基于<code>redis</code>的<code>setnx（set if not exist）</code>命令；<a id="more"></a></li></ul><h3 id="1-jedis实现分布式锁"><a href="#1-jedis实现分布式锁" class="headerlink" title="1. jedis实现分布式锁"></a>1. jedis实现分布式锁</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-1-实现示例"><a href="#1-1-实现示例" class="headerlink" title="1.1 实现示例:"></a>1.1 实现示例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">correctGetLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">    String result = jedis.set(lockKey, requestId, <span class="string">"NX"</span>, <span class="string">"PX"</span>, expireTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"OK"</span>.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jedis.set(String key, String value, String nxxx, String expx, int time)</code><br>    - <strong><code>key</code></strong>：保证唯一，用来当锁（<code>redis</code>记录的<code>key</code>）<br>    - <strong><code>value</code></strong>：<code>redis</code>记录的<code>value</code>，目的是为了标志锁的所有者（竞争锁的客户端），保证解锁时只能解自己加的锁。<code>requestId</code>可以使用<code>UUID.randomUUID().toString()</code>方法生成<br>    - <strong><code>nxxx</code></strong>：<code>&quot;NX&quot;</code>意思是<code>SET IF NOT EXIST</code>，即当<code>key</code>不存在时，我们进行<code>set</code>操作，若<code>key</code>已经存在，则不做任何操作<br>    - <strong><code>expx</code></strong>：<code>&quot;PX&quot;</code>意思是要给这个<code>key</code>加一个过期的设置（单位毫秒），过期时间由第五个参数决定<br>    - <strong><code>time</code></strong>：<code>expx</code>设置为<code>&quot;PX&quot;</code>时，<code>redis key</code>的过期时间</p><h4 id="1-2-解锁示例"><a href="#1-2-解锁示例" class="headerlink" title="1.2 解锁示例:"></a>1.2 解锁示例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">correctReleaseLock</span><span class="params">(String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">    String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">    <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eval</code>命令执行<code>Lua</code>代码的时候，<code>Lua</code>代码将被当成一个命令去执行，并且直到<code>eval</code>命令执行完成，<code>Redis</code>才会执行其他命令，所以保证了检查和删除操作都是原子的。</p><h4 id="1-3-这类琐最大的缺点"><a href="#1-3-这类琐最大的缺点" class="headerlink" title="1.3 这类琐最大的缺点"></a>1.3 这类琐最大的缺点</h4><p>加锁时只作用在一个<code>Redis</code>节点上，即使<code>Redis</code>通过<code>sentinel</code>保证高可用，如果这个<code>master</code>节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p><ol><li>在<code>Redis</code>的<code>master</code>节点上拿到了锁；</li><li>但是这个加锁的<code>key</code>还没有同步到<code>slave</code>节点；</li><li><code>master</code>故障，发生故障转移，<code>slave</code>节点升级为<code>master</code>节点；</li><li>导致锁丢失。</li></ol><blockquote><p>因此，<code>Redis</code>作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：<code>Redlock</code>。基于<code>Redis</code>的<code>Redisson</code>实现了<code>Redlock</code>。</p></blockquote><h3 id="2-Redisson实现普通分布式锁"><a href="#2-Redisson实现普通分布式锁" class="headerlink" title="2. Redisson实现普通分布式锁"></a>2. Redisson实现普通分布式锁</h3><p>普通分布式实现非常简单，无论是那种架构，向<code>Redis</code>通过<code>EVAL</code>命令执行<code>LUA脚本</code>即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>单机模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造redisson实现分布式锁必要的Config</span></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">"redis://172.29.1.180:5379"</span>)</span><br><span class="line">                        .setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 构造RedissonClient</span></span><br><span class="line">RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"><span class="comment">// 设置锁定资源名称, 还可以getFairLock(), getReadWriteLock()</span></span><br><span class="line">RLock lock = redissonClient.getLock(<span class="string">"DISLOCK"</span>);</span><br><span class="line"><span class="keyword">boolean</span> isLock;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line">    <span class="comment">// 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</span></span><br><span class="line">    isLock = lock.tryLock(<span class="number">500</span>, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">//TODO if get lock success, do something;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论如何, 最后都要解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哨兵模式:</strong><br>即<code>Sentinel</code>模式，实现代码和单机模式几乎一样，唯一的不同就是<code>Config</code>的构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSentinelServers().addSentinelAddress(</span><br><span class="line">        <span class="string">"redis://172.29.3.245:26378"</span>,<span class="string">"redis://172.29.3.245:26379"</span>, <span class="string">"redis://172.29.3.245:26380"</span>)</span><br><span class="line">      .setMasterName(<span class="string">"mymaster"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>集群模式:</strong><br>即<code>Cluster</code>模式，集群模式构造<code>Config</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useClusterServers().addNodeAddress(</span><br><span class="line">        <span class="string">"redis://172.29.3.245:6375"</span>,<span class="string">"redis://172.29.3.245:6376"</span>, <span class="string">"redis://172.29.3.245:6377"</span>,</span><br><span class="line">        <span class="string">"redis://172.29.3.245:6378"</span>,<span class="string">"redis://172.29.3.245:6379"</span>, <span class="string">"redis://172.29.3.245:6380"</span>)</span><br><span class="line">      .setPassword(<span class="string">"a123456"</span>).setScanInterval(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h3 id="3-Redisson实现Redlock分布式锁"><a href="#3-Redisson实现Redlock分布式锁" class="headerlink" title="3. Redisson实现Redlock分布式锁"></a>3. Redisson实现Redlock分布式锁</h3><h4 id="3-1-Redlock算法大概原理："><a href="#3-1-Redlock算法大概原理：" class="headerlink" title="3.1 Redlock算法大概原理："></a>3.1 Redlock算法大概原理：</h4><ul><li>在<code>Redis</code>的分布式环境中，我们假设有<code>N</code>个<code>Redis master</code>。这些节点<strong>完全互相独立，不存在主从复制或者其他集群协调机制</strong>。我们确保将在<code>N</code>个实例上使用与在<code>Redis</code>单实例下相同方法获取和释放锁。</li><li>为了取到锁，客户端应该执行以下操作:<ul><li>获取当前<code>Unix</code>时间，以毫秒为单位。</li><li>依次尝试从<code>N</code>个实例，使用相同的<code>key</code>和具有唯一性的<code>value</code>（例如UUID）获取锁。</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。</li><li><strong>当且仅当(N/2+1)的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功</strong>，例如3个节点至少需要<code>3/2+1=2</code>2个。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li><li>若获取锁失败，客户端应该在<strong>所有的Redis实例上进行解锁</strong>（即便某些Redis实例根本就没有加锁成功）。</li></ul></li></ul><h4 id="3-2-使用Redlock"><a href="#3-2-使用Redlock" class="headerlink" title="3.2 使用Redlock"></a>3.2 使用<code>Redlock</code></h4><p>单机模式<code>Redis</code>为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useClusterServers().addNodeAddress(</span><br><span class="line">        <span class="string">"redis://127.0.0.1:6379"</span>,<span class="string">"redis://127.0.0.1:6369"</span>, <span class="string">"redis://127.0.0.1:6359"</span>,</span><br><span class="line">        <span class="string">"redis://127.0.0.1:6349"</span>,<span class="string">"redis://127.0.0.1:6339"</span>)</span><br><span class="line">        .setPassword(<span class="string">"******"</span>);</span><br><span class="line"><span class="comment">// 节点1</span></span><br><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><br><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class="line"><span class="comment">// 节点2</span></span><br><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><br><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6378"</span>);</span><br><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class="line"><span class="comment">// 节点3</span></span><br><span class="line">Config config3 = <span class="keyword">new</span> Config();</span><br><span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6377"</span>);</span><br><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class="line"><span class="comment">// 设置锁定资源名称</span></span><br><span class="line">String resourceName = <span class="string">"REDLOCK"</span>;</span><br><span class="line">RLock lock1 = redissonClient1.getLock(resourceName);</span><br><span class="line">RLock lock2 = redissonClient2.getLock(resourceName);</span><br><span class="line">RLock lock3 = redissonClient3.getLock(resourceName);</span><br><span class="line"><span class="comment">// 实例化RedissonRedLock</span></span><br><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLock = redLock.tryLock(<span class="number">500</span>, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">//TODO if get lock success, do something;</span></span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最核心的变化就是 <code>RedissonRedLock redLock</code>=<strong><code>new RedissonRedLock(lock1,lock2,lock3)</code>;</strong>，因为我这里是以三个节点为例。</p><ul><li>如果是主从<code>Redis</code>架构、哨兵<code>Redis</code>架构、集群<code>Redis</code>架构实现<code>Redlock</code>，只需要改变上述<code>config1</code>、<code>config2</code>、<code>config3</code>为主从模式、哨兵模式、集群模式配置即可，但相应需要<code>3</code>个独立的<code>Redis</code>主从集群、<code>3</code>个<code>Redis</code>独立的哨兵集群、<code>3</code>个独立的<code>Cluster</code>集群。</li><li>以<code>sentinel</code>模式架构为例，<code>3</code>个<code>sentinel</code>模式集群，如果要获取分布式锁，那么需要向这<code>3</code>个<code>sentinel</code>集群通过<code>EVAL</code>命令执行<code>LUA</code>脚本，需要<code>3/2+1=2</code>，即至少2个<code>sentinel</code>集群响应成功，才算成功的以<code>Redlock</code>算法获取到分布式锁。</li></ul><h3 id="4-Redlock问题合集"><a href="#4-Redlock问题合集" class="headerlink" title="4. Redlock问题合集"></a>4. Redlock问题合集</h3><h4 id="4-1-N个节点的理解"><a href="#4-1-N个节点的理解" class="headerlink" title="4.1 N个节点的理解"></a>4.1 N个节点的理解</h4><p>假设我们用<code>N(&gt;=3)</code>个节点实现<code>Redlock</code>算法的分布式锁。<strong>不是</strong>一个有<code>N</code>个主节点的cluster集群；而是<strong>要么是<code>N</code>个redis单实例，要么是<code>N</code>个sentinel集群，要么是<code>N</code>个cluster集群</strong>。</p><h4 id="4-2-失效时间如何设置"><a href="#4-2-失效时间如何设置" class="headerlink" title="4.2 失效时间如何设置"></a>4.2 失效时间如何设置</h4><p>这个问题的场景是，假设设置失效时间10秒，如果由于某些原因导致10秒还没执行完任务，这时候锁自动失效，导致其他线程也会拿到分布式锁。<br>这确实是Redis分布式最大的问题，不管是普通分布式锁，还是Redlock算法分布式锁，都没有解决这个问题。也有一些文章提出了对失效时间续租，即延长失效时间，很明显这又提升了分布式锁的复杂度（没有现成的框架有实现）。</p><h4 id="4-3-redis分布式锁的高可用"><a href="#4-3-redis分布式锁的高可用" class="headerlink" title="4.3 redis分布式锁的高可用"></a>4.3 redis分布式锁的高可用</h4><p>关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者Antirez之间已经发生过一场争论。有兴趣的同学，搜索”基于Redis的分布式锁到底安全吗”就能得到你想要的答案，需要注意的是，有上下两篇（这应该就是传说中的神仙打架吧）。</p><h4 id="4-4-使用Zookeeper还是Redis实现分布式锁"><a href="#4-4-使用Zookeeper还是Redis实现分布式锁" class="headerlink" title="4.4 使用Zookeeper还是Redis实现分布式锁"></a>4.4 使用Zookeeper还是Redis实现分布式锁</h4><p>没有绝对的好坏，只有更适合自己的业务。<br>就<strong>性能</strong>而言，<code>Redis</code>很明显优于<code>Zookeeper</code>；就分布式锁实现的健壮性(<strong>高可用</strong>)而言，<code>Zookeeper</code>很明显优于<code>Redis</code>。至于如何选择，还要看具体业务场景。</p><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SETNX命令简介&quot;&gt;&lt;a href=&quot;#SETNX命令简介&quot; class=&quot;headerlink&quot; title=&quot;SETNX命令简介&quot;&gt;&lt;/a&gt;SETNX命令简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SETNX key value&lt;/code&gt;返回(&lt;code&gt;1:key&lt;/code&gt;的值被设置，&lt;code&gt;0:key&lt;/code&gt;的值没被设置)，将&lt;code&gt;key&lt;/code&gt;的值设为&lt;code&gt;value&lt;/code&gt;，并且仅当&lt;code&gt;key&lt;/code&gt;不存在。&lt;/li&gt;
&lt;li&gt;锁的&lt;code&gt;key&lt;/code&gt;为目标数据的唯一键，&lt;code&gt;value&lt;/code&gt;为锁的期望超时时间点；&lt;/li&gt;
&lt;li&gt;基于&lt;code&gt;Redis&lt;/code&gt;实现的分布式锁，主要基于&lt;code&gt;redis&lt;/code&gt;的&lt;code&gt;setnx（set if not exist）&lt;/code&gt;命令；
    
    </summary>
    
      <category term="Redis" scheme="http://chaooo.github.io/categories/Redis/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【ElasticStack】Beats+Logstash+Elasticsearch+Kibana基础整合</title>
    <link href="http://chaooo.github.io/article/20191123.html"/>
    <id>http://chaooo.github.io/article/20191123.html</id>
    <published>2019-11-23T14:29:59.000Z</published>
    <updated>2019-12-08T08:27:03.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ElasticStack的组成"><a href="#1-ElasticStack的组成" class="headerlink" title="1. ElasticStack的组成"></a>1. ElasticStack的组成</h3><ol><li><strong><code>Beats</code></strong>：数据采集</li><li><strong><code>LogStash</code></strong>: 数据处理</li><li><strong><code>ElasticSearch</code></strong>(核心引擎): 数据存储、查询和分析</li><li><strong><code>Kibana</code></strong>: 数据探索与可视化分析<a id="more"></a></li></ol><p><img src="http://cdn.chaooo.top/Java/elastic-stream.jpg" alt></p><h3 id="2-Filebeat"><a href="#2-Filebeat" class="headerlink" title="2. Filebeat"></a>2. Filebeat</h3><p><code>Filebeat</code>是本地文件的轻量型日志数据采集器。<br><code>Beats</code>可以直接（或者通过<code>Logstash</code>）将数据发送到<code>Elasticsearch</code>，在那里你可以进一步处理和增强数据，然后在<code>Kibana</code>中将其可视化。</p><h4 id="2-1-Filebeat工作原理"><a href="#2-1-Filebeat工作原理" class="headerlink" title="2.1 Filebeat工作原理"></a>2.1 Filebeat工作原理</h4><p>Filebeat由两个主要组件组成：<code>prospector</code>和<code>harvester</code>。这些组件一起工作来读取文件（tail file）并将事件数据发送到您指定的输出</p><ul><li><strong><code>Harvester</code></strong>：<ul><li>负责<strong>读取单个文件</strong>的内容</li><li>如果文件在读取时被删除或重命名，<code>Filebeat</code>将继续读取文件</li></ul></li><li><strong><code>prospector</code></strong>：<ul><li><code>prospector</code>负责<strong>管理<code>harvester</code></strong>并找到所有要读取的文件来源</li><li>如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个<code>harvester</code></li><li><code>Filebeat</code>目前支持两种<code>prospector</code>类型：<code>log</code>和<code>stdin</code></li></ul></li></ul><p><img src="http://cdn.chaooo.top/Java/filebeat.jpg" alt></p><blockquote><ul><li><code>Filebeat</code>如何<strong>保持文件的状态</strong><ul><li><code>Filebeat</code> 保存每个文件的状态并经常将状态刷新到磁盘上的注册文件中</li><li>该状态用于记住<code>harvester</code>正在读取的最后偏移量，并确保发送所有日志行</li><li>如果输出（例如<code>Elasticsearch</code>或<code>Logstash</code>）无法访问，<code>Filebeat</code>会跟踪最后发送的行，并在输出再次可用时继续读取文件。</li><li>在<code>Filebeat</code>运行时，每个<code>prospector</code>内存中也会保存的文件状态信息，当重新启动<code>Filebeat</code>时，将使用注册文件的数据来重建文件状态，<code>Filebeat</code>将每个<code>harvester</code>在从保存的最后偏移量继续读取</li><li><code>Filebeat</code>存储唯一标识符以检测文件是否先前已采集过</li></ul></li></ul></blockquote><blockquote><ul><li><code>Filebeat</code>如何<strong>确保至少一次交付</strong><ul><li><code>Filebeat</code>保证事件至少会被传送到配置的输出一次，并且不会丢失数据。 <code>Filebeat</code>能够实现此行为，因为它将每个事件的传递状态存储在注册文件中。</li><li>在输出阻塞或未确认所有事件的情况下，<code>Filebeat</code>将继续尝试发送事件，直到接收端确认已收到。</li><li>如果<code>Filebeat</code>在发送事件的过程中关闭，它不会等待输出确认所有收到事件。</li><li>发送到输出但在<code>Filebeat</code>关闭前未确认的任何事件在重新启动<code>Filebeat</code>时会再次发送。</li><li>这可以确保每个事件至少发送一次，但最终会将重复事件发送到输出。</li><li>也可以通过设置<code>shutdown_timeout</code>选项来配置<code>Filebeat</code>以在关闭之前等待特定时间</li></ul></li></ul></blockquote><h4 id="2-2-Filebeat安装与配置"><a href="#2-2-Filebeat安装与配置" class="headerlink" title="2.2 Filebeat安装与配置"></a>2.2 Filebeat安装与配置</h4><p>安装<code>Filebeat</code>，创建配置文件<code>itcast.yml</code>，控制台运行测试</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建如下配置文件 itcast.yml</span></span><br><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">stdin</span>  <span class="comment"># 标准输入</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">output.console:</span> <span class="comment"># 输出到控制台</span></span><br><span class="line"><span class="attr">  pretty:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#启动filebeat</span></span><br><span class="line"><span class="string">./filebeat</span> <span class="bullet">-e</span> <span class="bullet">-c</span> <span class="string">itcast.yml</span></span><br></pre></td></tr></table></figure><p>输入hello运行结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"@timestamp"</span>: <span class="string">"2019-11-23T09:21:19.213Z"</span>,</span><br><span class="line">  "@metadata": &#123; #元数据信息</span><br><span class="line">    "beat": "filebeat",</span><br><span class="line">    "type": "_doc",</span><br><span class="line">    "version": "7.4.2" # beat版本</span><br><span class="line">  &#125;,</span><br><span class="line">  "host": &#123;</span><br><span class="line">    "name": "chaooo"</span><br><span class="line">  &#125;,</span><br><span class="line">  "agent": &#123; &#125;,</span><br><span class="line">  "log": &#123;</span><br><span class="line">    "offset": 0,</span><br><span class="line">    "file": &#123;</span><br><span class="line">      "path": ""</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "message": "hello", # 输入的内容</span><br><span class="line">  "input": &#123; # 控制台标准输入</span><br><span class="line">    "type": "stdin"</span><br><span class="line">  &#125;,</span><br><span class="line">  "ecs": &#123;</span><br><span class="line">    "version": "1.1.0"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-读取文件"><a href="#2-3-读取文件" class="headerlink" title="2.3 读取文件"></a>2.3 读取文件</h4><p>创建配置文件<code>itcast-log.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/test/*.log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line"><span class="string">output.console:</span> <span class="comment"># 输出到控制台</span></span><br><span class="line"><span class="attr">  pretty:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#启动filebeat</span></span><br><span class="line"><span class="string">./filebeat</span> <span class="bullet">-e</span> <span class="bullet">-c</span> <span class="string">itcast-log.yml</span></span><br></pre></td></tr></table></figure><p>在<code>/test/</code>下创建<code>a.log</code>文件，并输入如下内容<code>hello world</code>,观察<code>filebeat</code>输出:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"@timestamp"</span>: <span class="string">"2019-11-23T09:45:56.379Z"</span>,</span><br><span class="line">  <span class="attr">"@metadata"</span>: &#123;</span><br><span class="line">    <span class="attr">"beat"</span>: <span class="string">"filebeat"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"7.4.2"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"log"</span>: &#123;</span><br><span class="line">    <span class="attr">"offset"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"file"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"/test/a.log"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"hello"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"log"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"ecs"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.1.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"host"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"chaooo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"agent"</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"@timestamp"</span>: <span class="string">"2019-11-23T09:45:56.379Z"</span>,</span><br><span class="line">  <span class="attr">"@metadata"</span>: &#123;</span><br><span class="line">    <span class="attr">"beat"</span>: <span class="string">"filebeat"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"7.4.2"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"host"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"chaooo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"agent"</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">"log"</span>: &#123;</span><br><span class="line">    <span class="attr">"file"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"/test/a.log"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"offset"</span>: <span class="number">7</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"world"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"log"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"ecs"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.1.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-自定义字段"><a href="#2-4-自定义字段" class="headerlink" title="2.4 自定义字段"></a>2.4 自定义字段</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/test/*.log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">["web"]</span> <span class="comment">#添加自定义tag，便于后续的处理</span></span><br><span class="line"><span class="attr">  fields:</span> <span class="comment">#添加自定义字段</span></span><br><span class="line"><span class="attr">    from:</span> <span class="string">itcast-im</span></span><br><span class="line"><span class="attr">  fields_under_root:</span> <span class="literal">true</span> <span class="comment">#true为添加到根节点，false为添加到子节点中</span></span><br><span class="line"><span class="string">output.console:</span> <span class="comment"># 输出到控制台</span></span><br><span class="line"><span class="attr">  pretty:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="2-5-输出到Elasticsearch"><a href="#2-5-输出到Elasticsearch" class="headerlink" title="2.5 输出到Elasticsearch"></a>2.5 输出到Elasticsearch</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/test/*.log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">["web"]</span> <span class="comment">#添加自定义tag，便于后续的处理</span></span><br><span class="line"><span class="attr">  fields:</span> <span class="comment">#添加自定义字段</span></span><br><span class="line"><span class="attr">    from:</span> <span class="string">itcast-im</span></span><br><span class="line"><span class="attr">  fields_under_root:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">setup.template.settings:</span></span><br><span class="line">  <span class="string">index.number_of_shards:</span> <span class="number">3</span> <span class="comment">#指定索引的分区数</span></span><br><span class="line"><span class="string">output.elasticsearch:</span> <span class="comment">#指定ES的配置</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["192.168.1.7:9200","192.168.1.7:9201","192.168.1.7:9202"]</span></span><br></pre></td></tr></table></figure><h4 id="2-6-读取Nginx日志文件"><a href="#2-6-读取Nginx日志文件" class="headerlink" title="2.6 读取Nginx日志文件"></a>2.6 读取Nginx日志文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/usr/local/nginx/logs/*.log</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">["nginx"]</span> </span><br><span class="line"><span class="string">setup.template.settings:</span></span><br><span class="line">  <span class="string">index.number_of_shards:</span> <span class="number">3</span> <span class="comment">#指定索引的分区数</span></span><br><span class="line"><span class="string">output.elasticsearch:</span> <span class="comment">#指定ES的配置</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["192.168.1.7:9200","192.168.1.7:9201","192.168.1.7:9202"]</span></span><br></pre></td></tr></table></figure><h4 id="2-7-Filebeat的Module"><a href="#2-7-Filebeat的Module" class="headerlink" title="2.7 Filebeat的Module"></a>2.7 Filebeat的Module</h4><p>日志数据的读取与处理可以不用手动配置的，在<code>Filebeat</code>中，有大量的<code>Module</code>，可以直接使用简化配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">./filebeat modules list</span><br><span class="line">Enabled:</span><br><span class="line">  </span><br><span class="line">Disabled:</span><br><span class="line">apache</span><br><span class="line">auditd</span><br><span class="line">aws</span><br><span class="line">cef</span><br><span class="line">cisco</span><br><span class="line">coredns</span><br><span class="line">elasticsearch</span><br><span class="line">envoyproxy</span><br><span class="line">googlecloud</span><br><span class="line">haproxy</span><br><span class="line">ibmmq</span><br><span class="line">icinga</span><br><span class="line">iis</span><br><span class="line">iptables</span><br><span class="line">kafka</span><br><span class="line">kibana</span><br><span class="line">logstash</span><br><span class="line">mongodb</span><br><span class="line">mssql</span><br><span class="line">mysql</span><br><span class="line">nats</span><br><span class="line">netflow</span><br><span class="line">nginx</span><br><span class="line">osquery</span><br><span class="line">panw</span><br><span class="line">postgresql</span><br><span class="line">rabbitmq</span><br><span class="line">redis</span><br><span class="line">santa</span><br><span class="line">suricata</span><br><span class="line">system</span><br><span class="line">traefik</span><br><span class="line">zeek</span><br></pre></td></tr></table></figure><p>可以看到，内置了很多的<code>module</code>，但都没有启用，如果需要启用需要进行<code>enable</code>操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/filebeat modules enable nginx #启动</span><br><span class="line">./filebeat modules disable nginx #禁用</span><br></pre></td></tr></table></figure><h4 id="2-8-nginx-module与filebeat配置"><a href="#2-8-nginx-module与filebeat配置" class="headerlink" title="2.8 nginx module与filebeat配置"></a>2.8 nginx module与filebeat配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- module:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  access:</span>      <span class="comment"># Access logs</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="string">var.paths:</span> <span class="string">["/usr/local/nginx/logs/access.log*"]</span></span><br><span class="line"><span class="attr">  error:</span>       <span class="comment"># Error logs</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="string">var.paths:</span> <span class="string">["/usr/local/nginx/logs/error.log*"]</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-nginx.yml</span></span><br><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="comment">#- type: log</span></span><br><span class="line"><span class="comment"># enabled: true</span></span><br><span class="line"><span class="comment"># paths:</span></span><br><span class="line"><span class="comment"># - /usr/local/nginx/logs/*.log</span></span><br><span class="line"><span class="comment"># tags: ["nginx"]</span></span><br><span class="line"><span class="string">setup.template.settings:</span></span><br><span class="line">  <span class="string">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"><span class="string">output.elasticsearch:</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["192.168.40.133:9200","192.168.40.134:9200","192.168.40.135:9200"]</span></span><br><span class="line"><span class="string">filebeat.config.modules:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br><span class="line">  <span class="string">reload.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>若启动报错，需要在<code>Elasticsearch</code>中安装<code>ingest-user-agent、ingest-geoip</code>插件</p><h3 id="3-Metricbeat"><a href="#3-Metricbeat" class="headerlink" title="3. Metricbeat"></a>3. Metricbeat</h3><p>用于从系统和服务<strong>收集指标</strong>。<code>Metricbeat</code>和<code>Filebeat</code>一样，是一个<strong>轻量级的采集器</strong>，<code>Metricbeat</code>由模块(<code>Module</code>)和度量集(<code>Metricset</code>)组成。<code>Metricbeat</code>模块定义了从特定服务（如Redis，MySQL等）收集数据的基本逻辑。该模块指定有关服务的详细信息，包括如何连接，收集指标的频率以及要收集的指标。</p><ul><li><code>Metricbeat</code>有2部分组成，一部分是<code>Module</code>，另一部分为<code>Metricset</code>。</li><li><code>Module</code><ul><li>收集的对象，如：<code>mysql、redis、nginx、操作系统</code>等；</li></ul></li><li><code>Metricset</code><ul><li>收集指标的集合，如：<code>cpu、memory、network</code>等；</li></ul></li><li>以<code>Redis Module</code>为例：<br><img src="http://cdn.chaooo.top/Java/metricbeat.jpg" alt></li></ul><h4 id="3-1-安装配置"><a href="#3-1-安装配置" class="headerlink" title="3.1 安装配置"></a>3.1 安装配置</h4><p>安装Metricbeat，根据实际情况配置文件<code>metricbeat.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metricbeat.config.modules:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">$&#123;path.config&#125;/modules.d/*.yml</span></span><br><span class="line">  <span class="string">reload.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">setup.kibana:</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">"192.168.56.13:5601"</span></span><br><span class="line"><span class="string">output.elasticsearch:</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["192.168.56.13:9200"]</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">"elastic"</span></span><br><span class="line"><span class="attr">  password:</span> <span class="string">"qiuyuetao"</span></span><br></pre></td></tr></table></figure><p>启动：<code>./metricbeat -e</code><br>查看<code>module</code>列表：<code>./metricbeat modules list</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Enabled:</span></span><br><span class="line"><span class="string">system</span> <span class="comment">#默认启用</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">Disabled:</span></span><br><span class="line"><span class="string">apache</span></span><br><span class="line"><span class="string">elasticsearch</span></span><br><span class="line"><span class="string">nginx</span></span><br><span class="line"><span class="string">mysql</span></span><br><span class="line"><span class="string">redis</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p><code>system module</code>默认启用的，其配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">system.yml</span></span><br><span class="line"><span class="comment"># Module: system</span></span><br><span class="line"><span class="comment"># Docs: https://www.elastic.co/guide/en/beats/metricbeat/6.5/metricbeat-modulesystem.html</span></span><br><span class="line"><span class="attr">- module:</span> <span class="string">system</span></span><br><span class="line"><span class="attr">  period:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">  metricsets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cpu</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">load</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">memory</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">network</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">process</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">process_summary</span></span><br><span class="line">    <span class="comment">#- core</span></span><br><span class="line">    <span class="comment">#- diskio</span></span><br><span class="line">    <span class="comment">#- socket</span></span><br><span class="line">  <span class="string">process.include_top_n:</span></span><br><span class="line"><span class="attr">    by_cpu:</span> <span class="number">5</span> <span class="comment"># include top 5 processes by CPU</span></span><br><span class="line"><span class="attr">    by_memory:</span> <span class="number">5</span> <span class="comment"># include top 5 processes by memory</span></span><br><span class="line"><span class="attr">- module:</span> <span class="string">system</span></span><br><span class="line"><span class="attr">  period:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line"><span class="attr">  metricsets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">filesystem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">fsstat</span></span><br><span class="line"><span class="attr">  processors:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">drop_event.when.regexp:</span></span><br><span class="line">    <span class="string">system.filesystem.mount_point:</span> <span class="string">'^/(sys|cgroup|proc|dev|etc|host|lib)($|/)'</span></span><br><span class="line"><span class="attr">- module:</span> <span class="string">system</span></span><br><span class="line"><span class="attr">  period:</span> <span class="number">15</span><span class="string">m</span></span><br><span class="line"><span class="attr">  metricsets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">uptime</span></span><br></pre></td></tr></table></figure><h4 id="3-2-Nginx-Module"><a href="#3-2-Nginx-Module" class="headerlink" title="3.2 Nginx Module"></a>3.2 Nginx Module</h4><p>在nginx中，需要开启状态查询，才能查询到指标数据。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置nginx</span></span><br><span class="line"><span class="string">location</span> <span class="string">/nginx-status</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">stub_status</span> <span class="string">on;</span></span><br><span class="line">    <span class="string">access_log</span> <span class="string">off;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>192.168.56.13/nginx-status</code>查看<code>nginx-status</code><ul><li><code>Active connections</code>：正在处理的活动连接数</li><li><code>server accepts handled requests</code>（连接数，握手数，处理请求总数）</li><li><code>Reading: 0 Writing: 1 Waiting: 1</code>（ 读取到客户端的Header信息数，返回给客户端Header信息数，已经处理完正在等候下一次请求指令的驻留链接）</li></ul></li></ul><p>配置<code>Nginx Module（metricbeat/modules.d/nginx.yml）</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- module:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  metricsets:</span> <span class="string">["stubstatus"]</span></span><br><span class="line"><span class="attr">  period:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line">  <span class="comment"># Nginx hosts</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["http://192.168.56.11"]</span></span><br><span class="line">  <span class="comment"># Path to server status. Default server-status</span></span><br><span class="line"><span class="attr"> server_status_path:</span> <span class="string">"nginx_status"</span></span><br></pre></td></tr></table></figure><p>启动：<code>./metricbeat -e</code></p><h3 id="4-Logstash"><a href="#4-Logstash" class="headerlink" title="4. Logstash"></a>4. Logstash</h3><p><code>Logstash</code>是<code>ElasticStack</code>中的实时数据采集引擎，可以采集来自不同数据源的数据，并对数据进行处理后输出到多种输出源，是<code>Elastic Stack</code>的重要组成部分。<br><img src="http://cdn.chaooo.top/Java/elastic-logstash.jpg" alt></p><h4 id="4-1-Logstash的数据处理过程"><a href="#4-1-Logstash的数据处理过程" class="headerlink" title="4.1 Logstash的数据处理过程"></a>4.1 Logstash的数据处理过程</h4><ul><li><code>Inputs(Codecs)--&gt;Filters--&gt;Outputs(Codecs)</code><ul><li>用户通过定义<code>pipeline</code>配置文件，设置需要使用的<code>input</code>，<code>filter</code>，<code>output</code>, <code>codec</code>插件，以实现特定的数据采集，数据处理，数据输出等功能</li></ul></li></ul><ol><li><code>Inputs</code>：用于从数据源获取数据，常见的插件如<code>file, syslog, redis, beats</code>等</li><li><code>Filters</code>：用于处理数据如格式转换，数据派生等，常见的插件如<code>grok, mutate, drop, clone, geoip</code>等</li><li><code>Outputs</code>：用于数据输出，常见的插件如<code>elastcisearch，file, graphite, statsd</code>等</li><li><code>Codecs</code>：<code>Codecs</code>不是一个单独的流程，而是在输入和输出等插件中用于数据转换的模块，用于对数据进行编码处理，常见的插件如<code>json，multiline</code></li></ol><h4 id="4-2-执行模型"><a href="#4-2-执行模型" class="headerlink" title="4.2 执行模型"></a>4.2 执行模型</h4><ol><li>每个<code>Input</code>启动一个线程，从对应数据源获取数据 </li><li><code>Input</code>会将数据写入一个队列：默认为内存中的有界队列（意外停止会导致数据丢失）。为了防止数丢失<code>Logstash</code>提供了两个特性：<ul><li><code>Persistent Queues</code>：通过磁盘上的<code>queue</code>来防止数据丢失</li><li><code>Dead Letter Queues</code>：保存无法处理的<code>event</code>（仅支持<code>Elasticsearch</code>作为输出源）  </li></ul></li><li><code>Logstash</code>会有多个<code>pipeline worker</code>, 每一个<code>pipeline worker</code>会从队列中取一批数据，然后执行<code>filter</code>和<code>output</code>（<code>worker</code>数目及每次处理的数据量均由配置确定）</li></ol><h4 id="4-3-安装配置"><a href="#4-3-安装配置" class="headerlink" title="4.3 安装配置"></a>4.3 安装配置</h4><p>下载<code>Logstash</code>并解压，配置有三部分，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123; #输入</span><br><span class="line">stdin &#123; ... &#125; #标准输入</span><br><span class="line">&#125;</span><br><span class="line">filter &#123; #过滤，对数据进行分割、截取等处理</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">output &#123; #输出</span><br><span class="line">stdout &#123; ... &#125; #标准输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-读取自定义日志"><a href="#4-4-读取自定义日志" class="headerlink" title="4.4 读取自定义日志"></a>4.4 读取自定义日志</h4><ol><li><p>日志结构：<code>2019-11-23 21:21:21|ERROR|读取数据出错|参数：id=1002</code>，日志中的内容是使用<code>“|”</code>进行分割的，使用，我们在处理的时候，也需要对数据做分割处理。</p></li><li><p>编写配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#vim itcast-pipeline.conf</span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; &quot;/itcast/logstash/logs/app.log&quot;</span><br><span class="line">    start_position =&gt; &quot;beginning&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123;&quot;message&quot;=&gt;&quot;|&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#启动</span><br><span class="line">./bin/logstash -f ./itcast-pipeline.conf</span><br><span class="line">#写日志到文件</span><br><span class="line">echo &quot;2019-11-23 21:21:21|ERROR|读取数据出错|参数：id=1002&quot; &gt;&gt; app.log</span><br><span class="line">#输出的结果</span><br><span class="line">&#123;</span><br><span class="line">  &quot;@timestamp&quot; =&gt; 2019-03-15T08:44:04.749Z,</span><br><span class="line">        &quot;path&quot; =&gt; &quot;/itcast/logstash/logs/app.log&quot;,</span><br><span class="line">    &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">        &quot;host&quot; =&gt; &quot;node01&quot;,</span><br><span class="line">     &quot;message&quot; =&gt; [</span><br><span class="line">        [0] &quot;2019-11-23 21:21:21&quot;,</span><br><span class="line">        [1] &quot;ERROR&quot;,</span><br><span class="line">        [2] &quot;读取数据出错&quot;,</span><br><span class="line">        [3] &quot;参数：id=1002&quot;</span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出到<code>Elasticsearch</code>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ &quot;192.168.40.133:9200&quot;,&quot;192.168.40.134:9200&quot;,&quot;192.168.40.135:9200&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-Elasticsearch-Logstash-Beats-Kibana基础整合"><a href="#5-Elasticsearch-Logstash-Beats-Kibana基础整合" class="headerlink" title="5. Elasticsearch + Logstash + Beats + Kibana基础整合"></a>5. Elasticsearch + Logstash + Beats + Kibana基础整合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">           (读取)          (发送)           (写入)                (读取)</span><br><span class="line">【日志文件】&lt;----【FileBeat】----&gt;【Logstash】----&gt;【Elasticsearch】&lt;----【Kibana】</span><br></pre></td></tr></table></figure><ol><li><p><code>Filebeat</code>配置与启动：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-dashboard.yml</span></span><br><span class="line"><span class="string">filebeat.inputs:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">log</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/itcast/logs/*.log</span></span><br><span class="line"><span class="string">setup.template.settings:</span></span><br><span class="line">  <span class="string">index.number_of_shards:</span> <span class="number">3</span></span><br><span class="line"><span class="string">output.logstash:</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">["192.168.40.133:5044"]</span> <span class="comment">#Logstash端口号</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line"><span class="string">./filebeat</span> <span class="bullet">-e</span> <span class="bullet">-c</span> <span class="string">itcast-dashboard.yml</span></span><br></pre></td></tr></table></figure></li><li><p><code>Logstash</code>配置与启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#vim itcast-dashboard.conf</span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; &quot;5044&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123;&quot;message&quot;=&gt;&quot;|&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;userId&quot; =&gt; &quot;%&#123;message[1]&#125;&quot;</span><br><span class="line">      &quot;visit&quot; =&gt; &quot;%&#123;message[2]&#125;&quot;</span><br><span class="line">      &quot;date&quot; =&gt; &quot;%&#123;message[3]&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">      convert =&gt; &#123;</span><br><span class="line">        &quot;userId&quot; =&gt; &quot;integer&quot;</span><br><span class="line">        &quot;visit&quot; =&gt; &quot;string&quot;</span><br><span class="line">        &quot;date&quot; =&gt; &quot;string&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ &quot;192.168.40.133:9200&quot;,&quot;192.168.40.134:9200&quot;,&quot;192.168.40.135:9200&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">#启动</span><br><span class="line">./bin/logstash -f itcast-dashboard.conf</span><br></pre></td></tr></table></figure></li><li><p><code>ElasticSearch</code>启动与<code>Kibana</code>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ElasticSearch默认端口:9200</span><br><span class="line">bin/elasticsearch </span><br><span class="line"># kibana默认端口:5601</span><br><span class="line">bin/kibana</span><br><span class="line">#通过浏览器进行访问,添加Logstash索引到Kibana中</span><br><span class="line">http://192.168.40.133:5601</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ElasticStack的组成&quot;&gt;&lt;a href=&quot;#1-ElasticStack的组成&quot; class=&quot;headerlink&quot; title=&quot;1. ElasticStack的组成&quot;&gt;&lt;/a&gt;1. ElasticStack的组成&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Beats&lt;/code&gt;&lt;/strong&gt;：数据采集&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;LogStash&lt;/code&gt;&lt;/strong&gt;: 数据处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ElasticSearch&lt;/code&gt;&lt;/strong&gt;(核心引擎): 数据存储、查询和分析&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Kibana&lt;/code&gt;&lt;/strong&gt;: 数据探索与可视化分析
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【ElasticStack】ElasticSearch聚合分析与数据建模</title>
    <link href="http://chaooo.github.io/article/20191121.html"/>
    <id>http://chaooo.github.io/article/20191121.html</id>
    <published>2019-11-21T14:30:47.000Z</published>
    <updated>2019-12-08T08:23:15.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ElasticSearch中的聚合分析"><a href="#1-ElasticSearch中的聚合分析" class="headerlink" title="1. ElasticSearch中的聚合分析"></a>1. ElasticSearch中的聚合分析</h3><p>聚合分析，英文<code>Aggregation</code>，是ES除了搜索功能之外提供的针对ES数据进行统计分析的功能。</p><ul><li>特点：<ul><li>①功能丰富，可满足大部分分析需求；</li><li>②实时性高，所有计算结果实时返回。</li></ul></li><li>基于分析规则的不同，ES将聚合分析主要划分为以下4种：<ol><li><strong><code>Metric</code></strong>: 指标分析类型，如：计算最值，平均值等；</li><li><strong><code>Bucket</code></strong>: 分桶类型，类似于<code>group by</code>语法，根据一定规则划分为若干个桶分类；</li><li><strong><code>Pipeline</code></strong>: 管道分析类型，基于上一级的聚合分析结果进行再分析；</li><li><code>Matrix</code>: 矩阵分析类型。<a id="more"></a></li></ol></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 聚合分析格式：</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> "aggs":&#123; // 关键词</span><br><span class="line">  "&lt;aggregation_name&gt;":&#123; // 自定义聚合分析名称，一般起的有意义</span><br><span class="line">   "&lt;aggregation_type&gt;":&#123; // 聚合分析类型</span><br><span class="line">    "&lt;aggregation_body&gt;" // 聚合分析主体</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [,"aggs":&#123;[&lt;svb_aggregation&gt;]+&#125;] // 可包含多个子聚合分析</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-Metric聚合分析"><a href="#1-1-Metric聚合分析" class="headerlink" title="1.1 Metric聚合分析"></a>1.1 Metric聚合分析</h4><p>主要分为两类：单值分析（输出单个结果）和多值分析（输出多个结果）。</p><h5 id="1-1-1-单值分析"><a href="#1-1-1-单值分析" class="headerlink" title="1.1.1 单值分析"></a>1.1.1 单值分析</h5><ol><li><code>min</code>：返回数值类型字段的最小值</li><li><code>max</code>：返回数值类型字段的最大值</li><li><code>avg</code>：返回数值类型字段的平均值</li><li><code>sum</code>：返回数值类型字段值的总和</li><li><code>cardinality</code>：返回字段的基数</li><li>使用多个单值分析关键词，返回多个结果</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"min_age"</span>:&#123;</span><br><span class="line">   "min":&#123; // 关键字min/max/avg/sum/cardinality</span><br><span class="line">    "field":"age"    </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 使用多个单值分析关键词，返回多个分析结果</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">  <span class="attr">"min_age"</span>:&#123;</span><br><span class="line">   "min":&#123;  // 求最小年龄</span><br><span class="line">    "field":"age"</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "max_age":&#123;</span><br><span class="line">   "max":&#123;  // 求最大年龄</span><br><span class="line">    "field":"age"</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "avg_age":&#123;</span><br><span class="line">   "avg":&#123;  // 求平均年龄</span><br><span class="line">    "field":"age"</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "sum_age":&#123;</span><br><span class="line">   "sum":&#123;  // 求年龄总和</span><br><span class="line">    "field":"age"</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-2-多值分析"><a href="#1-1-2-多值分析" class="headerlink" title="1.1.2 多值分析"></a>1.1.2 多值分析</h5><ol><li><code>stats</code>：返回所有单值结果</li><li><code>extended_stats</code>：对<code>stats</code>进行扩展，包含更多，如：方差，标准差，标准差范围等</li><li><code>Percentile</code>：百分位数统计</li><li><code>Top hits</code>：一般用于分桶之后获取该桶内最匹配的定不稳当列表，即详情数据</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"stats_age"</span>:&#123;</span><br><span class="line">   "stats":&#123; // 关键字stats/extended_stats/percentiles</span><br><span class="line">    "field":"age"    </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 使用percentiles关键词进行百分位数预测。</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"per_age"</span>:&#123;</span><br><span class="line">   "percentiles":&#123;    // 关键字</span><br><span class="line">    "field":"age",</span><br><span class="line">    "values":[20, 25] // 判断20和25分别在之前的年轻区间的什么位置，以百分数显示</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 使用top_hits关键词</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"jobs"</span>:&#123;</span><br><span class="line">   <span class="attr">"terms"</span>:&#123;</span><br><span class="line">    <span class="attr">"match"</span>:&#123;</span><br><span class="line">     "field":"job.keyword", // 按job.keyword进行分桶聚合</span><br><span class="line">     "size":10</span><br><span class="line">    &#125;,</span><br><span class="line">    "aggs":&#123;</span><br><span class="line">     "top_employee":&#123;</span><br><span class="line">      "top_hits":&#123;</span><br><span class="line">       "size":10,    // 返回文档数量</span><br><span class="line">       "sort":[</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="attr">"age"</span>:&#123;</span><br><span class="line">          <span class="attr">"order"</span>:<span class="string">"desc"</span>  // 按年龄倒叙排列</span><br><span class="line">         &#125; </span><br><span class="line">        &#125;</span><br><span class="line">       ]</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Bucket聚合分析"><a href="#1-2-Bucket聚合分析" class="headerlink" title="1.2 Bucket聚合分析"></a>1.2 Bucket聚合分析</h4><p><code>Bucket</code>，意为桶。即：按照一定规则，将文档分配到不同的桶中，达分类的目的。常见的有以下五类：</p><ol><li><code>Terms</code>: 直接按<code>term</code>进行分桶，如果是<code>text</code>类型，按分词后的结果分桶</li><li><code>Range</code>: 按指定数值范围进行分桶</li><li><code>Date Range</code>: 按指定日期范围进行分桶</li><li><code>Histogram</code>: 直方图，按固定数值间隔策略进行数据分割</li><li><code>Date Histogram</code>: 日期直方图，按固定时间间隔进行数据分割</li></ol><h5 id="1-2-1-Terms"><a href="#1-2-1-Terms" class="headerlink" title="1.2.1 Terms"></a>1.2.1 Terms</h5><p><code>Terms</code>: 直接按<code>term</code>进行分桶，如果是<code>text</code>类型，按分词后的结果分桶</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 使用terms关键词</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"terms_job"</span>:&#123;</span><br><span class="line">   "terms":&#123;    // 关键字</span><br><span class="line">    "field":"job.keyword", // 按job.keyword进行分桶</span><br><span class="line">    "size":5               // 返回五个文档</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-Range"><a href="#1-2-2-Range" class="headerlink" title="1.2.2 Range"></a>1.2.2 Range</h5><p><code>Range</code>: 按指定数值范围进行分桶：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 使用range关键词</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"number_ranges"</span>:&#123;</span><br><span class="line">   "range":&#123;    // 关键字</span><br><span class="line">    "field":"age",    // 按age进行分桶</span><br><span class="line">    "ranges":[</span><br><span class="line">     &#123;</span><br><span class="line">      "key":"&gt;=19 &amp;&amp; &lt; 25",  // 第一个桶：  19&lt;=年龄&lt;25</span><br><span class="line">      "from":19,</span><br><span class="line">      "to":25</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      "key":"&lt; 19",    // 第二个桶：  年龄&lt;19</span><br><span class="line">      "to":19</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      "key":"&gt;= 25",    // 第三个桶：  年龄&gt;=25</span><br><span class="line">      "from":25</span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-Date-Range"><a href="#1-2-2-Date-Range" class="headerlink" title="1.2.2 Date Range"></a>1.2.2 Date Range</h5><p><code>Date Range</code>: 按指定日期范围进行分桶</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">        3）：</span><br><span class="line"></span><br><span class="line">// 使用date_range关键词</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"date_ranges"</span>:&#123;</span><br><span class="line">   "date_range":&#123;    // 关键字</span><br><span class="line">    "field":"birth",    // 按age进行分桶</span><br><span class="line">    "format":"yyyy",</span><br><span class="line">    "ranges":[</span><br><span class="line">     &#123;</span><br><span class="line">      "key":"&gt;=1980 &amp;&amp; &lt; 1990",  // 第一个桶：  1980&lt;=出生日期&lt;1990</span><br><span class="line">      "from":"1980",</span><br><span class="line">      "to":"1990"</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      "key":"&lt; 1980",    // 第二个桶：  出生日期&lt;1980</span><br><span class="line">      "to":1980</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      "key":"&gt;= 1990",    // 第三个桶：  出生日期&gt;=1990</span><br><span class="line">      "from":1990</span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-Histogram"><a href="#1-2-2-Histogram" class="headerlink" title="1.2.2 Histogram"></a>1.2.2 Histogram</h5><p><code>Histogram</code>: 直方图，按固定数值间隔策略进行数据分割</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用histogram关键词</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"age_hist"</span>:&#123;</span><br><span class="line">   "histogram":&#123;     // 关键词</span><br><span class="line">    "field":"age",</span><br><span class="line">    "interval":3,    // 设定间隔大小为2</span><br><span class="line">    "extended_bounds":&#123;    // 设定数据范围</span><br><span class="line">     "min":0,</span><br><span class="line">     "max":30</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-Date-Histogram"><a href="#1-2-2-Date-Histogram" class="headerlink" title="1.2.2 Date Histogram"></a>1.2.2 Date Histogram</h5><p><code>Date Histogram</code>: 日期直方图，按固定时间间隔进行数据分割</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 使用date_histogram关键词</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"birth_hist"</span>:&#123;</span><br><span class="line">   "date_histogram":&#123;     // 关键词</span><br><span class="line">    "field":"birth",</span><br><span class="line">    "interval":"year",    // 设定间隔大小为年year</span><br><span class="line">    "format":"yyyy",</span><br><span class="line">    "extended_bounds":&#123;    // 设定数据范围</span><br><span class="line">     "min":"1980",</span><br><span class="line">     "max":"1990"</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Bucket-Metric聚合分析"><a href="#1-3-Bucket-Metric聚合分析" class="headerlink" title="1.3 Bucket+Metric聚合分析"></a>1.3 Bucket+Metric聚合分析</h4><p>Bucket聚合分析允许通过添加子分析来进一步进行分析，该子分析可以是Bucket，也可以是Metric。</p><ol><li>分桶之后再分桶（Bucket+Bucket），在数据可视化中一般使用千层饼图进行显示。</li><li>分桶之后再数据分析（Bucket+Metric）</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 分桶之后再分桶——Bucket+Bucket</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"jobs"</span>:&#123;</span><br><span class="line">   "terms":&#123;             // 第一层Bucket</span><br><span class="line">    "match":&#123;</span><br><span class="line">     "field":"job.keyword",</span><br><span class="line">     "size":10</span><br><span class="line">    &#125;,</span><br><span class="line">    "aggs":&#123;</span><br><span class="line">     "age_range":&#123;</span><br><span class="line">      "range":&#123;             // 第二层Bucket</span><br><span class="line">       "field":"age",</span><br><span class="line">       "ranges":[</span><br><span class="line">        &#123;"to":20&#125;,</span><br><span class="line">        &#123;"from":20,"to":30&#125;,</span><br><span class="line">        &#123;<span class="attr">"from"</span>:<span class="number">30</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 分桶之后再数据分析——Bucket+Metric</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"jobs"</span>:&#123;</span><br><span class="line">   "terms":&#123;             // 第一层Bucket</span><br><span class="line">    "match":&#123;</span><br><span class="line">     "field":"job.keyword",</span><br><span class="line">     "size":10</span><br><span class="line">    &#125;,</span><br><span class="line">    "aggs":&#123;                 </span><br><span class="line">     "stats_age":&#123;</span><br><span class="line">      "stats":&#123;            // 第二层Metric</span><br><span class="line">       "field":"age"</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-Pipeline聚合分析"><a href="#1-4-Pipeline聚合分析" class="headerlink" title="1.4 Pipeline聚合分析"></a>1.4 Pipeline聚合分析</h4><p>针对聚合分析的结果进行再分析，且支持链式调用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 使用pipeline聚合分析,计算订单月平均销售额。</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"sales_per_month"</span>:&#123;</span><br><span class="line">   <span class="attr">"date_histogram"</span>:&#123;</span><br><span class="line">    <span class="attr">"field"</span>:<span class="string">"date"</span>,</span><br><span class="line">    <span class="attr">"interval"</span>:<span class="string">"month"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"sales"</span>:&#123;</span><br><span class="line">     <span class="attr">"sum"</span>:&#123;</span><br><span class="line">      <span class="attr">"field"</span>:<span class="string">"price"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"avg_monthly_sales"</span>:&#123;</span><br><span class="line">   "avg_bucket":&#123;    // bucket类型</span><br><span class="line">    "buckets_path":"sales_per_month&gt;sales"    // 使用buckets_path参数，表明是pipeline</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pipeline</code>的分析结果会输出到原结果中，由输出位置不同，分为两类：<code>Parent</code>和<code>Sibling</code>。</p><ol><li><code>Sibling</code>。结果与现有聚合分析结果同级，如：Max/Min/Sum/Avg Bucket、Stats/Extended Stats Bucket、Percentiles Bucket</li><li><code>Parent</code>。结果内嵌到现有聚合分析结果中，如：Derivate、Moving Average、Cumulative Sum</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Sibling聚合分析(min_bucket)</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"jobs"</span>:&#123;</span><br><span class="line">   "terms":&#123;    // 根据job.keyword进行分桶</span><br><span class="line">    "field":"job.keyword",    </span><br><span class="line">    "size":10</span><br><span class="line">   &#125;,</span><br><span class="line">   "aggs":&#123;</span><br><span class="line">    "avg_salary":&#123;</span><br><span class="line">     "avg":&#123;    // 之后Metric中求工资的平均数</span><br><span class="line">      "field":"salary"</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "min_salary_by_job":&#123;</span><br><span class="line">   "min_bucket":&#123;    // 关键词</span><br><span class="line">    "buckets_path":"jobs&gt;avg_salary"    // 按工资平均数，排列每个桶中的job</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Parent聚合分析(Derivate)</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"bitrh"</span>:&#123;</span><br><span class="line">   <span class="attr">"date_histogram"</span>:&#123;</span><br><span class="line">    <span class="attr">"field"</span>:<span class="string">"birth"</span>,</span><br><span class="line">    <span class="attr">"interval"</span>:<span class="string">"year"</span>,</span><br><span class="line">    <span class="attr">"min_doc_count"</span>:<span class="number">0</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"avg_salary"</span>:&#123;</span><br><span class="line">     <span class="attr">"avg"</span>:&#123;</span><br><span class="line">      <span class="attr">"field"</span>:<span class="string">"salary"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"derivative_avg_salary"</span>:&#123;</span><br><span class="line">     "derivative":&#123;    // 关键词</span><br><span class="line">      "buckets_path":"avg_salary"</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-聚合分析的作用范围"><a href="#1-5-聚合分析的作用范围" class="headerlink" title="1.5 聚合分析的作用范围"></a>1.5 聚合分析的作用范围</h4><p>ES聚合分析默认作用范围是<code>query的结果集</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ES中聚合分析的默认作用范围是query的结果集</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"jobs"</span>:&#123;</span><br><span class="line">   <span class="attr">"terms"</span>:&#123;</span><br><span class="line">    "match":&#123;    // 此时，只在username字段中包含alfred的文档中进行分桶</span><br><span class="line">     "field":"job.keyword",    </span><br><span class="line">     "size":10</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过以下方式修改：<code>filter</code>、<code>post_filter</code>、<code>global</code></p><ol><li>filter: 为某个结合分析设定过滤条件，从而在不改变整体query语句的情况下修改范围</li><li>post_filter，作用于文档过滤，但在聚合分析之后才生效</li><li>global，无视query条件，基于所有文档进行分析</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用filter进行过滤</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"jobs_salary_small"</span>:&#123;</span><br><span class="line">   <span class="attr">"filter"</span>:&#123;</span><br><span class="line">    <span class="attr">"range"</span>:&#123;</span><br><span class="line">     <span class="attr">"salary"</span>:&#123;</span><br><span class="line">      <span class="attr">"to"</span>:<span class="number">10000</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"jobs"</span>:&#123;</span><br><span class="line">     "terms":&#123;    // 在salary小于10000的文档中对工作进行分桶</span><br><span class="line">      "field":"job.keyword"</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用post_filter进行过滤</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"jobs"</span>:&#123;</span><br><span class="line">   "terms":&#123;    // 在salary小于10000的文档中对工作进行分桶</span><br><span class="line">    "field":"job.keyword"</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> "post_filter":&#123;    // 在集合分析之后才生效</span><br><span class="line">  "match":&#123;</span><br><span class="line">   "job.keyword":"java engineer"   </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 使用global进行过滤</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"job.keyword"</span>:<span class="string">"java engineer"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"java_avg_salary"</span>:&#123;</span><br><span class="line">   <span class="attr">"avg"</span>:&#123;</span><br><span class="line">    <span class="attr">"field"</span>:<span class="string">"salary"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"all"</span>:&#123;</span><br><span class="line">   "global":&#123;    // 关键词</span><br><span class="line">    "aggs":&#123;</span><br><span class="line">     "avg_salary":&#123;</span><br><span class="line">      "avg":&#123;</span><br><span class="line">       "field":"salary"    // 依然是对所有的文档进行查询，而不会去管query   </span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-聚合分析中的排序"><a href="#1-6-聚合分析中的排序" class="headerlink" title="1.6 聚合分析中的排序"></a>1.6 聚合分析中的排序</h4><ol><li>可使用自带的关键数据排序，如：<code>_count</code>文档数、<code>_key</code>按key值</li><li>也可使用聚合结果进行排序</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 使用自带的数据进行排序</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"jobs"</span>:&#123;</span><br><span class="line">   <span class="attr">"terms"</span>:&#123;</span><br><span class="line">    <span class="attr">"field"</span>:<span class="string">"job.keyword"</span>,</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">"order"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"_count"</span>:<span class="string">"asc"</span>    // 默认按_count倒叙排列</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"_key"</span>:<span class="string">"desc"</span>    使用多个排序值，从上往下的顺序进行排列</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 使用聚合结果进行排序</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">  <span class="attr">"salary_hist"</span>:&#123;</span><br><span class="line">   <span class="attr">"histogram"</span>:&#123;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">    <span class="attr">"age"</span>:&#123;</span><br><span class="line">     <span class="attr">"filter"</span>:&#123;</span><br><span class="line">      <span class="attr">"range"</span>:&#123;</span><br><span class="line">       <span class="attr">"age"</span>:&#123;</span><br><span class="line">        <span class="attr">"gte"</span>:<span class="number">10</span></span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">      <span class="attr">"avg_age"</span>:&#123;</span><br><span class="line">       <span class="attr">"field"</span>:<span class="string">"age"</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-计算精准度问题"><a href="#1-7-计算精准度问题" class="headerlink" title="1.7 计算精准度问题"></a>1.7 计算精准度问题</h4><p>ES聚合的执行流程：每个<code>Shard</code>上分别计算，由<code>coordinating Node</code>做聚合。</p><ul><li><code>Terms</code>计算不准确原因：数据分散在多个<code>Shard</code>上，<code>coordinating Node</code>无法得悉数据全貌，那么在取数据的时候，造成精准度不准确。</li><li>如下图：正确结果应该为<code>a,b,c</code>,而返回的是a,b,d</li></ul><p><img src="http://cdn.chaooo.top/Java/elastic-hits.jpg" alt></p><ul><li><p>解决办法有两种：</p><ol><li>直接设置<code>shard</code>数量为1；消除数据分散问题，但无法承载大数据量。</li><li>设置<code>shard_size</code>大小，即每次从<code>shard</code>上额外多获取数据，从而提升精准度</li></ol></li><li><p>terms聚合返回结果中有两个统计值：</p><ol><li><code>doc_count_error_upper_bound</code>：被遗漏的term可能的最大值；</li><li><code>sum_other_doc_count</code>：返回结果bucket的term外其他term的文档总数。</li></ol></li><li><p>设定<code>show_term_doc_count_error</code>可以查看每个bucket误算的最大值(<code>doc_count_error_upper_bound</code>,为<code>0</code>表示计算准确)</p></li><li><p>Shard_Size默认大小：<code>(size*1.5)+10</code></p><ul><li>通过调整Shard_Size的大小降低<code>doc_count_error_upper_bound</code>来提升准确度</li><li>增大了整体的计算量，从而降低了响应时间</li></ul></li><li><p>权衡 <strong><code>海量数据</code>、<code>精准度</code>、<code>实时性</code></strong> 三者只能取其二。</p></li><li><p>Elasticsearch目前支持两种近似算法：cardinality(度量) 和 percentiles(百分位数度量)</p><ul><li>结果近似准确，但不一定精准</li><li>可通过参数的调整使其结果精准，但同时消耗更多时间和性能</li></ul></li></ul><h3 id="2-ElasticSearch的数据建模"><a href="#2-ElasticSearch的数据建模" class="headerlink" title="2. ElasticSearch的数据建模"></a>2. ElasticSearch的数据建模</h3><p>数据建模(Data Modeling)大致分为三个阶段：概念建模、逻辑建模、物理建模</p><ol><li>概念模型：时间占比<code>10%</code><ul><li>基础。确定系统的核心需求和范围边界，实际实体与实体之间的关系。</li></ul></li><li>逻辑模型：时间占比<code>60-70%</code><ul><li>核心。确定系统的核心需求和范围边界，实际实体与实体之间的关系。</li></ul></li><li>物理模型：时间占比<code>20-30%</code><ul><li>落地实现。结合具体的数据库产品，在满足业务读写性能等需求的前提下确定最终的定义。</li></ul></li></ol><h4 id="2-1-ES中的数据建模"><a href="#2-1-ES中的数据建模" class="headerlink" title="2.1 ES中的数据建模"></a>2.1 ES中的数据建模</h4><p>ES是基于Luence以倒排索引为基础实现的存储体系，不遵循关系型数据库中的范式约定。<br><img src="http://cdn.chaooo.top/Java/elastic-md.jpg" alt></p><h4 id="2-2-Mapping字段相关设置"><a href="#2-2-Mapping字段相关设置" class="headerlink" title="2.2 Mapping字段相关设置"></a>2.2 Mapping字段相关设置</h4><ol><li><strong><code>enabled</code></strong>:<code>true/false</code>。<code>false</code>表示 仅存储，不做搜索或聚合分析。</li><li>**<code>index</code>:<code>true/false</code>。是否构建倒排索引。不需进行字段的检索的时候设为false。</li><li><strong><code>index_options</code></strong>:<code>docs/freqs/positions/offsets</code>。确定存储倒排索引的哪些信息。</li><li><strong><code>norms</code></strong>:<code>true/false</code>。是否存储归一化相关系数，若字段仅用于过滤和聚合分析，则可关闭。</li><li><strong><code>doc_values</code></strong>:<code>true/false</code>。是否启用doc_values，用于排序和聚类分析。默认开启。</li><li><strong><code>field_data</code></strong>:<code>true/false</code>。是否设text类型为fielddata，实现排序和聚合分析。默认关闭。</li><li><strong><code>store</code></strong>:<code>true/false</code>。是否存储该字段。</li><li><strong><code>coerce</code></strong>:<code>true/false</code>。 是否开启数值类型转换功能，如：字符串转数字等。</li><li><strong><code>multifields</code></strong>:<code>多字段</code>。灵活使用多字段特性来解决多样业务需求。</li><li><strong><code>dynamic</code></strong>:<code>true/false/strict</code>。控制mapping自动更新。</li><li><strong><code>date_detection</code></strong>:<code>true/false</code>。是否启用自定识别日期类型，一般设为false，避免不必要的识别字符串中的日期。</li></ol><h4 id="2-3-Mapping字段属性设定流程"><a href="#2-3-Mapping字段属性设定流程" class="headerlink" title="2.3 Mapping字段属性设定流程"></a>2.3 Mapping字段属性设定流程</h4><p><code>判断类型</code>—&gt;<code>是否需要检索</code>—&gt;<code>是否需要排序和聚合分析</code>—&gt;<code>是否需要另行存储</code></p><ol><li>判断类型<ul><li>字符串类型：需要分词，则设为text，否则设为keyword。</li><li>枚举类型：基于性能考虑，设为keyword，即便该数据为整型。</li><li>数值类型：尽量选择贴近的类型，如byte即可表示所有数值时，即用byte，而不是所有都用long。</li><li>其他类型：布尔型，日期类型，地理位置类型等。</li></ul></li><li>是否需要检索<ul><li>完全不需要检索、排序、聚合分析的字段<code>enabled设为false</code>。</li><li>不需检索的字段<code>index设为false</code>。</li><li>需检索的字段，可通过如下配置设定需要的存储粒度:<ul><li><code>index_options</code> 结合需要设定。</li><li><code>norms</code> 不需归一化数据时可关闭。</li></ul></li></ul></li><li>是否需要排序和聚合分析<ul><li>当不需要排序和聚合分析功能时：<ul><li><code>doc_values设为false</code>。</li><li><code>field_data设为false</code>。</li></ul></li></ul></li><li>是否需要另行存储<ul><li><code>store设为true</code>即可存储该字段的原始内容(且与<code>_source</code>无关)，一般结合<code>_source</code>的<code>enabled设为false</code>时使用。</li></ul></li></ol><h4 id="2-4-ES建模实例"><a href="#2-4-ES建模实例" class="headerlink" title="2.4 ES建模实例"></a>2.4 ES建模实例</h4><ul><li><p>针对博客文章设定索引blog_index，包含字段：</p><ul><li>标题：title</li><li>发布日期：publish_data</li><li>作者：author</li><li>摘要：abstract</li><li>网址：url</li></ul></li><li><p><strong>简易的数据模型</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 简易模型blog_index</span><br><span class="line">PUT blog_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">    <span class="attr">"properties"</span>:&#123;</span><br><span class="line">      <span class="attr">"title"</span>:&#123;</span><br><span class="line">          //title设为text，包含自字段keyword。支持检索、排序、聚合分析</span><br><span class="line">          "type":"text",</span><br><span class="line">          "fields":&#123;</span><br><span class="line">            "keyword":&#123;"type":"keyword"&#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,//publish_data设为date，支持检索、排序、聚合分析</span><br><span class="line">      "publish_data":&#123;"type":"date"&#125;,</span><br><span class="line">      // author设为keyword，支持检索、排序、聚合分析</span><br><span class="line">      "author":&#123;"type":"keyword"&#125;,</span><br><span class="line">      // abstract设为text，支持检索、排序、聚合分析</span><br><span class="line">      "abstract":&#123;"type":"text"&#125;,</span><br><span class="line">      // url设为date，不需进行检索</span><br><span class="line">      "url":&#123;"enabled":false&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>如果在<code>blog_index</code>中加入一个内容字段<code>content</code></strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 为blog_index增加content字段</span><br><span class="line">PUT blog_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">    <span class="attr">"doc"</span>:&#123;</span><br><span class="line">     //关闭，不存原始内容到_source</span><br><span class="line">     "_source":&#123;"enabled":false&#125;,</span><br><span class="line">     "properties":&#123;</span><br><span class="line">        //title设为text，包含自字段keyword。支持检索、排序、聚合分析</span><br><span class="line">        "title":&#123;</span><br><span class="line">            "type":"text",</span><br><span class="line">            "fields":&#123;</span><br><span class="line">              "keyword":&#123;</span><br><span class="line">               "type":"keyword"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "store":true //对数据进行存储</span><br><span class="line">        &#125;,//publish_data设为date，支持检索、排序、聚合分析</span><br><span class="line">        "publish_data":&#123;</span><br><span class="line">            "type":"date",</span><br><span class="line">            "store":true // 对数据进行存储</span><br><span class="line">        &#125;,</span><br><span class="line">        "author":&#123;// author设为keyword，支持检索、排序、聚合分析</span><br><span class="line">            "type":"keyword",</span><br><span class="line">            "store":true    // 对数据进行存储</span><br><span class="line">        &#125;,</span><br><span class="line">        "abstract":&#123;// abstract设为text，支持检索、排序、聚合分析</span><br><span class="line">            "type":"text",</span><br><span class="line">            "store":true    // 对数据进行存储</span><br><span class="line">        &#125;,</span><br><span class="line">        "content":&#123;// content设为text，支持检索、排序、聚合分析</span><br><span class="line">            "type":"text",</span><br><span class="line">            "store":true    // 对数据进行存储</span><br><span class="line">        &#125;,</span><br><span class="line">        "url":&#123;</span><br><span class="line">            "type":"keyword",   // url设为keyword</span><br><span class="line">            "doc_values":false, // url不支持排序和聚合分析</span><br><span class="line">            "norms":false,      // url也不需要归一化数据</span><br><span class="line">            "ignore_above":100, // 预设内容长度为100</span><br><span class="line">            "store":true        // 对数据进行存储</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在搜索时增加高亮</strong>: 在此时，<code>content</code>里面的数据会存储大量的内容数据，数据量可能达到上千、上万，甚至几十万。那么在搜索的时候，根据<code>search</code>机制，如果还是像之前一样进行<code>_search</code>搜索，并只显示其他字段的话，其实依然还是每次获取了<code>content</code>字段的内容，影响性能，所以，使用<code>stored_fields</code>参数，控制返回的字段。节省了大量资源：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 使用stored_fields返回指定的存储后的字段</span><br><span class="line">GET blog_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"stored_fields"</span>:[<span class="string">"title"</span>,<span class="string">"publish_data"</span>,<span class="string">"author"</span>,<span class="string">"Abstract"</span>,<span class="string">"url"</span>],</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"content"</span>:<span class="string">"world"</span>//依然进行content搜索，但是不返回所有的content字段</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> "highlight":&#123; //针对content字段进行高亮显示</span><br><span class="line">  "fields":&#123;</span><br><span class="line">     "content":&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：<code>GET blog_index/_search?_source=title</code> 虽然只显示了<code>title</code>，但是<code>search</code>机制决定了，会把所有<code>_source</code>内容获取到，但只是显示<code>title</code>。</p></blockquote><h4 id="2-5-ES中关联关系处理"><a href="#2-5-ES中关联关系处理" class="headerlink" title="2.5 ES中关联关系处理"></a>2.5 ES中关联关系处理</h4><p><code>ES</code>不擅长处理关系型数据库中的关联关系，因为底层使用的倒排索引，如：文章表<code>blog</code>和评论表<code>comment</code>之间通过<code>blog_id</code>关联。<br>目前ES主要有以下4种常用的方法来处理关联关系：</p><ol><li><strong><code>Nested Object</code></strong>:嵌套文档</li><li><strong><code>Parent/Child</code></strong>:父子文档</li><li><code>Data denormalization</code>:数据的非规范化</li><li><code>Application-side joins</code>:服务端Join或客户端Join</li></ol><h5 id="2-5-1-Application-side-joins（服务端Join或客户端Join）"><a href="#2-5-1-Application-side-joins（服务端Join或客户端Join）" class="headerlink" title="2.5.1 Application-side joins（服务端Join或客户端Join）"></a>2.5.1 Application-side joins（服务端Join或客户端Join）</h5><p>索引之间完全独立（利于对数据进行标准化处理，如便于上述两种增量同步的实现），由应用端的多次查询来实现近似关联关系查询。</p><ul><li>适用于第一个实体只有少量的文档记录的情况（使用<code>ES</code>的<code>terms</code>查询具有上限，默认<code>1024</code>，具体可在<code>elasticsearch.yml</code>中修改），并且最好它们很少改变。这将允许应用程序对结果进行缓存，并避免经常运行第一次查询。</li></ul><h5 id="2-5-2-Data-denormalization（数据的非规范化）"><a href="#2-5-2-Data-denormalization（数据的非规范化）" class="headerlink" title="2.5.2 Data denormalization（数据的非规范化）"></a>2.5.2 Data denormalization（数据的非规范化）</h5><p>通俗点就是通过字段冗余，以一张大宽表来实现粗粒度的<code>index</code>，这样可以充分发挥扁平化的优势。但是这是以牺牲索引性能及灵活度为代价的。</p><ul><li>使用的前提：冗余的字段应该是很少改变的；比较适合与一对少量关系的处理。当业务数据库并非采用非规范化设计时，这时要将数据同步到作为二级索引库的ES中，就很难使用上述增量同步方案，必须进行定制化开发，基于特定业务进行应用开发来处理<code>join</code>关联和实体拼接。<blockquote><p>宽表处理在处理一对多、多对多关系时，会有字段冗余问题，适合“一对少量”且这个“一”更新不频繁的应用场景。</p></blockquote></li></ul><h5 id="2-5-3-Nested-objects（嵌套文档）"><a href="#2-5-3-Nested-objects（嵌套文档）" class="headerlink" title="2.5.3 Nested objects（嵌套文档）"></a>2.5.3 Nested objects（嵌套文档）</h5><p>索引性能和查询性能二者不可兼得，必须进行取舍。<br>嵌套文档将实体关系嵌套组合在单文档内部（类似与json的一对多层级结构），这种方式牺牲索引性能（文档内任一属性变化都需要重新索引该文档）来换取查询性能，可以同时返回关系实体，比较适合于一对少量的关系处理。</p><ul><li>当使用嵌套文档时，使用通用的查询方式是无法访问到的，必须使用合适的查询方式（nested query、nested filter、nested facet等），很多场景下，使用嵌套文档的复杂度在于索引阶段对关联关系的组织拼装。</li></ul><h5 id="2-5-4-Parent-Child（父子文档）"><a href="#2-5-4-Parent-Child（父子文档）" class="headerlink" title="2.5.4 Parent/Child（父子文档）"></a>2.5.4 Parent/Child（父子文档）</h5><p>父子文档牺牲了一定的查询性能来换取索引性能，适用于一对多的关系处理。其通过两种type的文档来表示父子实体，父子文档的索引是独立的。父-子文档ID映射存储在 Doc Values 中。当映射完全在内存中时， Doc Values 提供对映射的快速处理能力，另一方面当映射非常大时，可以通过溢出到磁盘提供足够的扩展能力。</p><ul><li><p>在查询parent-child替代方案时，发现了一种filter-terms的语法，要求某一字段里有关联实体的ID列表。基本的原理是在terms的时候，对于多项取值，如果在另外的index或者type里已知主键id的情况下，某一字段有这些值，可以直接嵌套查询。具体可参考官方文档的示例：通过用户里的粉丝关系，微博和用户的关系，来查询某个用户的粉丝发表的微博列表。</p><blockquote><p>父子文档相比嵌套文档较灵活，但只适用于“一对大量”且这个“一”不是海量的应用场景，该方式比较耗内存和CPU，这种方式查询比嵌套方式慢5~10倍，且需要使用特定的has_parent和has_child过滤器查询语法，查询结果不能同时返回父子文档（一次join查询只能返回一种类型的文档）。</p></blockquote></li><li><p>而受限于父子文档必须在同一分片上，ES父子文档在滚动索引、多索引场景下对父子关系存储和联合查询支持得不好，而且子文档type删除比较麻烦（子文档删除必须提供父文档ID）。</p></li><li><p>如果业务端对查询性能要求很高的话，还是建议使用宽表化处理的方式，这样也可以比较好地应对聚合的需求。在索引阶段需要做join处理，查询阶段可能需要做去重处理，分页方式可能也得权衡考虑下。</p></li></ul><h4 id="2-6-ES中的reindex"><a href="#2-6-ES中的reindex" class="headerlink" title="2.6 ES中的reindex"></a>2.6 ES中的reindex</h4><p><code>reindex</code>：指重建所有数据的过程，一般发生在一下情况：</p><ol><li><code>mapping</code>设置变更，如：字段类型变化，分词器字典更新等；</li><li><code>index</code>设置变更，如：分片数变化；</li><li>迁移数据。</li></ol><ul><li>ES提供了线程的api用于完成数据重建：<ul><li><code>_update_by_query</code>：在现有索引上重建；</li><li><code>_reindex</code>：在其他索引上重建。</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将blog_index中所有文档重建一遍：</span><br><span class="line">// 如果遇到版本冲突，依然执行。</span><br><span class="line">POST blog_index/_update_by_query?conflicts=proceed    </span><br><span class="line">// 此时如果blog_index中没有store的数据，则会报错</span><br></pre></td></tr></table></figure><h5 id="2-6-1-使用-update-by-query，更新文档的字段值和部分文档："><a href="#2-6-1-使用-update-by-query，更新文档的字段值和部分文档：" class="headerlink" title="2.6.1 使用_update_by_query，更新文档的字段值和部分文档："></a>2.6.1 使用<code>_update_by_query</code>，更新文档的字段值和部分文档：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 更新文档的字段值及部分文档</span><br><span class="line">POST blog_index/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line"> "script":&#123;    // 更新文档的字段值</span><br><span class="line">  "source":"ctx._source.likes++",    // 代码</span><br><span class="line">  "lang":"painless"    // ES自带script语法</span><br><span class="line"> &#125;,</span><br><span class="line"> "query":&#123;    // 更新部分文档</span><br><span class="line">  "term":&#123;</span><br><span class="line">   "user":"tom"</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在reindex发起后进入的文档，不会参与重建，类似于快照的机制。因此：一般在文档不再发生变更时，进行文档的reindex。</p><h5 id="2-6-2-使用-reindex，重建数据："><a href="#2-6-2-使用-reindex，重建数据：" class="headerlink" title="2.6.2 使用_reindex，重建数据："></a>2.6.2 使用<code>_reindex</code>，重建数据：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用_reindex：</span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line"> "source":&#123;    // 被重建索引</span><br><span class="line">  "index":"blog_index"</span><br><span class="line"> &#125;,</span><br><span class="line"> "dest":&#123;    // 目标索引</span><br><span class="line">  "index":"blog_new_index"</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据重建时间，受到索引文档规模的影响，此时设定<code>url</code>参数<code>wait_for_completion</code>为<code>false</code>，来异步执行。</li><li><code>ES</code>通过<code>task</code>来描述此类执行任务，并提供了<code>task api</code>来查看任务的执行进度和相关数据：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用task api</span><br><span class="line">POST blog_index/_update_by_query?comflicts=proceed&amp;wait_for_completion=false</span><br><span class="line">// 使用返回的taskid，查看任务的执行进度和相关数据</span><br><span class="line">GET _tasks/&lt;返回的task id&gt;</span><br></pre></td></tr></table></figure><h4 id="2-7-其他建议："><a href="#2-7-其他建议：" class="headerlink" title="2.7 其他建议："></a>2.7 其他建议：</h4><ol><li><p>对mapping进行版本管理：</p><ul><li>要么写文件/注释，加入到<code>Git</code>仓库，一眼可见；</li><li>要么增加<code>metadata</code>字段，维护版本，并在每次更新<code>mapping</code>设置的时候加<code>1</code>。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"metadata":&#123;</span><br><span class="line"> "version":1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>防止字段过多：</p><ul><li><code>index.mapping.total_fields_limit</code>，默认<code>1000</code>个。一般是因为没有高质量的数据建模导致，如：<code>dynamic</code>设为<code>true</code>。此时考虑查分多个索引来解决问题。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ElasticSearch中的聚合分析&quot;&gt;&lt;a href=&quot;#1-ElasticSearch中的聚合分析&quot; class=&quot;headerlink&quot; title=&quot;1. ElasticSearch中的聚合分析&quot;&gt;&lt;/a&gt;1. ElasticSearch中的聚合分析&lt;/h3&gt;&lt;p&gt;聚合分析，英文&lt;code&gt;Aggregation&lt;/code&gt;，是ES除了搜索功能之外提供的针对ES数据进行统计分析的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：&lt;ul&gt;
&lt;li&gt;①功能丰富，可满足大部分分析需求；&lt;/li&gt;
&lt;li&gt;②实时性高，所有计算结果实时返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于分析规则的不同，ES将聚合分析主要划分为以下4种：&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Metric&lt;/code&gt;&lt;/strong&gt;: 指标分析类型，如：计算最值，平均值等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Bucket&lt;/code&gt;&lt;/strong&gt;: 分桶类型，类似于&lt;code&gt;group by&lt;/code&gt;语法，根据一定规则划分为若干个桶分类；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Pipeline&lt;/code&gt;&lt;/strong&gt;: 管道分析类型，基于上一级的聚合分析结果进行再分析；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Matrix&lt;/code&gt;: 矩阵分析类型。
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【ElasticStack】ElasticSearch分布式特性 与 Search机制</title>
    <link href="http://chaooo.github.io/article/20191120.html"/>
    <id>http://chaooo.github.io/article/20191120.html</id>
    <published>2019-11-20T12:44:13.000Z</published>
    <updated>2019-12-08T08:27:09.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ElasticSearch的分布式特性"><a href="#1-ElasticSearch的分布式特性" class="headerlink" title="1. ElasticSearch的分布式特性"></a>1. ElasticSearch的分布式特性</h3><h4 id="1-1-分布式介绍"><a href="#1-1-分布式介绍" class="headerlink" title="1.1 分布式介绍"></a>1.1 分布式介绍</h4><ol><li><code>ES</code>支持<strong>集群模式</strong>，即一个分布式系统。其好处主要有以下2个:<ol><li><strong>可增大系统容量</strong>。比如：内存、磁盘的增加使得<code>ES</code>能够支持<code>PB</code>级别的数据；</li><li><strong>提高了系统可用性</strong>。即使一部分节点停止服务，集群依然可以正常对外服务。</li></ol></li><li><code>ES</code>集群由多个<code>ES实例</code>构成。<ul><li>不同集群通过<strong>集群名字</strong>来区分，通过配置文件<code>elasticsearch.yml</code>中的<code>cluster.name</code>可以修改，默认为<code>elasticsearch</code></li><li>每个<code>ES实例</code>的本质，其实是一个<code>JVM进程</code>，且有自己的名字，通过配置文件中的<code>node.name</code>可以修改。<a id="more"></a></li></ul></li></ol><h4 id="1-2-构建ES集群"><a href="#1-2-构建ES集群" class="headerlink" title="1.2 构建ES集群"></a>1.2 构建ES集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个本地化集群my_cluster</span><br><span class="line">bin/elasticsearch -Epath.data=node1 -Ecluster.name=my_cluster -Enode.name=node1 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2 -Ecluster.name=my_cluster -Enode.name=node2 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3 -Ecluster.name=my_cluster -Enode.name=node3 -d</span><br></pre></td></tr></table></figure><blockquote><p>可以通过cerebro插件可以看到，集群<code>my_cluster</code>中存在三个节点，分别为：<code>node1</code>、<code>node2</code>、<code>node3</code></p></blockquote><ol><li><strong><code>Cluster State</code></strong>：ES集群相关的数据，主要记录如下信息：<ul><li>节点信息：如节点名称、连接地址等</li><li>索引信息：如索引名称、配置等</li></ul></li><li><strong><code>Master Node</code></strong>：<strong>主节点</strong>，可修改<code>cluster state</code>的节点。一个集群<strong>只能有一个</strong>。<ul><li><code>cluster state</code>存储于每个节点上，<code>master</code>维护最新版本并向其他从节点同步。</li><li>master节点是通过集群中所有节点<strong>选举</strong>产生的，可被选举的节点称为<strong><code>master-eligible节点</code></strong></li><li>通过配置<code>node.master:true</code>设置节点为可被选举节点(默认为true)</li></ul></li><li><strong><code>Cordinating Node</code></strong>：处理请求的节点。是所有节点的默认角色，且不能取消。<ul><li>路由请求到正确的节点处理，如：创建索引的请求到master节点。</li></ul></li><li><strong><code>Data Node</code></strong>：存储数据的节点，默认节点都是<code>data</code>类型。配置<code>node.data:true</code>。</li></ol><h4 id="1-3-副本与分片"><a href="#1-3-副本与分片" class="headerlink" title="1.3 副本与分片"></a>1.3 副本与分片</h4><ul><li><p>提高系统可用性：</p><ol><li>服务可用性：集群</li><li>数据可用性：<strong>副本</strong>(Replication)</li></ol></li><li><p>增大系统容量：<strong>分片</strong>(Shard)</p></li><li><p><strong>分片</strong>是<code>ES</code>能支持<code>PB级别数</code>据的基石：可在创建索引时指定</p><ol><li>分片存储部分数据，可以分布于任意节点；</li><li>分片数在索引创建时指定，且后续不能更改，默认为5个；</li><li>有主分片和副本分片之分，以实现数据的高可用；</li><li>副本分片由主分片同步数据，可以有多个，从而提高数据吞吐量。</li></ol></li><li><p><strong>分片数的设定</strong>很重要，需要提前规划好</p><ul><li><strong>过小</strong>会导致后续无法通过增加节点实现水平扩容</li><li><strong>过大</strong>会导致一个节点分片过多，造成资源浪费，同时会影响查询性能</li></ul></li><li><p>例如：在3个节点的集群中配置索引指定3个分片和1个副本（<code>index.number_of_shards:3</code>,<br><code>index.number_of_replicas:1</code>），分布如下：<br><img src="http://cdn.chaooo.top/Java/es_shard.jpg" alt></p></li><li><p>怎样增加节点或副本提高索引的吞吐量</p><ul><li><strong>同时</strong>增加新的节点<strong>和</strong>加新的副本，这样把新的副本放在新的节点上，进行索引数据读取的时候，并且读取，就会提升索引数据读取的吞吐量。</li></ul></li></ul><h4 id="1-4-ES集群状态-与-故障转移"><a href="#1-4-ES集群状态-与-故障转移" class="headerlink" title="1.4 ES集群状态 与 故障转移"></a>1.4 ES集群状态 与 故障转移</h4><ul><li>ES的<strong>健康状态(<code>Cluster Health</code>)</strong>分为三种：<ol><li><code>Greed</code>，绿色。表示所有主分片和副本分片都正常分配；</li><li><code>Yellow</code>，黄色。表示所有主分片都正常分配，但有副本分片未分配；</li><li><code>Red</code>，红色。表示有主分片未分配。</li></ol></li><li>可通过<code>GET _cluster/health</code>查看集群状态<ul><li>返回<strong>集群名称</strong>，<strong>集群状态</strong>，<strong>节点数</strong>，<strong>活跃分片数</strong>等信息。</li><li>如果此时磁盘空间不够，name在创建新的索引的时候，主副分片都不会再分配，此时的集群状态会直接飙红，但此时依然可以访问集群和索引，也可以正常进行搜索。</li><li>所以：<strong>ES的集群状态为红色，不一定就不能正常服务</strong>。</li></ul></li></ul><ul><li><strong>故障转移 <code>Failover</code></strong><ol><li>当其余节点发现定时ping主节点master无响应的时候，集群状态转为Red。此时会发起master选举。</li><li>新master节点发现若有主分片未分配，会将副本分片提升为主分片，此时集群状态转为Yellow。</li><li>新master节点会将提升后的主分片生成新的副本，此时集群状态转为Green。整个故障转移过程结束。</li></ol></li></ul><h4 id="1-5-文档分布式存储"><a href="#1-5-文档分布式存储" class="headerlink" title="1.5 文档分布式存储"></a>1.5 文档分布式存储</h4><p>通过文档到分片的<strong>映射算法</strong>，使文档<strong>均匀分布</strong>到所有分片上，以充分利用资源。</p><ul><li><p>文档对应分片计算公式：<code>shard = hash(routing)%number_of_primary_shards</code></p><ul><li><code>hash</code>保证数据均匀分布在分片中</li><li><code>routing</code>作为关键参数，默认为文档ID，也可自行指定</li><li><code>number_of_primary_shards</code>为主分片数</li></ul></li><li><p><strong>主分片数一旦设定，不能更改</strong>：<code>为了保证文档对应的分片不会发生改变</code>。</p></li><li><p>文档<strong>创建</strong>流程:<br><img src="http://cdn.chaooo.top/Java/elastic1.jpg" alt></p></li><li><p>文档<strong>读取</strong>流程<br><img src="http://cdn.chaooo.top/Java/elastic2.jpg" alt></p></li><li><p>文档<strong>批量创建</strong>流程<br><img src="http://cdn.chaooo.top/Java/elastic3.jpg" alt></p></li><li><p>文档<strong>批量读取</strong>流程<br><img src="http://cdn.chaooo.top/Java/elastic4.jpg" alt></p></li></ul><h4 id="1-6-脑裂问题"><a href="#1-6-脑裂问题" class="headerlink" title="1.6 脑裂问题"></a>1.6 脑裂问题</h4><ul><li>在分布式系统中一个经典的网络问题<ul><li>当一个集群在运行时，作为<code>master</code>节点的<code>node1</code>的网络突然出现问题，无法和其他节点通信，出现网络隔离情况。那么<code>node1</code>自己会组成一个单节点集群，并更新<code>cluster state</code>；同时作为<code>data</code>节点的<code>node2</code>和<code>node3</code>因为无法和<code>node1</code>通信，则通过选举产生了一个新的<code>master</code>节点<code>node2</code>，也更新了<code>cluster state</code>。那么当<code>node1</code>的网络通信恢复之后，集群无法选择正确的<code>master</code>。</li></ul></li><li>解决方案也很简单：<ul><li>仅在可选举的<code>master-eligible</code>节点数<code>&gt;=quorum</code>的时候才进行<code>master</code>选举。</li><li><code>quorum(至少为2)=master-eligible数量/2 + 1</code>。</li><li>通过<code>discovery.zen.minimum_master_nodes</code>为<code>quorum</code>即可避免脑裂。</li></ul></li></ul><h4 id="1-7-Shards分片详解"><a href="#1-7-Shards分片详解" class="headerlink" title="1.7 Shards分片详解"></a>1.7 Shards分片详解</h4><ol><li>倒排索引一旦生成，不能更改。<ul><li>优点：<ol><li>不用考虑并发写文件的问题，杜绝了锁机制带来的性能问题</li><li>文件不在更改，则可以利用文件系统缓存，只需载入一次，只要内存足够，直接从内存中读取该文件，性能高；</li><li>利于生成缓存数据(且不需更改)；</li><li>利于对文件进行压缩存储，节省磁盘和内存存储空间。</li></ol></li><li>缺点：在写入新的文档时，必须重构倒排索引文件，然后替换掉老倒排索引文件后，新文档才能被检索到，导致实时性差。</li></ul></li><li>解决文档搜索的实时性问题的方案：<ul><li>新文档直接生成新待排索引文件，查询时同时查询所有倒排索引文件，然后做结果的汇总即可，从而提升了实时性。</li></ul></li><li><code>Segment</code><ul><li><code>Lucene</code>就采用了上述方案，构建的单个倒排索引称为<code>Segment</code>，多个<code>Segment</code>合在一起称为<code>Index</code>(<code>Lucene</code>中的<code>Index</code>)。在<code>ES</code>中的一个<code>shard</code>分片，对应一个<code>Lucene</code>中的<code>Index</code>。且<code>Lucene</code>有一个专门记录所有<code>Segment</code>信息的文件叫做<code>Commit Point</code>。</li><li><code>Segment</code>写入磁盘的过程依然很耗时，可以借助文件系统缓存的特性。【先将<code>Segment</code>在内存中创建并开放查询，来进一步提升实时性】，这个过程在<code>ES</code>中被称为：<code>refresh</code>。</li><li>在<code>refresh</code>之前，文档会先存储到一个缓冲队列<code>buffer</code>中，<code>refresh</code>发生时，将<code>buffer</code>中的所有文档清空，并生成<code>Segment</code>。</li><li><code>ES</code>默认每<code>1s</code>执行一次<code>refresh</code>操作，因此实时性提升到了<code>1s</code>。这也是<code>ES</code>被称为近实时的原因（<code>Near Real Time</code>）。</li></ul></li><li><code>translog</code>文件<ul><li><code>translog</code>机制：当文档写入<code>buffer</code>时，同时会将该操作写入到<code>translog</code>中，这个文件会即时将数据写入磁盘，在6.0版本之后默认每个要求都必须落盘，这个操作叫做<code>fsync</code>操作。这个时间也是可以通过配置：<code>index.translog.*</code>进行修改的。比如每五秒进行一次<code>fdync</code>操作，那么风险就是丢失这<code>5s</code>内的数据。</li></ul></li><li>文档搜索实时性——<code>flush</code>(十分重要)<ul><li><code>flush</code>的功能，就是：将内存中的<code>Segment</code>写入磁盘，主要做如下工作：<ol><li>将<code>translog</code>写入磁盘；</li><li>将<code>index bufffer</code>清空，其中的文档生成一个新的<code>Segment</code>，相当于触发一次<code>refresh</code>；</li><li>更新<code>Commit Point</code>文件并写入磁盘；</li><li>执行<code>fsync</code>落盘操作，将内存中的<code>Segment</code>写入磁盘；</li><li>删除旧的<code>translog</code>文件。</li></ol></li></ul></li><li><code>refresh</code>与<code>flush</code>的发生时机<ul><li><code>refresh</code>：发生时机主要有以下几种情况：<ol><li>间隔时间达到。<ul><li>通过<code>index.settings.refresh_interval</code>设置，默认为<code>1s</code>。</li></ul></li><li><code>index.buffer</code>占满时。<ul><li>通过<code>indices.memory.index_buffer_size</code>设置，默认<code>JVM heap</code>的<code>10%</code>，且所有<code>shard</code>共享。</li></ul></li><li><code>flush</code>发生时。会触发一次<code>refresh</code>。</li></ol></li><li><code>flush</code>：发生时机主要有以下几种情况：<ol><li>间隔时间达到。<ul><li>5.x版本之前，通过<code>index.translog.flush_threshold_period</code>设置，默认30min。</li><li>5.x版本之后，<strong>ES强制每30min执行一次flush，不能再进行更改</strong>。</li></ul></li><li><code>translog</code>占满时。<ul><li>通过<code>index.translog.flush_threshold_size</code>设置，默认<code>512m</code>。且每个<code>Index</code>有自己的<code>translog</code>。</li></ul></li></ol></li></ul></li><li>删除和更新文档：<ul><li>删除：<ul><li><code>Segment</code>一旦生成，就不能更改，删除的时候，<code>Lucene</code>专门维护一个<code>.del</code>文件，记录所有已删除的文档。</li><li><code>.del</code>文件上记录的是文档在<code>Lucene</code>中的<code>ID</code>，在查询结果返回之前，会过滤掉<code>.del</code>文件中的所有文档。</li></ul></li><li>更新：<ul><li>先删除老文档，再创建新文档，两个文档的<code>ID</code>在<code>Lucene</code>中的<code>ID</code>不同，但是在<code>ElasticSearch</code>中<code>ID</code>相同。</li></ul></li></ul></li><li><code>Segment Merging</code>(合并)<ol><li>随着<code>Segment</code>的增多，由于每次查询的<code>Segment</code>数量也增多，导致查询速度变慢；</li><li><code>ES</code>会定时在后台进行<code>Segment merge</code>的操作，减少<code>Segment</code>数量；</li><li>通过<code>force_merge api</code>可以手动强制做<code>Segment</code>的合并操作。</li></ol></li></ol><h3 id="2-ElasticSearch的集群优化"><a href="#2-ElasticSearch的集群优化" class="headerlink" title="2. ElasticSearch的集群优化"></a>2. ElasticSearch的集群优化</h3><h4 id="2-1-生产环境部署"><a href="#2-1-生产环境部署" class="headerlink" title="2.1 生产环境部署"></a>2.1 生产环境部署</h4><ol><li>遵照官方建议设置所有系统参数。<ul><li>在ES的配置文件中elasticsearch.yml中，尽量只写必备的参数，其他可通过api进行动态设置，随着ES版本的不断升级，很多网上流传的参数，现在已经不再适用，所以不要胡乱复制。</li><li>建议设置的基本参数有：<ol><li><code>cluster.name</code></li><li><code>node.name</code></li><li><code>node.master/node.data/node.ingest</code></li><li><code>network.host</code>: 建议显示指定为服务器的内网<code>ip</code>，切勿直接指定<code>0.0.0.0</code>，很容易直接从外部被修改<code>ES</code>数据。</li><li><code>discovery.zen.ping.unicast.hosts</code>: 设置集群其他节点地址，一般设置选举节点即可</li><li><code>discovery.zen.minimum_master_nodes</code>: 一般设置为<code>2</code>，有<code>3</code>个即可。</li><li><code>path.data/path.log</code></li><li>除上述参数外，再根据需要增加其他的静态配置参数，如：<code>refresh</code>优化参数，<code>indices.memory.index_buffer_size</code>。</li></ol></li><li>动态设定的参数有transient(短暂的)和persistent(持续的)两种，前者在集群重启后会丢失，后者在集群重启后依然// 生效。二者都覆盖了yml中的配置，举例：</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用transient和persistent动态设置ES集群参数</span><br><span class="line">PUT /_cluster/Settings</span><br><span class="line">&#123;</span><br><span class="line"> "persistent":&#123;    // 永久</span><br><span class="line">  <span class="string">"discovery.zen.minimum_master_nodes:2</span></span><br><span class="line"><span class="string"> &#125;,</span></span><br><span class="line"> "transient":&#123;   // 临时</span><br><span class="line">  "indices.store.throttle.max_bytes_per_sec":"50mb"</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>关于JVM内存设定<ul><li>每个节点尽量不要超多<code>31GB</code>。</li><li>预留一半内存给操作系统，用来做文件缓存。ES的具体内存大小根据node要存储的数据量来估算，为了保证性能<ul><li>搜索类项目中：内存：数据量   ===&gt;   1：16；</li><li>日志类项目中：内存：数据量   ===&gt;   1：48/96。</li></ul></li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设现有数据1TB，3个node，1个副本，那么：</span><br><span class="line">每个node存储(1+1)*1024 / 3 = 666GB,即700GB左右，做20%预留空间，每个node约存850GB数据。</span><br><span class="line">此时：</span><br><span class="line">如果是搜索类项目，每个node内存约为850/16=53GB，已经超过31GB最大限制；</span><br><span class="line">而：31*16 = 496，意味着每个node最大只能存496GB的数据，则：2024/496=4.08...即至少需要5个节点。</span><br><span class="line">如果是日志类项目，每个node最大能存:31*48=1488GB,则：2024/1488=1.36...，则三个节点已经够了。</span><br></pre></td></tr></table></figure><h4 id="2-2-写性能优化"><a href="#2-2-写性能优化" class="headerlink" title="2.2 写性能优化"></a>2.2 写性能优化</h4><p>在写上面的优化，主要是增大写的吞吐量——<code>EPS(Event Per Second)</code></p><ul><li>优化方案：<ol><li><code>Client</code>：多线程写，批量写<code>bulk</code>；</li><li><code>ES</code>：在高质量数据建模的前提下，主要在<code>refresh</code>、<code>translig</code>和<code>flush</code>之间做文章。</li></ol></li></ul><ol><li>降低<code>refresh</code>写入内存的频率：<ol><li>增大<code>refresh_interval</code>，降低实时性，增大每次<code>refresh</code>处理的文件数，默认1s。可以设为-1s，禁止自动<code>refresh</code>。</li><li>增大<code>index</code> <code>buffer</code>大小，参数为：<code>indices.memory.index_buffer_size</code>。此为静态参数，需设定在<code>elasticsea.yml</code>中，默认<code>10%</code></li></ol></li><li>降低translog写入磁盘频率，同时会降低容灾能力：<ol><li><code>index.translog.durability</code>：设为<code>async</code>；</li><li><code>index.translog.sync_interval</code>。设置需要的大小如：120s  =&gt;  每120s才写一次磁盘。</li><li><code>index.translog.flush_threshold_size</code>。默认512m。即当<code>translog</code>大小超过此值，会触发一次<code>flush</code>，可以调大避免<code>flush</code>过早触发。</li></ol></li><li>在<code>flush</code>方面，从6.x开始，ES固定每30min执行一次，所以优化点不多，一般都是ES自动完成。</li><li>其他：<ol><li>将副本数设置为0，在文档全部写完之后再加副本；</li><li>合理设计<code>shard</code>数，保证<code>shard</code>均匀地分布在所有<code>node</code>上，充分利用<code>node</code>资源：<ul><li><code>index.routing.allocation.total_shards_per_node</code>：限定每个索引在每个<code>node</code>上可分配的主副分片数，</li><li>如：有<code>5</code>个<code>node</code>，某索引有<code>10</code>个主分片，<code>1</code>个副本(<code>10</code>个副分片)，则：<code>20/5=45</code>,但是实际要设置为<code>5</code>，预防某个<code>node</code>下线后分片迁移失败。</li></ul></li></ol></li></ol><blockquote><p>写性能优化，主要还是index级别的设置优化。<br>一般在refresh、translog、flush三个方面进行优化；</p></blockquote><h4 id="2-3-读性能优化"><a href="#2-3-读性能优化" class="headerlink" title="2.3 读性能优化"></a>2.3 读性能优化</h4><ul><li>主要受以下几方面影响：<ol><li>数据模型是否符合业务模型？</li><li>数据规模是否过大？</li><li>索引配置是否优化？</li><li>查询运距是否优化？</li></ol></li></ul><ol><li>高质量的数据建模<ol><li>将需通过<code>cripte</code>脚本动态计算的值，提前计算好作为字段存入文档中；</li><li>尽量使数据模型贴近业务模型</li></ol></li><li>根据不同数据规模设定不同的<code>SLA</code>(服务等级协议)，万级数据和千万级数据和亿万级数据性能上肯定有差异；</li><li>索引配置优化<ol><li>根据数据规模设置合理的分片数，可通过测试得到最适合的分片数；</li><li>分片数并不是越多越好</li></ol></li><li>查询语句优化<ol><li>尽量使用<code>Filter</code>上下文，减少算分场景(<code>Filter</code>有缓存机制，能极大地提升查询性能)；</li><li>尽量不用<code>cript</code>进行字段计算或算分排序等；</li><li>结合<code>profile</code>、<code>explain API</code>分析慢查询语句的症结所在，再去优化数据模型。</li></ol></li></ol><h4 id="2-4-其他优化点"><a href="#2-4-其他优化点" class="headerlink" title="2.4 其他优化点"></a>2.4 其他优化点</h4><ol><li>如何设定<code>shard</code>数？<ul><li><code>ES</code>的性能基本是线性扩展的，因此，只需测出一个<code>shard</code>的性能指标，然后根据实际的性能需求就可算出所需的<code>shard</code>数。</li><li>测试一个<code>shard</code>的流程如下：<ol><li>搭建与生产环境相同配置的单节点集群；</li><li>设定一个单分片<code>0</code>副本的索引；</li><li>写入实际生产数据进行测试，获取（写性能指标）；</li><li>针对数据进行查询操作，获取（读性能指标）。</li></ol></li></ul></li><li>压力测试工具，可以采用<code>ES</code>自带的<code>esrally</code>，从经验上讲：<ul><li>如果是搜索引擎场景，单<code>shard</code>大小不超过<code>15GB</code>；</li><li>如果是日志分析场景，单<code>shard</code>大小不超过<code>50GB</code>；</li><li>估算索引的总数据大小，除以上述单<code>shard</code>大小，也可得到经验上的分片数。</li></ul></li></ol><h4 id="2-5-ES集群监控"><a href="#2-5-ES集群监控" class="headerlink" title="2.5 ES集群监控"></a>2.5 ES集群监控</h4><p>使用官方免费插件<code>X-pack</code>。</p><ol><li>安装与启动：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> X-pack的安装</span></span><br><span class="line">cd ~/elasticsearch-6.1.1</span><br><span class="line">bin/elasticsearch-plugin install x-pack</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">cd ~/kibana-6.1.1</span><br><span class="line">bin/kibana-plugin indtall x-pack</span><br></pre></td></tr></table></figure></li></ol><p>之后重启<code>ES</code>集群即可。<br>在<code>kibana</code>的界面可以看到新增了工具，使用<code>Monitoring</code>进行集群监控。</p><h3 id="3-ElasticSearch中Search的运行机制"><a href="#3-ElasticSearch中Search的运行机制" class="headerlink" title="3. ElasticSearch中Search的运行机制"></a>3. ElasticSearch中Search的运行机制</h3><ul><li><code>Search</code>执行的时候，实际分为两个步骤执行：<ol><li><code>Query</code>阶段：搜索</li><li><code>Fetch</code>阶段：获取</li></ol></li></ul><h4 id="3-1-Query—Then—Fetch："><a href="#3-1-Query—Then—Fetch：" class="headerlink" title="3.1 Query—Then—Fetch："></a>3.1 Query—Then—Fetch：</h4><p>若集群<code>my_cluster</code>中存在三个节点node1、node2、node3，其中<code>master</code>为node1，其余的为<code>data</code>节点。</p><ul><li><p><code>Query</code>阶段:<br><img src="http://cdn.chaooo.top/Java/elastic-q.jpg" alt></p></li><li><p><code>Fetch</code>阶段:<br><img src="http://cdn.chaooo.top/Java/elastic-f.jpg" alt></p></li></ul><h4 id="3-2-相关性算分："><a href="#3-2-相关性算分：" class="headerlink" title="3.2 相关性算分："></a>3.2 相关性算分：</h4><p><strong>相关性算分在<code>shard</code>和<code>shard</code>之间是相互独立的</strong>。也就意味着：同一个单词<code>term</code>在不同的<code>shard</code>上的<code>TDF</code>等值也可能是不同的。得分与<code>shard</code>有关。<br>当文档数量不多时，会导致相关性算分严重不准的情况发生。</p><ul><li>解决方案：<ol><li>设置分片数为<code>1</code>个，从根本上排除问题。（此方案只适用于百万/少千万级的少量数据）</li><li>使用<code>DFS Query-then-Fetch</code>查询方式。</li></ol></li><li><code>DFS Query-then-Fecth</code>：<ul><li>在拿到所有文档后，再重新进行完整的计算一次相关性得分，耗费更多的CPU和内存，<strong>执行性能也较低</strong>。所以也不推荐。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用DLS Query-then-Fetch进行查询：</span><br><span class="line">GET my_index/_search？search_type=dfs_query_then_fetch</span><br><span class="line">&#123;</span><br><span class="line"> &quot;query&quot;:&#123;</span><br><span class="line">  &quot;match&quot;:&#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-排序相关："><a href="#3-3-排序相关：" class="headerlink" title="3.3 排序相关："></a>3.3 排序相关：</h4><p>默认采用相关性算分结果进行排序。可通过<code>sort</code>参数自定义排序规则，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 使用sort关键词进行排序</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> "sort":&#123;    // 关键词</span><br><span class="line">  "birth":"desc"</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 或使用数组形式定义多字段排序规则</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"sort"</span>:[    // 使用数组</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">"birth"</span>:&#123;</span><br><span class="line">    <span class="attr">"order"</span>:<span class="string">"asc"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">"age"</span>:&#123;</span><br><span class="line">    <span class="attr">"order"</span>:<span class="string">"desc"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>直接按数字/日期排序，如上例中<code>birth</code></li><li>按字符串进行排序：字符串排序较特殊，因为在<code>ES</code>中有<code>keyword</code>和<code>text</code>两种：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 直接对text类型进行排序</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"sort"</span>:&#123;</span><br><span class="line">  <span class="attr">"username"</span>:<span class="string">"desc"</span>    // 针对username字段进行倒序排序</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 针对keyword进行排序</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"sort"</span>:&#123;</span><br><span class="line">  <span class="attr">"username.keyword"</span>:<span class="string">"desc"</span>    // 针对username的子类型keyword类型进行倒叙排序</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-3-1-关于fielddata和docvalues"><a href="#3-3-1-关于fielddata和docvalues" class="headerlink" title="3.3.1 关于fielddata和docvalues:"></a>3.3.1 关于fielddata和docvalues:</h5><p>排序的实质是对字段的原始内容排序的过程，此过程中<strong>倒排索引无法发挥作用</strong>，需要用到<strong>正排索引</strong>。即：通过文档<code>ID</code>和字段得到原始内容。</p><ul><li>ES提供2中实现方式：<ul><li><code>Fielddata</code>。    默认禁用。</li><li><code>DocValues</code>。    默认启用，除了text类型。</li></ul></li></ul><table><thead><tr><th>对比</th><th>Fielddata</th><th>DocValues</th></tr></thead><tbody><tr><td>创建时机</td><td>搜索时即时创建</td><td>创建索引时创建，和倒排索引创建时间一致</td></tr><tr><td>创建位置</td><td>JVM Heap</td><td>磁盘</td></tr><tr><td>优点</td><td>不占用额外磁盘空间</td><td>不占用Heap内存</td></tr><tr><td>缺点</td><td>文档较多时，同时创建会花费过多时间，占用过多Heap内存</td><td>减慢索引的速度，占用额外的磁盘空间</td></tr></tbody></table><h5 id="3-3-2-Fielddata的开启"><a href="#3-3-2-Fielddata的开启" class="headerlink" title="3.3.2 Fielddata的开启:"></a>3.3.2 Fielddata的开启:</h5><p><code>Fielddata</code><strong>默认关闭</strong>，可通过如下api进行开启，且在后续使用时随时可以开启/关闭：</p><ul><li>使用场景：<strong>一般在对分词做聚合分析的时候开启</strong>。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 开启字段的fielddata设置</span><br><span class="line">PUT my_index/_mapping/doc</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"properties"</span>:&#123;</span><br><span class="line">  <span class="attr">"username"</span>:&#123;</span><br><span class="line">   <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">   <span class="attr">"fielddata"</span>:<span class="literal">true</span>    // 关键词</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-3-Docvalues的关闭"><a href="#3-3-3-Docvalues的关闭" class="headerlink" title="3.3.3 Docvalues的关闭"></a>3.3.3 Docvalues的关闭</h4><p><code>Docvalues</code><strong>默认开启</strong>，可在创建索引时关闭，且之后不能再打开，要打开只能做reindex操作。</p><ul><li>使用场景：当明确知道，不会使用这个字段排序或者不做聚合分析的时候，可关闭doc_values，减少磁盘空间的占用。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 关闭字段的docvalues设置</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"username"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">     <span class="attr">"doc_values"</span>:<span class="literal">false</span>    // 关键词</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4-分页与遍历"><a href="#3-4-分页与遍历" class="headerlink" title="3.4 分页与遍历"></a>3.4 分页与遍历</h4><p>ES提供了三种方式来解决分页和遍历的问题： <code>from/size</code>，<code>scroll</code>，<code>search_after</code>。</p><h5 id="3-4-1-from-size"><a href="#3-4-1-from-size" class="headerlink" title="3.4.1 from/size"></a>3.4.1 from/size</h5><ul><li><code>from</code>：指明开始位置；</li><li><code>size</code>：指明获取总数<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 使用from——size</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> "from":1,    // 从第2个开始搜索</span><br><span class="line"> "size":2     // 获取2个长度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>经典问题：<strong>深度分页</strong>。<ul><li>问题：如何在数据分片存储的情况下， 获取前1000个文档？</li><li>答案：<ul><li>先从每个分片上获取前1000个文档， 然后由处理节点聚合所有分片的结果之后，再排序获取前1000个文档。</li><li>此时页数越深，处理的文档就越多，占用的内存就越大，耗时就越长。这就是深度分页问题。</li><li>为了尽量避免深度分页为题，ES通过设定<code>index.max_result_window</code>限定最多到10000条数据。</li></ul></li></ul></li><li>在设计分页系统时，有一个分页数十分重要：<ul><li><code>total_page=(total + page_size -1) / page_size</code></li><li>总分页数= (文档总数+认为设定的文档大小-1) / 人为设定的文档大小</li><li>但是在搜索引擎中的意义并不大，因为如果排在前面的结果都不能让用户满意，那么越往后，越不能让用户满意。</li></ul></li></ol><h5 id="3-4-2-scroll"><a href="#3-4-2-scroll" class="headerlink" title="3.4.2 scroll"></a>3.4.2 scroll</h5><ul><li>遍历文档集的<code>API</code>，以快照的方式来避免深度分页问题。<ol><li>不能用来做实时搜索，因为数据不是实时的；</li><li>尽量不用复杂的<code>sort</code>条件，使用<code>_doc</code>最高效；</li><li>使用比较复杂。</li></ol></li><li>步骤：<ol><li>发起一个<code>scroll search</code>，会返回后续会用到的<code>_scroll_id</code></li><li>调用<code>scroll search</code>的<code>api</code>，获取文档集合，不断迭代至返回<code>hits</code>数组为空时停止</li><li>之后不断返回新的<code>_scroll_id</code>，使用新的<code>_scroll_id</code>进行查询，直到返回数组为空。</li><li>当不断的进行迭代，会产生很多<code>scroll</code>，导致大量内存被占用，可以通过<code>clear api</code>进行删除</li></ol></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 发起一个scroll search</span><br><span class="line">GET my_index/_search?scroll=5m // 该快照的有效时间为5min</span><br><span class="line">&#123;</span><br><span class="line"> "size"1    // 指明每次scroll返回的文档数</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 调用scroll search 的api，获取文档集合</span><br><span class="line">POST _search/scroll</span><br><span class="line">&#123;</span><br><span class="line"> "scroll":"5m",    // 指明有效时间</span><br><span class="line"> "scroll_id":"xxxxxx"    // 上一步返回的_scroll_id</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 使用clear api对scroll进行删除</span><br><span class="line">DELETE /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"scroll_id"</span>:[</span><br><span class="line">   <span class="string">"xxxxxx"</span>,    // _scroll_id</span><br><span class="line">   <span class="string">"xxxxxx"</span>,    // _scroll_id</span><br><span class="line">   ......</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 删除所有的scroll</span><br><span class="line">DELETE /_search/scroll/_all</span><br></pre></td></tr></table></figure><h5 id="3-4-3-search-after"><a href="#3-4-3-search-after" class="headerlink" title="3.4.3 search_after"></a>3.4.3 search_after</h5><p>避免深度分页的性能问题，提供实时的下一页文档获取功能。</p><ul><li>缺点：不能使用from参数，即：不能指定页数。且只能下一页，不能上一页。</li><li>使用步骤：<ol><li>第一步：正常搜索，但是要指定sort值，并保证值唯一：</li><li>第二步：使用上一步最后一个文档的sort值进行查询：</li></ol></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 第一步，正常搜索</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">1</span>,</span><br><span class="line"> <span class="attr">"sort"</span>:&#123;</span><br><span class="line">  <span class="attr">"age"</span>:<span class="string">"desc"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>:<span class="string">"desc"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 第二步，使用sort值进行查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"size"</span>:<span class="number">1</span>,</span><br><span class="line"> "search_after":[28,"2"],// 28,"2"，是上一次搜索返回的sort值</span><br><span class="line"> "sort":&#123;</span><br><span class="line">  "age":"desc",</span><br><span class="line">  "_id":"desc"</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-4-4-如何避免深度分页问题"><a href="#3-4-4-如何避免深度分页问题" class="headerlink" title="3.4.4 如何避免深度分页问题:"></a>3.4.4 如何避免深度分页问题:</h5><p>这个问题目前连google都没能解决，所以只能最大程度避免，通过唯一排序值定位每次要处理的文档数都控制在size内：</p><ul><li>应用场景：<ol><li>from/size:需实时获取顶部的部分文档，且需自由翻页（实时）；</li><li>scroll:需全部文档，如：导出所有数据的功能（非实时）；</li><li>search_after:需全部文档，不需自由翻页（实时）。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ElasticSearch的分布式特性&quot;&gt;&lt;a href=&quot;#1-ElasticSearch的分布式特性&quot; class=&quot;headerlink&quot; title=&quot;1. ElasticSearch的分布式特性&quot;&gt;&lt;/a&gt;1. ElasticSearch的分布式特性&lt;/h3&gt;&lt;h4 id=&quot;1-1-分布式介绍&quot;&gt;&lt;a href=&quot;#1-1-分布式介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 分布式介绍&quot;&gt;&lt;/a&gt;1.1 分布式介绍&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ES&lt;/code&gt;支持&lt;strong&gt;集群模式&lt;/strong&gt;，即一个分布式系统。其好处主要有以下2个:&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;可增大系统容量&lt;/strong&gt;。比如：内存、磁盘的增加使得&lt;code&gt;ES&lt;/code&gt;能够支持&lt;code&gt;PB&lt;/code&gt;级别的数据；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高了系统可用性&lt;/strong&gt;。即使一部分节点停止服务，集群依然可以正常对外服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ES&lt;/code&gt;集群由多个&lt;code&gt;ES实例&lt;/code&gt;构成。&lt;ul&gt;
&lt;li&gt;不同集群通过&lt;strong&gt;集群名字&lt;/strong&gt;来区分，通过配置文件&lt;code&gt;elasticsearch.yml&lt;/code&gt;中的&lt;code&gt;cluster.name&lt;/code&gt;可以修改，默认为&lt;code&gt;elasticsearch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;ES实例&lt;/code&gt;的本质，其实是一个&lt;code&gt;JVM进程&lt;/code&gt;，且有自己的名字，通过配置文件中的&lt;code&gt;node.name&lt;/code&gt;可以修改。
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【ElasticStack】ElasticSearch入门</title>
    <link href="http://chaooo.github.io/article/20191119.html"/>
    <id>http://chaooo.github.io/article/20191119.html</id>
    <published>2019-11-19T12:42:59.000Z</published>
    <updated>2019-12-08T08:27:17.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-ElasticStack特点"><a href="#1-1-ElasticStack特点" class="headerlink" title="1.1 ElasticStack特点"></a>1.1 ElasticStack特点</h4><ol><li>使用门槛低，开发周期短，上线快</li><li>性能好，查询快，实时展示结果</li><li>扩容方便，快速支撑增长迅猛的数据<a id="more"></a></li></ol><h4 id="1-2-ElasticStack各组件作用"><a href="#1-2-ElasticStack各组件作用" class="headerlink" title="1.2 ElasticStack各组件作用"></a>1.2 ElasticStack各组件作用</h4><ol><li><strong><code>Beats</code></strong>：数据采集</li><li><strong><code>LogStash</code></strong>: 数据处理</li><li><strong><code>ElasticSearch</code></strong>(核心引擎): 数据存储、查询和分析</li><li><strong><code>Kibana</code></strong>: 数据探索与可视化分析<!-- more --></li></ol><h4 id="1-3-ElasticStack使用场景"><a href="#1-3-ElasticStack使用场景" class="headerlink" title="1.3 ElasticStack使用场景"></a>1.3 ElasticStack使用场景</h4><ul><li>搜索引擎、日志分析、指标分析</li></ul><h4 id="1-4-ElasticStack安装启动"><a href="#1-4-ElasticStack安装启动" class="headerlink" title="1.4 ElasticStack安装启动"></a>1.4 ElasticStack安装启动</h4><ol><li><p><code>ElasticSearch</code>启动：解压到安装目录，启动<code>bin/elasticsearch</code>（默认端口:<code>http://localhost:9200</code>, 加参数<code>-d</code>后台启动）</p></li><li><p><code>ElasticSearch</code>集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch -d </span><br><span class="line">bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3 -d</span><br></pre></td></tr></table></figure></li><li><p>Kibana启动：解压到安装目录，启动<code>bin/kibana</code>（默认端口:<code>http://localhost:5601</code>）</p></li></ol><h4 id="1-5-ElasticSearch常见术语"><a href="#1-5-ElasticSearch常见术语" class="headerlink" title="1.5 ElasticSearch常见术语"></a>1.5 ElasticSearch常见术语</h4><ol><li><code>Document</code>(文档)：用户存储在ES中的数据文档</li><li><code>Index</code>(索引)：由具有相同字段的文档列表组成</li><li><code>field</code>(字段)：包含具体数据</li><li><code>Node</code>(节点)：一个ES的实例，构成clister的单元</li><li><code>Cluster</code>(集群)：对外服务的一个/多个节点</li></ol><h4 id="1-6-Document介绍"><a href="#1-6-Document介绍" class="headerlink" title="1.6 Document介绍"></a>1.6 Document介绍</h4><ol><li>常用数据类型：字符串、数值型、布尔型、日期型、二进制、范围类型</li><li>每个文档都有一个唯一<code>ID</code>标识。（可以自行指定，也可由ES自动生成）</li><li>元数据，用于标注文档的相关信息：<ul><li><code>_index</code>：文档所在的索引名</li><li><code>_type</code>：文档所在的类型名(后续的版本中type这个概念将会被移除，也不允许一个索引中有多个类型)</li><li><code>_id</code>：文档唯一标识</li><li><code>_source</code>：文档的原始JSON数据，可从这获取每个字段的内容</li><li><code>_all</code>：整合所有字段内容到该字段。（默认禁用）</li><li><code>_version</code>：文档字段版本号，标识被操作了几次</li></ul></li><li><code>Index</code>介绍：<ul><li>索引中存储相同结构的文档，且每个index都有自己的Mapping定义，用于定义字段名和类型；</li><li>一个集群中可以有多个inex，类似于可以有多个table。</li></ul></li><li><code>RESTful API</code>两种交互方式：<ol><li>CURL命令行：curl -XPUT xxx</li><li>Kibana DevTools————PUT xxx{ }</li></ol></li><li><code>Index API</code>： 用户创建、删除、获取索引配置等。<ol><li>创建索引：<ul><li><code>PUT /test_index</code> #创建一个名为<code>test_index</code>的索引</li></ul></li><li>查看索引：<ul><li><code>GET _cat/indices</code> #查看所有的索引</li></ul></li><li>删除索引：<ul><li><code>DELETE /test_index</code> #删除名为<code>test_index</code>的索引</li></ul></li></ol></li></ol><h4 id="1-7-CRUD操作（交互基于Kibana-DevTools）"><a href="#1-7-CRUD操作（交互基于Kibana-DevTools）" class="headerlink" title="1.7 CRUD操作（交互基于Kibana DevTools）"></a>1.7 CRUD操作（交互基于Kibana DevTools）</h4><ol><li><p>创建文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建ID为1的Document</span><br><span class="line">PUT /test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"username"</span>:<span class="string">"alfred"</span>,</span><br><span class="line"> <span class="attr">"age"</span>:<span class="string">"24"</span></span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 不指定ID创建Document(ID会自动生成)</span><br><span class="line">POST /test_index/doc</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"username"</span>:<span class="string">"buzhiding"</span>,</span><br><span class="line"> <span class="attr">"age"</span>:<span class="string">"1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 查看名为test_index的索引中id为1的文档</span><br><span class="line">GET /test_index/doc/1</span><br><span class="line">//</span><br><span class="line">// 查询所有文档：</span><br><span class="line">// 查询名为test_index的索引中所有文档,用到endpoint：_search，默认返回符合的前10条</span><br><span class="line">// term和match的区别：term完全匹配，不进行分词器分析；match模糊匹配，进行分词器分析，包含即返回</span><br><span class="line">GET /test_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"term"</span>:&#123;</span><br><span class="line">   <span class="attr">"_id"</span>:<span class="string">"1"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>批量操作文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 批量创建文档，用到endpoint：_bulk</span><br><span class="line">// index和create的区别，如果文档存在时，使用create会报错，而index会覆盖</span><br><span class="line">POST _bulk</span><br><span class="line">&#123;<span class="attr">"index"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"test_index"</span>,<span class="attr">"_type"</span>:<span class="string">"doc"</span>,<span class="attr">"_id"</span>:<span class="string">"3"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"username"</span>:<span class="string">"alfred"</span>,<span class="attr">"age"</span>:<span class="string">"20"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"delete"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"test_index"</span>,<span class="attr">"_type"</span>:<span class="string">"doc"</span>,<span class="attr">"_id"</span>:<span class="string">"1"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"update"</span>:&#123;<span class="attr">"_id"</span>:<span class="string">"2"</span>,<span class="attr">"_index"</span>:<span class="string">"test_index"</span>,<span class="attr">"_type"</span>:<span class="string">"doc"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"doc"</span>:&#123;<span class="attr">"age"</span>:<span class="string">"30"</span>&#125;&#125;</span><br><span class="line">//</span><br><span class="line">// 批量查询文档，使用endpoint:_mget</span><br><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"doc"</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">"_index"</span>:<span class="string">"test_index"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:<span class="string">"doc"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:<span class="string">"1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">"_index"</span>:<span class="string">"test_index"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:<span class="string">"doc"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:<span class="string">"2"</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 根据搜索内容删除文档,使用endpoint:_delete_by_query</span><br><span class="line">POST /test_index/doc/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"buzhiding"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 删除整个test_index的索引中的文档,依然使用endpoint:_delete_by_query</span><br><span class="line">POST /test_index/doc/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match_all"</span>:&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-ElasticSearch倒排索引与分词"><a href="#2-ElasticSearch倒排索引与分词" class="headerlink" title="2. ElasticSearch倒排索引与分词"></a>2. ElasticSearch倒排索引与分词</h3><h4 id="2-1-倒排索引"><a href="#2-1-倒排索引" class="headerlink" title="2.1 倒排索引"></a>2.1 倒排索引</h4><ol><li>正排索引和倒排索引<ul><li>正排索引：文档ID —&gt; 文档内容</li><li>倒排索引：单词—&gt; 文档ID列表</li></ul></li><li>倒排索引组成：（单词词典，倒排列表）<ol><li>单词词典（<code>Term Dictionary</code>）<ul><li>记录所有文档的单词，记录了单词到倒排列表的关联信息，一般使用<code>B+Tree</code>实现。</li></ul></li><li>倒排列表（<code>Posting List</code>）<ul><li>记录单词对应的文档集合，由倒排索引项<code>Posting List</code>组成。</li><li>倒排索引项：<ol><li>文档<code>ID</code>：用于获取原始信息。</li><li>词频<code>TF</code>：记录该单词在该文档中的出现次数，用于计算相关性得分。</li><li>位置<code>Position</code>：记录单词在文档中的分词位置(多个)，用于词语搜索。</li><li>偏移<code>Offset</code>：记录单词在文档的开始和结束位置，用于高亮显示。</li></ol></li></ul></li></ol></li></ol><h4 id="2-2-分词Analysis"><a href="#2-2-分词Analysis" class="headerlink" title="2.2 分词Analysis"></a>2.2 分词Analysis</h4><p>分词：将文本转换成一系列单词<code>Term/Token</code>的过程，也可称作文本分析，ES中叫作：Analysis。</p><ul><li>一些概念：<ol><li><code>Token</code>(词元)：全文搜索引擎会用某种算法对要建索引的文档进行分析， 从文档中提取出若干Token(词元)。</li><li><code>Tokenizer</code>(分词器)：这些算法叫做Tokenizer(分词器)</li><li><code>Token Filter</code>(词元处理器)：这些Token会被进一步处理， 比如转成小写等， 这些处理算法被称为TokenFilter(词元处理器)</li><li><code>Term</code>(词)：被处理后的结果被称为Term(词)</li><li><code>Character Filter</code>(字符过滤器)：文本被Tokenizer处理前可能要做一些预处理， 比如去掉里面的HTML标记， 这些处理的算法被称为Character Filter(字符过滤器)</li><li><code>Analyzer</code>(分析器)：这整个的分析算法被称为Analyzer(分析器)，由Tokenizer(分词器)和Filter(过滤器)组成</li></ol></li><li>ES有很多<strong>内置<code>Analyzer</code></strong>,比如：<ol><li><code>standard</code>：按单词边界划分、支持多语言、小写处理、移除大部分标点符号，支持停用词</li><li><code>whitespace</code>：空格为分隔符</li><li><code>simple</code>：按非字母划分、小写处理</li><li><code>stop</code>：类似简单分词器，同时支持移除停用词(the、an、的、这等)</li><li><code>keyword</code>：不分词</li><li><code>pattern</code>：通过正则表达式自定义分隔符，默认\w+，即：非字词的符号作为分隔符</li></ol></li><li>第三方analyzer插件：常用的<strong>中文分词器</strong>有：<ol><li>IK：实现中英文分词，支持多模式，可自定义词库，支持热更新分词词典。</li><li>jieba。python中流行，支持繁体分词、并行分词，可自定义词典、词性标记等。</li></ol></li><li>ES提供了一个测试分词的API接口，使用<code>endpoint：_analyze</code>，不指定分词时，会使用默认的<code>standard</code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 指定分词器进行分词测试</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"analyzer"</span>:<span class="string">"standard"</span>,</span><br><span class="line"> <span class="attr">"text"</span>:<span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 直接指定索引中字段：使用username字段的分词方式对text进行分词。</span><br><span class="line">POST test_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"field"</span>:<span class="string">"username"</span>,</span><br><span class="line"> <span class="attr">"text"</span>:<span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 自定义分词器，自定义Tokenizer、filter、等进行分词：</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"tokenizer"</span>:<span class="string">"standard"</span>,</span><br><span class="line"> <span class="attr">"filter"</span>:[<span class="string">"lowercase"</span>],</span><br><span class="line"> <span class="attr">"text"</span>:<span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-ElasticSearch的Mapping"><a href="#3-ElasticSearch的Mapping" class="headerlink" title="3. ElasticSearch的Mapping"></a>3. ElasticSearch的Mapping</h3><h4 id="3-1-Mapping简介"><a href="#3-1-Mapping简介" class="headerlink" title="3.1 Mapping简介"></a>3.1 Mapping简介</h4><p>Mapping：类似于数据库中的表结构</p><ol><li>主要作用如下：<ol><li>定义<code>Index</code>下的<code>Field Name</code>；</li><li>定义<code>Field</code>的类型，如：数值型、字符串型、布尔型等；</li><li>定义倒排索引的相关配置，如：是否有索引，记录position等。</li></ol></li><li>获取一个<code>mapping</code>，使用<code>endpoint：_mapping</code>，例如：<ul><li><code>GET /test_index/_mapping</code></li></ul></li></ol><h4 id="3-2-自定义Mapping"><a href="#3-2-自定义Mapping" class="headerlink" title="3.2 自定义Mapping"></a>3.2 自定义Mapping</h4><ol><li>使用<code>mappings</code>进行自定义<code>mapping</code>。</li><li><code>Mapping</code>中的字段类型一旦设定之后，<strong>禁止直接修改</strong>。<ul><li>因为<code>Luence</code>事先的倒排索引生成后不能修改。</li><li>如果一定要改，可以重新建立新的索引，然后对应修改<code>mapping</code>，之后将之前的数据进行<code>reindex</code>操作，导入新的文档。</li></ul></li><li>自定义<code>mapping</code>时允许新增字段。通过<code>dynamic</code>参数进行控制字段的新增，<code>dynamic</code>有三种配置：<ul><li><code>true</code>：默认配置，允许自动新增字段；</li><li><code>false</code>：不允许自动新增字段，文档可以正常写入，但不能进行查询等操作；</li><li><code>strict</code>：严格模式。文档不能写入，写入会报错。</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建名为my_index的索引，并自定义mapping</span><br><span class="line">// 使用dynamic参数控制字段的新增</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> "mappings":&#123;        // 关键字</span><br><span class="line">  "doc":&#123;            // 类型名</span><br><span class="line">   "dynamic":false,  // 设置为false，索引不允许新增字段</span><br><span class="line">   "properties":&#123;    // 字段名称及类型定义</span><br><span class="line">    "title":&#123;</span><br><span class="line">     "type":"text"   // 字段类型</span><br><span class="line">    &#125;,</span><br><span class="line">    "name":&#123;</span><br><span class="line">     "type":"keyword"</span><br><span class="line">    &#125;,</span><br><span class="line">    "age":&#123;</span><br><span class="line">     "type":"integer"</span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-copy-to的使用"><a href="#3-3-copy-to的使用" class="headerlink" title="3.3 copy_to的使用"></a>3.3 copy_to的使用</h4><p>将该字段的值复制到目标字段，类似于6.0版本之前的<code>_all</code>的作用。且不会出现在<code>_source</code>，一般只用来进行搜索。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// copy_to的使用</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"first_name"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="attr">"copy_to"</span>:<span class="string">"full_name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"last_name"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="attr">"copy_to"</span>:<span class="string">"full_name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"full_name"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 向索引写入数据</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"first_name"</span>:<span class="string">"John"</span>,</span><br><span class="line"> <span class="attr">"last_name"</span>:<span class="string">"Smith"</span></span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 查询索引my_index中full_name同时包含John 和 Smith的数据</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"full_name"</span>:&#123;</span><br><span class="line">    <span class="attr">"query"</span>:<span class="string">"John Smith"</span>,</span><br><span class="line">    <span class="attr">"operator"</span>:<span class="string">"and"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-index参数的使用"><a href="#3-4-index参数的使用" class="headerlink" title="3.4 index参数的使用"></a>3.4 index参数的使用</h4><p>控制当前字段是否为索引，默认<code>true</code>，当设置为<code>false</code>的时候，不进行记录，此时该字段不能被搜索</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// index参数的使用</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"cookie"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="attr">"index"</span>:<span class="literal">false</span>    // 设置为<span class="literal">false</span>，该字段不能被搜索</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在进行数据写入和查询，不能进行该字段搜索。一般用来进行不想被查询的私密信息设置，如身份证号，电话号码等：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 向使用了index参数的字段写入信息</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"cookie"</span>:<span class="string">"name=alfred"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-index-options参数的使用："><a href="#3-5-index-options参数的使用：" class="headerlink" title="3.5 index_options参数的使用："></a>3.5 index_options参数的使用：</h4><p>控制倒排索引记录的内容，有如下四种配置：</p><ol><li><code>docs</code>：只记录文档ID</li><li><code>freqs</code>：记录文档ID和词频TF</li><li><code>positions</code>：记录文档ID、词频TF和分词位置</li><li><code>offsets</code>：记录文档ID、词频TF、分词位置和偏移<blockquote><p>其中：text类型默认的配置是positions，其他的比如integer等类型默认为docs，目的是为了节省空间。</p></blockquote></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// index_options参数的使用</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"cookie"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="attr">"index_options"</span>:<span class="string">"offsets"</span>  // 记录文档ID、词频TF、分词位置和偏移</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-null-value参数的使用："><a href="#3-6-null-value参数的使用：" class="headerlink" title="3.6 null_value参数的使用："></a>3.6 null_value参数的使用：</h4><p>当字段遇到空值<code>null</code>时的处理策略。默认为<code>null</code>，即跳过。此时ES会忽略该值，可通过修改进行默认值的修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用null_value修改ES遇到null值时的默认返回值</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"cookie"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">     <span class="attr">"null_value"</span>:<span class="string">"NULL"</span>    // 当遇到空值<span class="literal">null</span>的时候，返回一个字符串形式的NULL</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-Field字段的数据类型："><a href="#3-7-Field字段的数据类型：" class="headerlink" title="3.7 Field字段的数据类型："></a>3.7 Field字段的数据类型：</h4><ol><li>核心数据类型<ol><li>字符串型：<code>text</code>(分词)，<code>keyword</code>(不分词)</li><li>数值型：<code>long,integer,short,byte,double,float,half_float,scaled_float</code></li><li>日期类型：<code>date</code></li><li>布尔类型：<code>boolean</code></li><li>二进制类型：binary</li><li>范围类型：<code>integer_range,float_range,long_range,double_range,date_range</code></li></ol></li><li>复杂数据类型<ol><li>数组类型：<code>array</code></li><li>对象类型：<code>object</code></li><li>嵌套类型：<code>nested object</code></li></ol></li><li>地理位置数据类型<ol><li>点：<code>geo-point</code></li><li>形状：<code>geo-shape</code></li></ol></li><li>专用类型<ol><li>记录ip地址：<code>ip</code></li><li>实现自动补全：<code>completion</code></li><li>记录分词数：<code>token_count</code></li><li>记录字符串hash值：<code>murmur3</code></li><li><code>perclator</code></li><li><code>join</code></li></ol></li><li>多字段特性：<ul><li>ES允许对同一个字段采用不同的配置，如：分词。举例：对一个人名实现拼音搜索，只需要在人名字段中新增一个子字段pinyin即可。</li></ul></li></ol><h4 id="3-8-ES的自动类型识别："><a href="#3-8-ES的自动类型识别：" class="headerlink" title="3.8 ES的自动类型识别："></a>3.8 ES的自动类型识别：</h4><ol><li><p>Dynamic Mapping：</p><ul><li>ES可以自动识别文档字段类型，从而降低用户使用成本。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES的自动类型识别</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> "username":"alfred",    // username字段自动识别为text类型</span><br><span class="line"> "age":20                // age字段自动识别为long类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ES依靠JSON文档的字段类型实现自动识别字段类型：</p></li></ol><table><thead><tr><th>JSON类型</th><th>ElasticSearch类型</th></tr></thead><tbody><tr><td>null</td><td>忽略</td></tr><tr><td>boolean</td><td>boolean</td></tr><tr><td>浮点类型</td><td>float</td></tr><tr><td>整数类型</td><td>long</td></tr><tr><td>object</td><td>object</td></tr><tr><td>array</td><td>由第一个非null的值的类型决定</td></tr><tr><td>String</td><td>匹配为日期，则为date类型(默认开启)<br>匹配为数字，则为long类型/float类型(默认关闭)<br>都未匹配，则设为text类型，并附带keyword子字段</td></tr></tbody></table><ol start="3"><li>验证ES的字段类型自动识别：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 验证ES的字段类型自动识别</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> "username":"alfred",    // 字符串类型text</span><br><span class="line"> "age":20,               // 整数long</span><br><span class="line"> "bitrh":"1998-10-10",   // 默认识别日期date</span><br><span class="line"> "married":false,        // 布尔类型boolean</span><br><span class="line"> "year":"18"             // 默认不识别数字text</span><br><span class="line"> "tags":["boy","fashion"],// 数组中第一个不为null的元素为字符串类型，所以为text</span><br><span class="line"> "money":100.1           // 浮点类型float</span><br><span class="line">&#125;</span><br><span class="line">//  再对my_index进行mapping查询，就会获得每个字段的类型：</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-9-ES中日期类型和数字的自动识别："><a href="#3-9-ES中日期类型和数字的自动识别：" class="headerlink" title="3.9 ES中日期类型和数字的自动识别："></a>3.9 ES中日期类型和数字的自动识别：</h4><p>ES中可自行配置日期的格式，默认：[“<code>strict_date_optional_time</code>“,”<code>yyyy/MM/dd HH:mm:ss Z</code>|| <code>yyyy/MM/dd z</code>“]</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使用dynamic_date_formats自定义日期格式</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"dynamic_date_formats"</span>:[<span class="string">"MM/dd/yyyy"</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 写入符合自定义格式的日期数据，可识别为date类型</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"create_time"</span>:<span class="string">"01/01/2019"</span>    // create_time字段识别为date类型</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">//  2. 使用date_detection可以关闭自动识别日期格式：</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"date_detection"</span>:<span class="literal">false</span> </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"create_time"</span>:<span class="string">"01/01/2019"</span>    // create_time字段是text类型</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// ES中可配置数字是否识别，默认关闭：</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"numeric_detection"</span>:<span class="literal">true</span>    // 开启数字自动识别</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 写入数字数据，ES可以自动识别其类型</span><br><span class="line">PUT mu_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> "year":"18",    // year字段自动识别为long类型</span><br><span class="line"> "money":"100.1"    // money字段自动识别为float类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-ES中根据自动识别的数据类型，动态生成字符类型"><a href="#3-10-ES中根据自动识别的数据类型，动态生成字符类型" class="headerlink" title="3.10 ES中根据自动识别的数据类型，动态生成字符类型"></a>3.10 ES中根据自动识别的数据类型，动态生成字符类型</h4><p>例: </p><ol><li>字符串类型都设为keyword类型（不分词）</li><li>以message开头的字段都设为text类型（分词）</li><li>以long_开头的字段都设为long类型</li><li>自动匹配为double的类型都设为float类型。（为了节省空间）</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES根据自动识别的数据类型、字段名等动态设定字符类型</span><br><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"dynamic_template"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"strings"</span>:&#123;</span><br><span class="line">      // 匹配到所有的字符串类型，全部设为keyword类型</span><br><span class="line">      "match_mapping_type":"string",</span><br><span class="line">      "mapping":&#123;</span><br><span class="line">       "type":"keyword"</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配规则</strong>的参数：</p><ol><li><code>match_mapping_type</code>：匹配ES自动识别的字段类型，如boolean、long、string等</li><li><code>match</code>、<code>unmatch</code>：匹配字段名，比如”match”:”message*” ===&gt;以message开头的数据</li><li><code>path_match</code>、<code>path_unmatch</code>：匹配路径</li></ol><h4 id="3-11-自定义mapping的操作步骤"><a href="#3-11-自定义mapping的操作步骤" class="headerlink" title="3.11 自定义mapping的操作步骤"></a>3.11 自定义mapping的操作步骤</h4><ol><li>写入一条文档到ES的临时索引中，获取(复制)ES自动生成的mapping</li><li>修改获得的mapping，并在其中自定义相关配置</li><li>使用修改后的mapping创建实际所需索引。</li></ol><h3 id="4-ElasticSearch的Search-API"><a href="#4-ElasticSearch的Search-API" class="headerlink" title="4. ElasticSearch的Search API"></a>4. ElasticSearch的Search API</h3><p>在ES中，为了实现对存储的数据进行查询分析，使用<code>endpoint</code>：<strong><code>_search</code></strong>。</p><ol><li>实现对所有索引的泛查询：<code>GET /_search</code></li><li>实现对一个索引的单独查询：<code>GET /my_index/_search</code></li><li>实现对多个索引的指定查询：<code>GET /my_index1,my_index2/_search</code></li><li>实现对符合指定要求的索引进行查询：<code>GET /my_*/_search</code></li></ol><p>在进行查询的时候，主要有两种方式：(<code>URI Search</code>，<code>Request Body Search</code>)</p><ol><li><strong><code>URI Search</code></strong>：操作简单，直接通过命令行方便测试，但仅包含部分查询语法；<ul><li>如：<code>GET /my_index/_search?q=username:alfred</code></li></ul></li><li><strong><code>Request Body Search</code></strong>：ES提供的完备查询语法，使用<code>Query DSL(Domain Specific Language)</code>进行查询<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如：Request Body Search方式进行查询</span><br><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-1-URI-Search"><a href="#4-1-URI-Search" class="headerlink" title="4.1 URI Search"></a>4.1 URI Search</h4><ol><li>通过<code>url query</code>参数实现搜索，常用参数有：<ol><li><strong><code>q</code></strong>：指定查询的语句，使用query string syntax语法</li><li><strong><code>df</code></strong>：q中不指定字段时默认查询的字段（在不指定的时候默认查询所有字段）</li><li><strong><code>sort</code></strong>：排序</li><li><strong><code>timeout</code></strong>：指定超时时间，默认不超时 </li><li><strong><code>from,size</code></strong>：用于分页</li></ol><ul><li>举例：<ul><li><code>GET my_index/_search?q=alfred&amp;df=username&amp;sort=age:asc&amp;from=4&amp;size=10&amp;timeout=1s</code></li><li>解释：查询索引<code>my_index</code>中<code>username</code>字段中包含<code>alfred</code>的文档，结果按<code>age</code>字段<code>升序排列</code>，返回第<code>5-14</code>个文档，若超过<code>1s</code>未结束，则以超时结束。</li></ul></li></ul></li><li><code>query string syntax</code>语法<ul><li>前置内容：<code>term:单词</code>，<code>phrase:词语</code>。</li><li>单词与词语语法：<ul><li>单词：<code>alfred way</code>等价于<code>alfred</code> OR <code>way</code></li><li>词语：<code>&quot;alfred way&quot;</code>语句查询，要求先后顺序</li><li>泛查询：不指定字段，会在所有字段中去匹配其单词</li><li>指定字段查询：指定字段，在指定字段中匹配单词</li></ul></li><li>Group分组设定，使用括号指定匹配的规则<ul><li>举例：<code>GET my_index/_search?q=username:(alfred OR way)AND lee</code></li></ul></li></ul></li></ol><h5 id="4-1-1-URI-Search-API"><a href="#4-1-1-URI-Search-API" class="headerlink" title="4.1.1 URI Search API"></a>4.1.1 URI Search API</h5><ol><li><p>泛查询：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search?q=alfred</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"profile"</span>:<span class="literal">true</span> #使用profile参数，可以明确地看到ES如何执行的查询条件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定字段查询：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// a.查询字段username中包含alfred的文档</span><br><span class="line">GET my_index/_search?q=username:alfred</span><br><span class="line">//</span><br><span class="line">// b.查询字段username中包含alfred或way的文档</span><br><span class="line">GET my_index/_search?q=username:alfred way</span><br><span class="line">//</span><br><span class="line">// c.查询字段username为"alfred way"的文档</span><br><span class="line">GET my_index/_search?q=username:"alfred way"</span><br><span class="line">//</span><br><span class="line">// d.分组后，查询字段username中包含alfred，包含way的文档</span><br><span class="line">GET my_index/_search?q=username:(alfred way)</span><br><span class="line">// 这个和b的结果一样，但是区别在于使用分组之后，不进行泛查询。</span><br></pre></td></tr></table></figure></li><li><p>布尔操作符AND(&amp;&amp;)、OR(||)、NOT(!)、+(must)、-(must_not)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查询索引my_index中username包含alfred但是不包含way的文档</span><br><span class="line">GET my_index/_search?q=username:(alfred NOT way)</span><br><span class="line">//</span><br><span class="line">// 查询索引my_index中一定包含lee，一定不含alfred，可能有way的文档</span><br><span class="line">GET my_index/_search?q=username:(way +lee -alfred)</span><br><span class="line">// 或写成</span><br><span class="line">GET my_index/_search?q=username:((lee &amp;&amp; !alfred) || (way &amp;&amp; lee &amp;&amp; !alfred))</span><br><span class="line">//</span><br><span class="line">// 注意：url中，+(加号)会被解析成空格，所以要用 %2B ：</span><br><span class="line">// 查询索引my_index中一定包含lee，一定不包含alfred，可能包含way的文档</span><br><span class="line">GET my_index/_search?q=username:(way %2Blee -alfred)</span><br></pre></td></tr></table></figure></li><li><p>范围查询（支持数值和日期）</p><ul><li>区间写法：闭区间使用<code>[]</code>，开区间使用<code>{}</code><ol><li><code>age:[1 TO 10]</code>  // 1&lt;= age &lt;=10</li><li><code>age:[1 TO 10}</code>  // 1&lt;= age &lt;10</li><li><code>age:[1 TO ]</code>    // age &gt;=1</li><li><code>age:[* TO 10]</code>  // age &lt;=10</li></ol></li><li>算数符号写法：<ol><li><code>age:&gt;=1</code></li><li><code>age:(&gt;=1 &amp;&amp; &lt;= 10) / age:(+ &gt;= 1 + &lt;= 10)</code></li></ol></li><li>还可以对日期进行范围查询，注意：年/月是从1月1号/1号开始算的：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// a.查询索引my_index中username字段包含alfred_或_年龄大于20的文档</span><br><span class="line">GET my_index/_search?q=username:alfred age&gt;20</span><br><span class="line">//  </span><br><span class="line">// b.查询索引my_index中username字段包含alfred_且_年龄大于20的文档</span><br><span class="line">GET my_index/_search?q=username:alfred AND age&gt;20</span><br><span class="line">// </span><br><span class="line">// 查询索引my_index中birth字段在1985和1990之间的文档</span><br><span class="line">GET my_index/_search?q=birth:(&gt;1985 AND &lt; 1990)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通配符查询</p><ul><li><code>?</code>代表一个字符，<code>*</code>代表0个或多个字符，如：<code>name:a?lfred</code>或<code>name:a*d</code>或<code>name:alfred*</code></li><li>注意：通配符匹配的执行效率较低，且占用内存较多，不建议使用，如果没有特殊要求，也不要将?或者*放在最前面，因为意味着要匹配所有文档，可能会造成OOM。</li></ul></li><li><p>正则表达式/模糊匹配/近似度查询</p><ul><li>正则表达式：举例：<code>/[a]?l.*/</code></li><li>模糊匹配：<code>fuzzy query</code></li><li>近似度查询：<code>proximity search</code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 模糊匹配。匹配与alfred差一个字符的词，比如：alfreds、alfret等</span><br><span class="line">GET my_index/_search?q=username:alfred~1</span><br><span class="line">//</span><br><span class="line">// 近似度查询，查询字段username和"alfred way"差n个单词的文档</span><br><span class="line">GET my_index/_search?q=username:"alfred way" ~5</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>使用场景常见于用户输入词的纠错中。</p></blockquote><h4 id="4-2-Request-Body-Search"><a href="#4-2-Request-Body-Search" class="headerlink" title="4.2 Request Body Search"></a>4.2 Request Body Search</h4><p>ES自带的完备查询语句，将查询语句通过<code>http request body</code>发送到ES，主要参数有：</p><ol><li><code>query</code>：符合<code>Query DSL</code>语法的查询条件</li><li><code>from，size</code></li><li><code>timeout</code></li><li><code>sort</code></li></ol><ul><li><code>Query DSL</code>语法：<ul><li>基于<code>JSON</code>定义的查询语言，主要包含两个类型：<ol><li>字段类查询————如：<code>term</code>，<code>match</code>，<code>range</code>等。只针对一个字段进行查询</li><li>复合查询————如：<code>bool</code>查询等。包含一个/多个字段类查询/符合查询语句</li></ol></li></ul></li></ul><h5 id="4-2-1-字段类查询-全文匹配"><a href="#4-2-1-字段类查询-全文匹配" class="headerlink" title="4.2.1 字段类查询-全文匹配"></a>4.2.1 字段类查询-全文匹配</h5><p>针对<code>text</code>类型的字段进行全文检索，会对查询语句进行“先分词再查询”处理，如：<code>match</code>、<code>match_phrase</code>等</p><h6 id="4-2-1-1-match-query"><a href="#4-2-1-1-match-query" class="headerlink" title="4.2.1.1 match query"></a>4.2.1.1 match query</h6><ol><li>对字段进行全文检索(最基本和最常用的查询类型)，举例：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;  </span><br><span class="line">   "match":&#123;                 // 关键词</span><br><span class="line">    "username":"alfred way"  // 字段名和查询语句</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>从结果，可以返回匹配文件总数，返回文档列表，_score相关性得分等。<br>一般的执行流程为： 1.对查询语句分词==&gt;2.根据字段的倒排索引列表，进行匹配算分==&gt;3.汇总得分==&gt;4.根据得分排序，返回匹配文档</p></blockquote><ol start="2"><li><p>使用<code>operator</code>参数，可以控制单词间关系，有<code>and/or</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用operator参数控制单词间关系</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred way"</span>,</span><br><span class="line">   <span class="attr">"operator"</span>:<span class="string">"and"</span>    // and，同时包含alfred和way</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>minimum_should_match</code>参数控制需匹配的单词数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用minimum_should_match参数控制需匹配的单词数</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred way"</span>,</span><br><span class="line">   <span class="attr">"minimum_should_match"</span>:<span class="string">"2"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-2-1-2-相关性算分，其本质就是一个排序问题"><a href="#4-2-1-2-相关性算分，其本质就是一个排序问题" class="headerlink" title="4.2.1.2 相关性算分，其本质就是一个排序问题"></a>4.2.1.2 相关性算分，其本质就是一个排序问题</h6><ul><li>计算文档与待查询语句之间的相关度，一般有四个重要概念：<ol><li><code>Term Frequency</code> 词频(正相关)</li><li><code>Document Frequency</code> 文档频率(负相关)</li><li><code>Inverse Term Frequency</code> 逆文本频率(正相关)</li><li><code>Field-length Norm</code> 文档长度(负相关)</li></ol></li><li>目前ES有两个相关性算分的模型：<ol><li><code>TF/IDF</code>模型：经典模型。</li><li><code>BM25</code>模型：5.x版本后的默认模型，是对TF/IDF的优化模型。</li></ol></li></ul><ol><li><code>TF/IDF</code>模型：在使用kibana进行查询时，使用explain参数，可以查看具体的计算方法。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用explain参数，可以查看具体的相关性的得分是如何计算的</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> "explain":true,    // 设置为true</span><br><span class="line"> "query":&#123;</span><br><span class="line">  "match":&#123;</span><br><span class="line">   "username":"alfred"</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：ES计算相关性得分是根据<code>shard</code>进行的，即分片的分数计算相互独立，所以在使用的时候要注意分片数，可以通过设定分片数为1来避免这个问题，主要是为了观察，不代表之后所有的分片全都设为1。一般放在创建索引后，未加数据之前。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设定shards数量为1</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"settings"</span>:&#123;</span><br><span class="line">  <span class="attr">"number_of_shards"</span>:<span class="string">"1"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>BM25模型。5.x版本后的默认模型，是对TF/IDF的优化模型。<ul><li><code>best match，25</code>指：迭代了25次才计算。BM25的使用，降低了TF/IDF中因为TF过大导致的负面影响，在BM25中，一个单词的TF一直增长，到一定程度就趋于0变化。</li></ul></li></ol><h6 id="4-2-1-3-match-phrase-query"><a href="#4-2-1-3-match-phrase-query" class="headerlink" title="4.2.1.3 match phrase query"></a>4.2.1.3 match phrase query</h6><p>对字段做全文检索，有顺序要求。</p><ol><li><p>使用<code>match——phrase</code>查询词语</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  "match_phrase":&#123;    // 关键词</span><br><span class="line">   "job":"java engineer"</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过使用<code>slop</code>参数，可以控制单词间间隔：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match_phrase"</span>:&#123;</span><br><span class="line">   <span class="attr">"job"</span>:&#123;</span><br><span class="line">    <span class="attr">"query"</span>:<span class="string">"java engineer"</span>,</span><br><span class="line">    <span class="attr">"slop"</span>:<span class="string">"1"</span>    // 关键词，设定单词间隔</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-2-1-4-query-string-query"><a href="#4-2-1-4-query-string-query" class="headerlink" title="4.2.1.4 query string query"></a>4.2.1.4 query string query</h6><p>类似于<code>URI Search</code>中的q参数查询，举例：</p><ol><li>使用<code>query_string</code>查询<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"query_string"</span>:&#123;</span><br><span class="line">   <span class="attr">"default_field"</span>:<span class="string">"username"</span>,</span><br><span class="line">   "query":&#123;alfred AND way"</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">//* 或 */</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"query_string"</span>:&#123;</span><br><span class="line">   <span class="attr">"fileds"</span>:[<span class="string">"username"</span>,<span class="string">"job"</span>],</span><br><span class="line">   <span class="attr">"query"</span>:<span class="string">"alfred OR (java AND ruby)"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-2-1-5-simple-query-string-query"><a href="#4-2-1-5-simple-query-string-query" class="headerlink" title="4.2.1.5 simple query string query"></a>4.2.1.5 simple query string query</h6><p>类似于<code>query string</code>，但会忽略错误的查询语法，且仅支持部分查询语句。使用<code>+，|，-</code>分别代替<code>AND，OR，NOT</code>。</p><ol><li>使用simple query string query<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"simple_query_string"</span>:&#123;</span><br><span class="line">   <span class="attr">"fields"</span>:[username],</span><br><span class="line">   <span class="attr">"query"</span>:<span class="string">"alfred +way"</span>    #等价于 <span class="string">"query"</span>:<span class="string">"alfred AND way"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="4-2-2-字段类查询-单词匹配"><a href="#4-2-2-字段类查询-单词匹配" class="headerlink" title="4.2.2 字段类查询-单词匹配"></a>4.2.2 字段类查询-单词匹配</h5><h6 id="4-2-2-1-term-terms-query"><a href="#4-2-2-1-term-terms-query" class="headerlink" title="4.2.2.1 term/terms query"></a>4.2.2.1 term/terms query</h6><p>将待查询语句作为整个单词进行查询，不做分词处理，举例：</p><ol><li><p>使用term进行单查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"term"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用terms进行多查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"terms"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:[<span class="string">"alfred"</span>,<span class="string">"way"</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>此时如果直接使用<code>alfred way</code>作为<code>username</code>查询条件，是不会返回任何文档的。因为在<code>username</code>的倒排索引列表中，存在<code>&quot;alfred&quot;</code>和<code>&quot;way&quot;</code>的索引，但是不存在<code>&quot;alfred way&quot;</code>的索引。</p></blockquote><h6 id="4-2-2-2-range-query"><a href="#4-2-2-2-range-query" class="headerlink" title="4.2.2.2 range query"></a>4.2.2.2 range query</h6><ul><li>范围查询，主要针对数值类型和日期类型。<ul><li><strong><code>gt</code></strong>: greater than 大于</li><li><strong><code>gte</code></strong>: greate than or equal to 大于等于</li><li><strong><code>lt</code></strong>: less than 小于</li><li><strong><code>lte</code></strong>: less than or equal to 小于等于</li></ul></li></ul><ol><li><p>对数值的查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// range query对数值的查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"range"</span>:&#123;</span><br><span class="line">   <span class="attr">"age"</span>:&#123;</span><br><span class="line">    <span class="attr">"gte"</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">"lte"</span>:<span class="number">20</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对日期的查询</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// range query对日期的查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"range"</span>:&#123;</span><br><span class="line">   <span class="attr">"birth"</span>:&#123;</span><br><span class="line">    <span class="attr">"lte"</span>:<span class="string">"1988-01-01"</span> </span><br><span class="line">    // 或者使用"lte":"now-30y",这种Date Math类型</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong><code>Date Math</code>类型</strong>：针对日期提供的一种更友好的计算方式。<br>当前时间用<code>now</code>代替，具体时间的引用，需要使用<code>||</code>间隔。年、月、日、时、分、秒跟<code>date</code>一致：<code>y、M、w、d、h、m、s</code>。<br>举例：</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 假设当前时间为2019-01-02 12:00:00</span><br><span class="line">now+1h   =&gt;   2019-01-02 13:00:00</span><br><span class="line">now-1h   =&gt;   2019-01-02 11:00:00</span><br><span class="line">now-1h/d =&gt;   2019-01-02 00:00:00</span><br><span class="line">2019-01-01||+1M/d  =&gt; 2019-02-01 00:00:00</span><br></pre></td></tr></table></figure><h5 id="4-2-3-复合查询"><a href="#4-2-3-复合查询" class="headerlink" title="4.2.3 复合查询"></a>4.2.3 复合查询</h5><p>包含一个/多个字段类查询/符合查询语句</p><h6 id="4-2-3-1-constant-score-query"><a href="#4-2-3-1-constant-score-query" class="headerlink" title="4.2.3.1 constant_score query"></a>4.2.3.1 constant_score query</h6><ol><li><code>constant_score query</code>: 将内部的查询结果文档得分全部设定为1或boost的值。返回的相关性得分全部为1或boost</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用constant_score query</span><br><span class="line">GET my_index/_Search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  "constant_score":&#123;    #关键词</span><br><span class="line">   "match":&#123;</span><br><span class="line">    "username":"alfred"</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-2-bool-query"><a href="#4-2-3-2-bool-query" class="headerlink" title="4.2.3.2 bool query"></a>4.2.3.2 bool query</h6><p><code>bool query</code>: 由一个/多个布尔子句组成，主要包含以下四个：</p><ol><li><code>filter</code>: 只过滤符合条件的文档，不计算相关性得分，返回的相关性得分全部为0；<ul><li><code>ES</code>会对<code>filter</code>进行智能缓存，因此执行效率较高，在做简单匹配查询且不考虑得分的时候没推荐使用<code>filter</code>代替<code>query</code></li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 使用filter查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  "bool":&#123;    // 关键词</span><br><span class="line">   "filter":[</span><br><span class="line">    "term":&#123;</span><br><span class="line">     "username":"alfred"</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>must</code>: 文档必须符合<code>must</code>中的所有条件，影响相关性得分；</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 使用must进行查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"must"</span>:[    </span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"match"</span>:&#123;</span><br><span class="line">      <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"match"</span>:&#123;</span><br><span class="line">      <span class="attr">"job"</span>:<span class="string">"specialist"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>must_not</code>: 文档必须排除must_not中的所有条件； </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用must_not进行查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"must"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"match"</span>:&#123;</span><br><span class="line">     <span class="attr">"job"</span>:<span class="string">"java"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"must_not"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"match"</span>:&#123;</span><br><span class="line">     <span class="attr">"job"</span>:<span class="string">"ruby"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>should</code>: 文档可以符合<code>should</code>中的条件，影响相关性得分，分为两种情况：同时配合<code>minimum_should_match</code>控制满足调价你的个数/百分比。</p><ol><li><code>bool</code>查询中只有<code>should</code>，不包含<code>must</code>的情况</li><li>bool查询中既有should，又包含must的情况，文档不必满足should中的条件，但是如果满足的话则会增加相关性得分。</li></ol></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// bool查询中只有should的情况</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"should"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"term"</span>:&#123;<span class="attr">"job"</span>:<span class="string">"java"</span>&#125;    // 条件<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"term"</span>:&#123;<span class="attr">"job"</span>:<span class="string">"ruby"</span>&#125;    // 条件<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"term"</span>:&#123;<span class="attr">"job"</span>:<span class="string">"specialist"</span>&#125;    // 条件<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"minimum_should_match"</span>:<span class="number">2</span>    // 至少需要满足两个条件</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// bool查询中同时包含should和must</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"should"</span>:[    // 同时包含should</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"job"</span>:<span class="string">"ruby"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"must"</span>:[    // 同时包含must</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"usernmae"</span>:<span class="string">"alfred"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当一个查询语句位于query或filter上下文的时候，ES的执行结果也不同。</p></blockquote><table><thead><tr><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>query</td><td>查找和查询语句最匹配的文档，<br>并对所有文档计算相关性得分</td><td>query<br>bool中的：must/should</td></tr><tr><td>filter</td><td>查找和查询语句最匹配的文档</td><td>bool中的：filter/must_not<br>constant_score中的：filter</td></tr></tbody></table><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// query和filter上下文</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"must"</span>:[    // query上下文</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"title"</span>:<span class="string">"Search"</span>&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"content"</span>:<span class="string">"ElasticSearch"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"filter"</span>:[    // filter上下文</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"status"</span>:<span class="string">"published"</span>&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"range"</span>:&#123;</span><br><span class="line">     <span class="attr">"publish_date"</span>:&#123;</span><br><span class="line">      <span class="attr">"gte"</span>:<span class="string">"2015-01-01"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-3-count-API"><a href="#4-2-3-3-count-API" class="headerlink" title="4.2.3.3 count API"></a>4.2.3.3 count API</h6><p><code>count API</code>: 获取符合条件的文档书，使用<code>endpoint：_count</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用_count获取符合条件的文档数</span><br><span class="line">GET my_index/_count    // 关键词</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-4-Source-Filtering"><a href="#4-2-3-4-Source-Filtering" class="headerlink" title="4.2.3.4 Source Filtering"></a>4.2.3.4 Source Filtering</h6><p><code>Source Filtering</code>: 过滤返回结果中的<code>_source</code>中的字段，主要由以下两种方式：</p><ol><li>GET my_index/_search?_source=username #url参数</li><li>使用Request Body Search：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 不返回_source</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"_source"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">// 返回_source部分字段</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"_source"</span>:[<span class="string">"username"</span>,<span class="string">"age"</span>]</span><br><span class="line">&#125;</span><br><span class="line">// 通配符匹配返回_source部分字段</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"_source"</span>:&#123;</span><br><span class="line">  <span class="attr">"includes"</span>:<span class="string">"*I*"</span>,</span><br><span class="line">  <span class="attr">"encludes"</span>:<span class="string">"birth"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;h4 id=&quot;1-1-ElasticStack特点&quot;&gt;&lt;a href=&quot;#1-1-ElasticStack特点&quot; class=&quot;headerlink&quot; title=&quot;1.1 ElasticStack特点&quot;&gt;&lt;/a&gt;1.1 ElasticStack特点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用门槛低，开发周期短，上线快&lt;/li&gt;
&lt;li&gt;性能好，查询快，实时展示结果&lt;/li&gt;
&lt;li&gt;扩容方便，快速支撑增长迅猛的数据
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】NIO、Netty及websocket实现</title>
    <link href="http://chaooo.github.io/article/20191020.html"/>
    <id>http://chaooo.github.io/article/20191020.html</id>
    <published>2019-10-20T15:34:31.000Z</published>
    <updated>2019-11-16T15:11:33.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-BIO-NIO-AIO演变"><a href="#1-BIO-NIO-AIO演变" class="headerlink" title="1. BIO/NIO/AIO演变"></a>1. BIO/NIO/AIO演变</h3><p>Java IO 方式有很多种，基于不同的IO抽象模型和交互方式，可以进行简单区分。</p><table><thead><tr><th>IO类型</th><th>模型</th><th>客户端:线程数</th><th>API使用难度</th><th>调试难度</th><th>可靠性</th><th>吞吐量</th></tr></thead><tbody><tr><td>BIO</td><td>流，同步阻塞</td><td>1:1</td><td>简单</td><td>简单</td><td>很差</td><td>非常低</td></tr><tr><td>伪异步IO</td><td>同步阻塞</td><td>M:N</td><td>简单</td><td>简单</td><td>较差</td><td>中等</td></tr><tr><td>NIO</td><td>同步非阻塞</td><td>M:1</td><td>复杂</td><td>复杂</td><td>较高</td><td>高</td></tr><tr><td>AIO</td><td>异步非阻塞</td><td>M:0,被动回调</td><td>复杂</td><td>复杂</td><td>高</td><td>高</td></tr></tbody></table><ol><li>区分同步(synchronous)或异步(asynchronous)<ul><li>同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；</li><li>异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li></ul></li><li>区分阻塞(blocking)与非阻塞(non-blocking)<ul><li>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；</li><li>非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理</li></ul></li></ol><ul><li>传统的java.io包，它基于流模型实现，<strong>同步阻塞</strong>的交互方式，如File抽象、输入输出流等。好处是代码简单、直观，缺点是IO效率和扩展性局限性</li><li>很多时候，也把java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库，因为网络通信同样是IO行为。</li><li>伪异步IO：后端通过维护一个消息队列和N个活跃线程, 通过一个<strong>线程池</strong>来处理多个客户端的请求接入，通过线程池，可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入而导致的线程耗尽和宕机。</li><li>JDK4引入了NIO框架(java.nio)，提供了Channel、Selector、Buffer等新的抽象，可以构建<strong>多路复用</strong>的、<strong>同步非阻塞</strong>IO程序，同时提供了更接近操作系统底层的高性能数据操作方式。</li><li>JDK7中，NIO有了进一步的改进，引入了异步非阻塞IO方式，也叫AIO(Asynchronous IO)。异步IO操作基于事件和<strong>回调机制</strong>，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</li></ul><h4 id="1-1-NIO的主要组成部分："><a href="#1-1-NIO的主要组成部分：" class="headerlink" title="1.1 NIO的主要组成部分："></a>1.1 NIO的主要组成部分：</h4><ol><li>Buffer(缓冲区)，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现。<ul><li>Buffer最常见的类型是ByteBuffer，另外还有CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。</li></ul></li><li>Channel(通道)，是NIO中被用来支持批量式IO操作的一种抽象。<ul><li>和流不同，通道是双向的。数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</li></ul></li><li>Selector(多路复用器)，是NIO实现多路复用的基础，它允许单线程处理多个Channel。<ul><li>Selector是基于底层操作系统机制，不同模式、不同版本都存在区别。</li><li>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</li></ul></li></ol><h4 id="1-2-NIO多路复用的过程"><a href="#1-2-NIO多路复用的过程" class="headerlink" title="1.2 NIO多路复用的过程"></a>1.2 NIO多路复用的过程</h4><ol><li>通过Selector.open()创建一个Selector，作为类似调度员的角色。</li><li>创建一个ServerSocketChannel，并绑定监听端口，设置为非阻塞模式</li><li>将Channel向Selector注册，通过指定SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。</li><li>Selector循环阻塞在select操作，当有Channel发生接入请求，就会被唤醒。</li><li>调用selectedKeys方法获取就绪channel集合</li><li>通过SocketChannel和Buffer进行数据操作。</li></ol><h4 id="1-3-AIO"><a href="#1-3-AIO" class="headerlink" title="1.3 AIO"></a>1.3 AIO</h4><ul><li>AIO也叫NIO2.0 是一种非阻塞异步的通信模式。在NIO的基础上引入了新的<strong>异步通道</strong>的概念，并提供了异步文件通道和异步套接字通道的实现。<ul><li>没有采用NIO的多路复用器，而是使用异步通道的概念。</li><li>其read，write方法的返回类型都是Future对象。而Future模型是异步的，其核心思想是：去主函数等待时间。</li><li>AIO模型中通过AsynchronousSocketChannel和AsynchronousServerSocketChannel完成套接字通道的实现。非阻塞，异步。</li></ul></li></ul><h3 id="2-Netty框架"><a href="#2-Netty框架" class="headerlink" title="2. Netty框架"></a>2. Netty框架</h3><p>Netty是一个高性能事件驱动，异步非阻塞的IO开源框架，由Jboss提供，用于建立Tcp等底层的链接，基于Netty可以建立高性能的Http服务器，快速开发高性能、高可靠的网络服务器和客户端程序。支持Http、websocket，tcp，udp等协议。</p><ul><li>Netty使用场景：高性能领域（游戏，大数据分布式计算等）、多线程并发领域（多路复用模型，多线程模型，主从多线程模型）、异步通信领域</li><li>Netty 是一个吸收了多种协议（包括FTP、SMTP、HTTP等各种二进制文本协议）的实现经验，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。</li></ul><h4 id="2-1-Netty的核心概念"><a href="#2-1-Netty的核心概念" class="headerlink" title="2.1 Netty的核心概念"></a>2.1 Netty的核心概念</h4><ol><li>ServerBootstrap，服务器端程序的入口，这是 Netty 为简化网络程序配置和关闭等生命周期管理，所引入的 Bootstrapping 机制。我们通常要做的创建 Channel、绑定端口、注册 Handler 等，都可以通过这个统一的入口，以<strong>Fluent API</strong>等形式完成，相对简化了 API 使用。与之相对应， Bootstrap则是 Client 端的通常入口。</li><li>Channel，作为一个基于 NIO 的扩展框架，Channel 和 Selector 等概念仍然是 Netty 的基础组件，但是针对应用开发具体需求，提供了相对易用的抽象。</li><li>EventLoop，这是 Netty 处理事件的核心机制。例子中使用了 EventLoopGroup。我们在 NIO 中通常要做的几件事情，如注册感兴趣的事件、调度相应的 Handler 等，都是 EventLoop 负责。</li><li>ChannelFuture，这是 Netty 实现异步 IO 的基础之一，保证了同一个 Channel 操作的调用顺序。Netty 扩展了 Java 标准的 Future，提供了针对自己场景的特有Future定义。</li><li>ChannelHandler，这是应用开发者<strong>放置业务逻辑的主要地方</strong>，也是我上面提到的“Separation Of Concerns”原则的体现。</li><li>ChannelPipeline，它是 ChannelHandler 链条的容器，每个 Channel 在创建后，自动被分配一个 ChannelPipeline。在上面的示例中，我们通过 ServerBootstrap 注册了 ChannelInitializer，并且实现了 initChannel 方法，而在该方法中则承担了向 ChannelPipleline 安装其他 Handler 的任务。</li></ol><h4 id="2-2-对比-Java-标准-NIO-类库，Netty是如何实现更高性能的？"><a href="#2-2-对比-Java-标准-NIO-类库，Netty是如何实现更高性能的？" class="headerlink" title="2.2 对比 Java 标准 NIO 类库，Netty是如何实现更高性能的？"></a>2.2 对比 Java 标准 NIO 类库，Netty是如何实现更高性能的？</h4><p>单独从性能角度，Netty 在基础的 NIO 等类库之上进行了很多改进，例如：</p><ol><li>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</li><li>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</li><li>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li><li>在通信协议、序列化等其他角度的优化。</li></ol><p>Netty 的设计强调了 “Separation Of Concerns”，通过精巧设计的事件机制，将业务逻辑和无关技术逻辑进行隔离，并通过各种方便的抽象，一定程度上填补了了基础平台和业务开发之间的鸿沟，更有利于在应用开发中普及业界的最佳实践。另外，Netty &gt; java.nio + java. net！</p><p>除了核心的事件机制等，Netty 还额外提供了很多功能，例如：</p><ol><li>从网络协议的角度，Netty 除了支持传输层的 UDP、TCP、SCTP协议，也支持 HTTP(s)、WebSocket 等多种应用层协议，它并不是单一协议的 API。</li><li>在应用中，需要将数据从 Java 对象转换成为各种应用协议的数据格式，或者进行反向的转换，Netty 为此提供了一系列扩展的编解码框架，与应用开发场景无缝衔接，并且性能良好。</li><li>它扩展了 Java NIO Buffer，提供了自己的 ByteBuf 实现，并且深度支持 Direct Buffer 等技术，甚至 hack 了 Java 内部对 Direct Buffer 的分配和销毁等。同时，Netty 也提供了更加完善的 Scatter/Gather 机制实现。</li></ol><h3 id="3-基于Netty搭建简单的Http服务"><a href="#3-基于Netty搭建简单的Http服务" class="headerlink" title="3. 基于Netty搭建简单的Http服务"></a>3. 基于Netty搭建简单的Http服务</h3><ol><li>环境准备：<code>jdk1.8</code>、<code>Netty4.1.43.Final</code></li><li>代码编写：<code>MyChannelInitializer.java</code>、<code>MyClientHandler.java</code>、<code>NettyServer.java</code></li></ol><blockquote><p>MyChannelInitializer.java：添加了Http的处理协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据解码操作</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line">        <span class="comment">// 数据编码操作</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的接收数据实现方法</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MyServerHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            DefaultHttpRequest request = (DefaultHttpRequest) msg;</span><br><span class="line">            System.out.println(<span class="string">"URI:"</span> + request.getUri());</span><br><span class="line">            System.err.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpContent) &#123;</span><br><span class="line">            LastHttpContent httpContent = (LastHttpContent) msg;</span><br><span class="line">            ByteBuf byteData = httpContent.content();</span><br><span class="line">            <span class="keyword">if</span> (!(byteData <span class="keyword">instanceof</span> EmptyByteBuf)) &#123;</span><br><span class="line">                <span class="comment">//接收msg消息</span></span><br><span class="line">                <span class="keyword">byte</span>[] msgByte = <span class="keyword">new</span> <span class="keyword">byte</span>[byteData.readableBytes()];</span><br><span class="line">                byteData.readBytes(msgByte);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(msgByte, StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String sendMsg = <span class="string">"不平凡的岁月终究来自你每日不停歇的刻苦拼搏，每一次真正成长都因看清脚下路而抉择出的生活。"</span>;</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                HttpVersion.HTTP_1_1,</span><br><span class="line">                HttpResponseStatus.OK,</span><br><span class="line">                Unpooled.wrappedBuffer(sendMsg.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">"text/plain;charset=UTF-8"</span>);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line">        ctx.write(response);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NettyServer().bing(<span class="number">7397</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bing</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置服务端NIO线程组</span></span><br><span class="line">        EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(parentGroup, childGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)<span class="comment">//非阻塞模式</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyChannelInitializer());</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">"http-netty server start done. "</span>);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            childGroup.shutdownGracefully();</span><br><span class="line">            parentGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>启动<code>NettyServer</code>，<code>Postman</code>访问<code>http://localhost:7397</code>并设置参数</p></blockquote><h3 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a>4. WebSocket</h3><p>WebSocket是一种H5协议规范，通过握手机制客户端与服务器之间就能够建立一个类似Tcp的连接，从而方便客户端与服务器之间的通信。</p><ul><li>它是一种解决客户端与服务端实时通信而产生的技术：WebSocket本质是一种基于TCP协议，先通过Http/Https发一个特殊的Http请求进行握手，握手后会创建一个用于交换数据的TCP链接，之后客户端和服务端使用该TCP链接进行实时通信。当WebSocket的客户端和服务端握手后 建立通信后，就不再需要之前的http请求参与。</li></ul><h4 id="4-1-WebSocket的优点："><a href="#4-1-WebSocket的优点：" class="headerlink" title="4.1 WebSocket的优点："></a>4.1 WebSocket的优点：</h4><ul><li>节省通信开销，之前WebServer实现通信，都使用轮询，需要不停的向服务器发送请求，而HttpRequest的handler很长，请求包含真正的数据可能很小，会占用很多额外的带宽和服务器资源。</li><li>建立连接后，服务器可主动传数据给客户端，客户端也可以随意向服务端传数据。交换数据时所携带的头信息很小。浏览器（客户端）和服务器只需要做一个握手的动作。</li><li>实时通信：WebSocket不仅限于Ajax方式通信。ajax方式需要浏览器发起请求。而WebSocket技术 服务端和客户端可以彼此相互推送信息，从而实现实时通信。</li></ul><h4 id="4-2-WebSocket建立连接过程："><a href="#4-2-WebSocket建立连接过程：" class="headerlink" title="4.2 WebSocket建立连接过程："></a>4.2 WebSocket建立连接过程：</h4><p><code>客户端发起握手请求 ---&gt; 服务端响应请求 ---&gt; 建立连接</code></p><ul><li>详细流程：建立一个WebSocket连接，客户端或浏览器首先向服务器发送一个特殊的Http请求(携带一些附加头信息)Upgrade:websocket，服务端解析附加头信息，产生应答消息，然后响应给客户端，之后客户端就与服务端建立响应的链接。</li></ul><h4 id="4-3-WebSocket生命周期："><a href="#4-3-WebSocket生命周期：" class="headerlink" title="4.3 WebSocket生命周期："></a>4.3 WebSocket生命周期：</h4><ol><li>打开事件：端点上建立新链接时，该事件是先于其他任何事件发生之前。该事件发生会产生三部分信息。<ol><li>创建WebSocket Session对象：用于表示已经建立好的链接</li><li>配置对象：包含配置端点的信息。</li><li>一组路径参数，用于打开节点握手时，WebSocket端入栈匹配的URI</li></ol></li><li>消息事件：主要是接收WebSocket对话中，另一端发送的消息。链接上的消息将会有三种形式抵达客户端。<ol><li>文本消息 用String处理</li><li>二进制消息 用byteBuffer或者byte[]处理</li><li>pong消息 用Java WebSocket API中的pong.message接口的实例来处理</li></ol></li><li>错误事件：WebSocket链接或者端点发生错误时产生。可以处理入栈消息时发生的各种异常。入栈消息可能产生的三种异常。<ol><li>WebSocket建立链接时发生错误：SessionException类型</li><li>WebSocket试图将入栈消息解码成开发人员使用的对象时 EncodeException类型</li><li>WebSocket端点的其他方法运行时产生的错误，WebSocket实现将记录端点操作过程中产生的任何异常</li></ol></li><li>关闭事件：WebSocket链接端点关闭，做一些清理工作，可以由参与连接的任意一个端点发出。</li></ol><h4 id="4-4-WebSocket如何关闭链接："><a href="#4-4-WebSocket如何关闭链接：" class="headerlink" title="4.4 WebSocket如何关闭链接："></a>4.4 WebSocket如何关闭链接：</h4><p>流程：当服务器被指示关闭WebSocket链接时，服务端会发起一个TCP Close操作， 客户端应该等待服务器的TCP Close</p><ul><li>关闭WebSocket连接，端点需关闭底层TCP连接。</li><li>底层TCP连接，在大多数正常情况下，应该首先被服务器关闭，服务器持有TIME_WAIT状态（因为这会防止它在2个报文最大生存时间（2MLS）内重新打开连接，然而当一个新的带有更高的seq number的SYN时没有对应的服务器影响TIME_WAIT连接被立即重新打开）。</li><li>在异常情况下（例如在一个合理的时间量后没有接收到服务器的TCP Close）,客户端可以发起<code>TCP Close</code>。</li></ul><h3 id="5-基于Netty搭建WebSocket多人聊天室"><a href="#5-基于Netty搭建WebSocket多人聊天室" class="headerlink" title="5. 基于Netty搭建WebSocket多人聊天室"></a>5. 基于Netty搭建WebSocket多人聊天室</h3><ol><li>使用SpringBoot+Netty+WebSocket搭建功能。</li><li>使用Netty提供的HttpServerCodec、HttpObjectAggregator、ChunkedWriteHandler进行编码解码处理。</li><li>环境准备：<code>jdk1.8</code>、<code>Netty4.1.43.Final</code>、<code>spring-boot-starter-web</code></li></ol><blockquote><p>目录结构</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">└── src.main</span><br><span class="line">       ├── java</span><br><span class="line">       │   └── top.chaooo.hellonetty</span><br><span class="line">       │       ├── domain</span><br><span class="line">       │       │    ├── ClientMsgProtocol.java</span><br><span class="line">       │       │    └── ServerMsgProtocol.java</span><br><span class="line">       │       ├── server</span><br><span class="line">       │       │    ├── MyChannelInitializer.java</span><br><span class="line">       │       │    ├── MyServerHandler.java</span><br><span class="line">       │       │    └── NettyServer.java</span><br><span class="line">       │       ├── util</span><br><span class="line">       │       │    ├── ChannelHandler.java</span><br><span class="line">       │       │    └── MsgUtil.java</span><br><span class="line">       │       ├── controller</span><br><span class="line">       │       │    └── NettyController.java    </span><br><span class="line">       │       └── NettyApplication.java</span><br><span class="line">       └── resources</span><br><span class="line">            ├── static(js,img)</span><br><span class="line">            ├── templates</span><br><span class="line">            │    └── index.html</span><br><span class="line">            └── application.yml</span><br></pre></td></tr></table></figure><blockquote><p>resources/application.yml：基础配置信息，包括了；应用端口、netty服务端端口等</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">netty:</span></span><br><span class="line"><span class="attr">  host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">7397</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  thymeleaf:</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">HTML5</span></span><br><span class="line"><span class="attr">    encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">    content-type:</span> <span class="string">text/html</span></span><br><span class="line"><span class="attr">    cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><blockquote><p>server/MyChannelInitializer.java：websocket处理协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"http-codec"</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"http-chunked"</span>, <span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的接收数据实现方法</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server/MyServerHandler.java：处理websocket消息信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> WebSocketServerHandshaker handshaker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端主动链接服务端的链接后，这个通道就是活跃的了。</span></span><br><span class="line"><span class="comment">     * 也就是客户端与服务端建立了通信通道并且可以传输数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) ctx.channel();</span><br><span class="line">        logger.info(<span class="string">"链接报告开始"</span>);</span><br><span class="line">        logger.info(<span class="string">"链接报告信息：有一客户端链接到本服务端"</span>);</span><br><span class="line">        logger.info(<span class="string">"链接报告IP:&#123;&#125;"</span>, channel.localAddress().getHostString());</span><br><span class="line">        logger.info(<span class="string">"链接报告Port:&#123;&#125;"</span>, channel.localAddress().getPort());</span><br><span class="line">        logger.info(<span class="string">"链接报告完毕"</span>);</span><br><span class="line">        ChannelUtil.channelGroup.add(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端主动断开服务端的链接后，这个通道就是不活跃的。</span></span><br><span class="line"><span class="comment">     * 也就是说客户端与服务端的关闭了通信通道并且不可以传输数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"客户端断开链接&#123;&#125;"</span>, ctx.channel().localAddress().toString());</span><br><span class="line">        ChannelUtil.channelGroup.remove(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//http</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest) &#123;</span><br><span class="line">            FullHttpRequest httpRequest = (FullHttpRequest) msg;</span><br><span class="line">            <span class="keyword">if</span> (!httpRequest.decoderResult().isSuccess()) &#123;</span><br><span class="line">                DefaultFullHttpResponse httpResponse = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST);</span><br><span class="line">                <span class="comment">// 返回应答给客户端</span></span><br><span class="line">                <span class="keyword">if</span> (httpResponse.status().code() != <span class="number">200</span>) &#123;</span><br><span class="line">                    ByteBuf buf = Unpooled.copiedBuffer(httpResponse.status().toString(), CharsetUtil.UTF_8);</span><br><span class="line">                    httpResponse.content().writeBytes(buf);</span><br><span class="line">                    buf.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是非Keep-Alive，关闭连接</span></span><br><span class="line">                ChannelFuture f = ctx.channel().writeAndFlush(httpResponse);</span><br><span class="line">                <span class="keyword">if</span> (httpResponse.status().code() != <span class="number">200</span>) &#123;</span><br><span class="line">                    f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            WebSocketServerHandshakerFactory wsFactory = <span class="keyword">new</span> WebSocketServerHandshakerFactory(<span class="string">"ws:/"</span> + ctx.channel() + <span class="string">"/websocket"</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            handshaker = wsFactory.newHandshaker(httpRequest);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == handshaker) &#123;</span><br><span class="line">                WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handshaker.handshake(ctx.channel(), httpRequest);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ws</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> WebSocketFrame) &#123;</span><br><span class="line">            WebSocketFrame webSocketFrame = (WebSocketFrame) msg;</span><br><span class="line">            <span class="comment">//关闭请求</span></span><br><span class="line">            <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> CloseWebSocketFrame) &#123;</span><br><span class="line">                handshaker.close(ctx.channel(), (CloseWebSocketFrame) webSocketFrame.retain());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ping请求</span></span><br><span class="line">            <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> PingWebSocketFrame) &#123;</span><br><span class="line">                ctx.channel().write(<span class="keyword">new</span> PongWebSocketFrame(webSocketFrame.content().retain()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只支持文本格式，不支持二进制消息</span></span><br><span class="line">            <span class="keyword">if</span> (!(webSocketFrame <span class="keyword">instanceof</span> TextWebSocketFrame)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"仅支持文本格式"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String request = ((TextWebSocketFrame) webSocketFrame).text();</span><br><span class="line">            System.out.println(<span class="string">"服务端收到："</span> + request);</span><br><span class="line">            ClientMsgProtocol clientMsgProtocol = JSON.parseObject(request, ClientMsgProtocol.class);</span><br><span class="line">            <span class="comment">//1请求个人信息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == clientMsgProtocol.getType()) &#123;</span><br><span class="line">                ctx.channel().writeAndFlush(MsgUtil.buildMsgOwner(ctx.channel().id().toString()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//群发消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> == clientMsgProtocol.getType()) &#123;</span><br><span class="line">                TextWebSocketFrame textWebSocketFrame = MsgUtil.buildMsgAll(ctx.channel().id().toString(), clientMsgProtocol.getMsgInfo());</span><br><span class="line">                ChannelUtil.channelGroup.writeAndFlush(textWebSocketFrame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抓住异常，当发生异常的时候，可以做一些相应的处理，比如打印日志、关闭链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        logger.info(<span class="string">"异常信息：\r\n"</span> + cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server/NettyServer.java：主服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"nettyServer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line">    <span class="comment">//配置服务端NIO线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bing</span><span class="params">(InetSocketAddress address)</span> </span>&#123;</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(parentGroup, childGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)    <span class="comment">//非阻塞模式</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyChannelInitializer());</span><br><span class="line">            channelFuture = b.bind(address).syncUninterruptibly();</span><br><span class="line">            channel = channelFuture.channel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != channelFuture &amp;&amp; channelFuture.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">"demo-netty server start done"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"demo-netty server start error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channelFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == channel) <span class="keyword">return</span>;</span><br><span class="line">        channel.close();</span><br><span class="line">        parentGroup.shutdownGracefully();</span><br><span class="line">        childGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>util/MsgUtil.java：消息构建工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title">buildMsgAll</span><span class="params">(String channelId, String msgInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟头像</span></span><br><span class="line">        <span class="keyword">int</span> i = Math.abs(channelId.hashCode()) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        ServerMsgProtocol msg = <span class="keyword">new</span> ServerMsgProtocol();</span><br><span class="line">        msg.setType(<span class="number">2</span>); <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        msg.setChannelId(channelId);</span><br><span class="line">        msg.setUserHeadImg(<span class="string">"head"</span> + i + <span class="string">".jpg"</span>);</span><br><span class="line">        msg.setMsgInfo(msgInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title">buildMsgOwner</span><span class="params">(String channelId)</span> </span>&#123;</span><br><span class="line">        ServerMsgProtocol msg = <span class="keyword">new</span> ServerMsgProtocol();</span><br><span class="line">        msg.setType(<span class="number">1</span>); <span class="comment">//链接信息;1链接信息、2消息信息</span></span><br><span class="line">        msg.setChannelId(channelId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>util/ChannelUtil.java：存储每一个客户端接入进来时的channel对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于存放用户Channel信息，也可以建立map结构模拟不同的消息群</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>domain/*MsgProtocol.java：省略get/set</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMsgProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;             <span class="comment">//链接信息;1:自发信息、2:群发消息</span></span><br><span class="line">    <span class="keyword">private</span> String channelId;     <span class="comment">//通信管道ID，实际使用中会映射成用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userHeadImg;   <span class="comment">//用户头像[模拟分配]</span></span><br><span class="line">    <span class="keyword">private</span> String msgInfo;       <span class="comment">//通信消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMsgProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;       <span class="comment">//1:请求个人信息，2:发送聊天信息</span></span><br><span class="line">    <span class="keyword">private</span> String msgInfo; <span class="comment">//消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>controller/NettyController.java：路由控制层</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>, <span class="string">"Dear"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>js逻辑：依赖jquery.min.js、jquery.serialize-object.min.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript Document</span></span><br><span class="line"><span class="keyword">var</span> socket;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;</span><br><span class="line">        <span class="built_in">window</span>.WebSocket = <span class="built_in">window</span>.MozWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;</span><br><span class="line">        alert(<span class="string">"您的浏览器不支持WebSocket协议！推荐使用谷歌浏览器进行测试。"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:7397/websocket"</span>);</span><br><span class="line">    socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> msg = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">        <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == msg.type)&#123;</span><br><span class="line">            jQuery.data(<span class="built_in">document</span>.body, <span class="string">'channelId'</span>, msg.channelId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> == msg.type)&#123;</span><br><span class="line">            <span class="keyword">var</span> channelId =    msg.channelId;</span><br><span class="line">            <span class="comment">//自己</span></span><br><span class="line">            <span class="keyword">if</span>(channelId == jQuery.data(<span class="built_in">document</span>.body, <span class="string">'channelId'</span>))&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = $(<span class="string">".msgBlockOwnerClone"</span>).clone();</span><br><span class="line">                <span class="built_in">module</span>.removeClass(<span class="string">"msgBlockOwnerClone"</span>).addClass(<span class="string">"msgBlockOwner"</span>).css(&#123;<span class="attr">display</span>: <span class="string">"block"</span>&#125;);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".headPoint"</span>).attr(<span class="string">"src"</span>, <span class="string">"res/img/"</span>+msg.userHeadImg);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_msgInfo .msgPoint"</span>).text(msg.msgInfo);</span><br><span class="line">                $(<span class="string">"#msgPoint"</span>).before(<span class="built_in">module</span>);</span><br><span class="line">                util.divScroll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//好友</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = $(<span class="string">".msgBlockFriendClone"</span>).clone();</span><br><span class="line">                <span class="built_in">module</span>.removeClass(<span class="string">"msgBlockFriendClone"</span>).addClass(<span class="string">"msgBlockFriend"</span>).css(&#123;<span class="attr">display</span>: <span class="string">"block"</span>&#125;);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".headPoint"</span>).attr(<span class="string">"src"</span>, <span class="string">"res/img/"</span>+msg.userHeadImg);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_channelId"</span>).text(<span class="string">"ID："</span>+msg.channelId);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_msgInfo .msgPoint"</span>).text(msg.msgInfo);</span><br><span class="line">                $(<span class="string">"#msgPoint"</span>).before(<span class="built_in">module</span>);</span><br><span class="line">                util.divScroll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">"打开WebSoket 服务正常，浏览器支持WebSoket!"</span>);</span><br><span class="line">        <span class="keyword">var</span> clientMsgProtocol = &#123;&#125;;</span><br><span class="line">        clientMsgProtocol.type = <span class="number">1</span>;</span><br><span class="line">        clientMsgProtocol.msgInfo = <span class="string">"请求个人信息"</span>;</span><br><span class="line">        socket.send(<span class="built_in">JSON</span>.stringify(clientMsgProtocol));</span><br><span class="line">     &#125;;</span><br><span class="line">    socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">"WebSocket 关闭"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">13</span> == e.keyCode &amp;&amp; e.ctrlKey)&#123;</span><br><span class="line">            util.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">util = &#123;</span><br><span class="line">    send: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">            <span class="keyword">var</span> clientMsgProtocol = &#123;&#125;;</span><br><span class="line">            clientMsgProtocol.type = <span class="number">2</span>;</span><br><span class="line">            clientMsgProtocol.msgInfo = $(<span class="string">"#sendBox"</span>).val();</span><br><span class="line">            socket.send(<span class="built_in">JSON</span>.stringify(clientMsgProtocol));</span><br><span class="line">            $(<span class="string">"#sendBox"</span>).val(<span class="string">""</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">"WebSocket 连接没有建立成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    divScroll: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>); </span><br><span class="line">        div.scrollTop = div.scrollHeight; </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>主要Html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span> <span class="attr">xmlns:sec</span>=<span class="string">"http://www.thymeleaf.org/extras/spring-security"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/jquery.serialize-object.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chatDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chat"</span> <span class="attr">style</span>=<span class="string">"width:529px; height:667px; background-color:#F5F5F5; float:right;"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 会话区域 begin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"show"</span> <span class="attr">style</span>=<span class="string">"width:529px; height:450px; float:left;overflow-y:scroll;"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息块；好友 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlockFriendClone"</span> <span class="attr">style</span>=<span class="string">" display:none; margin-left:30px; margin-top:15px; width:340px; height:auto; margin-bottom:15px; float:left;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_userHeadImg"</span> <span class="attr">style</span>=<span class="string">"float:left; width:35px; height:35px;border-radius:3px;-moz-border-radius:3px; background-color:#FFFFFF;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"headPoint"</span> <span class="attr">src</span>=<span class="string">"/img/head5.jpg"</span> <span class="attr">width</span>=<span class="string">"35px"</span> <span class="attr">height</span>=<span class="string">"35px"</span> <span class="attr">style</span>=<span class="string">"border-radius:3px;-moz-border-radius:3px;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_channelId"</span> <span class="attr">style</span>=<span class="string">"float:left; width:100px; margin-top:-5px; margin-left:10px; padding-bottom:2px; font-size:10px;"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 名称 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_msgInfo"</span> <span class="attr">style</span>=<span class="string">"height:auto;width:280px;float:left;margin-left:12px; margin-top:4px;border-radius:3px;-moz-border-radius:3px; "</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:4px; height:20px; background-color:#CC0000; float:left;border-radius:3px;-moz-border-radius:3px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgPoint"</span> <span class="attr">style</span>=<span class="string">"float:left;width:260px; padding:7px; background-color:#FFFFFF; border-radius:3px;-moz-border-radius:3px; height:auto; font-size:12px;display:block;word-break: break-all;word-wrap: break-word;"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息块；自己 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlockOwnerClone"</span> <span class="attr">style</span>=<span class="string">" display:none; margin-right:30px; margin-top:15px; width:340px; height:auto; margin-bottom:15px; float:right;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:right; width:35px; height:35px;border-radius:3px;-moz-border-radius:3px; background-color:#FFFFFF;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"headPoint"</span> <span class="attr">src</span>=<span class="string">"/img/head3.jpg"</span> <span class="attr">width</span>=<span class="string">"35px"</span> <span class="attr">height</span>=<span class="string">"35px"</span> <span class="attr">style</span>=<span class="string">"border-radius:3px;-moz-border-radius:3px;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_msgInfo"</span> <span class="attr">style</span>=<span class="string">"height:auto;width:280px;float:left;margin-left:12px; margin-top:4px;border-radius:3px;-moz-border-radius:3px; "</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgPoint"</span> <span class="attr">style</span>=<span class="string">"float:left;width:260px; padding:7px; background-color:#FFFFFF; border-radius:3px;-moz-border-radius:3px; height:auto; font-size:12px;display:block;word-break: break-all;word-wrap: break-word;"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:4px; height:20px; background-color:#CC0000; float:right;border-radius:3px;-moz-border-radius:3px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"msgPoint"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 会话区域 end --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:100%; height:2px; float:left; background-color:#CCCCCC;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin:0 auto; width:100%; height:149px; margin-top:5px;  background-color:#FFFFFF; float:left;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"sendBox"</span> <span class="attr">style</span>=<span class="string">"font-size:14px; border:0; width:499px; height:80px; outline:none; padding:15px;font-family:”微软雅黑”;resize: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:20px; float:right; margin-right:35px; padding:5px; padding-left:15px; padding-right:15px; font-size:12px; background-color:#F5F5F5;border-radius:3px;-moz-border-radius:3px; cursor:pointer;"</span> <span class="attr">onclick</span>=<span class="string">"javascript:util.send();"</span>&gt;</span>发送(S)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动SpringBoot，Netty会随着启动；</li><li>用不同浏览器访问 <code>http://localhost:8080/index</code> 测试多人实时聊天。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-BIO-NIO-AIO演变&quot;&gt;&lt;a href=&quot;#1-BIO-NIO-AIO演变&quot; class=&quot;headerlink&quot; title=&quot;1. BIO/NIO/AIO演变&quot;&gt;&lt;/a&gt;1. BIO/NIO/AIO演变&lt;/h3&gt;&lt;p&gt;Java IO 方式有很多种，基
      
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】阻塞队列 与 线程池</title>
    <link href="http://chaooo.github.io/article/20191014.html"/>
    <id>http://chaooo.github.io/article/20191014.html</id>
    <published>2019-10-14T15:04:54.000Z</published>
    <updated>2019-11-20T14:53:44.150Z</updated>
    
    <content type="html"><![CDATA[<ul><li>池和队列的关系<ul><li>线程池或者数据库连接池，都有最大限制。如果超出了限制数量，则新进来的申请连接都要放入额外的<strong>队列里</strong>，等到池空出来时，从队列中取出连接放进池里。<a id="more"></a></li></ul></li></ul><h3 id="1-BlockingQueue（阻塞队列）"><a href="#1-BlockingQueue（阻塞队列）" class="headerlink" title="1. BlockingQueue（阻塞队列）"></a>1. BlockingQueue（阻塞队列）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue接口</span><br><span class="line">    |———— BlockingQueue接口</span><br><span class="line">        |———— ArrayBlockingQueue类</span><br><span class="line">        |———— DelayQueue类</span><br><span class="line">        |———— LinkedBlockingQueue类</span><br><span class="line">        |———— PriorityBlockingQueue类</span><br><span class="line">        |———— SynchronousQueue类</span><br></pre></td></tr></table></figure><ul><li><code>BlockingQueue</code>继承了<code>Queue</code>接口，提供了一些阻塞方法，主要作用如下：<ul><li>当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）；</li><li>当线程从队列中取元素（删除队列元素）时，如果队列为空，则阻塞线程，直到队列有元素；</li></ul></li><li><code>BlockingQueue</code>在<code>Queue</code>方法基础上增加了两类和阻塞相关的方法：<code>put(e)</code>、<code>take()</code>；<code>offer(e, time, unit)</code>、<code>poll(time, unit)</code>。</li></ul><table><thead><tr><th>操作类型</th><th>抛出异常</th><th>返回特殊值</th><th>阻塞线程</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>读取</td><td>element()</td><td>peek()</td><td>/</td><td>/</td></tr></tbody></table><ul><li><strong><code>put(e)</code></strong>和<strong><code>take()</code></strong>方法会一直阻塞调用线程，直到线程被中断或队列状态可用；</li><li><strong><code>offer(e, time, unit)</code></strong>和<strong><code>poll(time, unit)</code></strong>方法会限时阻塞调用线程，直到超时或线程被中断或队列状态可用。</li><li>阻塞队列主要用在生产者/消费者的场景</li></ul><h4 id="1-1-ArrayBlockingQueue"><a href="#1-1-ArrayBlockingQueue" class="headerlink" title="1.1 ArrayBlockingQueue"></a>1.1 ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code>是一个有边界的阻塞队列，它的内部实现是一个数组。</p><ul><li>有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</li><li><code>ArrayBlockingQueue</code>是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</li></ul><h4 id="1-2-DelayQueue"><a href="#1-2-DelayQueue" class="headerlink" title="1.2 DelayQueue"></a>1.2 DelayQueue</h4><p><code>DelayQueue</code>阻塞的是其内部元素，<code>DelayQueue</code>中的元素必须实现<code>java.util.concurrent.Delayed</code>接口，<code>Delayed</code>接口继承了<code>Comparable</code>接口，这是因为<code>DelayedQueue</code>中的元素需要进行排序，一般情况，我们都是按元素过期时间的优先级进行排序。</p><ul><li><code>DelayQueue</code>应用场景：定时关闭连接、缓存对象，超时处理等</li></ul><h4 id="1-3-LinkedBlockingQueue"><a href="#1-3-LinkedBlockingQueue" class="headerlink" title="1.3 LinkedBlockingQueue"></a>1.3 LinkedBlockingQueue</h4><p><code>LinkedBlockingQueue</code>阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。</p><ul><li>说是无边界，其实是采用了默认大小为<code>Integer.MAX_VALUE</code>的容量 。它的内部实现是一个链表。</li><li>和<code>ArrayBlockingQueue</code>一样，<code>LinkedBlockingQueue</code> 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</li></ul><h4 id="1-4-PriorityBlockingQueue"><a href="#1-4-PriorityBlockingQueue" class="headerlink" title="1.4 PriorityBlockingQueue"></a>1.4 PriorityBlockingQueue</h4><p><code>PriorityBlockingQueue</code>是一个没有边界的队列，它的排序规则和<code>java.util.PriorityQueue</code>一样。需要注意，<code>PriorityBlockingQueue</code>中允许插入null对象。</p><ul><li>所有插入<code>PriorityBlockingQueue</code>的对象必须实现<code>java.lang.Comparable</code>接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。</li><li>从<code>PriorityBlockingQueue</code>获得一个迭代器<code>Iterator</code>，但这个迭代器并不保证按照优先级顺序进行迭代。</li></ul><h4 id="1-5-SynchronousQueue"><a href="#1-5-SynchronousQueue" class="headerlink" title="1.5 SynchronousQueue"></a>1.5 SynchronousQueue</h4><p><code>SynchronousQueue</code>队列内部仅允许容纳一个元素。</p><ul><li>当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</li></ul><h3 id="2-Callable-amp-Future"><a href="#2-Callable-amp-Future" class="headerlink" title="2. Callable &amp; Future"></a>2. Callable &amp; Future</h3><p><code>Callable</code>与<code>Runnable</code>的功能大致相似，<code>Callable</code>功能强大一些，就是被线程执行后，可以返回值，并且能抛出异常。</p><ul><li><code>Runnable</code>接口只有一个<code>run()</code>方法，实现类重写<code>run</code>方法，把一些费时操作写在其中，然后使用某个线程去执行该<code>Runnable</code>实现类即可实现多线程。</li><li><code>Callable</code>是一个泛型接口只有一个<code>call()</code>方法，返回的类型就是创建<code>Callable</code>传进来的V类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Callable</code>一般是和<code>ExecutorService</code>配合来使用的，在<code>ExecutorService</code>接口中声明了若干个<code>submit</code>方法的重载版本</p></blockquote><h4 id="2-1-Future-amp-FutureTask"><a href="#2-1-Future-amp-FutureTask" class="headerlink" title="2.1 Future &amp; FutureTask"></a>2.1 Future &amp; FutureTask</h4><p><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的<strong>执行结果</strong>进行取消、查询是否完成、获取结果。必要时可以通过<code>get</code>方法获取执行结果，该方法会阻塞直到任务返回结果。</p><ul><li>也就是说<code>Future</code>提供了三种功能：<ol><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ol></li><li>在<code>Future</code>接口中声明了5个方法：<strong><code>cancel</code></strong>、<strong><code>isCancelled</code></strong>、<strong><code>isDone</code></strong>、<strong><code>get</code></strong><ul><li><code>boolean</code> <strong><code>cancel(boolean mayInterruptIfRunning)</code></strong>;//用来取消任务，参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务。<ul><li>如果取消已经完成的任务会返回<code>false</code>；如果任务还没有执行会返回<code>true</code>；</li><li>如果任务正在执行，则返回<code>mayInterruptIfRunning</code>设置的值(<code>true/false</code>)；</li></ul></li><li><code>boolean</code> <strong><code>isCancelled()</code></strong>;//任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li><code>boolean</code> <strong><code>isDone()</code></strong>;//任务是否已经完成，若任务完成，则返回true；</li><li><code>V</code> <strong><code>get()</code></strong>;//获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li><code>V</code> <strong><code>get(long timeout, TimeUnit unit)</code></strong>;//获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul></li></ul><blockquote><p><code>Future</code>可以得到别的线程任务方法的返回值。<code>Future</code>是一个接口,引用对象指向的实际是<strong>FutureTask</strong>。</p></blockquote><h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3. FutureTask"></a>3. FutureTask</h3><p><strong><code>FutureTask</code></strong>的父类是<code>RunnableFuture</code>，而<code>RunnableFuture</code>继承了<code>Runnbale</code>和<code>Futrue</code>这两个接口</p><ul><li>从<code>FutureTask</code>构造方法可以了解到：<ol><li><code>FutureTask</code>最终都是执行<code>Callable</code>类型的任务。</li><li>如果构造函数参数是<code>Runnable</code>，会被<code>Executors.callable</code>方法转换为<code>Callable</code>类型。</li><li><code>Executors.callable</code>方法直接返回一个<code>RunnableAdapter</code>实例。</li><li><code>RunnableAdapter</code>是<code>FutureTask</code>的一个静态内部类并且实现了<code>Callable</code>，也就是说<code>RunnableAdapter</code>是<code>Callable</code>子类。</li><li><code>RunnableAdapter</code>的<code>call</code>方法实现代码是，执行<code>Runnable</code>的<code>run</code>方法，并返回构造<code>FutureTask</code>传入<code>result</code>参数。</li></ol></li><li><code>FutureTask</code>总结：<ul><li><code>FutureTask</code>实现了两个接口，<code>Runnable</code>和<code>Future</code>，所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值，这个组合的好处：假设有一个很费时逻辑需要计算并且返回这个值，同时这个值不是马上需要，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过<code>Future</code>得到！</li></ul></li></ul><blockquote><p>注意：</p><ul><li>通过<code>Executor</code>执行线程任务都是以<code>Callable</code>形式，如果传入<code>Runnable</code>都会转化为<code>Callable</code>。</li><li>通过<code>new Thread(runnable)</code>，只能是<code>Runnable</code>子类形式。</li></ul></blockquote><h3 id="4-Fork-Join"><a href="#4-Fork-Join" class="headerlink" title="4. Fork/Join"></a>4. Fork/Join</h3><p>从<code>JDK1.7</code>开始，Java提供<code>Fork/Join</code>框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。</p><ul><li>主要有两步：任务切分 -&gt; 结果合并<ol><li>第一步<strong><code>分割任务</code></strong>。首先我们需要有一个 <code>fork</code> 类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</li><li>第二步执行任务并<strong><code>合并结果</code></strong>。分割的子任务分别放在<strong>双端队列</strong>里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li></ol></li><li>工作窃取算法（<code>work-stealing</code>）是指某个线程从其他队列里窃取任务来执行。</li><li><code>Fork/Join</code> 使用两个类来完成以上两个步骤：<ol><li><strong><code>ForkJoinTask</code></strong>：我们要使用 <code>ForkJoin</code> 框架，必须首先创建一个 <code>ForkJoin</code> 任务。它提供在任务中执行 <code>fork()</code> 和 <code>join()</code> 操作的机制，通常情况下我们不需要直接继承 <code>ForkJoinTask</code> 类，而只需要继承它的子类，<code>Fork/Join</code> 框架提供了以下两个子类：<ul><li><code>RecursiveAction</code>：用于没有返回结果的任务。</li><li><code>RecursiveTask</code>：用于有返回结果的任务。</li></ul></li><li><strong><code>ForkJoinPool</code></strong>：<code>ForkJoinTask</code> 需要通过 <code>ForkJoinPool</code> 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li></ol></li></ul><h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5. 线程池"></a>5. 线程池</h3><p>线程池可以看作是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。</p><ul><li>一个线程池包括以下四个基本组成部分：<ol><li>线程池管理器（<code>ThreadPool</code>）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li><li>工作线程（<code>PoolWorker</code>）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li><li>任务接口（<code>Task</code>）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li><li>任务队列（<code>taskQueue</code>）：用于存放没有处理的任务。提供一种缓冲机制。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Executor接口</span><br><span class="line">    |———— ExecutorService接口</span><br><span class="line">        |———— AbstractExecutorService抽象类</span><br><span class="line">            |———— ForkJoinPool类</span><br><span class="line">            |———— ThreadPoolExecutor类</span><br><span class="line">        |———— ScheduledExecutorService接口</span><br><span class="line">            |———— ScheduledThreadPoolExecutor类</span><br><span class="line">Executors类</span><br></pre></td></tr></table></figure><h4 id="5-1-通过Executors工厂类中的六个静态方法创建线程池"><a href="#5-1-通过Executors工厂类中的六个静态方法创建线程池" class="headerlink" title="5.1 通过Executors工厂类中的六个静态方法创建线程池"></a>5.1 通过Executors工厂类中的六个静态方法创建线程池</h4><p>六大静态方法创建的<code>ThreadPoolExecutor</code>对象，返回的父接口的引用，即返回的<code>ExecutorService</code>的引用。六大静态方法内部都是直接或间接调用<code>ThreadPoolExecutor</code>类的构造方法创建线程池对象。</p><ol><li><code>newCachedThreadPool(ThreadPoolExecutor)</code>：创建一个可缓存的线程池<ul><li>如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）,<code>maximumPoolSize</code>最大可以至(<code>Integer.MAX_VALUE</code>),若达到该上限,直接OOM。</li></ul></li><li><code>newFixedThreadPool(ThreadPoolExecutor)</code>：创建固定大小的线程池。<ul><li>每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li></ul></li><li><code>newSingleThreadExecutor(ThreadPoolExecutor)</code>：创建一个单线程的线程池。<ul><li>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务,保证按任务的提交顺序依次执行。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li></ul></li><li><code>newScheduledThreadPool(ScheduledThreadPoolExecutor)</code>：创建一个支持定时及周期性任务执行的线程池。<ul><li>线程数最大至<code>Integer.MAX_ VALUE</code>,存在OOM风险,不回收工作线程.</li></ul></li><li><code>newSingleThreadScheduledExecutor(ScheduledThreadPoolExecutor)</code>：创建一个单线程用于定时以及周期性执行任务的需求。</li><li><code>newWorkStealingPool(ForkJoinPool)</code>：创建一个工作窃取<ul><li>JDK8 引入,创建持有足够线程的线程池支持给定的并行度;并通过使用多个队列减少竞争;</li></ul></li></ol><blockquote><p>Executors返回的线程池对象的弊端：</p><ol><li><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>：<ul><li>允许的<strong>请求队列长度</strong>为<code>Integer.MAX_VALUE</code>，可能会<strong>堆积大量的请求</strong>，从而导致OOM。</li></ul></li><li><code>CachedThreadPool</code>：<ul><li>允许的<strong>创建线程数量</strong>为<code>Integer.MAX_VALUE</code>，可能会<strong>创建大量的线程</strong>，从而导致OOM。</li></ul></li></ol></blockquote><h4 id="5-2-通过ThreadPoolExecutor构造方法创建线程池"><a href="#5-2-通过ThreadPoolExecutor构造方法创建线程池" class="headerlink" title="5.2 通过ThreadPoolExecutor构造方法创建线程池"></a>5.2 通过<code>ThreadPoolExecutor</code>构造方法创建线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,   //核心线程数，包括空闲线程</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, //线程空闲时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,      //时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//缓存队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,      //线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler  //拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? </span><br><span class="line">        <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-1-corePoolSize-核心线程数量"><a href="#5-2-1-corePoolSize-核心线程数量" class="headerlink" title="5.2.1 corePoolSize(核心线程数量)"></a>5.2.1 corePoolSize(核心线程数量)</h5><ul><li><code>corePoolSize</code>的设置非常关键：<ul><li><code>=0</code>：则任务执行完之后,没有任何请求进入时销毁线程池的线程</li><li><code>&gt;0</code>：即使本地任务执行完毕,核心线程也不会被销毁</li><li>设置过大会浪费资源; 设置过小会导致线程频繁地创建或销毁</li></ul></li><li>若设置了<code>allowCoreThreadTimeOut</code>这个参数,当提交一个任务到线程池时,若<code>线程数量(包括空闲线程)小于corePoolSize</code>,线程池会创建一个新线程放入<code>works(一个HashSet)</code>中执行任务,等到需要执行的任务数大于线程池基本大小时就不再创建,会尝试放入等待队列<code>workQueue</code>；如果调用线程池的<code>prestartAllCoreThreads()</code>,线程池会提前创建并启动所有核心线程</li></ul><h5 id="5-2-2-maximumPoolSize（线程池最大线程数）"><a href="#5-2-2-maximumPoolSize（线程池最大线程数）" class="headerlink" title="5.2.2 maximumPoolSize（线程池最大线程数）"></a>5.2.2 maximumPoolSize（线程池最大线程数）</h5><ul><li><code>maximumPoolSize</code>表示线程池能够容纳同时执行的最大线程数,必须&gt;=1.</li><li>若队列满,并且已创建的线程数小于最大线程数,则线程池会再创建新的线程放入<code>works</code>中执行任务,<code>CashedThreadPool</code>的关键,固定线程数的线程池无效</li><li>如果<code>maximumPoolSize = corePoolSize</code>,即是固定大小线程池.</li><li>若使用了无界任务队列,这个参数就没什么效果</li></ul><h5 id="5-2-3-keepAliveTime（线程池中的线程空闲时间）"><a href="#5-2-3-keepAliveTime（线程池中的线程空闲时间）" class="headerlink" title="5.2.3 keepAliveTime（线程池中的线程空闲时间）"></a>5.2.3 keepAliveTime（线程池中的线程空闲时间）</h5><ul><li>线程没有任务执行时最多保持多久时间终止（线程池的工作线程空闲后，保持存活的时间)</li><li>如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率</li><li>当空闲时间达到<code>keepAliveTime</code>时,线程会被销毁,直到只剩下<code>corePoolSize</code>个线程;避免浪费内存和句柄资源.</li><li>在默认情况下,当线程池的线程数大于<code>corePoolSize</code>时,<code>keepAliveTime</code>才起作用.</li><li>但是当<code>ThreadPoolExecutor</code>的<code>allowCoreThreadTimeOut=true</code>时,核心线程超时后也会被回收.</li></ul><h5 id="5-2-4-TimeUnit（时间单位）"><a href="#5-2-4-TimeUnit（时间单位）" class="headerlink" title="5.2.4 TimeUnit（时间单位）"></a>5.2.4 TimeUnit（时间单位）</h5><ul><li>keepAliveTime的时间单位通常是<code>TimeUnit.SECONDS</code></li><li>可选的单位：天(<code>DAYS</code>)、小时(<code>HOURS</code>)、分钟(<code>MINUTES</code>)、毫秒(<code>MILLISECONDS</code>)、微秒(<code>MICROSECONDS</code>，千分之一毫秒) 和 纳秒(<code>NANOSECONDS</code>，千分之一微秒)</li></ul><h5 id="5-2-5-workQueue（缓存队列）"><a href="#5-2-5-workQueue（缓存队列）" class="headerlink" title="5.2.5 workQueue（缓存队列）"></a>5.2.5 workQueue（缓存队列）</h5><ul><li>存储待执行任务的阻塞队列，这些任务必须是<code>Runnable</code>的对象（如果是<code>Callable</code>对象，会在<code>submit</code>内部转换为<code>Runnable</code>对象） </li><li>当请求的线程数大于<code>maximumPoolSize</code>时,线程进入<code>BlockingQueue</code>.</li><li>可以选择以下几个阻塞队列:<ul><li><code>LinkedBlockingQueue</code>:一个基于链表结构的阻塞队列,此队列按<code>FIFO</code>排序元素,吞吐量通常要高于<code>ArrayBlockingQueue</code>.静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列</li><li><code>SynchronousQueue</code>:一个不存储元素的阻塞队列.每个插入操作必须等到另一个线程调用移除操作,否则插入操作一直处于阻塞状态,吞吐量通常要高于<code>LinkedBlockingQueue</code>,静态工厂方法<code>Executors.newCachedThreadPoo</code>l使用了这个队列</li></ul></li></ul><h5 id="5-2-6-threadFactory-（线程工厂）"><a href="#5-2-6-threadFactory-（线程工厂）" class="headerlink" title="5.2.6 threadFactory （线程工厂）"></a>5.2.6 threadFactory （线程工厂）</h5><ul><li>用于设置创建线程的工厂;</li><li>线程池的命名是通过增加组名前缀来实现的，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li><li>在虚拟机栈分析时,就可以知道线程任务是由哪个线程工厂产生的.</li></ul><h5 id="5-2-7-RejectedExecutionHandler（拒绝策略）"><a href="#5-2-7-RejectedExecutionHandler（拒绝策略）" class="headerlink" title="5.2.7 RejectedExecutionHandler（拒绝策略）"></a>5.2.7 RejectedExecutionHandler（拒绝策略）</h5><ul><li>当队列和线程池都满,说明线程池饱和,必须采取一种策略处理提交的新任务；策略默认<strong><code>AbortPolicy</code></strong>,表无法处理新任务时抛出异常</li><li>当超过参数<code>workQueue</code>的任务缓存区上限的时候,就可以通过该策略处理请求,这是一种简单的限流保护.</li><li>友好的拒绝策略可以是如下三种:<ol><li>保存到数据库进行削峰填谷;在空闲时再提取出来执行</li><li>转向某个提示页面</li><li>打印日志</li></ol></li><li><code>AbortPolicy</code>：丢弃任务，抛出<code>RejectedExecutionException</code></li><li><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务,有反馈机制，使任务提交的速度变慢）。</li><li><code>DiscardOldestPolicy</code>：若没有发生shutdown,尝试丢弃队列里最近的一个任务,并执行当前任务, 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务</li><li><code>DiscardPolicy</code>:不处理,丢弃掉, 拒绝执行，不抛异常 </li><li>当然,也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略.如记录日志或持久化存储不能处理的任务</li></ul><h4 id="5-3-自定义一个ThreadPoolExecutor线程池"><a href="#5-3-自定义一个ThreadPoolExecutor线程池" class="headerlink" title="5.3 自定义一个ThreadPoolExecutor线程池"></a>5.3 自定义一个ThreadPoolExecutor线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">5</span>, <span class="comment">//核心线程数</span></span><br><span class="line">    Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="number">60</span>,<span class="comment">//线程空闲时间</span></span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.setName(<span class="string">"order-thread"</span>);<span class="comment">//设置有意义的线程名字</span></span><br><span class="line">            <span class="keyword">if</span>(t.isDaemon()) &#123;<span class="comment">//若是守护线程将其释放</span></span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.NORM_PRIORITY != t.getPriority()) &#123;</span><br><span class="line">                <span class="comment">//恢复线程优先级</span></span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            System.err.println(<span class="string">"拒绝策略:"</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><h4 id="5-3-1-线程池执行流程"><a href="#5-3-1-线程池执行流程" class="headerlink" title="5.3.1 线程池执行流程"></a>5.3.1 线程池执行流程</h4><ul><li>要求 线程池有上限，使用有限队列</li></ul><ol><li>当线程池核心线程数量用完，先扔进队列</li><li>队列也用完后，看最大线程数量</li><li>最大线程数量用完后，走拒绝策略</li><li>拒绝策略可以打印一些日志，做一些补偿</li><li>线程池用完一定要优雅的关闭</li></ol><blockquote><p>线程池要统一管理，不要用Executors工厂类，要用ThreadPoolExecutor自定义线程池</p></blockquote><h4 id="5-3-2-线程池配置-核心线程数量"><a href="#5-3-2-线程池配置-核心线程数量" class="headerlink" title="5.3.2 线程池配置-核心线程数量"></a>5.3.2 线程池配置-核心线程数量</h4><p>线程CPU时间所占比例越高，需要越少线程(CPU密集)。线程等待时间所占比例越高，需要越多线程(IO密集)。</p><ol><li><strong>CPU密集型</strong>：内存运算、不涉及IO操作等<ul><li>设置线程数为：<code>CPU核数+1</code> </li></ul></li><li><strong>IO密集型</strong>：数据读取、存取、数据库操作、持久化操作等<ul><li>最佳线程数目：<code>CPU核数/(1-阻塞系数)</code> 这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9。</li></ul></li></ol><blockquote><p>java.lang.<code>Runtime.availableProcessors()</code> 方法返回到Java虚拟机的可用的处理器数量(CPU核数)。此值可能会改变在一个特定的虚拟机调用。应用程序可用处理器的数量是敏感的，因此偶尔查询该属性，并适当地调整自己的资源使用情况.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;池和队列的关系&lt;ul&gt;
&lt;li&gt;线程池或者数据库连接池，都有最大限制。如果超出了限制数量，则新进来的申请连接都要放入额外的&lt;strong&gt;队列里&lt;/strong&gt;，等到池空出来时，从队列中取出连接放进池里。
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】AQS框架 与 锁框架（JUC.locks）</title>
    <link href="http://chaooo.github.io/article/20191010.html"/>
    <id>http://chaooo.github.io/article/20191010.html</id>
    <published>2019-10-10T15:00:24.000Z</published>
    <updated>2019-11-07T13:55:58.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-AQS（队列同步器）"><a href="#1-AQS（队列同步器）" class="headerlink" title="1. AQS（队列同步器）"></a>1. AQS（队列同步器）</h3><p><code>AbstractQueuedSynchronizer</code>：队列同步器，简称<code>AQS</code>。</p><ul><li><code>AQS</code>维护了一个<code>volatile int</code><strong><code>state</code></strong>(代表资源共享变量) 和一个<strong><code>FIFO</code>线程等待队列</strong>(多线程争用资源被阻塞时会进入此队列)。</li><li><code>AQS</code>定义了两种资源共享方式：<code>Exclusive</code>(独占)，<code>Share</code>(共享)<a id="more"></a></li><li><code>isHeldExclusively</code>方法：该线程是否正在独占资源</li><li><code>tryAcquire</code>/<code>tryRelease</code>：独占的方式尝试获取和释放资源</li><li><code>tryAcquireShared</code>/<code>tryReleaseShared</code>：共享的方式尝试获取和释放资源</li></ul><p>整个框架的核心就是<strong>如何管理线程阻塞队列</strong>，该队列是严格的<code>FIFO</code>队列，因此不支持线程优先级的同步。</p><ul><li><code>AQS</code>只有一个同步队列，可以有多个条件队列。<ul><li>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，同步队列选择了<strong><code>CLH</code></strong>作为实现的基础。</li><li>条件队列：<code>AQS</code>框架提供了一个<code>ConditionObject</code>类，给维护独占同步的类以及实现<code>Lock</code>接口的类使用。</li></ul></li><li>使用<code>Node</code>实现<strong><code>FIFO</code>双向队列</strong>，可以用于构建锁 或 其他同步装置的基础框架</li><li>内部有一个int变量表示的<strong><code>同步状态</code></strong>(同步状态通过<strong><code>getState</code></strong>、<strong><code>setState</code></strong>、<strong><code>compareAndSetState</code></strong>来维护，同时这三个方法能够保证线程安全)</li><li><code>AQS</code>是个<strong>抽象类</strong>（但没有抽象方法），同步组件一般通过维护<code>AQS</code>的<strong>继承子类来实现</strong>。</li><li><code>AQS</code><strong>既</strong>支持独占地获取同步状态(<strong>排它锁</strong>)，<strong>又</strong>支持共享地获取同步状态(<strong>共享锁</strong>)，从而实现不同类型的组件。</li><li><code>AQS</code>是<strong>基于模板方法</strong>，同步组件需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</li></ul><blockquote><p><code>Synchronizer</code>(同步器)：是一个对象，它根据本身的状态调节线程的控制流。常见类型的<code>Synchronizer</code>包括信号量、关卡和闭锁。</p></blockquote><h3 id="2-CountDownLatch（倒计时闭锁）"><a href="#2-CountDownLatch（倒计时闭锁）" class="headerlink" title="2. CountDownLatch（倒计时闭锁）"></a>2. CountDownLatch（倒计时闭锁）</h3><ul><li>闭锁(<code>latch</code>)是一种<code>Synchronizer</code>，它可以延迟线程的进度直到线程达到<strong>终止状态</strong>。</li><li><strong><code>CountDownLatch</code></strong>(倒计时闭锁)是一个灵活的闭锁实现。</li><li><code>CountDownLatch</code>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。</li><li><code>CountDownLatch</code><strong>原理</strong>：是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得<code>减1</code>。当计数器到达<code>0</code>时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。<ul><li><code>await()</code>，阻塞程序继续执行</li><li><code>countDown()</code>，计数器的值<code>减1</code>，当计数器值减至<code>零</code>时，所有因调用<code>await()</code>方法而处于等待状态的线程就会继续往下执行。</li></ul></li><li>计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用<code>CycliBarrier</code></li></ul><blockquote><p><code>CountDownLatch</code>使用场景：应用初始化</p></blockquote><h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><ul><li><strong><code>Semaphore</code></strong>(信号量)：用来<strong>控制同时访问</strong>特定资源的线程<strong>数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。</li><li><code>Semaphore</code><strong>原理</strong>：线程需要通过<code>acquire()</code>方法获取许可，而<code>release()</code>释放许可。如果许可数达到最大活动数，那么调用<code>acquire()</code>之后，便进入等待队列，等待已获得许可的线程释放许可，从而使得多线程能够合理的运行。<ul><li><code>acquire()</code>：获取权限，其底层实现与<code>CountDownLatch.countdown()</code>类似;</li><li><code>release()</code>：释放权限，其底层实现与<code>acquire()</code>是一个互逆的过程。</li></ul></li></ul><blockquote><p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。</p></blockquote><h3 id="4-CyclicBarrier（同步屏障）"><a href="#4-CyclicBarrier（同步屏障）" class="headerlink" title="4. CyclicBarrier（同步屏障）"></a>4. CyclicBarrier（同步屏障）</h3><ul><li><strong><code>CyclicBarrier</code></strong>(同步屏障)：可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所有被阻塞的线程才能继续执行。</li><li><code>CyclicBarrier</code>类似于<code>CountDownLatch</code>，它也是通过计数器来实现的。但是相比于<code>CountDownLatch</code>功能更加强大。</li><li><code>CyclicBarrier</code><strong>原理</strong>：当某个线程调用<code>await</code>方法时，该线程进入等待状态，且计数器加1，当计数器的值达到设置的初始值时，所有因调用<code>await</code>进入等待状态的线程被唤醒，继续执行后续操作。因为<code>CycliBarrier</code>在释放等待线程后可以重用，所以称为循环<code>barrier</code>。</li></ul><h4 id="4-1-CountDownLatch-和-CyclicBarrier-对比"><a href="#4-1-CountDownLatch-和-CyclicBarrier-对比" class="headerlink" title="4.1 CountDownLatch 和 CyclicBarrier 对比"></a>4.1 CountDownLatch 和 CyclicBarrier 对比</h4><ol><li><code>CountDownLatch</code>描述的是线程(1个或多个)等待其他线程的关系；<code>CyclicBarrier</code>描述的是多个线程相互等待的关系。</li><li><code>CountDownLatch</code>的计数器只能使用一次。而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置并复用。</li><li><code>CountDownLatch</code>方法比较少，操作比较简单，而<code>CyclicBarrier</code>提供的方法更多，比如：<ul><li><code>getNumberWaiting()</code>：获取阻塞的线程数量。</li><li><code>isBroken()</code>：获取阻塞线程的状态，被中断返回<code>true</code>，否则返回<code>false</code>。</li><li><code>CyclicBarrier</code>的构造方法可以传入<code>barrierAction</code>，指定当所有线程都到达时执行的业务功能；</li></ul></li></ol><blockquote><p><code>CyclicBarrier</code>可以用于多线程计算数据，最后合并计算结果的应用场景</p></blockquote><h3 id="5-JUC-locks-锁框架"><a href="#5-JUC-locks-锁框架" class="headerlink" title="5. JUC.locks 锁框架"></a>5. JUC.locks 锁框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks</span><br><span class="line">    |———— Lock接口</span><br><span class="line">        |———— ReentrantLock类</span><br><span class="line">            |———— ReentrantReadWriteLock.ReadLock内部类</span><br><span class="line">            |———— ReentrantReadWriteLock.WriteLock内部类</span><br><span class="line">    |———— Condition接口</span><br><span class="line">    |———— ReadWriteLock接口</span><br><span class="line">        |———— ReentrantReadWriteLock类</span><br><span class="line">    |———— LockSupport类</span><br></pre></td></tr></table></figure><ul><li><strong><code>Lock</code>接口</strong>核心方法：<code>lock()</code>，<code>unlock()</code>，<code>lockInterruptibly()</code>，<code>newCondition()</code>，<code>tryClock()</code><ul><li><code>lock()</code>方法类似于使用<code>synchronized</code>关键字加锁，如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</li><li><code>lockInterruptibly()</code>方法顾名思义，就是如果锁不可用，那么当前正在等待的线程是可以被中断的，这比<code>synchronized</code>关键字更加灵活。</li></ul></li><li><strong><code>Condition</code>接口</strong>核心方法：<code>awit()</code>，<code>signal()</code>，<code>signalAll()</code><ul><li>可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用</li></ul></li><li><strong><code>ReadWriteLock</code>接口</strong>核心方法：<code>readLock()</code>，<code>writeLock()</code><ul><li>获取读锁和写锁，注意除非使用<code>Java8</code>新锁，否则读读不互斥，读写是互斥的</li></ul></li></ul><h3 id="6-ReentrantLock（可重入锁）"><a href="#6-ReentrantLock（可重入锁）" class="headerlink" title="6. ReentrantLock（可重入锁）"></a>6. ReentrantLock（可重入锁）</h3><p><strong><code>ReentrantLock</code>重入锁</strong>使用<strong><code>AQS</code>同步状态</strong>来保存锁重复持有的次数</p><ul><li>底层代码分析：<ul><li><strong><code>state</code></strong>初始化为0，表示未锁定状态</li><li>A线程<code>lock()</code>时，会调用<code>tryAcquire(</code>)独占该锁并将<strong><code>state+1</code></strong></li><li>此后，其他线程再<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到<code>state=0</code>(即释放锁)为止，其他线程才有机会获取该锁</li><li>当然，锁释放之前，A线程自己是可以重复获取此锁的(<code>state</code>会累加)，这就是可重入的概念</li></ul></li></ul><p><code>synchronized</code>实现的锁的重入依赖于<code>JVM</code>，是一种重量级锁。<br><code>ReentrantLock</code>实现了在内存语义上的<code>synchronized</code>，使用<strong><code>AQS</code>同步状态</strong>来保存锁重复持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code>也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。</p><ul><li>公平锁和非公平锁<ul><li>公平锁还是非公平锁取决于<code>ReentrantLock</code>的构造方法，<strong>默认</strong>无参为<strong>非公平锁</strong>(<code>NonfairSync</code>)；含参构造方法，入参<code>true</code>为<code>FairSync</code>，入参<code>false</code>为<code>NonfairSync</code>。</li></ul></li><li>非公平锁中，抢到<code>AQS</code>的同步状态的未必是同步队列的首节点，只要线程通过<code>CAS</code>抢到了同步状态或者在<code>acquire</code>中抢到同步状态，就优先占有锁（插队），而相对同步队列这个严格的<code>FIFO</code>队列来说，所以会被认为是非公平锁。</li><li>公平锁的实现直接调用<code>AQS</code>的<code>acquire</code>方法，<code>acquire</code>中调用<code>tryAcquire</code>。和非公平锁相比，这里不会执行一次<code>CAS</code>，接下来在<code>tryAcquire</code>去抢占锁的时候，也会先调用<code>hasQueuedPredecessors</code>看看前面是否有节点已经在等待获取锁了，如果存在则同步队列的前驱节点优先（排队<code>FIFO</code>）。</li></ul><blockquote><p>虽然公平锁看起来在公平性上比非公平锁好，但是公平锁为此付出了大量线程切换的代价，而非公平锁在锁的获取上不能保证公平，就有可能出现锁饥饿，即有的线程多次获取锁而有的线程获取不到锁，没有大量的线程切换保证了非公平锁的吞吐量。</p></blockquote><h3 id="7-读写锁RRW（ReentrantReadWriteLock）"><a href="#7-读写锁RRW（ReentrantReadWriteLock）" class="headerlink" title="7. 读写锁RRW（ReentrantReadWriteLock）"></a>7. 读写锁RRW（ReentrantReadWriteLock）</h3><p><code>ReentrantLock</code>是独占锁，<code>ReentrantReadWriteLock</code>是读写锁。</p><ul><li>独占锁通过<code>state</code>变量的<code>0</code>和<code>1</code>两个状态来控制是否有线程占有锁，共享锁通过<code>state</code>变量<code>0</code>或者<code>非0</code>来控制多个线程访问。</li><li>读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</li><li><code>ReentrantReadWriteLock</code>的特殊之处其实就是用一个<code>int</code>值表示两种不同的状态（<code>低16</code>位表示写锁的重入次数，<code>高16</code>位表示读锁的使用次数），并通过两个内部类同时实现了<code>AQS</code>的两套<code>API</code>，核心部分与共享/独占锁并无什么区别。</li></ul><blockquote><p><code>ReentrantReadWriteLock</code>也会发生<strong>写请求饥饿</strong>的情况，因为写请求一样会排队，不管是公平锁还是非公平锁，在有读锁的情况下，都<strong>不能保证写锁</strong>一定能获取到，这样只要读锁一直占用，就会发生写饥饿的情况。<code>JDK8</code>中新增的改进读写锁<code>StampedLock</code>可解决饥饿问题</p></blockquote><h3 id="8-LockSupport工具类"><a href="#8-LockSupport工具类" class="headerlink" title="8. LockSupport工具类"></a>8. LockSupport工具类</h3><p>归根结底，<code>LockSupport</code>调用的<code>Unsafe</code>中的<code>native</code>代码：<code>park()</code>，<code>unpark()</code>；</p><ul><li><code>park</code>函数是将当前<code>Thread</code>阻塞，而<code>unpark</code>函数则是将另一个<code>Thread</code>唤醒。</li><li>与<code>Object</code>类的<code>wait/notify</code>机制相比，<code>park/unpark</code>有两个优点：<ol><li>以<code>thread</code>为操作对象更符合阻塞线程的直观定义；</li><li>操作更精准，可以准确地唤醒某一个线程（<code>Object</code>类的<code>notify</code>随机唤醒一个线程，<code>notifyAll</code>唤醒所有等待的线程），增加了灵活性</li></ol></li></ul><blockquote><p><code>park</code>方法的调用一般要在方法一个循环判断体里面。之所以这样做，是为了防止线程被唤醒后，不进行判断而意外继续向下执行，这其实是一种的多线程设计模式-Guarded Suspension。</p></blockquote><h3 id="9-StampedLock（Java8新型锁）"><a href="#9-StampedLock（Java8新型锁）" class="headerlink" title="9. StampedLock（Java8新型锁）"></a>9. StampedLock（Java8新型锁）</h3><p><code>ReentrantReadWriteLock</code>锁具有读写锁，问题在于<code>ReentrantReadWriteLock</code>使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的 ，很容易造成写锁获取不到资源(写请求饥饿)。</p><ul><li><code>Java8</code>引入了一个新的读写锁叫<code>StampedLock</code>. 不仅这个锁更快，而且它提供强大的乐观锁API。这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会阻塞写线程。</li><li><code>StampedLock</code>的主要特点：<ol><li>所有<strong>获取锁</strong>的方法，都返回一个邮戳（<code>Stamp</code>），<code>Stamp</code>为0表示获取失败，其余都表示成功；</li><li>所有<strong>释放锁</strong>的方法，都需要一个邮戳（<code>Stamp</code>），这个<code>Stamp</code>必须是和成功获取锁时得到的<code>Stamp</code>一致；</li><li><code>StampedLock</code>是<strong>不可重入</strong>的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li><li><code>StampedLock</code>有<strong>三种访问模式</strong>：<ul><li><code>Reading</code>（读模式）：功能和ReentrantReadWriteLock的读锁类似</li><li><code>Writing</code>（写模式）：功能和ReentrantReadWriteLock的写锁类似</li><li><code>Optimistic reading</code>（乐观读模式）：这是一种优化的读模式。</li></ul></li><li><code>StampedLock</code>支持读锁和写锁的相互转换</li><li><code>RRW</code>(ReentrantReadWriteLock)中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的；<code>StampedLock</code>提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</li><li>无论写锁还是读锁，都不支持<code>Conditon</code>等待</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-AQS（队列同步器）&quot;&gt;&lt;a href=&quot;#1-AQS（队列同步器）&quot; class=&quot;headerlink&quot; title=&quot;1. AQS（队列同步器）&quot;&gt;&lt;/a&gt;1. AQS（队列同步器）&lt;/h3&gt;&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;：队列同步器，简称&lt;code&gt;AQS&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AQS&lt;/code&gt;维护了一个&lt;code&gt;volatile int&lt;/code&gt;&lt;strong&gt;&lt;code&gt;state&lt;/code&gt;&lt;/strong&gt;(代表资源共享变量) 和一个&lt;strong&gt;&lt;code&gt;FIFO&lt;/code&gt;线程等待队列&lt;/strong&gt;(多线程争用资源被阻塞时会进入此队列)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AQS&lt;/code&gt;定义了两种资源共享方式：&lt;code&gt;Exclusive&lt;/code&gt;(独占)，&lt;code&gt;Share&lt;/code&gt;(共享)
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】JUC并发容器类</title>
    <link href="http://chaooo.github.io/article/20191006.html"/>
    <id>http://chaooo.github.io/article/20191006.html</id>
    <published>2019-10-06T15:04:22.000Z</published>
    <updated>2019-11-07T13:49:18.769Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>java.util.concurrent</code>包中，提供了两种类型的并发集合：一种是阻塞式，另一种是非阻塞式。</p><ul><li>阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程将被阻塞，一直等到该方法可以被成功执行</li><li>非阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程不会被阻塞，而是直接则返回null或抛出异常。<a id="more"></a></li></ul><h3 id="1-线程安全相关容器"><a href="#1-线程安全相关容器" class="headerlink" title="1. 线程安全相关容器"></a>1. 线程安全相关容器</h3><h4 id="1-1-线程安全-同步容器："><a href="#1-1-线程安全-同步容器：" class="headerlink" title="1.1 线程安全-同步容器："></a>1.1 线程安全-同步容器：</h4><ol><li><code>ArrayList</code> –&gt; <code>Vector,Stack</code></li><li><code>HashMap</code> –&gt; <code>HashTable</code>(key、value不能为null)</li><li><code>Collections.synchronizedXXX</code>(List/Set/Map) //本质是对相应的容器进行包装，通过在方法中加synchronized同步锁来实现</li></ol><ul><li>同步容器的同步原理就是在方法上用<code>synchronized</code>修饰。<strong>性能开销大</strong>。</li><li>在<strong>单独</strong>使用里面的方法的时候，可以保证线程安全，但是，<strong>复合操作需要额外加锁</strong>来保证线程安全。</li></ul><h4 id="1-2-线程安全-并发容器："><a href="#1-2-线程安全-并发容器：" class="headerlink" title="1.2 线程安全-并发容器："></a>1.2 线程安全-并发容器：</h4><ol><li><code>ArrayList</code> –&gt; <strong><code>CopyOnWriteArrayList</code></strong>：保证<strong><code>最终一致性</code></strong>，写时复制，适用于<strong><code>读多写少</code></strong>的并发场景</li><li><code>HashSet</code>、<code>TreeSet</code> –&gt; <code>CopyOnWriteArraySet</code>、<code>ConcurrentSkipListSet</code>：</li><li><code>HashMap</code>、<code>TreeMap</code> –&gt; <strong><code>ConcurrentHashMap</code></strong>、<code>ConcurrentSkipListMap</code>：</li></ol><h4 id="1-3-安全共享对象策略"><a href="#1-3-安全共享对象策略" class="headerlink" title="1.3 安全共享对象策略"></a>1.3 安全共享对象策略</h4><ol><li>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有者修改</li><li>共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但不能修改</li><li>线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，其他线程无需额外的同步就可以通过公共接口随意访问它</li><li>被守护对象：被守护对象只能通过获取特定的锁来访问</li></ol><h3 id="2-CopyOnWrite机制"><a href="#2-CopyOnWrite机制" class="headerlink" title="2. CopyOnWrite机制"></a>2. CopyOnWrite机制</h3><p><code>CopyOnWrite</code>（简称COW），是计算机程序设计领域中的一种优化策略，也是一种思想–即<strong>写入时复制思想</strong>。</p><ul><li>在<code>CopyOnWrite</code>中，对容器的修改操作加锁后，通过copy一个新的容器副本来进行修改，修改完毕后将容器替换为新的容器即可。<ul><li>这种方式的好处显而易见：通过copy一个新的容器来进行修改，这样读操作就不需要加锁，可以并发读，因为在读的过程中是采用的旧的容器，即使新容器做了修改对旧容器也没有影响，同时也很好的解决了迭代过程中其他线程修改导致的并发问题。</li></ul></li><li>从JDK1.5开始，<code>java.util.concurrent</code>包中提供了两个<code>CopyOnWrite</code>机制容器，分别为<strong><code>CopyOnWriteArrayList</code></strong>和<strong><code>CopyOnWriteArraySet</code></strong></li><li><code>CopyOnWriteArrayList</code>通过使用<strong><code>ReentrantLock</code>锁</strong>来实现线程安全：<ul><li>在添加、获取元素时，使用<code>getArray()</code>获取底层数组对象，获取此时集合中的数组对象；使用<code>setArray()</code>设置底层数组，将原有数组对象指针指向新的数组对象—-实以此来实现<code>CopyOnWrite</code>副本概念</li><li><strong>添加元素</strong>: 在添加元素之前进行加锁操作，保证数据的原子性。在添加过程中，进行数组复制，修改操作，再将新生成的数组复制给集合中的<code>array</code>属性。最后，释放锁；<ul><li>由于<code>array</code>属性被<code>volatile</code>修饰，所以当添加完成后，其他线程就可以立刻查看到被修改的内容。</li></ul></li><li><strong>获取元素</strong>：在获取元素时，由于<code>array</code>属性被<code>volatile</code>修饰，所以每当获取线程执行时，都会拿到最新的数据。此外，添加线程在进行添加元素时，会将新的数组赋值给<code>array</code>属性，所以在获取线程中并不会因为元素的添加而导致本线程的执行异常。因为获取线程中的<code>array</code>和被添加后的<code>array</code>指向了不同的内存区域。</li></ul></li></ul><blockquote><p>在执行<code>add()</code>时，为什么还要在加锁的同时又copy了一分新的数组对象?</p><ul><li>因为，在<code>add()</code>时候加了锁，首先不会有多个线程同时进到<code>add</code>中去，这一点保证了数组的安全。当在一个线程执行<code>add</code>时，又进行了数组的复制操作，生成了一个新的数组对象，在<code>add</code>后又将新数组对象的指针指向了旧的数组对象指针，注意此时是指针的替换，原来旧的数组对象还存在。这样就实现了，添加方法无论如何操作数组对象，获取方法在获取到集合后，都不会受到其他线程添加元素的影响。</li></ul></blockquote><ul><li><code>CopyOnWrite</code>机制的优缺点<ul><li>优点: <code>CopyOnWriteArrayList</code>保证了数据在多线程操作时的<strong>最终一致性</strong>。</li><li>缺点: 缺点也同样显著，那就是内存空间的浪费：因为在写操作时，进行数组复制，在内存中产生了两份相同的数组。如果数组对象比较大，那么就会造成频繁的GC操作，进而影响到系统的性能；</li></ul></li></ul><blockquote><p>适用场景：<strong>读多写少</strong>的并发场景</p></blockquote><h3 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3. ConcurrentHashMap"></a>3. ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code>容器相较于CopyOnWrite容器在并发加锁粒度上有了更大一步的优化，它通过修改对<strong>单个hash桶元素加锁</strong>的达到了更细粒度的并发控制。</p><ul><li>在底层数据结构上，<code>ConcurrentHashMap</code>和<code>HashMap</code>都使用了数组+链表+红黑树的方式，只是在HashMap的基础上添加了并发相关的一些控制。</li><li>JDK1.8中<strong>取消</strong>了segment分段锁，而采用<code>CAS和synchronized</code>来保证并发安全。<code>synchronized</code>只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。并且初始化操作大大简化，修改为<code>lazy-load</code>形式。</li></ul><h4 id="3-1-put方法过程"><a href="#3-1-put方法过程" class="headerlink" title="3.1 put方法过程"></a>3.1 put方法过程</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>判断键值是否为<code>null</code>，为null抛出异常</li><li>调用<code>spread()</code>方法计算key的<code>hashCode()</code>获得哈希地址</li><li>判断<code>Node[]</code>数组(<code>table</code>)是否为空，若空则进行初始化操作<ul><li>需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong><code>尝试</code></strong>初始化<code>table</code>，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程</li></ul></li><li>使用<code>(容量大小-1 &amp; 哈希地址)</code>计算下标，如果没有碰撞，使用<code>CAS</code>原子性操作放入桶中；插入失败(被别的线程抢先插入了)则进入下次循环。</li><li>如果该下标上的节点(头节点)的哈希地址为<code>-1</code>，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果碰撞了(<code>bucket</code>不为空)且又不需要扩容，则进入到<code>bucket</code>中，且锁住该<code>bucket</code>，其他<code>bucket</code>不影响。</li><li>进入到<code>bucket</code>里面，首先判断这个<code>bucket</code>存储的是红黑树(哈希地址小于0)还是链表。</li><li>如果是链表，则遍历链表，若节点已经存在(<code>key</code>相同)就覆盖旧值，没有找到相同的节点就将新增的节点插入到链表尾部。如果是红黑树，则将节点插入。到这里释放锁。</li><li>判断该<code>bucket</code>上的链表长度是否链表长度超过阀值<code>（TREEIFY_THRESHOLD==8）</code>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树。</li><li>调用<code>addCount()</code>方法，作用是将<code>ConcurrentHashMap</code>的键值对数量+1，还有另一个作用是检查<code>ConcurrentHashMap</code>是否需要扩容。</li></ol><blockquote><p>总结：</p><ul><li>JDK8中的实现也是锁分离的思想，它把锁分的比<code>segment（JDK1.5）</code>更细一些，只要hash不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作<code>CAS</code>插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过<code>synchronized</code>获得头结点锁，进行后续的操作。<strong>性能比segment分段锁又再次提升</strong>。</li></ul></blockquote><h4 id="3-2-ConcurrentHashMap多线程环境下扩容"><a href="#3-2-ConcurrentHashMap多线程环境下扩容" class="headerlink" title="3.2 ConcurrentHashMap多线程环境下扩容"></a>3.2 ConcurrentHashMap多线程环境下扩容</h4><ul><li><code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持<strong>多线程扩容</strong>，而且也<strong>没有进行加锁</strong>，所以实现会变得有点儿复杂。整个扩容操作分为两步：<ul><li>构建一个<code>nextTable</code>，其大小为原来大小的两倍，这个步骤是在单线程环境下完成的</li><li>将原来<code>table</code>里面的内容复制到<code>nextTable</code>中，这个步骤是允许多线程操作的，所以性能得到提升，减少了扩容的时间消耗。</li></ul></li><li>扩容的时机：<ol><li>如果新增节点之后，所在链表的元素个数达到了阈值 8，则会调用treeifyBin方法把链表转换成红黑树，不过在结构转换之前，会对数组长度进行判断：<ul><li>如果数组长度n小于阈值<code>MIN_TREEIFY_CAPACITY</code>，默认是64，则会调用<code>tryPresize</code>方法把数组长度扩大到原来的两倍，并触发<code>transfer</code>方法，重新调整节点的位置。</li></ul></li><li>新增节点之后，会调用<code>addCount</code>方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发<code>transfer</code>方法，重新调整节点的位置。</li></ol></li><li>JDK8的源码里面就引入了一个<strong><code>ForwardingNode</code></strong>类，在一个线程发起扩容的时候，就会改变<code>sizeCtl</code>这个值，其含义如下： <ul><li><code>sizeCtl</code> ：默认为0，用来控制<code>table</code>的初始化和扩容操作，具体应用在后续会体现出来。</li><li><code>-1</code> 代表<code>table</code>正在初始化</li><li><code>-N</code> 表示有<code>N-1</code>个线程正在进行扩容操作</li><li>其余情况：  <ol><li>如果<code>table</code>未初始化，表示<code>table</code>需要初始化的大小。  </li><li>如果<code>table</code>初始化完成，表示<code>table</code>的容量，默认是<code>table</code>大小的<code>0.75</code>倍</li></ol></li></ul></li><li>扩容时候会判断<code>sizeCtl</code>的值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用<code>tabAt</code>方法获得i位置的元素f，初始化一个<code>forwardNode</code>实例<code>fwd</code>，如果<code>f == null</code>，则在<code>table</code>中的i位置放入<code>fwd</code>，否则采用头插法的方式把当前旧<code>table</code>数组的指定任务范围的数据给迁移到新的数组中，然后给旧<code>table</code>原位置赋值<code>fwd</code>。直到遍历过所有的节点以后就完成了复制工作，把<code>table</code>指向<code>nextTable</code>，并更新<code>sizeCtl</code>为新数组大小的<code>0.75</code>倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断<code>head</code>节点是否为<code>forwardNode</code>节点，如果是就<strong>帮助扩容</strong>。</li><li>在<strong>扩容时读写操作</strong>如何进行<ol><li>对于<code>get</code>读操作，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。如果当前链表已经迁移完成，那么头节点会被设置成<code>fwd</code>节点，此时<code>get</code>线程会帮助扩容。</li><li>对于<code>put</code>/<code>remove</code>写操作，如果当前链表已经迁移完成，那么头节点会被设置成<code>fwd</code>节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。 </li></ol></li></ul><blockquote><p>总结: <code>ConcurrentHashMap</code>扩容的原理是新生成原来<code>2倍</code>的数组，然后拷贝旧数组数据到新的数组里面，在多线程情况下，这里面如果注意线程安全问题，在解决安全问题的同时，我们也要关注其效率，这才是并发容器类的最出色的地方。 </p></blockquote><h4 id="3-3-size、mappingCount方法"><a href="#3-3-size、mappingCount方法" class="headerlink" title="3.3 size、mappingCount方法"></a>3.3 size、mappingCount方法</h4><ul><li><code>size</code>和<code>mappingCount</code>方法都是用来统计table的<code>size</code>的</li><li>这两者不同的地方在<code>size</code>返回的是一个<code>int类型</code>，即可以表示<code>size</code>的范围是<code>[-2^31，2^31-1]</code>，超过这个范围就返回int能表示的最大值</li><li><code>mappingCount</code>返回的是一个<code>long类型</code>，即可以表示<code>size</code>的范围是<code>[-2^63，2^63-1]</code>。</li><li>这两个方法都是调用的<code>sumCount()</code>方法实现统计。</li><li><strong>对于<code>size</code>和迭代器是弱一致性</strong><ul><li><code>volatile</code>修饰的数组引用是强可见的，但是其元素却不一定，所以，这导致<code>size</code>的根据<code>sumCount</code>的方法<strong>并不准确</strong>。</li><li>同理<code>Iteritor</code>的迭代器也一样，并不能准确反映最新的实际情况 </li></ul></li></ul><h3 id="4-ConcurrentSkipListMap"><a href="#4-ConcurrentSkipListMap" class="headerlink" title="4. ConcurrentSkipListMap"></a>4. ConcurrentSkipListMap</h3><p><code>ConcurrentSkipListMap</code>内部使用<strong>跳表（<code>SkipList</code>）</strong>这种数据结构来实现，他的结构相对红黑树来说非常简单理解，实现起来也相对简单，而且在理论上它的查找、插入、删除时间复杂度都为<code>log(n)</code>。在并发上，<code>ConcurrentSkipListMap</code>采用无锁的<strong><code>CAS+自旋</code></strong>来控制。</p><ul><li>跳表简单来说就是一个多层的链表，底层是一个普通的链表，然后逐层减少，通常通过一个简单的算法实现每一层元素是下一层的元素的二分之一，这样当搜索元素时从最顶层开始搜索，可以说是另一种形式的二分查找。</li><li><code>ConcurrentSkipListMap</code>的<strong><code>put</code></strong>(插入)：<ul><li>调用<code>doPut()</code>方法，可以分为3大步来理解：</li><li>第一步获取前继节点后通过<code>CAS</code>来插入节点；</li><li>第二步对<code>level</code>层数进行判断，如果大于最大层数，则插入一层；</li><li>第三步插入对应层的数据。整个插入过程全部通过<code>CAS</code>自旋的方式保证并发情况下的数据正确性。</li></ul></li></ul><h3 id="5-volatile-amp-Atmoic-amp-UnSafe"><a href="#5-volatile-amp-Atmoic-amp-UnSafe" class="headerlink" title="5. volatile &amp; Atmoic &amp; UnSafe"></a>5. volatile &amp; Atmoic &amp; UnSafe</h3><ul><li><strong><code>volatile</code></strong>作用：①多线程间的可见性、②阻止指令重排序</li><li><strong><code>Atmoic系列类</code></strong>提供了原子性操作，保障多线程下的安全</li><li><strong><code>UnSafe类</code></strong>的作用：①内存操作、②字段的定位与修改(底层)、③线程挂起与恢复、④<code>CAS</code>操作(乐观锁)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;java.util.concurrent&lt;/code&gt;包中，提供了两种类型的并发集合：一种是阻塞式，另一种是非阻塞式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程将被阻塞，一直等到该方法可以被成功执行&lt;/li&gt;
&lt;li&gt;非阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程不会被阻塞，而是直接则返回null或抛出异常。
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】常见集合类 的 数据结构</title>
    <link href="http://chaooo.github.io/article/20191003.html"/>
    <id>http://chaooo.github.io/article/20191003.html</id>
    <published>2019-10-03T14:53:06.000Z</published>
    <updated>2019-10-30T13:58:11.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合-Collection-Map"><a href="#集合-Collection-Map" class="headerlink" title="集合(Collection/Map)"></a>集合(Collection/Map)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection接口</span><br><span class="line">    |———— List接口</span><br><span class="line">        |———— ArrayList类</span><br><span class="line">        |———— Vector类</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">        |———— Stack类</span><br><span class="line">    |———— Set接口</span><br><span class="line">        |———— HashSet类</span><br><span class="line">        |———— TreeSet类</span><br><span class="line">        |———— LinkedHashSet类</span><br><span class="line">    |———— Queue接口</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">Map接口</span><br><span class="line">    |———— HashMap类</span><br><span class="line">    |———— TreeMap类</span><br><span class="line">    |———— LinkedHashMap类</span><br><span class="line">    |———— Hashtable类</span><br></pre></td></tr></table></figure><h4 id="0-1-List"><a href="#0-1-List" class="headerlink" title="0.1 List"></a>0.1 List</h4><ul><li><strong>Arraylist</strong>： 动态数组</li><li>Vector： 动态数组(线程安全)</li><li><strong>LinkedList</strong>： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><h4 id="0-2-Set"><a href="#0-2-Set" class="headerlink" title="0.2 Set"></a>0.2 Set</h4><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li><li>TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树)</li></ul><h4 id="0-3-Map"><a href="#0-3-Map" class="headerlink" title="0.3 Map"></a>0.3 Map</h4><ul><li><strong>HashMap</strong>： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间</li><li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，<strong>增加了一条双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>Hashtable： 数组+链表(线程安全)，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h4 id="0-4-如何选用集合"><a href="#0-4-如何选用集合" class="headerlink" title="0.4 如何选用集合"></a>0.4 如何选用集合</h4><p>主要根据集合的特点来选用：</p><ul><li>键值对就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.</li><li>只需要存放元素值时，就选用Collection接口下的集合，需要保证元素唯一时选择实现Set接口的集合（TreeSet或HashSet），不需要就选择实现List接口的ArrayList或LinkedList</li></ul><h4 id="0-5-对数公式log-与-时空复杂度"><a href="#0-5-对数公式log-与-时空复杂度" class="headerlink" title="0.5 对数公式log 与 时空复杂度"></a>0.5 对数公式log 与 时空复杂度</h4><ul><li>若<code>a^n = b</code> (a&gt;0,a≠1) 则 <code>n = log(a)b</code> , 如<code>log(2)8 = 3</code>; Java数据结构中log默认以2为底(个人理解,有待考证)</li><li>常用O(1), O(n), O(logn)表示对应算法的时间复杂度, 也用于表示空间复杂度。<ul><li><strong><code>O(1)</code></strong>: 最低的时空复杂度, 无论数据规模多大，都可以在一次计算后找到目标</li><li><strong><code>O(n)</code></strong>: 数据量增大n倍时，耗时增大n倍; 比如常见的遍历算法</li><li><strong><code>O(n^2)</code></strong>: 数据量增大n倍时，耗时增大n的平方倍; 比如冒泡排序，对n个数排序，需要扫描n×n次</li><li><strong><code>o(logn)</code></strong>: 当数据增大n倍时，耗时增大logn倍; 二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标(2^8=256)</li><li><strong><code>O(nlogn)</code></strong>: 同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度</li></ul></li></ul><h4 id="0-6-移位运算符"><a href="#0-6-移位运算符" class="headerlink" title="0.6  移位运算符"></a>0.6  移位运算符</h4><p>按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移) 和 &gt;&gt;&gt;(无符号右移)</p><ul><li><code>左移 &lt;&lt;</code> : 丢弃最高位,0补最低位；左移n位就相当于乘以2的n次方</li><li><code>右移 &gt;&gt;</code> : 符号位不变,高位补上符号位(正数0, 负数1)；右移n位相当于除以2的n次方</li><li><code>无符号右移 &gt;&gt;&gt;</code> : 忽略符号位，0补最高位(补码移位所得)</li></ul><blockquote><ul><li>正数的左移与右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。</li><li>负数的右移，就是补码高位补1,然后按位取反加1即可。</li></ul></blockquote><ul><li>运算规则：<ul><li>左移：高位移出(舍弃)，低位的空位补零；int类型时，每移动1位它的第31位就要被移出并且丢弃；long类型时，每移动1位它的第63位就要被移出并且丢弃；byte和short类型时，将自动把这些类型扩大为int型。</li><li>右移：低位移出(舍弃)，高位的空位补符号位，即正数补0，负数补1；当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。</li><li>无符号右移：补码移位，高位补0；正数和右移表现一致，负数变成了很大的正数；</li></ul></li></ul><h3 id="1-Arraylist"><a href="#1-Arraylist" class="headerlink" title="1. Arraylist"></a>1. Arraylist</h3><p>ArrayList的底层是数组队列，相当于<strong>动态数组</strong>。与数组相比，它的容量能动态增长。在添加大量元素前，应用程序使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p><ul><li><strong>数组</strong>时间复杂度: <strong>插入/删除:O(n)</strong>，<strong>增加(末尾)/随机访问: O(1)</strong></li><li>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的<strong>添加、删除、修改、遍历</strong>等功能</li><li>ArrayList 实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是<strong>快速随机访问</strong></li><li>ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，<strong>能被克隆</strong>。</li><li>ArrayList 实现java.io.Serializable 接口，这意味着ArrayList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>和 Vector 不同，ArrayList 中的操作<strong>不是线程安全的</strong>！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li></ul><h4 id="1-1-ArrayList扩容机制-（重点）"><a href="#1-1-ArrayList扩容机制-（重点）" class="headerlink" title="1.1 ArrayList扩容机制*（重点）"></a>1.1 ArrayList扩容机制*（重点）</h4><ul><li>以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组；当add第一个元素时，才真正分配容量(<strong>默认10</strong>)</li><li>ArrayList在每次增加元素(1个或一组)时，都要调用<code>ensureCapacityInternal()</code>方法来确保足够的容量</li><li>当容量不足以容纳当前的元素个数时，进入<code>grow()</code>方法进行扩容，首先设置新的容量为旧容量的<strong>1.5倍</strong></li><li>若设置后的新容量还不够，则设置新容量为<code>minCapacity</code>(所需最小容量)</li><li>比较新容量是否大于<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)，若大于，再比较<code>minCapacity</code>是否大于<code>MAX_ARRAY_SIZE</code>，若大于，设置新的容量为<code>Integer.MAX_VALUE</code>(Integer最大值)，否则设置新的容量为<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)</li><li>最后用<code>Arrays.copyof()</code>方法将元素拷贝到新的数组</li><li>(第<code>Integer.MAX_VALUE+1</code>次添加元素时，抛出<code>OutOfMemoryError</code>异常)</li></ul><blockquote><p><strong>System.arraycopy()和Arrays.copyOf()方法</strong><br>通过源码发现这两个实现数组复制的方法被广泛使用, 比如插入操作add(int index, E element)方法就很巧妙的用到了 System.arraycopy()方法让数组自己复制自己实现让index开始之后的所有成员后移一个位置</p><ul><li>Arrays.copyOf()内部也是调用了System.arraycopy()方法 </li><li>Arrays.copyOf()是系统自动在内部新建一个数组，并返回该数组</li><li>System.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li></ul></blockquote><h4 id="1-2-ensureCapacity"><a href="#1-2-ensureCapacity" class="headerlink" title="1.2 ensureCapacity"></a>1.2 ensureCapacity</h4><p>ArrayList对外提供了一个<code>ensureCapacity(int n)</code>方法</p><ul><li>最好在<code>add</code>大量元素之前用ensureCapacity方法，以<strong>减少增量重新分配的次数</strong></li><li>ensureCapacity一次性扩容到位，否则在添加大量元素的过程中，一点一点的进行扩容</li></ul><h4 id="1-3-内部类"><a href="#1-3-内部类" class="headerlink" title="1.3 内部类"></a>1.3 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span></span>&#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>ArrayList有四个内部类</p><ul><li>Itr 实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；</li><li>ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法</li><li>Iterator和ListIterator的区别: <ul><li>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</li></ul></li></ul><h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h3><p>LinkedList是基于<strong>双向链表</strong>实现的, 可以在任何位置进行高效地插入和移除操作的有序序列。</p><ul><li>复杂度: <strong>增加(末尾)/删除:O(1)</strong>，<strong>插入/获取: O(n)</strong></li><li>LinkedList 继承AbstractSequentialList的<strong>双向链表</strong>。它也可以被当作堆栈、队列或双端队列进行操作。</li><li>LinkedList 实现 List 接口，能对它进行<strong>队列操作</strong>。</li><li>LinkedList 实现 Deque 接口，即能将LinkedList当作<strong>双端队列</strong>使用。</li><li>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，<strong>能克隆</strong>。</li><li>LinkedList 实现java.io.Serializable接口，这意味着LinkedList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>LinkedList <strong>不是线程安全的</strong>，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法</li></ul><h4 id="2-1-LinkedList底层分析"><a href="#2-1-LinkedList底层分析" class="headerlink" title="2.1 LinkedList底层分析:"></a>2.1 LinkedList底层分析:</h4><p>LinkedList的底层是一个双向链表，链表中挂载着一个个的Node元素；可以从LinkedList的Node内部类看出奥秘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//尾指针</span></span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 数据域（当前节点的值）</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 后继（指向当前一个节点的后一个节点）</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 前驱（指向当前节点的前一个节点）</span></span><br><span class="line">    <span class="comment">// 构造函数，赋值前驱后继</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LinkedList 是基于链表结构实现，所以在类中包含了 first 和 last 两个指针(Node)。</li><li>Node 中包含了上一个节点和下一个节点的引用，这样就构成了双向的链表。</li></ul><h4 id="2-2-LinkedList增删改查"><a href="#2-2-LinkedList增删改查" class="headerlink" title="2.2 LinkedList增删改查"></a>2.2 LinkedList增删改查</h4><ul><li>链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。增加一定会修改modCount。</li><li>通过下标获取某个node的时候(add select)，会根据index处于前半段还是后半段<strong>进行一个折半</strong>，以提升查询效率</li><li>删也一定会修改modCount。 <ul><li>按下标删，也是先根据index找到Node，然后去链表上unlink掉这个Node。 </li><li>按元素删，会先去遍历链表寻找是否有该Node，如果有，去链表上unlink掉这个Node。</li></ul></li><li>改也是先根据index找到Node，然后替换值。不修改modCount。</li><li>CRUD操作里，都涉及到根据index去找到Node的操作。</li></ul><h4 id="2-2-unlink原理"><a href="#2-2-unlink原理" class="headerlink" title="2.2 unlink原理"></a>2.2 unlink原理</h4><ul><li>先判断该节点是否存在上一个节点，即是否有前驱节点。<ul><li>无前驱节点则说明要删除的节点为链表的第一节点，那么只需要把该节点的下一个节点设置为链表的第一个节点。</li><li>有前驱节点则需要把前驱节点的尾部引用指向该节点的下一个节点。</li></ul></li><li>再判断该节点是否存在下一个节点，即是否有后继节点。<ul><li>无后继节点则说明该节点是链表的最后一个节点，那么只需要把该节点前驱节点设置成链表的最后一个节点即可。</li><li>有后继节点则需要把后继节点的头部引用指向该节点的上一个节点。</li></ul></li><li>核心就是在于将要删除的节点的前驱节点尾部指向该节点的后继节点，将要删除的节点的后继节点的头部指向该节点的前驱节点。这样便完成了链表的删除操作。</li></ul><blockquote><p>删除和新增方法的实现基本是对该节点的上一个节点和下一个节点的引用设置，不需要操作其他节点，效率相对较高</p></blockquote><h4 id="2-3-offer与add的区别"><a href="#2-3-offer与add的区别" class="headerlink" title="2.3 offer与add的区别"></a>2.3 offer与add的区别</h4><ul><li>offer属于 offer in interface <strong>Deque</strong>。</li><li>add 属于 add in interface <strong>Collection</strong>。</li><li>当队列为空时候，使用add方法会报错，而offer方法会返回false。</li><li>作为List使用时,一般采用add / get方法来 压入/获取对象。</li><li>作为Queue使用时,才会采用 offer/poll/take等方法作为链表对象时,offer等方法相对来说没有什么意义这些方法是用于支持队列应用的。</li></ul><h4 id="2-2-对比Vector、ArrayList、LinkedList有何区别"><a href="#2-2-对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="2.2 对比Vector、ArrayList、LinkedList有何区别"></a>2.2 对比Vector、ArrayList、LinkedList有何区别</h4><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全</strong>的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据扩容为旧容量的<strong>2倍</strong>。</li><li>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。ArrayList 也是可以根据需要调整容量，在扩容为旧容量的<strong>1.5倍</strong>。</li><li>LinkedList 顾名思义是 Java 提供的双向链表，<strong>不需要扩容</strong>，它也不是线程安全的。LinkedList不支持高效的随机元素访问。</li></ul><h3 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3. HashMap"></a>3. HashMap</h3><p>HashMap是<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的, 用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。</p><ul><li>HashMap继承了AbstractMap类，实现了Map，Cloneable，Serializable接口</li><li>继承 abstractMap，也就是用来减轻实现Map接口的编写负担。</li><li>实现 Cloneable：能够使用Clone()方法，在HashMap中，实现的是<strong>浅层次拷贝</strong>，即对拷贝对象的改变会影响被拷贝的对象。</li><li>实现 Serializable：能够使之<strong>序列化</strong>，即可以将HashMap对象保存至本地，之后可以恢复状态。</li></ul><blockquote><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>，以实现O(logn)时间复杂读查找。</p></blockquote><p>HashMap类中有一个非常重要的字段，就是 Node[] table，即<strong>哈希桶数组</strong>，明显它是一个Node的数组。</p><ul><li>HashMap的实例有两个参数影响其性能:<ul><li>初始容量(默认16)：哈希表中桶的数量</li><li>加载因子(默认0.75)：哈希表在其容量自动增加之前可以达到多满的一种尺度</li></ul></li><li>当哈希表中条目数超出了当前容量*加载因子(其实就是HashMap的实际容量)时，则对该哈希表进行rehash操作，将哈希表扩充至两倍的桶数。</li></ul><h4 id="3-1-HashMap的-put-方法过程-（重点）"><a href="#3-1-HashMap的-put-方法过程-（重点）" class="headerlink" title="3.1 HashMap的 put 方法过程*（重点）"></a>3.1 HashMap的 put 方法过程*（重点）</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>对 Key 求 Hash 值，然后再计算下标。</li><li>如果没有碰撞，直接放入桶中，</li><li>如果碰撞了，若是树节点，就<code>putTreeVal</code>添加元素，若不是就遍历链表插入。</li><li>如果链表长度超过阀值（TREEIFY_THRESHOLD==8），就把链表转成红黑树。</li><li>如果节点已经存在就替换旧值，若未找到则继续</li><li>如果桶满了（容量 * 加载因子），就需要 resize(扩容为原来2倍并重新散列,元素的下标要么不变，要么变为【原下标+原容量】)。</li></ol><h4 id="3-2-HashMap-桶下标计算"><a href="#3-2-HashMap-桶下标计算" class="headerlink" title="3.2 HashMap 桶下标计算"></a>3.2 HashMap 桶下标计算</h4><ul><li><strong>下标</strong>：<code>hash(key) &amp; (table.length - 1)</code></li><li>扰动函数<strong>hash(key)</strong>：(key==null) ? 0 : <code>(key.hashCode()^(key.hashCode() &gt;&gt;&gt; 16))</code></li><li>低16位 和 高 16位 做了一个<strong>异或</strong>得到 hash值 与 (容器长度-1)进行<strong>取模(%)</strong>运算,得到下标。<ul><li>利用位运算代替取模运算，提高程序的计算效率：（当 b=2^n 时，a%b = a &amp; (b-1) ），也是因此，HashMap 才将初始长度设置为 16，且扩容只能是以 2 的倍数（2^n）扩容。</li></ul></li><li>有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以尽可能有效的避免哈希碰撞。</li></ul><blockquote><p>HashMap 的性能表现非常依赖于哈希码的有效性: equals相等，hashCode一定要相等。重写了 hashCode 也要重写 equals。hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</p></blockquote><h4 id="3-3-HashMap-容量、负载因子和树化"><a href="#3-3-HashMap-容量、负载因子和树化" class="headerlink" title="3.3 HashMap 容量、负载因子和树化"></a>3.3 HashMap 容量、负载因子和树化</h4><ul><li>容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。</li><li>如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。</li><li>计算条件：<strong>负载因子 * 容量 &gt; 元素数量</strong>；所以，预先设置的容量需要满足，大于“预估元素数量/负载因子”，同时它是<strong>2的幂数</strong></li><li>容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 <strong>1&lt;&lt;30</strong>，也就是2的30次方</li></ul><h5 id="3-3-1-HashMap-负载因子loadFactor"><a href="#3-3-1-HashMap-负载因子loadFactor" class="headerlink" title="3.3.1 HashMap 负载因子loadFactor"></a>3.3.1 HashMap 负载因子loadFactor</h5><ul><li>loadFactor加载因子是控制数组存放数据的疏密程度，越大越密，越小越稀疏。</li><li>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的<strong>默认值为0.75f</strong>是官方给出的一个比较好的临界值。</li><li>给定的默认容量为16，负载因子为0.75。当数量达到了 16*0.75 = 12 就需要将当前16的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li><li>而对于负载因子，建议：<ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</li><li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul></li></ul><h5 id="3-3-2-HashMap-门限值threshold"><a href="#3-3-2-HashMap-门限值threshold" class="headerlink" title="3.3.2 HashMap 门限值threshold"></a>3.3.2 HashMap 门限值threshold</h5><p><code>threshold = capacity * loadFactor</code>，当<code>Size&gt;=threshold</code>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</p><ul><li>门限值等于(负载因子 x 容量)，如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。</li><li>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="3-3-2-HashMap-树化改造"><a href="#3-3-2-HashMap-树化改造" class="headerlink" title="3.3.2 HashMap 树化改造"></a>3.3.2 HashMap 树化改造</h5><p>树化改造逻辑主要在 putVal 和 <code>treeifyBin</code> 中。</p><ul><li>链表结构（这里叫 bin）的数量大于 <code>TREEIFY_THRESHOLD</code>(默认为8) 时：<ul><li>如果容量小于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64) ，只会进行简单的扩容。</li><li>如果容量大于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64)，则会进行树化改造。</li></ul></li></ul><h4 id="3-4-HashMap-扩容resize"><a href="#3-4-HashMap-扩容resize" class="headerlink" title="3.4 HashMap 扩容resize"></a>3.4 HashMap 扩容resize</h4><ul><li>HashMap扩容条件：<ul><li>元素个数超出了加载因子与当前容量的乘积，并且发生了Hash碰撞</li></ul></li><li>HashMap扩容步骤：<ol><li>创建一个新的Entry空数组，长度是原来的2倍。</li><li>遍历原Entry数组，把所有的Entry重新Hash到新数组里。</li><li>重新散列的元素下标要么【不变】，要么变为【原下标+原容量】，取决于位运算((n - 1) &amp; hash)</li></ol></li></ul><blockquote><p>经过一次扩容处理后，元素会更加均匀的分布在各个桶中，会提升访问效率。<br>但会遍历所有的元素，时间复杂度很高；遍历元素所带来的坏处大于元素在桶中均匀分布所带来的好处。<br>尽量避免进行扩容处理。</p></blockquote><h4 id="3-5-常见的hash算法及冲突的解决"><a href="#3-5-常见的hash算法及冲突的解决" class="headerlink" title="3.5 常见的hash算法及冲突的解决"></a>3.5 常见的hash算法及冲突的解决</h4><p>hash函数，即散列函数。它可以将不定长的输入，通过散列算法转换成一个定长的输出，这个输出就是散列值(不保证唯一)。</p><ul><li>常见Hash算法：<ol><li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址（H(k)=ak+b）。</li><li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址（如一组出生日期，相较于年-月，月-日的差别要大得多，可以降低冲突概率）</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li><li>伪随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</li><li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址（H(k)=k%p, p&lt;=m; p一般取m或素数）。</li></ol></li><li>常见解决hash冲突的方法<ol><li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li><li>开放定址法：即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。</li><li>再哈希法：即发生冲突时，由其他的函数再计算一次哈希值。</li><li>建立公共溢出区：将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。</li></ol></li></ul><blockquote><p>HashMap就是使用链地址法来解决冲突的（JDK1.8增加了红黑树）</p></blockquote><h4 id="3-6-对比Hashtable、HashMap、TreeMap有什么不同"><a href="#3-6-对比Hashtable、HashMap、TreeMap有什么不同" class="headerlink" title="3.6 对比Hashtable、HashMap、TreeMap有什么不同"></a>3.6 对比Hashtable、HashMap、TreeMap有什么不同</h4><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</li><li>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</li><li>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O(log(n))的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集合-Collection-Map&quot;&gt;&lt;a href=&quot;#集合-Collection-Map&quot; class=&quot;headerlink&quot; title=&quot;集合(Collection/Map)&quot;&gt;&lt;/a&gt;集合(Collection/Map)&lt;/h3&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】Redis穿透、击穿、雪崩和数据一致性</title>
    <link href="http://chaooo.github.io/article/20190927.html"/>
    <id>http://chaooo.github.io/article/20190927.html</id>
    <published>2019-09-27T11:15:31.000Z</published>
    <updated>2019-11-04T07:25:49.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。</p><ul><li>解决方案：<ol><li>采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；</li><li>访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</li><li>接口限流与熔断、降级</li><li>使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））</li></ol></li></ul><h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><ul><li>解决方案<ol><li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li><li>建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</li><li>加锁排队，实现同上;</li></ol></li></ul><h3 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h3><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p><ul><li>解决方案<ul><li>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</li></ul></li></ul><h3 id="4-缓存并发竞争"><a href="#4-缓存并发竞争" class="headerlink" title="4. 缓存并发竞争"></a>4. 缓存并发竞争</h3><p>多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）</p><ul><li>解决方案<ol><li>如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。</li><li>如果对这个key操作，要求顺序：<ol><li>分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了）</li><li>利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）</li></ol></li></ol></li></ul><h3 id="5-缓存和数据库一致性解决方案"><a href="#5-缓存和数据库一致性解决方案" class="headerlink" title="5. 缓存和数据库一致性解决方案"></a>5. 缓存和数据库一致性解决方案</h3><h4 id="5-1-并发量、一致性要求都不是很高的场景"><a href="#5-1-并发量、一致性要求都不是很高的场景" class="headerlink" title="5.1 并发量、一致性要求都不是很高的场景"></a>5.1 并发量、一致性要求都不是很高的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，之后再<strong>异步将数据刷回缓存</strong></li><li>读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：实现起来简单，异步刷新，补缺补漏</li><li>缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</li></ol><h4 id="5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）"><a href="#5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）" class="headerlink" title="5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）"></a>5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，监听从库binlog，通过<strong>解析binlog来刷新缓存</strong></li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：容灾</li><li>缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读/写的时候，缓存中的数据已失效，此时又发生了更新）</li></ol><h4 id="5-3-业务只需要达到“最终一致性”要求的场景"><a href="#5-3-业务只需要达到“最终一致性”要求的场景" class="headerlink" title="5.3 业务只需要达到“最终一致性”要求的场景"></a>5.3 业务只需要达到“最终一致性”要求的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的<strong>数据标识</strong>，然后将<strong>数据标识写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：只能达到”最终一致性”</li></ol><h4 id="5-4-强一致性的场景"><a href="#5-4-强一致性的场景" class="headerlink" title="5.4 强一致性的场景"></a>5.4 强一致性的场景</h4><ul><li>写流程：我们把<strong>修改的数据通过Cache_0标记</strong>“正在被修改”，如果<strong>标记成功，写数据库，删除缓存，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识<strong>写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。</li><li>读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-缓存穿透&quot;&gt;&lt;a href=&quot;#1-缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;1. 缓存穿透&quot;&gt;&lt;/a&gt;1. 缓存穿透&lt;/h3&gt;&lt;p&gt;访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Redis" scheme="http://chaooo.github.io/categories/Redis/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】深入学习Redis及集群</title>
    <link href="http://chaooo.github.io/article/20190920.html"/>
    <id>http://chaooo.github.io/article/20190920.html</id>
    <published>2019-09-20T08:19:26.000Z</published>
    <updated>2019-11-04T07:25:07.911Z</updated>
    
    <content type="html"><![CDATA[<p>Redis本质上是一个Key-Value类型的<strong>内存数据库</strong>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。<a id="more"></a>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="1-Redis数据结构及命令操作"><a href="#1-Redis数据结构及命令操作" class="headerlink" title="1. Redis数据结构及命令操作"></a>1. Redis数据结构及命令操作</h3><h4 id="1-1-基本概念及操作"><a href="#1-1-基本概念及操作" class="headerlink" title="1.1 基本概念及操作"></a>1.1 基本概念及操作</h4><ul><li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库；</li><li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；</li><li>select命令切换数据库：select 0-15；</li><li>dbsize：查看当前数据库的key的数量；</li><li>flushdb：清空当前库；</li><li>flushall；通杀全部库；</li></ul><h4 id="1-2-Redis数据结构"><a href="#1-2-Redis数据结构" class="headerlink" title="1.2 Redis数据结构"></a>1.2 Redis数据结构</h4><p>redis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)</p><ol><li>String：set, get, del, append, strlen</li><li>Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall</li><li>List：lpush, rpush, lrange, lpop(删除), rpop, lindex</li><li>Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)</li><li>ZSet：zadd, zrange, zrem</li></ol><h4 id="1-3-Redis键-key-–常用命令介绍"><a href="#1-3-Redis键-key-–常用命令介绍" class="headerlink" title="1.3 Redis键(key)–常用命令介绍"></a>1.3 Redis键(key)–常用命令介绍</h4><ul><li>keys *：查看所有 key ；</li><li>exists key的名字：判断某个 key 是否存在；</li><li>move key dbID（0-15）： 当前库就没有了，被移除了；</li><li>expire key 秒钟： 为给定的 key 设置过期时间；</li><li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；</li><li>type key： 查看你的 key 是什么类型；</li></ul><h3 id="2-Redis持久化"><a href="#2-Redis持久化" class="headerlink" title="2. Redis持久化"></a>2. Redis持久化</h3><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。</p><h4 id="2-1-RDB（Redis-DataBase）"><a href="#2-1-RDB（Redis-DataBase）" class="headerlink" title="2.1 RDB（Redis DataBase）"></a>2.1 RDB（Redis DataBase）</h4><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p><ul><li>开启RDB持久化方式一：save命令，或bgsave(异步)</li><li>开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：<code>redis-server redis.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1     # 900s内至少达到一条写命令</span><br><span class="line">save 300 10    # 300s内至少达至10条写命令</span><br><span class="line">save 60 10000  # 60s内至少达到10000条写命令</span><br></pre></td></tr></table></figure><ul><li><p>RDB的几个优点</p><ul><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li></ul></li><li><p>RDB的几个缺点</p><ul><li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ul></li></ul><h4 id="2-2-AOF-Append-only-file"><a href="#2-2-AOF-Append-only-file" class="headerlink" title="2.2 AOF(Append-only file)"></a>2.2 AOF(Append-only file)</h4><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><ul><li>开启方式：在Redis配置文件redis.conf配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes                  # 开启aof机制</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # aof文件名</span><br><span class="line"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec(每秒写入一次)或no(操作系统处理)</span><br><span class="line">appendfsync always</span><br><span class="line">no-appendfsync-on-rewrite no    # 默认不重写aof文件</span><br><span class="line">dir ~/redis/                    # 保存目录</span><br></pre></td></tr></table></figure><ul><li>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令</li></ul><ul><li>AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li><li>AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。</li><li>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</li></ul><h5 id="2-2-1-AOF文件修复"><a href="#2-2-1-AOF文件修复" class="headerlink" title="2.2.1 AOF文件修复"></a>2.2.1 AOF文件修复</h5><ol><li>备份被写坏的AOF文件</li><li>运行redis-check-aof –fix进行修复</li><li>用diff -u来看下两个文件的差异，确认问题点</li><li>重启redis，加载修复后的AOF文件</li></ol><h3 id="3-Redis的高并发和快速原因"><a href="#3-Redis的高并发和快速原因" class="headerlink" title="3. Redis的高并发和快速原因"></a>3. Redis的高并发和快速原因</h3><ol><li>redis是基于内存的，内存的读写速度非常快；</li><li>redis是单线程的，省去了很多上下文切换线程的时间；</li><li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</li><li>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li><li>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li></ol><h3 id="4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用"><a href="#4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用" class="headerlink" title="4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用"></a>4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用</h3><ol><li>哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。<ol><li>集群监控：负责监控Redis master和slave进程是否正常工作</li><li>消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li><li>故障转移：如果master node挂掉了，会自动转移到slave node上</li><li>配置中心：如果故障转移发生了，通知client客户端新的master地址</li></ol></li><li>复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。<ol><li>从数据库向主数据库发送sync(数据同步)命令。</li><li>主数据库接收同步命令后，会保存快照，创建一个RDB文件。</li><li>当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。</li><li>主数据库将缓冲区的所有写命令发给从服务器执行。</li><li>以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。</li></ol></li></ol><h3 id="5-Redis-主从复制、哨兵和集群这三个有什么区别"><a href="#5-Redis-主从复制、哨兵和集群这三个有什么区别" class="headerlink" title="5. Redis 主从复制、哨兵和集群这三个有什么区别"></a>5. Redis 主从复制、哨兵和集群这三个有什么区别</h3><p>主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。</p><ol><li>主从模式：读写分离，备份，一个Master可以有多个Slaves。</li><li>哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li><li>集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li></ol><h3 id="6-Redis-Cluster集群"><a href="#6-Redis-Cluster集群" class="headerlink" title="6. Redis Cluster集群"></a>6. Redis Cluster集群</h3><p>Redis Cluster，是Redis 3.0开始引入的分布式存储方案。<br>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p><ul><li>集群的作用：<ol><li>数据分区：数据分区(或称数据分片)是集群最核心的功能。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</li></ol></li></ul><h4 id="6-1-Redis-Cluster集群的搭建可以分为四步："><a href="#6-1-Redis-Cluster集群的搭建可以分为四步：" class="headerlink" title="6.1 Redis Cluster集群的搭建可以分为四步："></a>6.1 Redis Cluster集群的搭建可以分为四步：</h4><ol><li><strong>启动节点</strong>：将节点以集群模式启动，此时节点是独立的，并没有建立联系；</li><li><strong>节点握手</strong>：让独立的节点连成一个网络；</li><li><strong>分配槽</strong>：将16384个槽分配给主节点；</li><li><strong>指定主从关系</strong>：为从节点指定主节点。</li></ol><h4 id="6-2-Redis-Cluster工作原理"><a href="#6-2-Redis-Cluster工作原理" class="headerlink" title="6.2 Redis Cluster工作原理"></a>6.2 Redis Cluster工作原理</h4><ul><li>客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点</li><li>根据公式<code>HASH_SLOT=CRC16(key) mod 16384</code>，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         CRC16(key)    |  0~5460   | &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">         mode 16384    |</span><br><span class="line">Client --------------&gt; | 5461~10922| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">                       |</span><br><span class="line">                       |10923~10383| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br></pre></td></tr></table></figure><h4 id="6-3-Redis-Cluster优点"><a href="#6-3-Redis-Cluster优点" class="headerlink" title="6.3 Redis Cluster优点:"></a>6.3 Redis Cluster优点:</h4><ol><li>无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master</li><li>可以进行水平扩容</li><li>支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。</li></ol><h4 id="6-4-Redis-Cluster缺点"><a href="#6-4-Redis-Cluster缺点" class="headerlink" title="6.4 Redis Cluster缺点:"></a>6.4 Redis Cluster缺点:</h4><ol><li>批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）</li><li>资源隔离性较差，容易出现相互影响的情况。</li></ol><h4 id="6-5-Redis-Cluster总结："><a href="#6-5-Redis-Cluster总结：" class="headerlink" title="6.5 Redis Cluster总结："></a>6.5 Redis Cluster总结：</h4><ol><li>Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。</li><li>单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。</li><li>不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。</li><li>如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。</li><li>Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。</li><li>Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis本质上是一个Key-Value类型的&lt;strong&gt;内存数据库&lt;/strong&gt;，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。
    
    </summary>
    
      <category term="Redis" scheme="http://chaooo.github.io/categories/Redis/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL事务处理与并发控制</title>
    <link href="http://chaooo.github.io/article/20190907.html"/>
    <id>http://chaooo.github.io/article/20190907.html</id>
    <published>2019-09-07T15:31:48.000Z</published>
    <updated>2019-11-03T15:42:24.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MySQL事务"><a href="#1-MySQL事务" class="headerlink" title="1. MySQL事务"></a>1. MySQL事务</h3><ol><li>事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；<a id="more"></a></li><li>事务的特性(ACID)：<ul><li><strong>原子性</strong>（Atomicity，或称不可分割性）：最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚</li><li><strong>一致性</strong>（Consistency）：事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则， 不会因为出现系统意外等原因导致状态的不一致</li><li><strong>隔离性</strong>（Isolation，又称独立性）：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）</li><li><strong>持久性</strong>（Durability）：事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失</li></ul></li><li>事务的开启与提交模式<ul><li>若参数autocommit=0，自动开启<strong>手动提交</strong></li><li>若参数autocommit=1（系统默认值），又分为两种状态：<ul><li><strong>自动开启自动提交</strong>：用户的每一个操作都是一个完整的事务周期。</li><li><strong>手动开启手动提交</strong>：从用户执行<code>start transaction</code>命令到用户执行<code>commit</code>命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。<ul><li><code>begin</code> 或者 <code>start transaction</code>   – 开启事务</li><li><code>commit</code> 或者 <code>rollback</code>           – 事务提交或回滚</li></ul></li></ul></li></ul></li></ol><h4 id="1-1-事务的隔离级别"><a href="#1-1-事务的隔离级别" class="headerlink" title="1.1 事务的隔离级别"></a>1.1 事务的隔离级别</h4><ul><li>查看/设置隔离级别<ul><li>查看：<code>SELECT @@tx_isolation</code></li><li>设置：<code>set tx_isolation=&#39;xxx&#39;</code></li></ul></li></ul><ol><li><strong>读未提交</strong>（Read Uncommitted）<ul><li>事务未提交对其他事务也是可见的，脏读（dirty read）</li></ul></li><li><strong>读提交</strong>（Read Committed）–解决脏读问题 <ul><li>一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）</li></ul></li><li><strong>可重复读</strong>（Repeatable Read）–解决不可重复读问题<ul><li>在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题</li></ul></li><li><strong>串行化</strong>（Serializable）–解决所有问题<ul><li>最高的隔离级别，通过强制事务的串行执行，但是会导致大量超时以及锁争用问题</li></ul></li></ol><blockquote><p>Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别。<br>事务的隔离级别的实现：锁、MVCC（多版本并发控制 Multiversion Currency Control）。</p></blockquote><h4 id="1-2-事务的七大传播行为"><a href="#1-2-事务的七大传播行为" class="headerlink" title="1.2 事务的七大传播行为"></a>1.2 事务的七大传播行为</h4><p>Spring在TransactionDefinition接口中规定了<strong>7种</strong>类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。</p><ul><li>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时<strong>事务如何传播</strong>。<ul><li><code>@Transactional(propagation = Propagation.REQUIRED)</code></li></ul></li></ul><ol><li>第一类：运行在同一个事务<ul><li><strong><code>REQUIRED</code></strong>（required）：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li><li><code>SUPPORTS</code>（supports）：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li><li><code>MANDATORY</code>（mandatory）：支持当前事务，如果当前没有事务，就抛出异常</li></ul></li><li>第二类：运行在不同事务<ul><li><strong><code>REQUIRES_NEW</code></strong>（requires new）：新建事务，如果当前存在事务，把当前事务挂起</li><li><code>NOT_SUPPORTED</code>(not supported)：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li><code>NEVER</code>（never）：以非事务方式执行，如果当前存在事务，则抛出异常</li></ul></li><li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul><li><strong><code>NESTED</code></strong>（nested）：如果当前事务存在，则嵌套事务执行</li></ul></li></ol><h3 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h3><p>锁是用于管理不同事务对共享资源的并发访问，InnoDB存储引擎支持行锁和表锁（InnoDB表锁是另类的行锁）</p><ul><li>InnoDB行锁<ul><li>共享锁（读锁）：Shared Locks</li><li>排它锁（写锁）：Exclusive Locks</li></ul></li><li>InnoDB表锁<ul><li>意向锁共享锁（IS）：Intention Shared Locks</li><li>意向锁排它锁（IX）：Intention Exclusive Locks</li><li>自增锁：AUTO-INC Locks</li></ul></li><li>行锁的算法<ul><li>记录锁 Record Locks</li><li>间隙锁 Gap Locks</li><li>临键锁 Next-key Locks</li></ul></li></ul><h4 id="2-1-共享锁-Shared-amp-排他锁-Exclusive"><a href="#2-1-共享锁-Shared-amp-排他锁-Exclusive" class="headerlink" title="2.1 共享锁(Shared) &amp; 排他锁(Exclusive)"></a>2.1 共享锁(Shared) &amp; 排他锁(Exclusive)</h4><p>它们都是标准的<strong>行级锁</strong>。</p><ul><li>共享锁（S锁）：读锁，读锁允许多个连接可以同一时刻<strong>并发的读</strong>取同一资源,互不干扰，但是只能读不能修改;<ul><li>加锁： <code>select * from users WHERE id=1</code><strong><code>LOCK IN SHARE MODE</code></strong>; </li><li>解锁：<strong><code>commit</code></strong>或<strong><code>rollback</code></strong></li></ul></li><li>排他锁（X锁）：写锁，一个写锁会<strong>阻塞</strong>其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。<ul><li>加锁： <code>select * from users WHERE id=1</code><strong><code>FOR UPDATE</code></strong>; </li><li><strong><code>delete/update/insert 默认上 X 锁</code></strong></li><li>解锁：<strong><code>commit</code></strong>或<strong><code>rollback</code></strong></li></ul></li></ul><blockquote><p>注意：所谓共享锁、排他锁其实均是<strong>锁机制本身的策略</strong>，通过这两种策略对锁做了区分。</p><ul><li>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的。</li><li>只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）</li></ul></blockquote><h4 id="2-2-意向锁-Intention-amp-自增锁-AUTO-INC"><a href="#2-2-意向锁-Intention-amp-自增锁-AUTO-INC" class="headerlink" title="2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)"></a>2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)</h4><p>它们都是标准的<strong>表级锁</strong>。</p><ul><li><strong>意向锁</strong>（Intention Locks）：表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，才被允许对该表加行锁(S或X)。(即一个数据行加锁前必须先取得该表的意向锁)<ul><li>意向锁(IS、IX)是InnoDB数据操作之前<strong>自动加的</strong>，不需要用户干预 </li><li>意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li></ul></li><li><strong>自增锁</strong>（AUTO-INC Locks）：针对自增列自增长的一个特殊的表级别锁<ul><li><code>show variables like &#39;innodb_autoinc_lock_mode&#39;</code>;</li><li>默认取值1，代表连续，事务未提交ID永久丢失</li></ul></li></ul><h4 id="2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key"><a href="#2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key" class="headerlink" title="2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)"></a>2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)</h4><ul><li><strong>临键锁 Next-key locks</strong>： <ul><li><strong>锁住记录+区间（左开右闭）</strong></li><li>Innodb<strong>默认</strong>行锁算法</li><li>当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、&lt;、&gt;等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，<strong>锁住索引的记录+区间（左开右闭）</strong></li></ul></li><li><strong>间隙锁 Gap locks</strong>：<ul><li><strong>锁住数据不存在的区间（左开右开）</strong></li><li>当记录不存在，临键锁<strong>退化</strong>为Gap锁</li><li>当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，Gap只在RR事务隔离级别存在，<strong>锁住索引不存在的区间（左开右开</strong>） </li></ul></li><li><strong>记录锁 Record locks</strong>： <ul><li><strong>锁住具体的索引项</strong></li><li>唯一性(主键/唯一)索引，条件为<strong>精准匹配，退化</strong>成Record锁</li><li>当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，<strong>锁住具体的索引项</strong></li></ul></li></ul><h4 id="2-4-死锁的产生与避免"><a href="#2-4-死锁的产生与避免" class="headerlink" title="2.4 死锁的产生与避免"></a>2.4 死锁的产生与避免</h4><ul><li>死锁<ul><li>在InnoDB中，锁是逐步获得的，就造成了死锁的可能（2个或以上并发事务）</li><li>每个事务都持有锁（或者是已经在等待锁）; </li><li>每个事务都需要再继续持有锁；<strong>事务之间产生加锁的循环等待</strong>，形成死锁。</li></ul></li><li>死锁的产生与避免<ol><li>类似的业务逻辑以固定的<strong>顺序访问</strong>表和行。</li><li>大事务拆小。大事务更倾向于死锁，如果业务允许，将<strong>大事务拆小</strong>。</li><li>在同<strong>一个事务</strong>中，尽可能做到<strong>一次锁定</strong>所需要的所有资源，减少死锁概 率。</li><li>降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择</li><li>为表添加<strong>合理的索引</strong>。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）</li></ol></li></ul><h3 id="3-MVCC-多版本并发控制"><a href="#3-MVCC-多版本并发控制" class="headerlink" title="3. MVCC(多版本并发控制)"></a>3. MVCC(多版本并发控制)</h3><p>Multiversion concurrency control (多版本并发控制)：</p><ul><li><strong>MVCC</strong> 就是 <strong>同一份数据临时保留多版本的一种方式，进而实现并发控制</strong></li><li>是行级锁的变种，它在普通读情况下<strong>避免了加锁操作</strong>，因此<strong>开销更低</strong>。</li><li>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用<strong>时间戳或者事务ID</strong>去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。<strong>读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据</strong>。</li></ul><h4 id="3-1-MVCC逻辑流程"><a href="#3-1-MVCC逻辑流程" class="headerlink" title="3.1 MVCC逻辑流程"></a>3.1 MVCC逻辑流程</h4><ul><li>在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列<ul><li><code>DB_TRX_ID</code>：数据行的版本号</li><li><code>DB_ROLL_PT</code>：删除版本号</li></ul></li></ul><ol><li>MVCC逻辑流程-插入<ul><li>在插入数据的时候，会把全局事务ID记录到列<code>DB_TRX_ID</code>中去</li></ul></li><li>MVCC逻辑流程-删除<ul><li>执行完删除SQL之后数据并没有被真正删除，而是对删除版本号(<code>DB_ROLL_PT</code>)做改变</li></ul></li><li>MVCC逻辑流程-修改<ul><li>修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前事务ID，最后把旧数据的删除版本号标记为新数据行版本号的值(即当前事务ID)。</li></ul></li><li>MVCC逻辑流程-查询<ul><li>查找数据行版本号早于当前事务ID的数据行记录</li><li>也就是说，数据行的版本号要小于或等于 当前事务ID，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据</li><li>查找删除版本号要么为NULL，要么大于当前事务版本号的记录</li><li>这样确保查询出来的数据行记录在事务开启之前没有被删除</li></ul></li></ol><blockquote><p>MySQL解决不可重复读和脏读并不是单纯利用 MVCC 机制来实现的。</p></blockquote><h3 id="4-MySQL事务日志-Undo-Log和Redo-Log"><a href="#4-MySQL事务日志-Undo-Log和Redo-Log" class="headerlink" title="4. MySQL事务日志(Undo Log和Redo Log)"></a>4. MySQL事务日志(Undo Log和Redo Log)</h3><p>innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。<br>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：</p><ol><li>redo log通常是<strong>物理日志</strong>，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</li><li>undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，根据每行记录进行记录。</li></ol><p>s</p><h4 id="4-1-Undo-Log"><a href="#4-1-Undo-Log" class="headerlink" title="4.1 Undo Log"></a>4.1 Undo Log</h4><ul><li>Undo Log定义：<ul><li>undo意为取消，以撤销操作为目的，返回指定某个状态的操作</li><li>undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log) </li></ul></li><li><strong>UndoLog是为了实现事务的原子性而出现的产物</strong></li><li>Undo Log实现事务原子性：<ul><li>事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份 将数据恢复到事务开始之前的状态</li></ul></li><li><strong>UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制</strong></li><li>Undo log实现多版本并发控制：<ul><li>事务未提交之前，Undo保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供 其他并发事务进行快照读</li></ul></li></ul><h4 id="4-2-当前读-amp-快照读"><a href="#4-2-当前读-amp-快照读" class="headerlink" title="4.2 当前读 &amp; 快照读"></a>4.2 当前读 &amp; 快照读</h4><ul><li>快照读：<ul><li>SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读 innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成 </li></ul></li><li>当前读：<ul><li>SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改 UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读</li></ul></li></ul><h4 id="4-3-Redo-Log"><a href="#4-3-Redo-Log" class="headerlink" title="4.3 Redo Log"></a>4.3 Redo Log</h4><ul><li>Undo Log定义： <ul><li>Redo，顾名思义就是重做。以恢复操作为目的，重现操作；</li><li>Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)</li></ul></li><li>Redo log的持久： <ul><li>不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体 的落盘策略可以进行配置</li></ul></li><li><strong>RedoLog是为了实现事务的持久性而出现的产物</strong></li><li>Redo Log实现事务持久性： <ul><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</li></ul></li><li>一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所 以Redo log的写入是日志文件循环写入的</li></ul><h3 id="附-58同城数据库设计30条军规"><a href="#附-58同城数据库设计30条军规" class="headerlink" title="附: 58同城数据库设计30条军规"></a>附: 58同城数据库设计30条军规</h3><ul><li>军规适用场景：并发量大、数据量大的互联网业务 </li><li>解读：讲解原因，<strong>解读比军规更重要</strong> </li></ul><h4 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h4><ol><li>必须使用InnoDB存储引擎<ul><li>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</li></ul></li><li>必须使用UTF8字符集 UTF-8MB4<ul><li>解读：万国码，无需转码，无乱码风险，节省空间</li></ul></li><li>数据表、数据字段必须加入中文注释<ul><li>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</li></ul></li><li>禁止使用存储过程、视图、触发器、Event<ul><li>解读：<strong>高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务 层”</strong>，并发量大的情况下，这些功能很可能将数据库拖死，<strong>业务逻辑放到服务层具备更好的 扩展性，能够轻易实现“增机器就加性能”</strong>。数据库擅长存储与索引，CPU计算还是上移吧</li></ul></li><li>禁止存储大文件或者大照片<ul><li>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI 多好</li></ul></li></ol><h4 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h4><ol start="6"><li>只允许<strong>使用内网域名，而不是ip连接数据库</strong></li><li>线上环境、开发环境、测试环境数据库内网域名遵循命名规范<ul><li>业务名称：xxx，线上环境：xxx.db，开发环境：xxx.rdb，测试环境：xxx.tdb </li><li>从库在名称后加-s标识，备库在名称后加-ss标识 线上从库：xxx-s.db 线上备库：xxx-sss.db</li></ul></li><li>库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止 拼音英文混用</li><li>表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</li></ol><h4 id="三、表设计规范"><a href="#三、表设计规范" class="headerlink" title="三、表设计规范"></a>三、表设计规范</h4><ol start="10"><li>单实例表数目必须小于500</li><li>单表列数目必须小于30</li><li>表必须有主键，例如自增主键<ul><li>解读：<ol><li>主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和 内存的使用</li><li>主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类 型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li><li>无主键的表删除，在row模式的主从架构，会导致备库夯住</li></ol></li></ul></li><li>禁止使用外键，如果有外键完整性约束，需要应用程序控制<ul><li>解读：<strong>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响 sql 的性能</strong>，甚至会造成死锁。高并发情况下容易造成数据库性能，<strong>大数据高并发业务场景 数据库使用以性能优先</strong></li></ul></li></ol><h4 id="四、字段设计规范"><a href="#四、字段设计规范" class="headerlink" title="四、字段设计规范"></a>四、字段设计规范</h4><ol start="14"><li>必须把字段定义为NOT NULL并且提供默认值<ul><li>解读： <ol><li>null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</li><li>null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条 件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li><li>null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标 识</li><li>对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、 not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记 录，查询结果就不会包含name为null值的记录</li></ol></li></ul></li><li>禁止使用TEXT、BLOB类型<ul><li>解读：会浪费更多的磁盘和内存空间，<strong>非必要的大量的大字段查询会淘汰掉热数据，导致内 存命中率急剧降低，影响数据库性能</strong></li></ul></li><li>禁止使用小数存储货币<ul><li>解读：使用整数吧，小数容易导致钱对不上</li></ul></li><li>必须使用varchar(20)存储手机号<ul><li>解读：<ol><li>涉及到区号或者国家代号，可能出现+-()</li><li>手机号会去做数学运算么？</li><li>varchar可以支持模糊查询，例如：like“138%”</li></ol></li></ul></li><li>禁止使用ENUM，可使用TINYINT代替<ul><li>解读：<ol><li>增加新的ENUM值要做DDL操作</li><li>ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</li></ol></li></ul></li></ol><h4 id="五、索引设计规范"><a href="#五、索引设计规范" class="headerlink" title="五、索引设计规范"></a>五、索引设计规范</h4><ol start="19"><li>单表索引建议控制在5个以内</li><li>单索引字段数不允许超过5个<ul><li>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</li></ul></li><li>禁止在更新十分频繁、区分度不高的属性上建立索引<ul><li>解读：<ol><li>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</li><li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性 能与全表扫描类似</li></ol></li></ul></li><li>建立组合索引，必须把区分度高的字段放在前面<ul><li>解读：能够更加有效的过滤数据</li></ul></li></ol><h4 id="六、SQL使用规范"><a href="#六、SQL使用规范" class="headerlink" title="六、SQL使用规范"></a>六、SQL使用规范</h4><ol start="23"><li>禁止使用SELECT *，只获取必要的字段，需要显示说明列属性<ul><li>解读：<ol><li>读取不需要的列会增加CPU、IO、NET消耗</li><li>不能有效的利用覆盖索引</li></ol></li></ul></li><li>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性<ul><li>解读：容易在增加或者删除字段后出现程序BUG</li></ul></li><li>禁止使用属性隐式转换<ul><li>解读：SELECT uid FROM t_user WHERE phone=13812345678 <strong>会导致全表扫描</strong>，而不 能命中phone索引</li></ul></li><li>禁止在WHERE条件的属性上使用函数或者表达式<ul><li>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全 表扫描 正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</li></ul></li><li>禁止负向查询，以及%开头的模糊查询<ul><li>解读：<ol><li>负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</li><li>%开头的模糊查询，会导致全表扫描</li></ol></li></ul></li><li>禁止大表使用JOIN查询，禁止大表使用子查询<ul><li>解读：<strong>会产生临时表</strong>，消耗较多内存与CPU，极大影响数据库性能</li></ul></li><li>禁止使用OR条件，必须改为IN查询<ul><li>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费 更多的CPU帮助实施查询优化呢？</li></ul></li><li>应用程序必须捕获SQL异常，并有相应处理</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-MySQL事务&quot;&gt;&lt;a href=&quot;#1-MySQL事务&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL事务&quot;&gt;&lt;/a&gt;1. MySQL事务&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL索引的使用及优化</title>
    <link href="http://chaooo.github.io/article/20190905.html"/>
    <id>http://chaooo.github.io/article/20190905.html</id>
    <published>2019-09-05T09:04:12.000Z</published>
    <updated>2019-11-02T05:51:22.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-索引的基本概念"><a href="#1-索引的基本概念" class="headerlink" title="1. 索引的基本概念"></a>1. 索引的基本概念</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><ul><li>索引意义：<ol><li>索引能极大的减少存储引擎需要扫描的数据量</li><li>索引可以把随机IO变成顺序IO</li><li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表<a id="more"></a></li></ol></li><li>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引。</li></ul><h3 id="2-索引的适用场景"><a href="#2-索引的适用场景" class="headerlink" title="2. 索引的适用场景"></a>2. 索引的适用场景</h3><h4 id="2-1-适合建索引的场景"><a href="#2-1-适合建索引的场景" class="headerlink" title="2.1 适合建索引的场景"></a>2.1 适合建索引的场景</h4><ol><li>表的主键自动建立唯一索引</li><li>表的字段唯一约束</li><li>直接条件查询的字段（在SQL中用于条件约束的字段）</li><li>查询中与其它表关联的字段</li><li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li><li>查询中统计或分组统计的字段</li><li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li><li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li><li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li><li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li></ol><h4 id="2-2-不适合建索引的场景"><a href="#2-2-不适合建索引的场景" class="headerlink" title="2.2 不适合建索引的场景"></a>2.2 不适合建索引的场景</h4><ol><li>表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）</li><li>经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。</li><li>数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）</li></ol><h3 id="3-MySQl中索引的结构（B-树）"><a href="#3-MySQl中索引的结构（B-树）" class="headerlink" title="3. MySQl中索引的结构（B+树）"></a>3. MySQl中索引的结构（B+树）</h3><h4 id="3-1-基本概念："><a href="#3-1-基本概念：" class="headerlink" title="3.1 基本概念："></a>3.1 基本概念：</h4><ol><li>二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；</li><li>B树：多路搜索树，每个节点存储M/2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；</li><li>B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；</li><li>B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1/2提高到2/3；</li></ol><h4 id="3-2-B-树的特性："><a href="#3-2-B-树的特性：" class="headerlink" title="3.2 B+树的特性："></a>3.2 B+树的特性：</h4><ol><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>不可能在非叶子结点命中；</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>更适合文件索引系统；</li></ol><h4 id="3-3-B-树的三个特点："><a href="#3-3-B-树的三个特点：" class="headerlink" title="3.3 B+树的三个特点："></a>3.3 B+树的三个特点：</h4><ol><li>关键字数和子树相同<ul><li>在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</li></ul></li><li>非叶子节点仅用作索引，它的关键字和子节点有重复元素<ul><li>除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</li><li>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</li></ul></li><li>叶子节点用指针连在一起<ul><li>叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</li></ul></li></ol><blockquote><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。<br>B+ 树的查找必会查到叶子节点，更加稳定。<br>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p></blockquote><h4 id="3-4-B-树的三个优点："><a href="#3-4-B-树的三个优点：" class="headerlink" title="3.4 B+ 树的三个优点："></a>3.4 B+ 树的三个优点：</h4><ul><li>层级更低，IO 次数更少</li><li>每次都需要查询到叶子节点，查询性能稳定</li><li>叶子节点形成有序链表，范围查询方便</li></ul><h3 id="4-索引的优化"><a href="#4-索引的优化" class="headerlink" title="4. 索引的优化"></a>4. 索引的优化</h3><h4 id="4-1-优化法则（口诀）："><a href="#4-1-优化法则（口诀）：" class="headerlink" title="4.1 优化法则（口诀）："></a>4.1 优化法则（口诀）：</h4><ul><li>全值匹配我最爱，最左前缀要遵守</li><li>带头大哥不能死，中间兄弟不能断</li><li>索引列上无计算，范围之后全失效</li><li>like百分写最右，覆盖索引不写星</li><li>不等控制还有or，索引失效要少用</li><li>var引号不能丢，SQL优化也不难</li></ul><h4 id="4-2-具体描述"><a href="#4-2-具体描述" class="headerlink" title="4.2 具体描述"></a>4.2 具体描述</h4><ol><li>全值匹配<ul><li>怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多</li></ul></li><li>最佳左前缀法则<ul><li>指的是查询从索引的最左前列开始并且不跳过索引中的列。</li><li>例如：复合索引<code>A-&gt;B-&gt;C</code>，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。</li></ul></li><li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右面的列<ul><li>例如：<code>select t from test where A=1 and B&gt;2 and C=3</code>，那么B&gt;2后的查询条件失效。</li></ul></li><li>尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 <code>SELECT *</code>。</li><li>MySQL在使用不等于(<code>!=</code> 或<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描</li><li><code>is null</code>，<code>is not null</code> 也无法使用索引</li><li>like以通配符开头<code>(&#39;%abc...&#39;)</code>mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面<code>(&#39;abc...%&#39;)</code>的才能避免索引失效。</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li></ol><h3 id="5-in-和-exists区别及应用场景"><a href="#5-in-和-exists区别及应用场景" class="headerlink" title="5. in 和 exists区别及应用场景"></a>5. in 和 exists区别及应用场景</h3><h4 id="5-1-in-和-exists的区别"><a href="#5-1-in-和-exists的区别" class="headerlink" title="5.1 in 和 exists的区别:"></a>5.1 in 和 exists的区别:</h4><ul><li>如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。</li><li>其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</li><li>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</li></ul><h4 id="5-2-not-in-和not-exists"><a href="#5-2-not-in-和not-exists" class="headerlink" title="5.2 not in 和not exists"></a>5.2 not in 和not exists</h4><ul><li>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；</li><li>而not extsts 的子查询依然能用到表上的索引。</li><li>所以无论那个表大，用not exists都比not in要快</li></ul><h3 id="6-order-by-和-group-by-优化"><a href="#6-order-by-和-group-by-优化" class="headerlink" title="6. order by 和 group by 优化"></a>6. order by 和 group by 优化</h3><p>索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。</p><h4 id="6-1-提高ORDER-BY速度的技巧"><a href="#6-1-提高ORDER-BY速度的技巧" class="headerlink" title="6.1 提高ORDER BY速度的技巧"></a>6.1 提高ORDER BY速度的技巧</h4><ol><li>ORDER BY时不要使用SELECT *，只查需要的字段。</li><li>增大<code>sort_buffer_size</code>参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）</li><li>增大<code>max_length_for_sort_data</code>参数大小</li></ol><h4 id="6-2-GROUP-BY的优化"><a href="#6-2-GROUP-BY的优化" class="headerlink" title="6.2 GROUP BY的优化"></a>6.2 GROUP BY的优化</h4><ol><li>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。</li><li>当无法使用索引列，考虑增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>的参数设置。</li><li>WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。</li></ol><blockquote><p>注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)</p></blockquote><p>一般性建议：</p><ul><li>对于单值索引，尽量选择针对query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。</li><li>在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li></ul><blockquote><p>参考链接：<a href="https://www.zhihu.com/people/hen-six-49/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/hen-six-49/activities</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-索引的基本概念&quot;&gt;&lt;a href=&quot;#1-索引的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 索引的基本概念&quot;&gt;&lt;/a&gt;1. 索引的基本概念&lt;/h3&gt;&lt;p&gt;索引是为了加速对表中数据行的检索而创建的一种分散存储的&lt;strong&gt;数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引意义：&lt;ol&gt;
&lt;li&gt;索引能极大的减少存储引擎需要扫描的数据量&lt;/li&gt;
&lt;li&gt;索引可以把随机IO变成顺序IO&lt;/li&gt;
&lt;li&gt;索引可以帮助我们在进行分组、排序等操作时，避免使用临时表
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL性能优化基础</title>
    <link href="http://chaooo.github.io/article/20190901.html"/>
    <id>http://chaooo.github.io/article/20190901.html</id>
    <published>2019-09-01T13:36:46.000Z</published>
    <updated>2019-11-03T15:42:08.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MySQL基础操作"><a href="#1-MySQL基础操作" class="headerlink" title="1. MySQL基础操作"></a>1. MySQL基础操作</h3><h4 id="1-1-MySQL备份与恢复"><a href="#1-1-MySQL备份与恢复" class="headerlink" title="1.1 MySQL备份与恢复"></a>1.1 MySQL备份与恢复</h4><ol><li>备份：在mysql的安装目录的bin目录下有<strong>mysqldump命令</strong>，可以完成对数据库的备份。 <ul><li>语法：<code>mysqldump -u 用户名 -p 数据库名&gt; 磁盘SQL文件路径</code> <a id="more"></a></li><li>由于mysqldump命令不是sql命令，需要在<strong>dos窗口下使用</strong>。</li><li>仅仅只会备份数据库中的表和数据，恢复时需要先手动创建数据库。</li></ul></li><li>恢复：先手动创建数据库：<code>create database 数据库名</code><ul><li>然后dos窗口：<code>mysql -u 用户名-p 导入库名&lt; 磁盘SQL文件绝对路径</code></li></ul></li></ol><h4 id="1-2-MySQL事务基础"><a href="#1-2-MySQL事务基础" class="headerlink" title="1.2 MySQL事务基础"></a>1.2 MySQL事务基础</h4><ol><li>特性(ACID)：<strong>原子性</strong>（Atomicity，或称不可分割性）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation，又称独立性）、<strong>持久性</strong>（Durability）。</li><li>事务隔离级别：<strong>读未提交</strong>（Read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（Serializable）。</li><li>MYSQL事务处理主要有两种方法： <ol><li>用 BEGIN, ROLLBACK, COMMIT来实现:<ul><li>BEGIN 开始一个事务</li><li>COMMIT 事务确认 </li><li>ROLLBACK 事务回滚</li></ul></li><li>直接用 SET 来改变 MySQL 的自动提交模式: <ul><li>SET AUTOCOMMIT=0 禁止自动提交</li><li>SET AUTOCOMMIT=1 开启自动提交</li></ul></li></ol></li><li>事务并发操作出现几种问题: 丢失修改数据、读“脏”数据、数据不一致</li></ol><h4 id="1-3-查看设置MySQL编码"><a href="#1-3-查看设置MySQL编码" class="headerlink" title="1.3 查看设置MySQL编码"></a>1.3 查看设置MySQL编码</h4><ol><li><p>查看：<code>mysql&gt; show variables like &#39;character%&#39;</code></p></li><li><p>设置: # <code>vi /etc/my.cnf</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">character‐set‐server=utf8</span><br><span class="line">collation‐server=utf8_general_ci</span><br><span class="line">sql_mode=<span class="string">'NO_ENGINE_SUBSTITUTION'</span></span><br><span class="line">[mysql] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[mysql.server] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[mysqld_safe] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[client] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8</span><br></pre></td></tr></table></figure></li><li><p>mysql的主配置文件: <code>/etc/my.cnf</code></p></li><li><p>数据库文件存放位置: <code>/var/lib/mysql</code></p></li><li><p>数据库的日志输出存放位置: <code>/var/log/mysql</code></p></li><li><p>端口: <code>Netstat –nltp</code> 看是否能找到3306的端口</p></li></ol><h4 id="1-4-范式"><a href="#1-4-范式" class="headerlink" title="1.4 范式"></a>1.4 范式</h4><p>概念：范式就是符合某一规范级别的关系模式的集合。共有7种范式：<code>1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF⊃6NF</code></p><ol><li>第一范式(1NF, First Normal Form)：字段值具有<strong>原子性</strong>,不能再分(所有关系型数据库系统都满足第一范式);<ul><li>例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;</li></ul></li><li>第二范式(2NF, Second Normal Form)：一个表<strong>必须有主键</strong>,即每行数据都能被唯一的区分(2NF必须先满足第一范式);</li><li>第三范式(3NF, Third Normal Form)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表<strong>不能有冗余字段</strong>(3NF必须先满足第二范式);<ul><li>备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;</li><li>例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</li></ul></li></ol><h3 id="2-SQL语句优化"><a href="#2-SQL语句优化" class="headerlink" title="2. SQL语句优化"></a>2. SQL语句优化</h3><h4 id="2-1-通过慢查日志发现有问题的SQL"><a href="#2-1-通过慢查日志发现有问题的SQL" class="headerlink" title="2.1 通过慢查日志发现有问题的SQL"></a>2.1 通过慢查日志发现有问题的SQL</h4><ol><li>查询次数多且每次查询占用时间长的sql<ul><li>通常为<strong>pt-query-digest</strong>分析的前几个查询；该工具可以很清楚的看出每个SQL执行的次数及百分比等信息，执行的次数多，占比比较大的SQL</li></ul></li><li>IO大的sql<ul><li>注意pt-query-digest分析中的Rows examine项。扫描的行数越多，IO越大。</li></ul></li><li>未命中的索引的SQL<ul><li>注意pt-query-digest分析中的Rows examine 和Rows Send的对比。说明该SQL的索引命中率不高，对于这种SQL，我们要重点进行关注。</li></ul></li><li>通过explain查询分析SQL的执行计划, SQL的执行计划侧面反映出了SQL的执行效率，</li></ol><h4 id="2-2-常见SQL优化手段"><a href="#2-2-常见SQL优化手段" class="headerlink" title="2.2 常见SQL优化手段"></a>2.2 常见SQL优化手段</h4><ol><li>函数Max()的优化<ul><li>在求max的字段<strong>建索引</strong></li></ul></li><li>函数Count()的优化：<ul><li>Count(*):是包含null值；Count(id)：不包含null值</li></ul></li><li>子查询的优化<ul><li>子查询是我们在开发过程中经常使用的一种方式，在通常情况下，需要把<strong>子查询优化为join查询</strong>但在优化是需要注意关联键是否有一对多的关系，要注意重复数据(distinct去重)。</li><li>在用Join进行多表联合查询时，我们通常使用On来建立两个表的关系。其实还有一个更方便的关键字，那就是Using（如果两个表的关联字段名是一样）。</li></ul></li><li>group by的优化: <ul><li>最好使用同一表中的列，在子查询中分组</li></ul></li><li>Limit查询的优化：Limit常用于分页处理，时常会伴随order by从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。<ul><li>优化步骤1：使用有索引的列或主键进行order by操作，因为大家知道，innodb是按照主键的逻辑顺序进行排序的。可以避免很多的IO操作。</li><li>优化步骤2：记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）</li><li>注意事项：主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足一页的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可。</li></ul></li></ol><h3 id="3-索引的优化"><a href="#3-索引的优化" class="headerlink" title="3. 索引的优化"></a>3. 索引的优化</h3><h4 id="3-1-索引基础概念"><a href="#3-1-索引基础概念" class="headerlink" title="3.1 索引基础概念"></a>3.1 索引基础概念</h4><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><ul><li>索引的建立是表中<strong>比较有指向性的字段</strong>，相当于目录，比如说行政区域代码，同一个地域的行政区域代码都是相同的，那么给这一列加上索引，避免让它重复扫描，从而达到优化的目的！</li><li>创建索引：在执行create table语句时可以创建索引，也可以单独用create index或alter index来为表增加索引。<strong>不能用create index语句创建primary key索引</strong>。</li><li>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为primary key或unique索引。对于单列惟一性索引，这保证单列不包含重复的值。对于<strong>多列惟一性索引，保证多个值的组合不重复</strong>。</li><li>primary key索引和unique索引非常类似。事实上，<strong>primary key索引仅是一个具有名称PRIMARY的unique索引</strong>。</li><li>查看索引：<code>show index from tblname;</code>或<code>show keys from tblname;</code></li></ul><h4 id="3-2-索引的创建与删除"><a href="#3-2-索引的创建与删除" class="headerlink" title="3.2 索引的创建与删除"></a>3.2 索引的创建与删除</h4><ol><li>创建<strong>普通索引</strong>：<ul><li>方式1：<code>create index 索引名 on 表名(列名)</code></li><li>方式2：<code>alter table 表名 add index 索引名(列名)</code></li><li>方式3：创建表的时候直接指定: <code>,index [索引名] (列名)</code></li></ul></li><li>删除索引： <code>drop index [索引名] on 表名</code></li><li>唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>创建<strong>唯一索引</strong>：<ul><li>方式1：<code>create unique index 索引名 on 表名(列名)</code></li><li>方式2：<code>alter table 表名 add unique 索引名(列名)</code></li><li>方式3：创建表的时候直接指定: <code>,unique [索引名] (列名)</code></li></ul></li></ol><h4 id="3-3-使用索引的场景"><a href="#3-3-使用索引的场景" class="headerlink" title="3.3 使用索引的场景"></a>3.3 使用索引的场景</h4><ol><li>表的主键自动建立唯一索引</li><li>表的字段唯一约束</li><li>直接条件查询的字段（在SQL中用于条件约束的字段）</li><li>查询中与其它表关联的字段</li><li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li><li>查询中统计或分组统计的字段</li><li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li><li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li><li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li><li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li></ol><h4 id="3-4-索引的维护及优化（重复及冗余索引）"><a href="#3-4-索引的维护及优化（重复及冗余索引）" class="headerlink" title="3.4 索引的维护及优化（重复及冗余索引）"></a>3.4 索引的维护及优化（重复及冗余索引）</h4><p>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引</p><ul><li>重复索引：重复索引是指相同的列以相同的顺序建立的同类型的索引，如在primary key再建立唯一索引就是重复索引</li><li>冗余索引：冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，如对于innodb来说，每一个索引后面，实际上都会包含主键，这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。</li><li>工具：使用<strong><code>pt-duplicate-key-checker</code>工具检查重复及冗余索引</strong>: <code>pt-duplicate-key-checker -uroot -padmin -h 127.0.0.1</code></li><li>索引维护的方法: 由于业务变更，某些索引是后续不需要使用的，就要进行<strong>删除</strong>。</li><li>在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；<code>pt-index-usage -uroot -padmin /var/lib/mysql/mysql-host-slow.log</code></li></ul><h4 id="3-5-设计MySql索引的注意事项"><a href="#3-5-设计MySql索引的注意事项" class="headerlink" title="3.5 设计MySql索引的注意事项"></a>3.5 设计MySql索引的注意事项</h4><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p><ol><li><strong>创建索引</strong><ul><li>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。</li><li>但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</li></ul></li><li><strong>复合索引</strong><ul><li>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;</li><li>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为<strong>最佳左前缀特性</strong>。</li><li>因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</li></ul></li><li>索引不会包含有NULL值的列<ul><li>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有<strong>NULL值</strong>，那么这一列对于此复合索引就是<strong>无效</strong>的。所以我们在数据库设计时不要让字段的默认值为NULL。</li></ul></li><li>使用短索引<ul><li>对字符串列进行索引，如果可能应该<strong>指定一个前缀长度</strong>。</li><li>例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li></ul></li><li>排序的索引问题<ul><li>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列<strong>创建复合索引</strong>。</li></ul></li><li>like语句操作<ul><li>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” <strong>不会使用索引</strong>，而like “aaa%”可以使用索引。</li></ul></li><li>不要在列上进行运算<ul><li>select * from users where YEAR(adddate)</li></ul></li><li>不使用NOT IN操作<ul><li>NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以<strong>NOT EXISTS代替</strong></li></ul></li></ol><h3 id="4-MYSQL数据库设计规范与原则"><a href="#4-MYSQL数据库设计规范与原则" class="headerlink" title="4. MYSQL数据库设计规范与原则"></a>4. MYSQL数据库设计规范与原则</h3><h4 id="4-1-设计规范"><a href="#4-1-设计规范" class="headerlink" title="4.1 设计规范"></a>4.1 设计规范</h4><ol><li>命名规范<ul><li>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成</li><li>命名简洁明确,多个单词用下划线’_’分隔,长度不超过30个字符</li><li>除非是备份数据库可以加0-9的自然数,如：<code>&#39;user_db_20191210&#39;</code></li><li>表前缀可以有效的把相同关系的表显示在一起,如：<code>&#39;user_&#39;</code></li><li>每个表中必须有自增主键</li><li>表与表之间的相关联字段名称要求尽可能的相同</li></ul></li><li>字段类型规范<ul><li>用尽量少的存储空间来存数一个字段的数据, 例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);</li><li>IP地址最好使用int类型;</li><li>固定长度的类型最好使用char,例如：邮编;</li><li>能使用tinyint就不要使用smallint,int;</li><li>最好给每个字段一个默认值, 最好不能为null;</li></ul></li><li>索引规范<ul><li>命名简洁明确,例如：<code>user_login</code>表<code>user_name</code>字段的索引应为<code>user_name_index</code>唯一索引;</li><li>为每个表创建一个主键索引;</li><li>为每个表创建合理的索引;</li><li>建立复合索引请<strong>慎重</strong>;</li></ul></li></ol><h4 id="4-2-设计原则"><a href="#4-2-设计原则" class="headerlink" title="4.2 设计原则"></a>4.2 设计原则</h4><ol><li>核心原则<ul><li>不在数据库做运算;</li><li>cpu计算务必移至业务层;</li><li>控制列数量(字段少而精,字段数建议在20以内);</li><li>平衡范式与冗余(效率优先；往往牺牲范式)</li><li>拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch); </li></ul></li><li>字段类原则<ul><li>用好数值类型(用合适的字段类型节约空间);</li><li>字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);</li><li>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);</li><li>少用text类型(尽量使用varchar代替text字段); </li></ul></li><li>索引类原则<ul><li>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);</li><li>字符字段必须建前缀索引;</li><li>不在索引做列运算;</li><li>innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);</li><li>不用外键(由程序保证约束);</li></ul></li><li>sql类原则<ul><li>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);</li><li>简单的事务;</li><li>避免使用trig/func(触发器、函数不用客户端程序取而代之);</li><li>不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);</li><li>OR改写为IN(or的效率是n级别);</li><li>OR改写为UNION(mysql的索引合并很弱智);</li><li>避免负向%;</li><li>慎用count(*);</li><li>limit高效分页(limit越大，效率越低);</li><li>使用union all替代union(union有去重开销);</li><li>少用连接join;</li><li>使用group by;</li><li>请使用同类型比较;</li><li>打散批量更新;</li></ul></li></ol><h3 id="5-数据库结构的优化"><a href="#5-数据库结构的优化" class="headerlink" title="5. 数据库结构的优化"></a>5. 数据库结构的优化</h3><h4 id="5-1-选择合适的数据类型"><a href="#5-1-选择合适的数据类型" class="headerlink" title="5.1 选择合适的数据类型"></a>5.1 选择合适的数据类型</h4><p>数据类型的选择，重点在于“合适”二字</p><ol><li>使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）</li><li>使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）</li><li>尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）</li><li>尽量少用text类型，非用不可时最好考虑分表。</li></ol><h4 id="5-2-数据库表的范式化优化"><a href="#5-2-数据库表的范式化优化" class="headerlink" title="5.2 数据库表的范式化优化"></a>5.2 数据库表的范式化优化</h4><ol><li>表范式化<ul><li>范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</li></ul></li><li>反范式化<ul><li>反范式化是指为了查询效率的考虑把原本符合<strong>第三范式</strong>的表“适当”的<strong>增加冗余</strong>，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。</li></ul></li></ol><h4 id="5-3-数据库表的垂直拆分"><a href="#5-3-数据库表的垂直拆分" class="headerlink" title="5.3 数据库表的垂直拆分"></a>5.3 数据库表的垂直拆分</h4><p>所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。</p><ul><li>垂直拆分原则<ol><li>把不常用的字段表单独存放到一个表中。</li><li>把大字段独立存放到一个表中。</li><li>把经常一起使用的字段放到一起。</li></ol></li></ul><h4 id="5-4-数据库表的水平拆分"><a href="#5-4-数据库表的水平拆分" class="headerlink" title="5.4 数据库表的水平拆分"></a>5.4 数据库表的水平拆分</h4><p>表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的</p><ol><li>水平拆分原因<ul><li>如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。</li></ul></li><li>如何将数据平均分为N份<ol><li>对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。</li><li>针对不动的hashid把数据存储到不同的表中。</li></ol></li><li>水平拆分面临的挑战<ol><li>夸分区表进行数据查询<ul><li>前端业务统计：业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。</li></ul></li><li>统计及后台报表操作<ul><li>但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。</li></ul></li></ol></li></ol><h3 id="6-数据库系统配置优化"><a href="#6-数据库系统配置优化" class="headerlink" title="6. 数据库系统配置优化"></a>6. 数据库系统配置优化</h3><p>数据库是基于操作系统的，目前大多数MySQL都是安装在<strong>linux系统</strong>之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能</p><h4 id="6-1-操作系统的优化"><a href="#6-1-操作系统的优化" class="headerlink" title="6.1 操作系统的优化"></a>6.1 操作系统的优化</h4><p>网络方面的配置，要修改<code>/etc/sysctl.conf</code></p><ol><li>增加tcp支持的队列数<ul><li><code>net.ipv4.tcp_max_syn_backlog = 65535</code></li></ul></li><li>减少断开连接时，资源回收(tcp有连接状态)<ul><li><code>net.ipv4.tcp_max_tw_buckets = 8000</code></li><li><code>net.ipv4.tcp_tw_reuse = 1</code></li><li><code>net.ipv4.tcp_tw_recycle = 1</code></li><li><code>net.ipv4.tcp_fin_timeout = 10</code></li><li>说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。</li></ul></li></ol><h4 id="6-2-打开文件数的限制"><a href="#6-2-打开文件数的限制" class="headerlink" title="6.2 打开文件数的限制"></a>6.2 打开文件数的限制</h4><p>打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改<code>/etc/security/limits.conf</code>文件</p><ul><li>limits.conf中增加以下内容以修改打开文件数量的限制（永久生效）<ul><li><code>*Soft nofile 65535</code></li><li><code>*Hard nofile 65535</code></li></ul></li><li>如果一次有效，就要使用<code>ulimit –n 65535</code>即可。（默认情况是1024）</li><li>除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件</li></ul><h4 id="6-3-MySQL配置文件优化"><a href="#6-3-MySQL配置文件优化" class="headerlink" title="6.3 MySQL配置文件优化"></a>6.3 MySQL配置文件优化</h4><p>Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于<code>/etc/my.cnf</code>或<code>/etc/mysql/my.cnf</code></p><ul><li>MySQL<strong>查找配置文件的顺序</strong>可以通过以下命令获得：<ul><li><code>/usr/sbin/mysqld --verbose --help | grep -A 1 &#39;default options&#39;</code></li><li>注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。</li></ul></li></ul><h5 id="6-3-1-my-cnf常用-连接请求-参数"><a href="#6-3-1-my-cnf常用-连接请求-参数" class="headerlink" title="6.3.1 my.cnf常用 连接请求 参数"></a>6.3.1 <code>my.cnf</code>常用 连接请求 参数</h5><ol><li><code>max_connections</code>：最大连接数<ul><li>如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，MySQL会为每个连接提供连接缓冲区，连接数越多就会开销越多的内存，所以要<strong>适当调整该值</strong>，不能盲目提高设值。</li><li>数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</li><li><code>max_used_connections / max_connections * 100%</code>（<strong>理想值≈ 85%</strong>）: 响应的连接数/最大连接数</li></ul></li><li><code>back_log</code>：能暂存的连接数量<ul><li>如果MySQL的连接数据达到<code>max_connections</code>时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即<code>back_log</code>，如果等待连接的数量超过<code>back_log</code>，将不被授予连接资源。</li><li><strong>默认数值是50，可调优为128</strong>，对于Linux系统设置范围为小于512的整数。</li></ul></li><li><code>interactive_timeout</code>：服务器关闭<strong>交互式连接</strong>前等待活动的秒数<ul><li>默认数值是28800，可调优为7200。</li></ul></li><li><code>wait_timeout</code>：服务器关闭<strong>非交互连接</strong>之前等待活动的秒数<ul><li>指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</li></ul></li></ol><h5 id="6-3-1-my-cnf常用-缓冲区-参数"><a href="#6-3-1-my-cnf常用-缓冲区-参数" class="headerlink" title="6.3.1 my.cnf常用 缓冲区 参数"></a>6.3.1 <code>my.cnf</code>常用 缓冲区 参数</h5><ol><li><code>key_buffer_size</code>: 指定索引缓冲区的大小<ul><li>它决定索引处理的速度，尤其是索引读的速度。</li><li>它只对<strong>MyISAM表起作用</strong>。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值</li></ul></li><li><code>query_cache_size</code> ：查询缓存的内存<ul><li>使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。</li><li>通过检查状态值Qcache_*，可以知道<code>query_cache_size</code>设置是否合理（上述状态值可以使用<code>SHOW STATUS LIKE ‘Qcache%’</code>获得）。如果<code>Qcache_lowmem_prunes</code>的值非常大，则表明经常出现缓冲不够的情况，如果<code>Qcache_hits</code>的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果<code>Qcache_hits</code>的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入<code>SQL_NO_CACHE</code>可以明确表示不使用查询缓冲。</li><li>与查询缓冲有关的参数还有<code>query_cache_type</code>、<code>query_cache_limit</code>、<code>query_cache_min_res_unit</code>。<ul><li><code>query_cache_type</code>指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。</li><li><code>query_cache_limit</code>指定单个查询能够使用的缓冲区大小，缺省为1M。</li><li><code>query_cache_min_res_unit</code>指定分配缓冲区空间的最小单位，缺省为4K。检查状态值<code>Qcache_free_blocks</code>，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小<code>query_cache_min_res_unit</code>。</li></ul></li></ul></li><li><code>record_buffer_size</code>：顺序扫描缓冲区大小<ul><li>每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</li><li>默认数值是131072(128K)，可改为16773120 (16M)</li></ul></li><li><code>read_rnd_buffer_size</code>：随机读缓冲区大小<ul><li>当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M</li></ul></li><li><code>sort_buffer_size</code>：排序扫描缓冲区大小<ul><li>每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。</li><li>默认数值是2097144(2M)，可改为16777208 (16M)。</li></ul></li><li><code>join_buffer_size</code>：联合查询缓冲区大小<ul><li>联合查询操作所能使用的缓冲区大小。</li><li><code>record_buffer_size</code>，<code>read_rnd_buffer_size</code>，<code>sort_buffer_size</code>，<code>join_buffer_size</code>为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100</li></ul></li><li><code>table_cache</code>：表高速缓存的大小<ul><li>表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值<code>Open_tables</code>和<code>Opened_tables</code>，可以决定是否需要增加<code>table_cache</code>的值。如果你发现open_tables等于<code>table_cache</code>，并且opened_tables在不断增长，那么你就需要增加<code>table_cache</code>的值了（上述状态值可以使用<code>SHOW STATUS LIKE ‘Open%tables’</code>获得）。注意，不能盲目地把<code>table_cache</code>设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。</li><li>1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。</li></ul></li><li><code>max_heap_table_size</code>：用户可以创建的内存表(memory table)的大小<ul><li>这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#</li><li>这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。</li></ul></li><li><code>tmp_table_size</code>：临时表的大小<ul><li>通过设置<code>tmp_table_size</code>选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。</li><li>每次创建临时表，<code>Created_tmp_tables</code>增加，如果临时表大小超过<code>tmp_table_size</code>，则是在磁盘上创建临时表，<code>Created_tmp_disk_tables</code>也增加,<code>Created_tmp_files</code>表示MySQL服务创建的临时文件文件数</li><li>比较理想的配置是：<code>Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%</code>比如上面的服务器<code>Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%</code>，应该相当好了</li><li>默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞</li></ul></li><li><code>thread_cache_size</code>：可以复用的保存在中的线程的数量<ul><li>可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。</li><li>通过比较 Connections和<code>Threads_created</code>状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。</li></ul></li><li><code>thread_concurrency</code>：同一时间运行的线程系统提示所需数量的线程<ul><li>推荐设置为服务器 CPU核数的2倍，</li><li>例如双核的CPU, 那么<code>thread_concurrency</code>的应该为4；2个双核的cpu, <code>thread_concurrency</code>的值应为8。默认为8</li><li>这个参数<strong>已经在5.7.2版本的MySQL中被移除</strong></li></ul></li></ol><h5 id="6-3-1-my-cnf常用-配置InnoDB的-参数"><a href="#6-3-1-my-cnf常用-配置InnoDB的-参数" class="headerlink" title="6.3.1 my.cnf常用 配置InnoDB的 参数"></a>6.3.1 <code>my.cnf</code>常用 配置InnoDB的 参数</h5><ol><li><code>innodb_buffer_pool_size</code>：缓冲池大小<ul><li>对于InnoDB表来说，<code>innodb_buffer_pool_size</code>的作用就相当于<code>key_buffer_size</code>对于MyISAM表的作用一样。</li><li>InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。</li><li>根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。</li></ul></li><li><code>innodb_flush_log_at_trx_commit</code>：主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个<ul><li>设置为0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；</li><li>设置为1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；</li><li>设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。</li><li>实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。</li><li>根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</li></ul></li><li><code>innodb_log_buffer_size</code>：log缓存大小<ul><li>一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。</li></ul></li><li><code>innodb_additional_mem_pool_size</code>：内存池大小<ul><li>该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。</li><li>根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。</li><li><code>innodb_thread_concurrency=8</code>，推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8</li></ul></li><li><code>skip-name-resolve</code>：禁止域名解析<ul><li>禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</li><li>但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</li></ul></li></ol><h3 id="7-MySQL的执行顺序"><a href="#7-MySQL的执行顺序" class="headerlink" title="7. MySQL的执行顺序"></a>7. MySQL的执行顺序</h3><p>MySQL的语句一共分为<strong>11步</strong>，最<strong>先</strong>执行的总是<strong>FROM</strong>操作，最<strong>后</strong>执行的是<strong>LIMIT</strong>操作。</p><ul><li>其中<strong>每一个操作都会产生一张虚拟的表</strong>，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有<strong>最后一个虚拟的表才会被作为结果返回</strong>。</li><li>如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。<ul><li>⑧<code>select</code></li><li>⑨<code>distinct &lt;字段名&gt;</code></li><li>①<code>from &lt;表名&gt;</code></li><li>③<code>&lt;连接类型&gt;join &lt;表名&gt;</code></li><li>②<code>on&lt;连接条件&gt;</code></li><li>④<code>where&lt;查询条件&gt;</code></li><li>④<code>group by&lt;分组字段&gt;</code></li><li>⑥<code>with{cube|rollup}</code></li><li>⑦<code>having&lt;查询条件&gt;</code></li><li>⑩<code>order by&lt;排序字段&gt;</code></li><li>⑪<code>limit&lt;分页数量&gt;</code></li></ul></li></ul><p>查询处理的每一个阶段分析：</p><ol><li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算<strong>笛卡尔积</strong>。产生虚表VT1</li><li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<code>&lt;连接条件&gt;</code>的行才会被记录在虚表VT2中。</li><li><strong>JOIN</strong>：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li><li><strong>WHERE</strong>：对虚拟表VT3进行WHERE条件过滤。只有符合<code>&lt;where查询条件&gt;</code>的记录才会被插入到虚拟表VT4中。</li><li><strong>GROUP BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li><li><strong>CUBE | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li><li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<code>&lt;having查询条件&gt;</code>的记录才会被 插入到虚拟表VT7中。</li></ol><h3 id="8-MySQL执行引擎"><a href="#8-MySQL执行引擎" class="headerlink" title="8. MySQL执行引擎"></a>8. MySQL执行引擎</h3><h4 id="8-1-MyISAM存储引擎"><a href="#8-1-MyISAM存储引擎" class="headerlink" title="8.1 MyISAM存储引擎"></a>8.1 MyISAM存储引擎</h4><ul><li><strong>不支持事务、也不支持外键</strong>，优势是<strong>访问速度快</strong>，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表</li><li>支持3种不同的存储格式，分别是：静态表；动态表；压缩表</li><li>静态表：<ul><li>表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</li></ul></li><li>动态表：<ul><li>记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</li></ul></li><li>压缩表：<ul><li>因为每个记录是被单独压缩的，所以只有非常小的访问开支</li></ul></li></ul><h4 id="8-2-InnoDB存储引擎"><a href="#8-2-InnoDB存储引擎" class="headerlink" title="8.2 InnoDB存储引擎"></a>8.2 InnoDB存储引擎</h4><ul><li>提供了具有提交、回滚和崩溃恢复能力的<strong>事务安全</strong>。但是对比MyISAM引擎，<strong>写的处理效率会差一些</strong>，并且会占用更多的磁盘空间以保留数据和索引。 </li><li>InnoDB存储引擎的特点：<strong>支持自动增长列，支持外键约束</strong></li></ul><h4 id="8-3-MEMORY存储引擎"><a href="#8-3-MEMORY存储引擎" class="headerlink" title="8.3 MEMORY存储引擎"></a>8.3 MEMORY存储引擎</h4><ul><li>Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且<strong>默认使用HASH索引</strong>，但是<strong>一旦服务关闭，表中的数据就会丢失掉</strong>。 </li><li>MEMORY存储引擎的表可以选择使用<strong>BTREE索引</strong>或者<strong>HASH索引</strong>，两种不同类型的索引有其不同的使用范围</li><li>Hash索引优点： <ul><li>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 </li></ul></li><li>Hash索引缺点： <ul><li>那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；</li></ul></li><li>Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。</li></ul><h4 id="8-4-MERGE存储引擎"><a href="#8-4-MERGE存储引擎" class="headerlink" title="8.4 MERGE存储引擎"></a>8.4 MERGE存储引擎</h4><ul><li>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-MySQL基础操作&quot;&gt;&lt;a href=&quot;#1-MySQL基础操作&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL基础操作&quot;&gt;&lt;/a&gt;1. MySQL基础操作&lt;/h3&gt;&lt;h4 id=&quot;1-1-MySQL备份与恢复&quot;&gt;&lt;a href=&quot;#1-1-MySQL备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;1.1 MySQL备份与恢复&quot;&gt;&lt;/a&gt;1.1 MySQL备份与恢复&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;备份：在mysql的安装目录的bin目录下有&lt;strong&gt;mysqldump命令&lt;/strong&gt;，可以完成对数据库的备份。 &lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;mysqldump -u 用户名 -p 数据库名&amp;gt; 磁盘SQL文件路径&lt;/code&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL慢日志查询分析</title>
    <link href="http://chaooo.github.io/article/20190829.html"/>
    <id>http://chaooo.github.io/article/20190829.html</id>
    <published>2019-08-28T16:26:43.000Z</published>
    <updated>2019-11-01T13:30:10.494Z</updated>
    
    <content type="html"><![CDATA[<p>同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。<a id="more"></a></p><ul><li>错误日志：记录启动、运行或停止mysqld时出现的问题。</li><li>通用日志：记录建立的客户端连接和执行的语句。</li><li>更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。</li><li>二进制日志：记录所有更改数据的语句。还用于复制。</li><li>慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询</li><li>Innodb日志：InnoDB redo log(记录了事务的行为，可以很好的通过其对页进行“重做”操作)</li></ul><h3 id="1-开启慢查询日志"><a href="#1-开启慢查询日志" class="headerlink" title="1. 开启慢查询日志"></a>1. 开启慢查询日志</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。<br>通过<code>show variables like &#39;slow_query%&#39;;</code>查询是否开了慢查询(默认禁用OFF)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%slow_query_log%';</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br><span class="line">| Variable_name       | Value                                                |</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br><span class="line">| slow_query_log      | OFF                                                  |</span><br><span class="line">| slow_query_log_file | D:\mysql-5.7.27-winx64\data\DESKTOP-E9F062A-slow.log |</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><blockquote><p><code>slow_query_log</code> 慢查询开启状态  OFF 未开启 ON 为开启<br><code>slow_query_log_file</code> 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</p></blockquote><p>开启慢查询，需要设置<code>slow_query_log</code>参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log = 1; //设置开启或者关闭，0为关闭，1为开启</span><br><span class="line">mysql&gt; set global long_query_time = 3;  //设置慢的阙值时间，默认10秒</span><br></pre></td></tr></table></figure><blockquote><p>如果通过终端命令设定的话，需要重新连接或新开一个会话才能看到修改值</p></blockquote><p>使用set global slow_query_log 命令开启慢查询日志，只对当前数据库生效，如果Mysql重启后则会失效。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1 <span class="comment">#开启</span></span><br><span class="line">slow_query_log_file = /mysql-5.7.27-winx64/data/mysql-slow.log <span class="comment">#默认host_name_show.log</span></span><br><span class="line">long_query_time = 3 <span class="comment">#默认10秒（查询超过多少秒才记录）</span></span><br><span class="line">log-queries-not-using-indexes = on <span class="comment">#如果值设置为ON，则会记录所有没有利用索引的查询，一般在性能调优的时候会暂时开启。</span></span><br><span class="line">log_output = 'FILE,TABLE' <span class="comment">#输出的格式(FILE:文本, TABLE:表中, FILE,TABLE:同时输出到文本和表中)</span></span><br></pre></td></tr></table></figure><p>插入一条测试慢查询</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(5);</span><br></pre></td></tr></table></figure><p>通过MySQL命令查看有多少慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like '%Slow_queries%';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Slow_queries  | 1     |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="2-慢查询日志分析工具"><a href="#2-慢查询日志分析工具" class="headerlink" title="2. 慢查询日志分析工具"></a>2. 慢查询日志分析工具</h3><table><thead><tr><th>工具</th><th>一般统计</th><th>高级统计</th><th>语言</th><th>优势</th><th>针对log</th></tr></thead><tbody><tr><td>mysqldumpslow</td><td><code>√</code></td><td><code>×</code></td><td>perl</td><td>mysql官方自带</td><td>slow</td></tr><tr><td>myprofi</td><td><code>√</code></td><td><code>×</code></td><td>php</td><td>简单</td><td>slow</td></tr><tr><td>mysql-log-filter</td><td><code>√</code></td><td>部分<code>√</code></td><td>python</td><td>简单</td><td>slow</td></tr><tr><td>mysql-explain-slow-log</td><td><code>√</code></td><td><code>×</code></td><td>perl</td><td>无</td><td>slow</td></tr><tr><td>mysqlbinlog</td><td><code>√</code></td><td><code>×</code></td><td>二进制</td><td>mysql官方自带</td><td>binary log</td></tr><tr><td>mysqlsla</td><td><code>√</code></td><td><code>√</code></td><td>perl</td><td>总能强大，使用简单，自定义能力强</td><td>所有日志，包括自定义日志</td></tr><tr><td>pt-query-digest</td><td><code>√</code></td><td><code>√</code></td><td>perl</td><td>总能强大，使用简单，自定义能力强</td><td>所有日志，包括自定义日志</td></tr></tbody></table><h4 id="2-1-mysqldumpslow"><a href="#2-1-mysqldumpslow" class="headerlink" title="2.1 mysqldumpslow"></a>2.1 mysqldumpslow</h4><ul><li>MySQL自带的慢查询日志分析工具mysqldumpslow主要功能是, 统计不同慢sql的:<ul><li>出现次数(Count),</li><li>执行最长时间(Time), </li><li>累计总耗费时间(Time),</li><li>等待锁的时间(Lock), </li><li>发送给客户端的行总数(Rows),</li><li>扫描的行总数(Rows), </li><li>用户以及sql语句本身(抽象了一下格式, 比如 limit 1, 20 用 limit N,N 表示).<br>安装后基本使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log  //得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /data/mysql/mysql-slow.log //得到访问次数最多的10个SQL </span><br><span class="line">mysqldumpslow -s t -t 10 -g "left join" /data/mysql/mysql-slow.log  //得到按照时间排序的前10条里面含有做了连接的查询SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log | more  //另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-2-mysqlsla"><a href="#2-2-mysqlsla" class="headerlink" title="2.2 mysqlsla"></a>2.2 mysqlsla</h4><p>hackmysql.com推出的一款日志分析工具(该网站还维护了 mysqlreport, mysqlidxchk 等比较实用的mysql工具)</p><ul><li>整体来说, 功能非常强大. 数据报表,非常有利于分析慢查询的原因, 包括执行频率, 数据量, 查询消耗等.</li></ul><p>安装后基本使用方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlsla -lt slow -sort t_sum -top 1000  /tmp/slow_query.log</span><br></pre></td></tr></table></figure><ul><li>结果选项说明：<ul><li>总查询次数 (queries total),</li><li>去重后的sql数量 (unique),</li><li>输出报表的内容排序(sorted by),</li><li>最重大的慢sql统计信息(包括 平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数)</li><li>Count, sql的执行次数及占总的slow log数量的百分比.</li><li>Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.</li><li>95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.</li><li>Lock Time, 等待锁的时间.</li><li>95% of Lock , 95%的慢sql等待锁时间.</li><li>Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.</li><li>Rows examined, 扫描的行数量.</li><li>Database, 属于哪个数据库</li><li>Users, 哪个用户,IP, 占到所有用户执行的sql百分比</li><li>Query abstract, 抽象后的sql语句</li><li>Query sample, sql语句</li></ul></li><li>mysqlsla常用参数说明：<ol><li><code>-log-type (-lt) type logs</code>:通过这个参数来制定log的类型，主要有slow, general, binary, msl, udl,分析slow log时通过制定为slow</li><li><code>-sort</code>:t_sum:按总时间排序(默认)，c_sum:按总次数排序c_sum_p: sql语句执行次数占总执行次数的百分比。</li><li><code>-top</code>:显示sql的数量，默认是10,表示按规则取排序的前多少条</li><li><code>–statement-filter (-sf) [+-][TYPE]</code>:过滤sql语句的类型，比如select、update、drop，[TYPE] 有SELECT, CREATE, DROP, UPDATE, INSERT，例如”+SELECT,INSERT”，不出现的默认是-，即不包括。</li><li><code>-db</code>：要处理哪个库的日志：</li></ol></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举个例子，只取funsion数据库的select语句，并按照总时间排序，取前1000条数据</span></span><br><span class="line"><span class="comment"># 保存到当前目录下的 slow_query.pretty.log文件中</span></span><br><span class="line">mysqlsla -lt slow  -sort t_sum  -sf "+<span class="keyword">select</span><span class="string">"  -db funsion  -top 1000  /tmp/slow_query.log &gt; ./slow_query.pretty.log</span></span><br></pre></td></tr></table></figure><blockquote><p>深度使用可参考： <a href="https://yq.aliyun.com/articles/59260" target="_blank" rel="noopener">MySQL日志分析神器之mysqlsla</a></p></blockquote><h4 id="2-3-pt-query-digest"><a href="#2-3-pt-query-digest" class="headerlink" title="2.3 pt-query-digest"></a>2.3 pt-query-digest</h4><p>pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析最近12小时内的查询：</span></span><br><span class="line">pt-query-digest  <span class="comment">--since=12h  slow.log &gt; slow_report2.log</span></span><br></pre></td></tr></table></figure><ol><li>pt-query-digest语法及重要选项<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest [OPTIONS] [FILES] [DSN]</span><br><span class="line">    <span class="comment">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class="line">    <span class="comment">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class="line">    <span class="comment">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span></span><br><span class="line">    <span class="comment">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span></span><br><span class="line">    <span class="comment">--host  mysql服务器地址</span></span><br><span class="line">    <span class="comment">--user  mysql用户名</span></span><br><span class="line">    <span class="comment">--password  mysql用户密码</span></span><br><span class="line">    <span class="comment">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span></span><br><span class="line">    <span class="comment">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span></span><br><span class="line">    <span class="comment">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span></span><br><span class="line">    <span class="comment">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span></span><br><span class="line">    <span class="comment">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span></span><br></pre></td></tr></table></figure></li></ol><p>分析pt-query-digest输出结果</p><ol><li>总体统计结果<ul><li>Overall：总共有多少条查询</li><li>Time range：查询执行的时间范围</li><li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li><li>total：总计   min：最小   max：最大  avg：平均</li><li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li><li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li></ul></li><li>查询分组统计结果<ul><li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li><li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li><li>Response：总的响应时间</li><li>time：该查询在本次分析中总的时间占比</li><li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li><li>R/Call：平均每次执行的响应时间</li><li>V/M：响应时间Variance-to-mean的比率</li><li>Item：查询对象</li></ul></li><li>每一种查询的详细统计结果<ul><li>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</li><li>ID：查询的ID号，和上图的Query ID对应</li><li>Databases：数据库名</li><li>Users：各个用户执行的次数（占比）</li><li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li><li>Tables：查询中涉及到的表</li><li>Explain：SQL语句</li></ul></li></ol><h3 id="3-explain查看执行计划"><a href="#3-explain查看执行计划" class="headerlink" title="3. explain查看执行计划"></a>3. explain查看执行计划</h3><p>在上面的慢查询中，我们已经将查询时间超过阀值的sql语句过滤了出来，<code>explain+查询语句</code>具体分析是哪里出了问题。<br>MySQL 提供了一个 <code>Explain</code> 命令, 它可以对 select 语句进行分析, 并输出 select 执行的详细信息, 以供开发人员针对性优化.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure><ol><li><p>各列的含义如下:</p><ul><li><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li><code>select_type</code>: SELECT 查询的类型.<ul><li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY, 表示此查询是最外层的查询</li><li>UNION, 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>SUBQUERY, 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><code>table</code>: 查询的是哪个表</li><li><code>partitions</code>: 匹配的分区</li><li><code>type</code>: join 类型<ul><li>type字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过<code>type</code>字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</li><li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li><li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li><li>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. </li><li>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.</li><li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li><li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li><li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难.</li></ul></li><li><code>possible_keys</code>: 此次查询中可能选用的索引<ul><li>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</li></ul></li><li><code>key</code>: 此字段是 MySQL 在当前查询时所真正使用到的索引.</li><li><code>key_len</code>: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</li><li><code>ref</code>: 哪个字段或常数与 key 一起被使用</li><li><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.<ul><li>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数, 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</li></ul></li><li><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</li><li><code>extra</code>: EXplain 中的很多额外的信息会在 Extra 字段显示<ul><li>Using filesort: 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li><li>Using index: “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li>Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ul></li></ul></li><li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:</p></li></ol><ul><li><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><ul><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</li></ul></li></ul><h3 id="4-MySQL性能分析语句show-profile"><a href="#4-MySQL性能分析语句show-profile" class="headerlink" title="4. MySQL性能分析语句show profile"></a>4. MySQL性能分析语句show profile</h3><p>Query Profile是MySQL自带的一种Query诊断分析工具，可以完整的显示一条sql执行的各方面的详细信息，默认关闭;</p><ol><li><p>看看当前的MySQL版本是否支持: <code>show variables like &#39;profiling&#39;;</code>或<code>show variables like &#39;profiling%&#39;;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'profiling%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>使用前需要开启: <code>set profiling = 1; (1:开 / 0:关)</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling = 1;</span><br></pre></td></tr></table></figure></li><li><p><strong>运行sql后</strong>，查询结果<code>show profiles;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILES\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Query_ID: 1</span><br><span class="line">Duration: 0.02949950</span><br><span class="line">   Query: <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">2</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.03405350</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">select</span> * <span class="keyword">from</span> housedemo</span><br><span class="line">*************************** <span class="number">3.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">3</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.07813800</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">select</span> * <span class="keyword">from</span> house</span><br><span class="line">*************************** <span class="number">4.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">4</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.00018150</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">show</span> prifiles</span><br></pre></td></tr></table></figure></li><li><p>诊断SQL, show profile <code>Type</code> io for query <code>Query_ID</code></p><ul><li>LIMIT部分的用法与SELECT中LIMIT子句一致，不赘述。</li><li>Type是可选的，取值范围可以如下：<ul><li><code>ALL</code> 显示所有性能信息</li><li><code>BLOCK IO</code> 显示块IO操作的次数</li><li><code>CONTEXT SWITCHES</code> 显示上下文切换次数，不管是主动还是被动</li><li><code>CPU</code> 显示用户CPU时间、系统CPU时间</li><li><code>IPC</code> 显示发送和接收的消息数量</li><li><code>MEMORY</code> [暂未实现]</li><li><code>PAGE FAULTS</code> 显示页错误数量</li><li><code>SOURCE</code> 显示源码中的函数名称与位置</li><li><code>SWAPS</code> 显示SWAP的次数</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 3;</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line">| starting             | 0.000077 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| checking permissions | 0.000013 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| Opening tables       | 0.031992 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| init                 | 0.000059 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| System <span class="keyword">lock</span>          | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| optimizing           | <span class="number">0.000007</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">statistics</span>           | <span class="number">0.000017</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| preparing            | <span class="number">0.008535</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| executing            | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>         | <span class="number">0.037234</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">end</span>                  | <span class="number">0.000011</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>            | <span class="number">0.000012</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| closing <span class="keyword">tables</span>       | <span class="number">0.000014</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000108</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000030</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br></pre></td></tr></table></figure><p>从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理的你工作，在这完全可以看到一条SQL的完整生命周期。</p><ol start="5"><li>日常开发需要注意<ul><li>如果show profile … for query id；出现了如下四个，则必须优化这条sql。<ol><li><code>converting HEAP to MyISAM</code> 查询结果太大， 内存都不够用了网磁盘上搬了</li><li><code>Creating tmp table</code> 创建临时表</li><li>拷贝数据到临时表：假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这个时候就是导致SQL变慢的罪魁祸首</li><li>用完再删除</li><li><code>Copying to tmp table on disk</code> 把内存中临时表复制到磁盘，危险！！！</li><li><code>locked</code></li></ol></li></ul></li></ol><h3 id="5-全局查询日志"><a href="#5-全局查询日志" class="headerlink" title="5. 全局查询日志"></a>5. 全局查询日志</h3><p>切记：<strong>永远不要再生产环境开启这个功能</strong>。<br>全局查询日志有时也能帮助我们来调SQL。但是，切记，这家伙只能在测试环境使用，绝不可以在生产环境使用。</p><ol><li><p>命令启用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global general_log=1; #开启后会把所有的SQL偷偷的记录</span><br><span class="line">mysql&gt; set global log_output='TABLE';</span><br></pre></td></tr></table></figure></li><li><p>配置启用,  在MySQL的my.cnf中，设置如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启</span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment">#记录日志文件的路径</span></span><br><span class="line">general_log_file=/path/logfile</span><br><span class="line"><span class="comment">#输出格式</span></span><br><span class="line">log_output=file</span><br></pre></td></tr></table></figure></li><li><p>此后，你所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mysql.general_log;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>场景：如果需要做系统的定案分析(今天下午2点-3点出的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。那么用general_log这个表来收集什么时间段发生了什么样的SQL，帮助我们定位收集。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】深入JVM(三)-内存模型JMM 与 锁机制</title>
    <link href="http://chaooo.github.io/article/20190827.html"/>
    <id>http://chaooo.github.io/article/20190827.html</id>
    <published>2019-08-27T09:30:45.000Z</published>
    <updated>2019-12-01T11:04:53.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型-Java-Memory-Model"><a href="#Java内存模型-Java-Memory-Model" class="headerlink" title="Java内存模型(Java Memory Model)"></a>Java内存模型(Java Memory Model)</h3><p>Java Memory Model(JMM)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节(可见性,有序性,原子性)。</p><ul><li>所有的变量都存储在主内存中</li><li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li><li>JMM规定：<ul><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。<a id="more"></a></li></ul></li></ul><p><img src="http://cdn.chaooo.top/Java/JMM.png" alt></p><h3 id="1-JMM-同步八种操作"><a href="#1-JMM-同步八种操作" class="headerlink" title="1. JMM-同步八种操作"></a>1. JMM-同步八种操作</h3><p>JMM模型下,线程间通信必须要经过主内存。<br>JMM数据原子操作:<code>lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock</code></p><ol><li><strong>lock</strong>（锁定）：将<strong>主内存</strong>变量加锁，标识为线程独占状态</li><li><strong>read</strong>（读取）：从<strong>主内存</strong>读取数据到工作内存</li><li><strong>load</strong>（载入）：将读取的数据写入<strong>工作内存</strong></li><li><strong>use</strong>（使用）：将<strong>工作内存</strong>数据传递给执行引擎来计算</li><li><strong>assign</strong>（赋值）：将计算好的值赋值给<strong>工作内存</strong>的变量</li><li><strong>store</strong>（存储）：把<strong>工作内存</strong>数据存储到主内存</li><li><strong>write</strong>（写入）：把store过来的变量值赋值给<strong>主内存</strong>的变量</li><li><strong>unlock</strong>（解锁）：将<strong>主内存</strong>变量解锁，释放后的变量才可以被其他线程锁定。</li></ol><p>在执行上述八种基本操作时，必须满足如下规则：</p><ol><li>从主复制到工作,必须按顺序执行<code>read-&gt;load</code>操作; 从工作同步到主内存,必须按顺序执行<code>store-&gt;write</code>操作; 但不保证必须是连续执行</li><li>不允许<code>read-&gt;load</code>、<code>store-&gt;write</code>操作之一单独出现</li><li>assign操作改变数据后必须同步到主内存,不允许把没有发生过assign操作的数据同步到主内存</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作,lock和unlock必须成对出现</li><li>lock操作会清空工作内存中此变量的值，执行引擎使用前需要重新执行load或assign操作初始化变量的值</li><li>不允许去unlock一个未被锁定 或 被其他线程锁定的变量</li><li>unlock之前，必须先同步到主内存中（执行store和write操作）</li></ol><h3 id="2-JMM-原子性"><a href="#2-JMM-原子性" class="headerlink" title="2. JMM-原子性"></a>2. JMM-原子性</h3><p>和数据库事务中的原子性一样，满足原子性特性的操作是不可中断的，要么全部执行成功要么全部执行失败。<br>Synchronized能够实现：<strong>原子性</strong>(同步) 和 可见性</p><ul><li>JMM关于synchronized的两条规定：<ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li></ol></li><li>线程执行互斥代码的过程：<ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存</li><li>执行代码</li><li>将更改后的共享变量的值刷新到主内存</li><li>释放互斥锁</li></ol></li></ul><h3 id="2-JMM-可见性"><a href="#2-JMM-可见性" class="headerlink" title="2. JMM-可见性"></a>2. JMM-可见性</h3><p>多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值。<br>volatile能够实现<strong>可见性</strong>，但不保证原子性</p><ul><li><p>深入来说：通过加入内存屏障和禁止重排序优化来实现的。</p><ul><li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li><li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li></ul></li><li><p>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</p></li><li><p>线程写volatile变量的过程：</p><ol><li>改变线程工作内存中volatile变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ol></li><li><p>线程读volatile变量的过程：</p><ol><li>从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ol></li></ul><h4 id="2-1-happens-before规则"><a href="#2-1-happens-before规则" class="headerlink" title="2.1 happens-before规则"></a>2.1 happens-before规则</h4><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这2个操作之间必须要存在happens-before关系。</p><ul><li>定义: 如果一个操作在另一个操作之前发生(happens-before),那么第一个操作的执行结果将对第二个操作可见, 而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><ul><li>happens-before规则：<ol><li>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；论是单线程还是多线程，必须要先释放锁，然后其他线程才能进行lock操作</li><li>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见</li><li>线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断</li><li>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</li></ol></li></ul><h3 id="3-JMM-有序性"><a href="#3-JMM-有序性" class="headerlink" title="3. JMM-有序性"></a>3. JMM-有序性</h3><p>编译器和处理器为了优化程序性能而对指令序列进行重排序，也就是你编写的代码顺序和最终执行的指令顺序是不一致的，重排序可能会导致多线程程序出现内存可见性问题。</p><ul><li>我们编写的源代码到最终执行的指令，会经过三种重排序:<ul><li>源代码–&gt;<strong>编译器优化重排序</strong>–&gt;<strong>指令级并行重排序</strong>–&gt;<strong>内存系统重排序</strong>–&gt;最终执行的指令</li></ul></li></ul><h4 id="3-1-as-if-serial语义"><a href="#3-1-as-if-serial语义" class="headerlink" title="3.1 as-if-serial语义"></a>3.1 as-if-serial语义</h4><p>as-if-serial语义：不管怎么重排序(编译器和处理器为了提高并行度做的优化),(单线程)程序的执行结果不会改变。编译器、runtime和处理器都必须遵守as-if-serial语义。<br>多线程中程序交错执行时, 重排序可能造成内存可见性问题, 可能会改变程序的执行结果。</p><ul><li><p>有序性规则表现在以下两种场景: 线程内和线程间</p><ol><li>线程内: 指令会按照一种“串行”(as-if-serial)的方式执行，此种方式已经应用于顺序编程语言。</li><li>线程间: 一个线程“观察”到其他线程并发地执行非同步的代码时，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块以及volatile字段的操作仍维持相对有序。</li></ol></li><li><p>As-if-serial只是保障单线程不会出问题，所以有序性保障，可以理解为把As-if-serial扩展到多线程，那么在多线程中也不会出现问题</p><ul><li>从底层的角度来看，是借助于处理器提供的相关指令内存屏障来实现的</li><li>对于Java语言本身来说，Java已经帮我们与底层打交道，我们不会直接接触内存屏障指令，java提供的关键字synchronized和volatile，可以达到这个效果，保障有序性（借助于显式锁Lock也是一样的，Lock逻辑与synchronized一致）</li></ul></li></ul><h4 id="3-2-著名的双检锁-double-checked-locking-模式实现单例"><a href="#3-2-著名的双检锁-double-checked-locking-模式实现单例" class="headerlink" title="3.2 著名的双检锁(double-checked locking)模式实现单例"></a>3.2 著名的双检锁(double-checked locking)模式实现单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile保证happens-before规则,重排序被禁止</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例没创建,才进入内部的synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 判断其他线程是否已经创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不用volatile修饰INSTANCE,可能造成访问的是一个初始化未完成的对象; 使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。</p></blockquote><h3 id="4-锁机制"><a href="#4-锁机制" class="headerlink" title="4. 锁机制"></a>4. 锁机制</h3><ul><li>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是<strong>锁的升级是单向的</strong>，也就是说只能从低到高升级，不会出现锁的降级）。</li><li>锁的状态是通过对象监视器在<strong>对象头</strong>中的字段来表明的。 四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。 这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(<strong>使用synchronized时</strong>)。</li></ul><h4 id="4-1-对象头Mark"><a href="#4-1-对象头Mark" class="headerlink" title="4.1 对象头Mark"></a>4.1 对象头Mark</h4><ul><li>Mark Word,对象头的标记,32位: 描述对象的hash,锁信息,垃圾回收标记,分代年龄<ul><li>指向锁记录的指针</li><li>指向monitor的指针</li><li>GC标记</li><li>偏向锁线程ID</li></ul></li></ul><h4 id="4-2-偏向锁"><a href="#4-2-偏向锁" class="headerlink" title="4.2 偏向锁"></a>4.2 偏向锁</h4><p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优化</p><ul><li>大部分情况锁是没有竞争的,所以可以通过偏向锁来提高性能; </li><li>所谓偏向,就是偏心,即锁会偏向于当前已经占有锁的线程,总是由同一线程多次获得; </li><li>会在对象头和栈帧中的锁记录里存储锁偏向的线程ID</li><li>只要没有竞争,获得偏向锁的线程,在将来进入同步块,不需要做同步</li><li>当其他线程请求相同的锁时,偏向模式结束</li><li>-XX:+UseBiasedLocking(默认开启)</li><li>在竞争激烈的场合,偏向锁会增加系统负担</li></ul><h4 id="4-3-轻量级锁"><a href="#4-3-轻量级锁" class="headerlink" title="4.3 轻量级锁"></a>4.3 轻量级锁</h4><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><ul><li>普通的锁处理性能不够理想,轻量级锁是一种快速的锁定方法.</li><li>过程: 如果对象没有被锁定:<ol><li>将对象头的Mark指针保存到锁对象中</li><li>将对象头设置为指向锁的指针(在线程栈空间中)</li></ol></li><li>如果轻量级锁失败,表示存在竞争,升级为重量级锁(常规锁)</li><li>在没有锁竞争的情况下,减少传统锁使用OS互斥量产生的性能损耗</li><li>在竞争激烈的场合,轻量级锁会多做很多额外操作,导致性能下降</li></ul><h4 id="4-4-自旋锁"><a href="#4-4-自旋锁" class="headerlink" title="4.4 自旋锁"></a>4.4 自旋锁</h4><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><ul><li>当竞争存在时,如果线程可以很快获得锁,那么可以不在OS层挂起线程,让线程做几个空操作(自旋)</li><li>如果同步块很长,自旋失败,会降低系统性能</li><li>如果同步块很短,自旋成功,节省线程挂起切换时间,提升系统性能</li></ul><h4 id="4-5-重量级锁"><a href="#4-5-重量级锁" class="headerlink" title="4.5 重量级锁"></a>4.5 重量级锁</h4><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h4 id="4-6-synchronized的执行过程："><a href="#4-6-synchronized的执行过程：" class="headerlink" title="4.6 synchronized的执行过程："></a>4.6 synchronized的执行过程：</h4><ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li><li>如果自旋成功则依然处于轻量级状态。</li><li>如果自旋失败，则升级为重量级锁。</li></ol><blockquote><p>以上几种锁都是JVM自己内部实现，当我们执行synchronized同步块的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；</p></blockquote><h3 id="5-Java语言层面对锁的优化"><a href="#5-Java语言层面对锁的优化" class="headerlink" title="5. Java语言层面对锁的优化"></a>5. Java语言层面对锁的优化</h3><ol><li><strong>减少锁持有时间</strong><ul><li>不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</li></ul></li><li><strong>减少锁的粒度</strong><ul><li>它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；</li><li>java中很多数据结构都是采用这种方法提高并发操作的效率：<ul><li>ConcurrentHashMap: 使用Segment数组,Segment继承自ReenTrantLock，所以每个Segment就是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</li><li>LongAdder:实现思路也类似ConcurrentHashMap，LongAdder有一个根据当前并发状况动态改变的Cell数组，Cell对象里面有一个long类型的value用来存储值;开始没有并发争用的时候或者是cells数组正在初始化的时候，会使用cas来将值累加到成员变量的base上，在并发争用的情况下，LongAdder会初始化cells数组，在Cell数组中选定一个Cell加锁，数组有多少个cell，就允许同时有多少线程进行修改，最后将数组中每个Cell中的value相加，在加上base的值，就是最终的值；cell数组还能根据当前线程争用情况进行扩容，初始长度为2，每次扩容会增长一倍，直到扩容到大于等于cpu数量就不再扩容，这也就是为什么LongAdder比cas和AtomicInteger效率要高的原因，后面两者都是volatile+cas实现的，他们的竞争维度是1，LongAdder的竞争维度为“Cell个数+1”为什么要+1？因为它还有一个base，如果竞争不到锁还会尝试将数值加到base上；</li></ul></li><li>拆锁的粒度不能无限拆，最多可以将一个锁拆为当前CPU数量即可；</li></ul></li><li><strong>锁粗化</strong><ul><li>大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度(如:循环内的操作);</li></ul></li><li><strong>锁分离</strong><ul><li>使用读写锁: ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写；</li><li>读写分离: CopyOnWriteArrayList 、CopyOnWriteArraySet<ul><li>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</li><li>CopyOnWrite并发容器用于读多写少的并发场景，因为，读的时候没有锁，但是对其进行更改的时候是会加锁的，否则会导致多个线程同时复制出多个副本，各自修改各自的；</li></ul></li><li>LinkedBlockingQueue: LinkedBlockingQueue也体现了这样的思想，在队列头入队，在队列尾出队，入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高；</li></ul></li><li><strong>锁消除</strong><ul><li>在即时编译时,如果发现不可能被共享的对象,则可以消除对象的锁操作</li></ul></li><li><strong>无锁</strong>(如CAS)<ul><li>如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用CAS效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+CAS操作会是非常高效的选择；</li></ul></li><li>消除缓存行的伪共享<ul><li>除了我们在代码中使用的同步锁和jvm自己内置的同步锁外，还有一种隐藏的锁就是缓存行，它也被称为性能杀手。在多核cup的处理器中，每个cup都有自己独占的一级缓存、二级缓存，甚至还有一个共享的三级缓存，为了提高性能，cpu读写数据是以缓存行为最小单元读写的；32位的cpu缓存行为32字节，64位cup的缓存行为64字节，这就导致了一些问题。</li></ul></li></ol><h3 id="6-CAS与原子类"><a href="#6-CAS与原子类" class="headerlink" title="6. CAS与原子类"></a>6. CAS与原子类</h3><p>CAS即<code>Compare and Swap</code>翻译过来就是比较并替换, 它体现了一种乐观锁的思想 (synchronized为悲观锁思想); </p><ul><li>结合CAS和volatile可以实现<strong>无锁并发</strong>(非阻塞同步),适用于竞争不激烈,多核CPU的场景下(竞争激烈,重试频繁发生会影响效率);</li><li>CAS算法涉及到三个操作数: 内存值V, 旧值A, 新值B; 当且仅当V==A时，CAS用新值B来更新V，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</li><li>CAS底层依赖一个Unsafe类来直接调用操作系统底层的CAS指令;</li></ul><h4 id="6-1-Unsafe类"><a href="#6-1-Unsafe类" class="headerlink" title="6.1 Unsafe类"></a>6.1 Unsafe类</h4><p>java中CAS操作依赖于Unsafe类，Unsafe类所有方法都是native的，直接调用操作系统底层资源执行相应任务，它可以像C一样操作内存指针，是非线程安全的。</p><ul><li>Unsafe里的CAS 操作相关实现: compareAndSwapObject,compareAndSwapInt,compareAndSwapLong<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，</span></span><br><span class="line"><span class="comment">//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">long</span> expected,<span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-原子操作类"><a href="#6-2-原子操作类" class="headerlink" title="6.2 原子操作类"></a>6.2 原子操作类</h4><p>并发包JUC(java.util.concurrent)中的原子操作类(Atomic系列),底层是基于<code>CAS + volatile</code>实现的.</p><ul><li>AtomicBoolean：原子更新布尔类型</li><li>AtomicInteger：原子更新整型</li><li>AtomicLong：原子更新长整型</li></ul><p>下面看AtomicInteger类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取指针类Unsafe    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe(); </span><br><span class="line">    <span class="comment">//省略...获取内存偏移量等</span></span><br><span class="line">    <span class="comment">//如果当前值为expect，则设置为update(当前值指的是value变量)    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//当前值加1返回旧值，底层CAS操作    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger基本是基于Unsafe类中CAS相关操作实现的，是无锁操作。<br>再看Unsafe类中的getAndAddInt()方法，该方法执行一个CAS操作，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unsafe类中的getAndAddInt方法(JDK8)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> v;        </span><br><span class="line">    <span class="keyword">do</span> &#123;            </span><br><span class="line">        v = getIntVolatile(o, offset);        </span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));        </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出getAndAddInt通过一个while循环不断的重试更新要设置的值，直到成功为止，调用的是Unsafe类中的compareAndSwapInt方法，是一个CAS操作方法。</p><h4 id="6-3-CAS操作中可能会带来的ABA问题"><a href="#6-3-CAS操作中可能会带来的ABA问题" class="headerlink" title="6.3 CAS操作中可能会带来的ABA问题"></a>6.3 CAS操作中可能会带来的ABA问题</h4><p>ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。</p><ul><li><strong>无法正确判断这个变量是否已被修改过</strong>，一般称这种情况为ABA问题。</li><li>ABA问题一般不会有太大影响，产生几率也比较小。但是并不排除极特殊场景下会造成影响，因此需要解决方法：<ul><li>AtomicStampedReference类</li><li>AtomicMarkableReference类</li></ul></li><li><strong>AtomicStampedReference类</strong>: 一个带有时间戳的对象引用，每次修改时，不但会设置新的值，还会记录修改时间。在下一次更新时，不但会对比当前值和期望值，还会对比当前时间和期望值对应的修改时间，只有二者都相同，才会做出更新。解决了反复读写时，无法预知值是否已被修改的窘境。<ul><li>底层实现为：一个键值对Pair存储数据和时间戳，并构造volatile修饰的私有实例；两者都符合预期才会调用Unsafe的compareAndSwapObject方法执行数值和时间戳替换。</li></ul></li><li>AtomicMarkableReference类: 一个boolean值的标识，true和false两种切换状态表示是否被修改。不靠谱。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java内存模型-Java-Memory-Model&quot;&gt;&lt;a href=&quot;#Java内存模型-Java-Memory-Model&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型(Java Memory Model)&quot;&gt;&lt;/a&gt;Java内存模型(Java Memory Model)&lt;/h3&gt;&lt;p&gt;Java Memory Model(JMM)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节(可见性,有序性,原子性)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的变量都存储在主内存中&lt;/li&gt;
&lt;li&gt;每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)&lt;/li&gt;
&lt;li&gt;JMM规定：&lt;ul&gt;
&lt;li&gt;线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。&lt;/li&gt;
&lt;li&gt;不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】深入JVM(二)-类文件结构 与 类加载机制</title>
    <link href="http://chaooo.github.io/article/20190825.html"/>
    <id>http://chaooo.github.io/article/20190825.html</id>
    <published>2019-08-25T11:29:48.000Z</published>
    <updated>2019-10-29T08:11:29.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h3><p>Class文件是一组以 <strong>8 位字节</strong>为基础单位的二进制流，各个数据<strong>严格按照顺序紧凑的排列</strong>在 Class 文件中，中间无任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，会按照高位在前的方式分割成若干个 8 位字节进行存储。<br>Java 虚拟机规范规定 Class 文件格式采用一种类似与 C 语言结构体的伪结构体来存储数据，这种伪结构体中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。<a id="more"></a></p><ul><li><strong>无符号数</strong>：属于基本数据类型，以u1、u2、u4、u8来代表1个字节、2个字节、4个字节、8个字节的无符号数， 无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li><strong>表</strong>：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以「_info」结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件就是一张表。</li></ul><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                <span class="comment">//Class文件的标志(魔数)</span></span><br><span class="line">    u2             minor_version;        <span class="comment">//Class的小版本号</span></span><br><span class="line">    u2             major_version;        <span class="comment">//Class的大版本号</span></span><br><span class="line">    u2             constant_pool_count;  <span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;         <span class="comment">//Class的访问标记</span></span><br><span class="line">    u2             this_class;           <span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;          <span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;     <span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;          <span class="comment">//Class文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];  <span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;         <span class="comment">//Class文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;      <span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.chaooo.top/Java/JVM-class.png" alt></p><h4 id="1-1-魔数-Magic-Number"><a href="#1-1-魔数-Magic-Number" class="headerlink" title="1.1 魔数 (Magic Number)"></a>1.1 魔数 (Magic Number)</h4><ul><li>Class文件的<strong>0~3字节</strong>(前四个字节: ca fe ba be)</li><li>作用: 确定这个文件是否为一个能被虚拟机接收的Class文件</li></ul><h4 id="1-2-Class文件版本"><a href="#1-2-Class文件版本" class="headerlink" title="1.2 Class文件版本"></a>1.2 Class文件版本</h4><ul><li><strong>4~7字节</strong>, 其中4<del>5次版本号,6</del>7主版本号(如jdk8主版本号是: 00 34)</li></ul><h4 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h4><ul><li><strong>8~9字节</strong>表示16进制常量池数量,其后紧跟具体常量池, 常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）</li><li>常量池主要存放两大常量: <strong>字面量</strong>和<strong>符号引用</strong><ul><li>字面量: Java语言层面的常量概念(String,final等)</li><li>符号引用: 编译原理方面的概念(类和接口的全限定名\字段的名称和描述符\方法的名称和描述符)</li></ul></li><li>常量池中每一项常量都是一个表，这<strong>14种表</strong>有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型</strong></li><li>.class文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)</li></ul><h4 id="1-4-类的访问标志与继承信息"><a href="#1-4-类的访问标志与继承信息" class="headerlink" title="1.4 类的访问标志与继承信息"></a>1.4 类的访问标志与继承信息</h4><ul><li>在常量池结束之后，紧接着的<strong>两个字节</strong>代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等.</li><li>access_flags中一共有16个标志位可以使用，当前只定义了其中的8个，没有使用到的标志位要求一律为0。</li></ul><h4 id="1-5-当前类索引-this-父类索引-super-与接口索引集合-interfaces"><a href="#1-5-当前类索引-this-父类索引-super-与接口索引集合-interfaces" class="headerlink" title="1.5 当前类索引(this),父类索引(super)与接口索引集合(interfaces)"></a>1.5 当前类索引(<code>this</code>),父类索引(<code>super</code>)与接口索引集合(<code>interfaces</code>)</h4><ul><li>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</li><li>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</li></ul><h4 id="1-6-成员变量信息-Feild"><a href="#1-6-成员变量信息-Feild" class="headerlink" title="1.6 成员变量信息(Feild)"></a>1.6 成员变量信息(Feild)</h4><ul><li>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li><li>字段信息包括：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称，以上修饰符都是布尔类型。</li><li>方法和字段的描述符作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</li><li>根描述规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，对象类型使用字符L加对象的全限定名来表示。<ul><li>B: 基本类型byte</li><li>C: 基本类型char</li><li>D: 基本类型double</li><li>F: 基本类型float</li><li>I: 基本类型</li><li>J: 基本类型long</li><li>S: 基本类型short</li><li>Z: 基本类型boolean</li><li>V: 特殊类型void</li><li>L: 对象类型，如Ljava/lang/Object</li></ul></li></ul><h4 id="1-7-方法信息-Method"><a href="#1-7-方法信息-Method" class="headerlink" title="1.7 方法信息(Method)"></a>1.7 方法信息(Method)</h4><ul><li><code>methods_count</code> 表示方法的数量，而 <code>method_info</code> 表示的方法表。</li><li>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</li></ul><h4 id="1-8-附加属性信息"><a href="#1-8-附加属性信息" class="headerlink" title="1.8 附加属性信息"></a>1.8 附加属性信息</h4><ul><li><code>attributes_count</code>表示属性表中的属性个数, <code>attribute_info</code> 表示属性表</li><li>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</li></ul><h3 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h3><p>Java字节码指令就是Java虚拟机能够识别、可执行的指令，可以说是Jvm的最小执行单元。javac命令会将Java源文件编译成字节码文件，即.class文件，其中就包含了大量的字节码指令，javap命令可以解析字节码(.class文件)，将字节码内部逻辑以可读的方式呈现出来 (<code>javap -v -p HelloWorld</code>)。</p><ul><li>按指令的功能分为如下几类：<ol><li><strong>存储和加载类指令</strong>：主要包括load系列(将一个局部变量加载到操作数栈)、store系列(将一个数值从操作数栈存储到局部变量表)和ldc/push/const系列(将一个常量加载到操作数栈)，主要用于在<strong>局部变量表</strong>、<strong>操作数栈</strong>和<strong>常量池</strong>三者之间进行<strong>数据调度</strong>；<ul><li>例如: <code>iload_0</code>表示从当前栈帧局部变量表中0号位置取int类型的数值加载到操作数栈</li></ul></li><li><strong>对象操作指令</strong>（创建与读写访问）：比如我们刚刚的putfield和getfield就属于读写访问的指令，此外还有putstatic/getstatic，还有new系列指令，以及instanceof等指令。</li><li><strong>操作数栈管理指令</strong>：如pop和dup，他们只对操作数栈进行操作。</li><li>类型转换指令和运算指令：如add(加)/sub(减)/mul(乘)/div(除)/l2i/d2f等系列指令，实际上这类指令一般也只对操作数栈进行操作。</li><li>控制跳转指令：这类里包含常用的if系列指令以及goto类指令。</li><li><strong>方法调用和返回指令</strong>：主要包括invoke系列指令和return系列指令。这类指令也意味这一个方法空间的开辟和结束，即invoke会唤醒一个新的java方法小宇宙（新的栈和局部变量表），而return则意味着这个宇宙的结束回收。</li></ol></li><li>从指令操作的数据类型来讲：指令开头或尾部的一些字母，就往往表明了它所能操作的数据类型：<ul><li>a对应对象，表示指令操作对象性数据，比如aload和astore、areturn等等。</li><li>i对应整形。也就有iload，istore等i系列指令。</li><li>f对应浮点型，l对应long，b对应byte，d对应double，c对应char。</li><li>ia对应int array，aa对应object array，da对应double array。</li></ul></li></ul><h3 id="3-编译期处理-语法糖"><a href="#3-编译期处理-语法糖" class="headerlink" title="3. 编译期处理(语法糖)"></a>3. 编译期处理(语法糖)</h3><p><strong>语法糖</strong>: 指Java编译器把.java源码编译为.class字节码过程中,自动生成和转换的一些代码. 如:默认构造器,自动拆装箱等.</p><ol><li><strong>默认构造器</strong>: <code>public class Candy{}</code> 编译后为: <code>public class Candy{public Candy(){super();}}</code> </li><li><strong>自动拆装箱</strong>: <code>Integer x=1;int y=x;</code> 编译后为: <code>Integer x=Integer.valueOf(1);int y=x.intValue();</code></li><li><strong>泛型擦除</strong>: 擦除的是字节码上的泛型信息.</li><li><strong>泛型反射</strong>: 通过反射获得泛型信息</li><li><strong>可变参数</strong>: <code>String... args</code> 可以是一个<code>String[] args</code></li><li><strong>foreach</strong>: 集合相当于获取迭代器Iterator</li><li><strong>switch</strong>: Jdk7开始可以配合String和枚举<ul><li>switch-String: 执行了两遍switch,第一遍根据字符串的hashCode和equals将字符串转换为相应的byte类型,第二遍利用byte执行比较.</li><li>switch-枚举: 会为当前类生成一个静态内部类(合成类,仅JVM使用,对我们不可见),用来映射枚举类的枚举编号(从0开始)与数组元素的关系,数组大小即为枚举元素的个数,里面存储case用来对比的数字,根据这个数字执行switch</li></ul></li><li><strong>枚举类</strong>: 继承Enum并且用final修饰类,构造方法私有,枚举量被编译成本类的final类变量,定义私有静态枚举量数组$VALUES,静态方法values()用来返回定义的枚举量数组的clone(),静态方法valueOf()调用父类valueOf(本类.class,名称)根据类型和名称得到相应实例</li><li><strong>try-with-resources</strong>: 无论try块的异常还是关闭资源时的异常都不会丢。可以在 try-with-resources 语句中同时处理多个资源。<ul><li>在 Java 7/8 ，try-with-resources 语句中必须声明要关闭的资源。通过这种方式声明的资源属于隐式 final。</li><li>Java 9 中甚至能使用预先创建的资源，只要所引用的资源声明为 final 或者是 effective final。</li><li>在幕后施展魔法的是 AutoCloseable 或者 Closeable 接口，它们与 try-with-resources 语句协同工作。</li></ul></li><li><strong>重写桥接</strong>: 子类重写方法返回值可以是父类返回值的子类,JVM内部使用了桥接方法(synthetic bridge修饰)重写父类方法并返回子类重写的同名方法,并且没有命名冲突,仅对jvm可见.</li><li><strong>匿名内部类</strong>: 内部创建了final修饰的实现类, 匿名内部类引用局部变量时,局部变量必须是final的:因为内部创建实现类时,将值赋给其对象的valx属性,valx属性没有机会再跟着一起变化.</li></ol><h3 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4. 类加载阶段"></a>4. 类加载阶段</h3><ol><li>隐式加载：new</li><li>显式加载：loadClass、forName等(需要调用Class的newInstance方法获取实例)</li><li>类的装载阶段：<strong><code>加载 --&gt; 链接 --&gt; 初始化</code></strong><ul><li>加载：通过Classloader加载class文件字节码，生成class对象</li><li>链接：校验–&gt;准备–&gt;解析<ul><li>校验：检查加载的Class的正确性和安全性</li><li>准备：为变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池内的符号引用转换为直接引用</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ul></li></ol><h4 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h4><ul><li>将类的字节码载入方法区中,内部采用C++的instanceKlass描述java类, 它的重要field有:<ul><li><code>_java_mirror</code>:Java类的镜像, <code>_super</code>:父类, <code>_field</code>:成员变量, <code>_methods</code>:方法, <code>_constants</code>:常量池, <code>_class_loader</code>:类加载器, <code>_vtable</code>:虚方法表, <code>_itable</code>:接口方法表</li></ul></li><li>如果这个类还有父类没加载,先加载父类</li><li><strong>加载和链接可能是交替运行的</strong></li></ul><blockquote><p><code>instanceKlass</code>这样的元数据是存储在方法区(元空间),但<code>_java_mirror</code>存储在堆中; 可通过HSDB工具查看.</p></blockquote><h4 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h4><ol><li>验证: 验证类是否符合JVM规范,安全性检查</li><li>准备: 为static变量分配空间,设置默认值<ul><li>jdk7开始, static变量存储于<code>_java_mirror</code>末尾, jdk7之前是instanceKlass末尾.</li><li>static变量分配空间和赋值是两个步骤, 分配空间在准备阶段完成,赋值在初始化阶段完成</li><li>如果static变量是final的<strong>基本类型或字符串常量</strong>,那么编译阶段值就确定了,赋值在准备阶段完成</li><li>如果static变量是final的<strong>引用类型</strong>,那么赋值还是会在初始化阶段完成</li></ul></li><li>解析: 将常量池中的符号引用解析为直接引用(确切知道类,方法,属性在内存中的位置)</li></ol><h4 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h4><ul><li>初始化即调用<code>&lt;cinit&gt;()V</code>方法,虚拟机会<strong>保证</strong>这个类的[<strong>构造方法</strong>]<strong>线程安全</strong></li><li><strong>发生的时机</strong>: 概括的说,类初始化是[<strong>懒惰的</strong>]<ul><li>main方法所在的类的,总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化, 如果父类没有初始化,会引发</li><li>子类访问父类静态变量, 只会触发父类的初始化</li><li>Class.forName 和 new操作 导致初始化</li></ul></li><li><strong>不会</strong>导致类初始化的情况<ul><li>访问类的static final 静态常量(基本类型和字符串常量)<strong>不会</strong>触发初始化</li><li>类对象.class 不会</li><li>创建该类的数组 不会</li><li>类加载器的loadClass方法 不会</li><li>Class.forName的第二个参数为false时 不会</li></ul></li></ul><h4 id="4-4-应用实例-懒惰初始化单例模式-线程安全"><a href="#4-4-应用实例-懒惰初始化单例模式-线程安全" class="headerlink" title="4.4 应用实例-懒惰初始化单例模式(线程安全)"></a>4.4 应用实例-懒惰初始化单例模式(线程安全)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 内部类中保存单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次调用getInstance,才会导致内部类加载和初始化其静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5. 类加载器"></a>5. 类加载器</h3><p>以JDK8为例:</p><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>启动类加载器, 最顶层, 打印显示为null</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>扩展类加载器, 第二级, 打印显示为$ExtClassLoader</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>应用程序类加载器, 第三级, 打印显示为$AppClassLoader</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="5-1-类加载器-双亲委派机制"><a href="#5-1-类加载器-双亲委派机制" class="headerlink" title="5.1 类加载器-双亲委派机制"></a>5.1 类加载器-双亲委派机制</h4><ul><li>类加载器在接到加载类的请求时，首先将加载任务<strong>委托给上级加载器</strong>，依次递归，如果上级加载器可以完成类加载任务，就成功返回；只有上级加载器无法完成此加载任务时，才自己去加载。</li><li>这种双亲委派模式的好处，一个可以避免类的重复加载，另外也避免了java的核心API被篡改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * loadClass方法的实现方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//【1】 检查该类是否已经加载</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//【2】 有上级的话,委派上级 loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//【3】 如果没有上级了(ExtClassLoader),则委派BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//【4】 每一级都找不到,调用findClass(每个类加载器自己扩展)来加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-线程上下文类加载器"><a href="#5-2-线程上下文类加载器" class="headerlink" title="5.2 线程上下文类加载器"></a>5.2 线程上下文类加载器</h4><ul><li>Java 提供了很多服务提供者接口(Service Provider Interface，SPI),允许第三方为这些接口提供实现(常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等)。</li><li>SPI接口中的代码经常需要加载具体的实现类; SPI的接口由Java核心库来提供，实现类可能是作为Java应用所依赖的jar包被包含进来，可以通过类路径（CLASSPATH）来找到。</li><li>SPI的接口是Java核心库的一部分，是由引导类加载器来加载的；引导类加载器是无法找到SPI的实现类的,这时候需要抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类。</li><li>类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。</li><li>Java默认的 线程上下文类加载器 是 应用程序类加载器(AppClassLoader)。</li></ul><h4 id="5-3-何时使用Thread-getContextClassLoader"><a href="#5-3-何时使用Thread-getContextClassLoader" class="headerlink" title="5.3 何时使用Thread.getContextClassLoader()?"></a>5.3 何时使用Thread.getContextClassLoader()?</h4><ul><li>总的说来动态加载资源时，一般只有两种选择，当前类加载器和线程上下文类加载器。当前类加载器是指当前方法所在类的加载器。这个类加载器是运行时类解析使用的加载器，Class.forName(String)和Class.getResource(String)也使用该类加载器。代码中X.class的写法使用的类加载器也是这个类加载器。</li><li>该如何选择类加载器？<ul><li>如若代码是限于某些特定框架，这些框架有着特定加载规则，则不要做任何改动，让框架开发者来保证其工作（比如应用服务器提供商，尽管他们并不能总是做对）。如在Web应用和EJB中，要使用Class.gerResource来加载资源。</li><li>在其他情况下，我们可以自己来选择最合适的类加载器。可以使用策略模式来设计选择机制。其思想是将“总是使用上下文类加载器”或者“总是使用当前类加载器”的决策同具体实现逻辑分离开。往往设计之初是很难预测何种类加载策略是合适的，该设计能够让你可以后来修改类加载策略。</li><li>一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程。</li></ul></li></ul><h4 id="5-4-类加载器与Web容器"><a href="#5-4-类加载器与Web容器" class="headerlink" title="5.4 类加载器与Web容器"></a>5.4 类加载器与Web容器</h4><p>以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。<strong>该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类</strong>。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p><ul><li>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：<ol><li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li><li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li><li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li></ol></li></ul><h4 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h4><ol><li>什么时候需要自定义类加载器<ul><li>加载非classpath路径的任意路径类文件</li><li>都是通过接口来使用实现,希望解耦时,常用于框架设计</li><li>这些类希望予以隔离,不同应用的同名类都可以加载,不冲突,常见于tomcat容器</li></ul></li><li>如何自定义类加载器<ol><li>继承ClassLoader类</li><li>重写findClass(String className)方法</li><li>读取(加载)类文件的字节码。</li><li>调用ClassLoader超类的defineClass方法，向虚拟机提供字节码。</li><li>使用者调用该自定义类加载器的loadClass方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 类名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String cname = <span class="string">"E:\\myclasspath\\"</span> + name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] classBytes = Files.readAllBytes(Paths.get(cname));</span><br><span class="line">            Class&lt;?&gt; cl = defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">            <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.print(e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-运行期JVM自动优化"><a href="#6-运行期JVM自动优化" class="headerlink" title="6. 运行期JVM自动优化"></a>6. 运行期JVM自动优化</h3><p>Java程序最初是通过解释器进行解释执行的，当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。<strong>解释执行节约内存，编译执行提升效率</strong>。 同时，解释器可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，则通过逆优化退回到解释状态继续执行。<br>HotSpot虚拟机中内置了两个即时编译器，分别称为<strong>Client Compiler(C1编译器)</strong>和<strong>Server Compiler(C2编译器)</strong>，默认采用Interpreter(解释器)与其中一个编译器直接配合的方式工作，使用哪个编译器取决于虚拟机运行的模式，也可以自己去指定。</p><ul><li><p>分层编译策略, JVM将执行状态分成了5个层次:</p><ol><li>0层, 解释执行</li><li>1层, 使用C1即时编译器编译执行(不带profiling)</li><li>2层, 使用C1即时编译器编译执行(带基本的profiling)</li><li>3层, 使用C1即时编译器编译执行(带完全的profiling)</li><li>4层, 使用C2即时编译器编译执行<blockquote><p>profiling是指在运行过程中收集一些程序执行状态的数据,例如[方法的调用次数],[循环的回边次数]等</p></blockquote></li></ol></li><li><p>即时编译器(JIT)与解释器的区别</p><ul><li>解释器是将字节码解释为机器码,下次即便遇到相同的字节码,仍会执行重复的解释</li><li>JIT是将一些字节码编译为机器码并存入CodeCache,下次遇到相同的代码,直接执行,无需再编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT会根据平台类型,生成平台特定的机器码</li></ul></li><li><p>对于占据大部分的不常用的代码,我们无需耗费时间将其编译成机器码,而是采用解释执行的方式运行;另一方面,对于占据小部分的热点代码,我们则可以将其编译成机器码,以达到理想的运行速度;</p></li><li><p>执行效率: <code>Interpreter &lt; C1 &lt; C2</code>, 总的目标是发现热点代码(hotpot名称的由来)优化之.</p></li></ul><h4 id="6-1-公共子表达式消除"><a href="#6-1-公共子表达式消除" class="headerlink" title="6.1 公共子表达式消除"></a>6.1 公共子表达式消除</h4><p>如果一个表达式E已经计算过了，并且先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共表达式，可以直接用之前的结果替换。<br>例：int d = (c * b) * 12 + a + (a + b * c) =&gt; int d = E * 12 + a + (a + E)</p><h4 id="6-2-数组边界检查消除"><a href="#6-2-数组边界检查消除" class="headerlink" title="6.2 数组边界检查消除"></a>6.2 数组边界检查消除</h4><p>Java语言中访问数组元素都要进行上下界的范围检查，每次读写都有一次条件判定操作，这无疑是一种负担。编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组长度以内，那么整个循环中就可以把上下界检查消除，这样可以省很多次的条件判断操作。</p><h4 id="6-3-方法内联"><a href="#6-3-方法内联" class="headerlink" title="6.3 方法内联"></a>6.3 方法内联</h4><p>方法内联能去除方法调用的成本，同时也为其他优化建立了良好的基础，因此各种编译器一般会把内联优化放在优化序列的最靠前位置，然而由于Java对象的方法默认都是虚方法，在编译期无法确定方法版本，就无法内联。</p><ul><li>因此方法调用都需要在运行时进行多态选择，为了解决虚方法的内联问题，Java虚拟机团队引入了“类型继承关系分析(CHA)”的技术。<ol><li>在内联时，若是非虚方法，则可以直接内联  </li><li>遇到虚方法，首先根据CHA判断此方法是否有多个目标版本，若只有一个，可以直接内联，但是需要预留一个“逃生门”，称为守护内联，若在程序的后续执行过程中，加载了导致继承关系发生变化的新类，就需要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</li><li>若CHA判断此方法有多个目标版本，则编译器会使用“内联缓存”，第一次调用缓存记录下方法接收者的版本信息，并且每次调用都比较版本，若一致则可以一直使用，若不一致则取消内联，查找虚方法表进行方法分派。</li></ol></li></ul><h4 id="6-4-逃逸分析"><a href="#6-4-逃逸分析" class="headerlink" title="6.4 逃逸分析"></a>6.4 逃逸分析</h4><p>分析对象动态作用域，当一个方法被定以后，它可能被外部方法所引用，称为方法逃逸，甚至还有可能被外部线程访问到，称为线程逃逸。</p><ul><li>若能证明一个对象不会逃逸到方法或线程之外，这可以通过栈上分配、同步消除、标量替换来进行优化。<ol><li>栈上分配：如果确定一个对象不会逃逸，则可以让它分配在栈上，对象所占用的内存空间就可以随栈帧出栈而销毁。这样可以减小垃圾收集系统的压力。  </li><li>同步消除：线程同步相对耗时，如果确定一个变量不会逃逸出线程，那这个变量的读写不会有竞争，则对这个变量实施的同步措施也就可以消除掉。  </li><li>标量替换：如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那么程序真正执行的时候可以不创建这个对象，改为直接创建它的成员变量，这样就可以在栈上分配。</li></ol></li></ul><h3 id="7-反射机制"><a href="#7-反射机制" class="headerlink" title="7. 反射机制"></a>7. 反射机制</h3><p>简单说，反射机制是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。<br>Class反射对象描述的是类的语义结构，通过class对象，可以获取构造器，成员变量，方法等类元素的反射对象，并且可以用编程的方法通过这些反射对象对目标对象进行操作。<br>这些反射类在java.lang.reflect包中定义，下面是最主要的三个类：</p><ol><li>Constructor：类的构造函数反射类：<ul><li>通过Class#getConstructors()方法可以获得类的所有构造函数的反射对象数组。</li><li>其中最主要的方法是newInstance(Object[] args),通过该方法可以创建一个对象类的实例，功能和new一样。在jdk5.0之后，提供了newInstance(Object…args)更为灵活。</li></ul></li><li>Method：类方法的反射类。<ul><li>通过Class#getDeclaredMethods()方法可以获取所有方法的反射类对象数组Method[].其中最主要的方法是:</li><li>invoke(String name,class parameterTypes),和invoke(Object obj,Object…args)。同时也还有很多其他方法</li><li>Class getReturnType（）：获取方法的返回值类型</li><li>Class[] getParameterTypes（）：获取方法的参数数组</li></ul></li><li>Field：类成员变量的反射类，<ul><li>通过Class#getDeclareFields（）可以获取类成员变量反射的数组。</li><li>Class#getDeclareField（String  name）获取某特定名称的反射对象。</li><li>最主要的方法是：set(Object obj,Object value),为目标对象的成员变量赋值。如果是基础类型还可以这样赋值setInt(),setString()…</li></ul></li></ol><ul><li>java还提供了包的反射类和注解的反射类。</li><li>总结:java反射体系保证了通过程序化的方式访问目标对象的所有元素，对于private 和protected成员变量或者方法，也是可以访问的。</li></ul><h4 id="7-1-反射中，Class-forName和classloader的区别"><a href="#7-1-反射中，Class-forName和classloader的区别" class="headerlink" title="7.1 反射中，Class.forName和classloader的区别"></a>7.1 反射中，Class.forName和classloader的区别</h4><ul><li>Class.forName()得到的Class是完成初始化的</li><li>而ClassLoader.loadClass()得到的Class是还没有链接的。</li><li>Spring IoC为了加快初始化速度，因此大量使用了延时加载技术。而使用classloader不需要执行类中的初始化代码，可以加快加载速度，把类的初始化工作留到实际使用到这个类的时候。</li></ul><h4 id="7-2-哪里用到反射机制？"><a href="#7-2-哪里用到反射机制？" class="headerlink" title="7.2 哪里用到反射机制？"></a>7.2 哪里用到反射机制？</h4><ul><li>JDBC中，利用反射动态加载了数据库驱动程序。</li><li>Web服务器中利用反射调用了Sevlet的服务方法。</li><li>Eclispe等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。</li><li>很多框架都用到反射机制，注入属性，调用方法，如Spring。</li></ul><h4 id="7-3-反射机制的优缺点？"><a href="#7-3-反射机制的优缺点？" class="headerlink" title="7.3 反射机制的优缺点？"></a>7.3 反射机制的优缺点？</h4><p>优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。<br>缺点：对性能有影响，这类操作总是慢于直接执行java代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-类文件结构&quot;&gt;&lt;a href=&quot;#1-类文件结构&quot; class=&quot;headerlink&quot; title=&quot;1. 类文件结构&quot;&gt;&lt;/a&gt;1. 类文件结构&lt;/h3&gt;&lt;p&gt;Class文件是一组以 &lt;strong&gt;8 位字节&lt;/strong&gt;为基础单位的二进制流，各个数据&lt;strong&gt;严格按照顺序紧凑的排列&lt;/strong&gt;在 Class 文件中，中间无任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，会按照高位在前的方式分割成若干个 8 位字节进行存储。&lt;br&gt;Java 虚拟机规范规定 Class 文件格式采用一种类似与 C 语言结构体的伪结构体来存储数据，这种伪结构体中只有两种数据类型：&lt;strong&gt;无符号数&lt;/strong&gt;和&lt;strong&gt;表&lt;/strong&gt;。
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
</feed>
