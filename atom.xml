<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路，走过去，前面是个天！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chaooo.github.io/"/>
  <updated>2019-11-19T13:00:49.775Z</updated>
  <id>http://chaooo.github.io/</id>
  
  <author>
    <name>郑超(Charles·Zheng)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【ELK】ElasticStack入门详解</title>
    <link href="http://chaooo.github.io/article/20191119.html"/>
    <id>http://chaooo.github.io/article/20191119.html</id>
    <published>2019-11-19T12:42:59.000Z</published>
    <updated>2019-11-19T13:00:49.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-ElasticStack特点"><a href="#1-1-ElasticStack特点" class="headerlink" title="1.1 ElasticStack特点"></a>1.1 ElasticStack特点</h4><ol><li>使用门槛低，开发周期短，上线快</li><li>性能好，查询快，实时展示结果</li><li>扩容方便，快速支撑增长迅猛的数据</li></ol><h4 id="1-2-ElasticStack（ELK）各组件作用"><a href="#1-2-ElasticStack（ELK）各组件作用" class="headerlink" title="1.2 ElasticStack（ELK）各组件作用"></a>1.2 ElasticStack（ELK）各组件作用</h4><ol><li><strong><code>ElasticSearch</code></strong>(核心引擎): 数据存储、查询和分析</li><li><strong><code>LogStash+beats</code></strong>: 数据收集和处理（类似于ETL）</li><li><strong><code>Kibana</code></strong>: 数据探索与可视化分析<a id="more"></a></li></ol><h4 id="1-3-ElasticStack使用场景"><a href="#1-3-ElasticStack使用场景" class="headerlink" title="1.3 ElasticStack使用场景"></a>1.3 ElasticStack使用场景</h4><ul><li>搜索引擎、日志分析、指标分析</li></ul><h4 id="1-4-ElasticStack安装启动"><a href="#1-4-ElasticStack安装启动" class="headerlink" title="1.4 ElasticStack安装启动"></a>1.4 ElasticStack安装启动</h4><ol><li><p><code>ElasticSearch</code>启动：解压到安装目录，启动<code>bin/elasticsearch</code>（默认端口:<code>http://localhost:9200</code>, 加参数<code>-d</code>后台启动）</p></li><li><p><code>ElasticSearch</code>集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch -d </span><br><span class="line">bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3 -d</span><br></pre></td></tr></table></figure></li><li><p>Kibana启动：解压到安装目录，启动<code>bin/kibana</code>（默认端口:<code>http://localhost:5601</code>）</p></li></ol><h4 id="1-5-ElasticSearch常见术语"><a href="#1-5-ElasticSearch常见术语" class="headerlink" title="1.5 ElasticSearch常见术语"></a>1.5 ElasticSearch常见术语</h4><ol><li><code>Document</code>(文档)：用户存储在ES中的数据文档</li><li><code>Index</code>(索引)：由具有相同字段的文档列表组成</li><li><code>field</code>(字段)：包含具体数据</li><li><code>Node</code>(节点)：一个ES的实例，构成clister的单元</li><li><code>Cluster</code>(集群)：对外服务的一个/多个节点</li></ol><h4 id="1-6-Document介绍"><a href="#1-6-Document介绍" class="headerlink" title="1.6 Document介绍"></a>1.6 Document介绍</h4><ol><li>常用数据类型：字符串、数值型、布尔型、日期型、二进制、范围类型</li><li>每个文档都有一个唯一<code>ID</code>标识。（可以自行指定，也可由ES自动生成）</li><li>元数据，用于标注文档的相关信息：<ul><li><code>_index</code>：文档所在的索引名</li><li><code>_type</code>：文档所在的类型名(后续的版本中type这个概念将会被移除，也不允许一个索引中有多个类型)</li><li><code>_id</code>：文档唯一标识</li><li><code>_source</code>：文档的原始JSON数据，可从这获取每个字段的内容</li><li><code>_all</code>：整合所有字段内容到该字段。（默认禁用）</li><li><code>_version</code>：文档字段版本号，标识被操作了几次</li></ul></li><li><code>Index</code>介绍：<ul><li>索引中存储相同结构的文档，且每个index都有自己的Mapping定义，用于定义字段名和类型；</li><li>一个集群中可以有多个inex，类似于可以有多个table。</li></ul></li><li><code>RESTful API</code>两种交互方式：<ol><li>CURL命令行：curl -XPUT xxx</li><li>Kibana DevTools————PUT xxx{ }</li></ol></li><li><code>Index API</code>： 用户创建、删除、获取索引配置等。<ol><li>创建索引：<ul><li><code>PUT /test_index</code> #创建一个名为<code>test_index</code>的索引</li></ul></li><li>查看索引：<ul><li><code>GET _cat/indices</code> #查看所有的索引</li></ul></li><li>删除索引：<ul><li><code>DELETE /test_index</code> #删除名为<code>test_index</code>的索引</li></ul></li></ol></li></ol><h4 id="1-7-CRUD操作（交互基于Kibana-DevTools）"><a href="#1-7-CRUD操作（交互基于Kibana-DevTools）" class="headerlink" title="1.7 CRUD操作（交互基于Kibana DevTools）"></a>1.7 CRUD操作（交互基于Kibana DevTools）</h4><ol><li><p>创建文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建ID为1的Document</span><br><span class="line">PUT /test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"username"</span>:<span class="string">"alfred"</span>,</span><br><span class="line"> <span class="attr">"age"</span>:<span class="string">"24"</span></span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 不指定ID创建Document(ID会自动生成)</span><br><span class="line">POST /test_index/doc</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"username"</span>:<span class="string">"buzhiding"</span>,</span><br><span class="line"> <span class="attr">"age"</span>:<span class="string">"1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 查看名为test_index的索引中id为1的文档</span><br><span class="line">GET /test_index/doc/1</span><br><span class="line">//</span><br><span class="line">// 查询所有文档：</span><br><span class="line">// 查询名为test_index的索引中所有文档,用到endpoint：_search，默认返回符合的前10条</span><br><span class="line">// term和match的区别：term完全匹配，不进行分词器分析；match模糊匹配，进行分词器分析，包含即返回</span><br><span class="line">GET /test_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"term"</span>:&#123;</span><br><span class="line">   <span class="attr">"_id"</span>:<span class="string">"1"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>批量操作文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 批量创建文档，用到endpoint：_bulk</span><br><span class="line">// index和create的区别，如果文档存在时，使用create会报错，而index会覆盖</span><br><span class="line">POST _bulk</span><br><span class="line">&#123;<span class="attr">"index"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"test_index"</span>,<span class="attr">"_type"</span>:<span class="string">"doc"</span>,<span class="attr">"_id"</span>:<span class="string">"3"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"username"</span>:<span class="string">"alfred"</span>,<span class="attr">"age"</span>:<span class="string">"20"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"delete"</span>:&#123;<span class="attr">"_index"</span>:<span class="string">"test_index"</span>,<span class="attr">"_type"</span>:<span class="string">"doc"</span>,<span class="attr">"_id"</span>:<span class="string">"1"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"update"</span>:&#123;<span class="attr">"_id"</span>:<span class="string">"2"</span>,<span class="attr">"_index"</span>:<span class="string">"test_index"</span>,<span class="attr">"_type"</span>:<span class="string">"doc"</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">"doc"</span>:&#123;<span class="attr">"age"</span>:<span class="string">"30"</span>&#125;&#125;</span><br><span class="line">//</span><br><span class="line">// 批量查询文档，使用endpoint:_mget</span><br><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"doc"</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">"_index"</span>:<span class="string">"test_index"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:<span class="string">"doc"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:<span class="string">"1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">"_index"</span>:<span class="string">"test_index"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:<span class="string">"doc"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:<span class="string">"2"</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 根据搜索内容删除文档,使用endpoint:_delete_by_query</span><br><span class="line">POST /test_index/doc/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"buzhiding"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 删除整个test_index的索引中的文档,依然使用endpoint:_delete_by_query</span><br><span class="line">POST /test_index/doc/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match_all"</span>:&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-ElasticSearch倒排索引与分词"><a href="#2-ElasticSearch倒排索引与分词" class="headerlink" title="2. ElasticSearch倒排索引与分词"></a>2. ElasticSearch倒排索引与分词</h3><h4 id="2-1-倒排索引"><a href="#2-1-倒排索引" class="headerlink" title="2.1 倒排索引"></a>2.1 倒排索引</h4><ol><li>正排索引和倒排索引<ul><li>正排索引：文档ID —&gt; 文档内容</li><li>倒排索引：单词—&gt; 文档ID列表</li></ul></li><li>倒排索引组成：（单词词典，倒排列表）<ol><li>单词词典（<code>Term Dictionary</code>）<ul><li>记录所有文档的单词，记录了单词到倒排列表的关联信息，一般使用<code>B+Tree</code>实现。</li></ul></li><li>倒排列表（<code>Posting List</code>）<ul><li>记录单词对应的文档集合，由倒排索引项<code>Posting List</code>组成。</li><li>倒排索引项：<ol><li>文档<code>ID</code>：用于获取原始信息。</li><li>词频<code>TF</code>：记录该单词在该文档中的出现次数，用于计算相关性得分。</li><li>位置<code>Position</code>：记录单词在文档中的分词位置(多个)，用于词语搜索。</li><li>偏移<code>Offset</code>：记录单词在文档的开始和结束位置，用于高亮显示。</li></ol></li></ul></li></ol></li></ol><h4 id="2-2-分词Analysis"><a href="#2-2-分词Analysis" class="headerlink" title="2.2 分词Analysis"></a>2.2 分词Analysis</h4><p>分词：将文本转换成一系列单词<code>Term/Token</code>的过程，也可称作文本分析，ES中叫作：Analysis。</p><ul><li>一些概念：<ol><li><code>Token</code>(词元)：全文搜索引擎会用某种算法对要建索引的文档进行分析， 从文档中提取出若干Token(词元)。</li><li><code>Tokenizer</code>(分词器)：这些算法叫做Tokenizer(分词器)</li><li><code>Token Filter</code>(词元处理器)：这些Token会被进一步处理， 比如转成小写等， 这些处理算法被称为TokenFilter(词元处理器)</li><li><code>Term</code>(词)：被处理后的结果被称为Term(词)</li><li><code>Character Filter</code>(字符过滤器)：文本被Tokenizer处理前可能要做一些预处理， 比如去掉里面的HTML标记， 这些处理的算法被称为Character Filter(字符过滤器)</li><li><code>Analyzer</code>(分析器)：这整个的分析算法被称为Analyzer(分析器)，由Tokenizer(分词器)和Filter(过滤器)组成</li></ol></li><li>ES有很多<strong>内置<code>Analyzer</code></strong>,比如：<ol><li><code>standard</code>：按单词边界划分、支持多语言、小写处理、移除大部分标点符号，支持停用词</li><li><code>whitespace</code>：空格为分隔符</li><li><code>simple</code>：按非字母划分、小写处理</li><li><code>stop</code>：类似简单分词器，同时支持移除停用词(the、an、的、这等)</li><li><code>keyword</code>：不分词</li><li><code>pattern</code>：通过正则表达式自定义分隔符，默认\w+，即：非字词的符号作为分隔符</li></ol></li><li>第三方analyzer插件：常用的<strong>中文分词器</strong>有：<ol><li>IK：实现中英文分词，支持多模式，可自定义词库，支持热更新分词词典。</li><li>jieba。python中流行，支持繁体分词、并行分词，可自定义词典、词性标记等。</li></ol></li><li>ES提供了一个测试分词的API接口，使用<code>endpoint：_analyze</code>，不指定分词时，会使用默认的<code>standard</code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 指定分词器进行分词测试</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"analyzer"</span>:<span class="string">"standard"</span>,</span><br><span class="line"> <span class="attr">"text"</span>:<span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 直接指定索引中字段：使用username字段的分词方式对text进行分词。</span><br><span class="line">POST test_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"field"</span>:<span class="string">"username"</span>,</span><br><span class="line"> <span class="attr">"text"</span>:<span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 自定义分词器，自定义Tokenizer、filter、等进行分词：</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"tokenizer"</span>:<span class="string">"standard"</span>,</span><br><span class="line"> <span class="attr">"filter"</span>:[<span class="string">"lowercase"</span>],</span><br><span class="line"> <span class="attr">"text"</span>:<span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-ElasticSearch的Mapping"><a href="#3-ElasticSearch的Mapping" class="headerlink" title="3. ElasticSearch的Mapping"></a>3. ElasticSearch的Mapping</h3><h4 id="3-1-Mapping简介"><a href="#3-1-Mapping简介" class="headerlink" title="3.1 Mapping简介"></a>3.1 Mapping简介</h4><p>Mapping：类似于数据库中的表结构</p><ol><li>主要作用如下：<ol><li>定义<code>Index</code>下的<code>Field Name</code>；</li><li>定义<code>Field</code>的类型，如：数值型、字符串型、布尔型等；</li><li>定义倒排索引的相关配置，如：是否有索引，记录position等。</li></ol></li><li>获取一个<code>mapping</code>，使用<code>endpoint：_mapping</code>，例如：<ul><li><code>GET /test_index/_mapping</code></li></ul></li></ol><h4 id="3-2-自定义Mapping"><a href="#3-2-自定义Mapping" class="headerlink" title="3.2 自定义Mapping"></a>3.2 自定义Mapping</h4><ol><li>使用<code>mappings</code>进行自定义<code>mapping</code>。</li><li><code>Mapping</code>中的字段类型一旦设定之后，<strong>禁止直接修改</strong>。<ul><li>因为<code>Luence</code>事先的倒排索引生成后不能修改。</li><li>如果一定要改，可以重新建立新的索引，然后对应修改<code>mapping</code>，之后将之前的数据进行<code>reindex</code>操作，导入新的文档。</li></ul></li><li>自定义<code>mapping</code>时允许新增字段。通过<code>dynamic</code>参数进行控制字段的新增，<code>dynamic</code>有三种配置：<ul><li><code>true</code>：默认配置，允许自动新增字段；</li><li><code>false</code>：不允许自动新增字段，文档可以正常写入，但不能进行查询等操作；</li><li><code>strict</code>：严格模式。文档不能写入，写入会报错。</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建名为my_index的索引，并自定义mapping</span><br><span class="line">// 使用dynamic参数控制字段的新增</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> "mappings":&#123;        // 关键字</span><br><span class="line">  "doc":&#123;            // 类型名</span><br><span class="line">   "dynamic":false,  // 设置为false，索引不允许新增字段</span><br><span class="line">   "properties":&#123;    // 字段名称及类型定义</span><br><span class="line">    "title":&#123;</span><br><span class="line">     "type":"text"   // 字段类型</span><br><span class="line">    &#125;,</span><br><span class="line">    "name":&#123;</span><br><span class="line">     "type":"keyword"</span><br><span class="line">    &#125;,</span><br><span class="line">    "age":&#123;</span><br><span class="line">     "type":"integer"</span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-copy-to的使用"><a href="#3-3-copy-to的使用" class="headerlink" title="3.3 copy_to的使用"></a>3.3 copy_to的使用</h4><p>将该字段的值复制到目标字段，类似于6.0版本之前的<code>_all</code>的作用。且不会出现在<code>_source</code>，一般只用来进行搜索。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// copy_to的使用</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"first_name"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="attr">"copy_to"</span>:<span class="string">"full_name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"last_name"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="attr">"copy_to"</span>:<span class="string">"full_name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"full_name"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 向索引写入数据</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"first_name"</span>:<span class="string">"John"</span>,</span><br><span class="line"> <span class="attr">"last_name"</span>:<span class="string">"Smith"</span></span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// 查询索引my_index中full_name同时包含John 和 Smith的数据</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"full_name"</span>:&#123;</span><br><span class="line">    <span class="attr">"query"</span>:<span class="string">"John Smith"</span>,</span><br><span class="line">    <span class="attr">"operator"</span>:<span class="string">"and"</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-index参数的使用"><a href="#3-4-index参数的使用" class="headerlink" title="3.4 index参数的使用"></a>3.4 index参数的使用</h4><p>控制当前字段是否为索引，默认<code>true</code>，当设置为<code>false</code>的时候，不进行记录，此时该字段不能被搜索</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// index参数的使用</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"cookie"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="attr">"index"</span>:<span class="literal">false</span>    // 设置为<span class="literal">false</span>，该字段不能被搜索</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在进行数据写入和查询，不能进行该字段搜索。一般用来进行不想被查询的私密信息设置，如身份证号，电话号码等：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 向使用了index参数的字段写入信息</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"cookie"</span>:<span class="string">"name=alfred"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-index-options参数的使用："><a href="#3-5-index-options参数的使用：" class="headerlink" title="3.5 index_options参数的使用："></a>3.5 index_options参数的使用：</h4><p>控制倒排索引记录的内容，有如下四种配置：</p><ol><li><code>docs</code>：只记录文档ID</li><li><code>freqs</code>：记录文档ID和词频TF</li><li><code>positions</code>：记录文档ID、词频TF和分词位置</li><li><code>offsets</code>：记录文档ID、词频TF、分词位置和偏移<blockquote><p>其中：text类型默认的配置是positions，其他的比如integer等类型默认为docs，目的是为了节省空间。</p></blockquote></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// index_options参数的使用</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"cookie"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"text"</span>,</span><br><span class="line">     <span class="attr">"index_options"</span>:<span class="string">"offsets"</span>  // 记录文档ID、词频TF、分词位置和偏移</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-null-value参数的使用："><a href="#3-6-null-value参数的使用：" class="headerlink" title="3.6 null_value参数的使用："></a>3.6 null_value参数的使用：</h4><p>当字段遇到空值<code>null</code>时的处理策略。默认为<code>null</code>，即跳过。此时ES会忽略该值，可通过修改进行默认值的修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用null_value修改ES遇到null值时的默认返回值</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"properties"</span>:&#123;</span><br><span class="line">    <span class="attr">"cookie"</span>:&#123;</span><br><span class="line">     <span class="attr">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">     <span class="attr">"null_value"</span>:<span class="string">"NULL"</span>    // 当遇到空值<span class="literal">null</span>的时候，返回一个字符串形式的NULL</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-Field字段的数据类型："><a href="#3-7-Field字段的数据类型：" class="headerlink" title="3.7 Field字段的数据类型："></a>3.7 Field字段的数据类型：</h4><ol><li>核心数据类型<ol><li>字符串型：<code>text</code>(分词)，<code>keyword</code>(不分词)</li><li>数值型：<code>long,integer,short,byte,double,float,half_float,scaled_float</code></li><li>日期类型：<code>date</code></li><li>布尔类型：<code>boolean</code></li><li>二进制类型：binary</li><li>范围类型：<code>integer_range,float_range,long_range,double_range,date_range</code></li></ol></li><li>复杂数据类型<ol><li>数组类型：<code>array</code></li><li>对象类型：<code>object</code></li><li>嵌套类型：<code>nested object</code></li></ol></li><li>地理位置数据类型<ol><li>点：<code>geo-point</code></li><li>形状：<code>geo-shape</code></li></ol></li><li>专用类型<ol><li>记录ip地址：<code>ip</code></li><li>实现自动补全：<code>completion</code></li><li>记录分词数：<code>token_count</code></li><li>记录字符串hash值：<code>murmur3</code></li><li><code>perclator</code></li><li><code>join</code></li></ol></li><li>多字段特性：<ul><li>ES允许对同一个字段采用不同的配置，如：分词。举例：对一个人名实现拼音搜索，只需要在人名字段中新增一个子字段pinyin即可。</li></ul></li></ol><h4 id="3-8-ES的自动类型识别："><a href="#3-8-ES的自动类型识别：" class="headerlink" title="3.8 ES的自动类型识别："></a>3.8 ES的自动类型识别：</h4><ol><li><p>Dynamic Mapping：</p><ul><li>ES可以自动识别文档字段类型，从而降低用户使用成本。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES的自动类型识别</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> "username":"alfred",    // username字段自动识别为text类型</span><br><span class="line"> "age":20                // age字段自动识别为long类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ES依靠JSON文档的字段类型实现自动识别字段类型：</p></li></ol><table><thead><tr><th>JSON类型</th><th>ElasticSearch类型</th></tr></thead><tbody><tr><td>null</td><td>忽略</td></tr><tr><td>boolean</td><td>boolean</td></tr><tr><td>浮点类型</td><td>float</td></tr><tr><td>整数类型</td><td>long</td></tr><tr><td>object</td><td>object</td></tr><tr><td>array</td><td>由第一个非null的值的类型决定</td></tr><tr><td>String</td><td>匹配为日期，则为date类型(默认开启)<br>匹配为数字，则为long类型/float类型(默认关闭)<br>都未匹配，则设为text类型，并附带keyword子字段</td></tr></tbody></table><ol start="3"><li>验证ES的字段类型自动识别：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 验证ES的字段类型自动识别</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> "username":"alfred",    // 字符串类型text</span><br><span class="line"> "age":20,               // 整数long</span><br><span class="line"> "bitrh":"1998-10-10",   // 默认识别日期date</span><br><span class="line"> "married":false,        // 布尔类型boolean</span><br><span class="line"> "year":"18"             // 默认不识别数字text</span><br><span class="line"> "tags":["boy","fashion"],// 数组中第一个不为null的元素为字符串类型，所以为text</span><br><span class="line"> "money":100.1           // 浮点类型float</span><br><span class="line">&#125;</span><br><span class="line">//  再对my_index进行mapping查询，就会获得每个字段的类型：</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-9-ES中日期类型和数字的自动识别："><a href="#3-9-ES中日期类型和数字的自动识别：" class="headerlink" title="3.9 ES中日期类型和数字的自动识别："></a>3.9 ES中日期类型和数字的自动识别：</h4><p>ES中可自行配置日期的格式，默认：[“<code>strict_date_optional_time</code>“,”<code>yyyy/MM/dd HH:mm:ss Z</code>|| <code>yyyy/MM/dd z</code>“]</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使用dynamic_date_formats自定义日期格式</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"dynamic_date_formats"</span>:[<span class="string">"MM/dd/yyyy"</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 写入符合自定义格式的日期数据，可识别为date类型</span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"create_time"</span>:<span class="string">"01/01/2019"</span>    // create_time字段识别为date类型</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">//  2. 使用date_detection可以关闭自动识别日期格式：</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"date_detection"</span>:<span class="literal">false</span> </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"create_time"</span>:<span class="string">"01/01/2019"</span>    // create_time字段是text类型</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// ES中可配置数字是否识别，默认关闭：</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"numeric_detection"</span>:<span class="literal">true</span>    // 开启数字自动识别</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 写入数字数据，ES可以自动识别其类型</span><br><span class="line">PUT mu_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> "year":"18",    // year字段自动识别为long类型</span><br><span class="line"> "money":"100.1"    // money字段自动识别为float类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-ES中根据自动识别的数据类型，动态生成字符类型"><a href="#3-10-ES中根据自动识别的数据类型，动态生成字符类型" class="headerlink" title="3.10 ES中根据自动识别的数据类型，动态生成字符类型"></a>3.10 ES中根据自动识别的数据类型，动态生成字符类型</h4><p>例: </p><ol><li>字符串类型都设为keyword类型（不分词）</li><li>以message开头的字段都设为text类型（分词）</li><li>以long_开头的字段都设为long类型</li><li>自动匹配为double的类型都设为float类型。（为了节省空间）</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES根据自动识别的数据类型、字段名等动态设定字符类型</span><br><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">   <span class="attr">"dynamic_template"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"strings"</span>:&#123;</span><br><span class="line">      // 匹配到所有的字符串类型，全部设为keyword类型</span><br><span class="line">      "match_mapping_type":"string",</span><br><span class="line">      "mapping":&#123;</span><br><span class="line">       "type":"keyword"</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配规则</strong>的参数：</p><ol><li><code>match_mapping_type</code>：匹配ES自动识别的字段类型，如boolean、long、string等</li><li><code>match</code>、<code>unmatch</code>：匹配字段名，比如”match”:”message*” ===&gt;以message开头的数据</li><li><code>path_match</code>、<code>path_unmatch</code>：匹配路径</li></ol><h4 id="3-11-自定义mapping的操作步骤"><a href="#3-11-自定义mapping的操作步骤" class="headerlink" title="3.11 自定义mapping的操作步骤"></a>3.11 自定义mapping的操作步骤</h4><ol><li>写入一条文档到ES的临时索引中，获取(复制)ES自动生成的mapping</li><li>修改获得的mapping，并在其中自定义相关配置</li><li>使用修改后的mapping创建实际所需索引。</li></ol><h3 id="4-ElasticSearch的Search-API"><a href="#4-ElasticSearch的Search-API" class="headerlink" title="4. ElasticSearch的Search API"></a>4. ElasticSearch的Search API</h3><p>在ES中，为了实现对存储的数据进行查询分析，使用<code>endpoint</code>：<strong><code>_search</code></strong>。</p><ol><li>实现对所有索引的泛查询：<code>GET /_search</code></li><li>实现对一个索引的单独查询：<code>GET /my_index/_search</code></li><li>实现对多个索引的指定查询：<code>GET /my_index1,my_index2/_search</code></li><li>实现对符合指定要求的索引进行查询：<code>GET /my_*/_search</code></li></ol><p>在进行查询的时候，主要有两种方式：(<code>URI Search</code>，<code>Request Body Search</code>)</p><ol><li><strong><code>URI Search</code></strong>：操作简单，直接通过命令行方便测试，但仅包含部分查询语法；<ul><li>如：<code>GET /my_index/_search?q=username:alfred</code></li></ul></li><li><strong><code>Request Body Search</code></strong>：ES提供的完备查询语法，使用<code>Query DSL(Domain Specific Language)</code>进行查询<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如：Request Body Search方式进行查询</span><br><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-1-URI-Search"><a href="#4-1-URI-Search" class="headerlink" title="4.1 URI Search"></a>4.1 URI Search</h4><ol><li>通过<code>url query</code>参数实现搜索，常用参数有：<ol><li><strong><code>q</code></strong>：指定查询的语句，使用query string syntax语法</li><li><strong><code>df</code></strong>：q中不指定字段时默认查询的字段（在不指定的时候默认查询所有字段）</li><li><strong><code>sort</code></strong>：排序</li><li><strong><code>timeout</code></strong>：指定超时时间，默认不超时 </li><li><strong><code>from,size</code></strong>：用于分页</li></ol><ul><li>举例：<ul><li><code>GET my_index/_search?q=alfred&amp;df=username&amp;sort=age:asc&amp;from=4&amp;size=10&amp;timeout=1s</code></li><li>解释：查询索引<code>my_index</code>中<code>username</code>字段中包含<code>alfred</code>的文档，结果按<code>age</code>字段<code>升序排列</code>，返回第<code>5-14</code>个文档，若超过<code>1s</code>未结束，则以超时结束。</li></ul></li></ul></li><li><code>query string syntax</code>语法<ul><li>前置内容：<code>term:单词</code>，<code>phrase:词语</code>。</li><li>单词与词语语法：<ul><li>单词：<code>alfred way</code>等价于<code>alfred</code> OR <code>way</code></li><li>词语：<code>&quot;alfred way&quot;</code>语句查询，要求先后顺序</li><li>泛查询：不指定字段，会在所有字段中去匹配其单词</li><li>指定字段查询：指定字段，在指定字段中匹配单词</li></ul></li><li>Group分组设定，使用括号指定匹配的规则<ul><li>举例：<code>GET my_index/_search?q=username:(alfred OR way)AND lee</code></li></ul></li></ul></li></ol><h5 id="4-1-1-URI-Search-API"><a href="#4-1-1-URI-Search-API" class="headerlink" title="4.1.1 URI Search API"></a>4.1.1 URI Search API</h5><ol><li><p>泛查询：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search?q=alfred</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"profile"</span>:<span class="literal">true</span> #使用profile参数，可以明确地看到ES如何执行的查询条件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定字段查询：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// a.查询字段username中包含alfred的文档</span><br><span class="line">GET my_index/_search?q=username:alfred</span><br><span class="line">//</span><br><span class="line">// b.查询字段username中包含alfred或way的文档</span><br><span class="line">GET my_index/_search?q=username:alfred way</span><br><span class="line">//</span><br><span class="line">// c.查询字段username为"alfred way"的文档</span><br><span class="line">GET my_index/_search?q=username:"alfred way"</span><br><span class="line">//</span><br><span class="line">// d.分组后，查询字段username中包含alfred，包含way的文档</span><br><span class="line">GET my_index/_search?q=username:(alfred way)</span><br><span class="line">// 这个和b的结果一样，但是区别在于使用分组之后，不进行泛查询。</span><br></pre></td></tr></table></figure></li><li><p>布尔操作符AND(&amp;&amp;)、OR(||)、NOT(!)、+(must)、-(must_not)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查询索引my_index中username包含alfred但是不包含way的文档</span><br><span class="line">GET my_index/_search?q=username:(alfred NOT way)</span><br><span class="line">//</span><br><span class="line">// 查询索引my_index中一定包含lee，一定不含alfred，可能有way的文档</span><br><span class="line">GET my_index/_search?q=username:(way +lee -alfred)</span><br><span class="line">// 或写成</span><br><span class="line">GET my_index/_search?q=username:((lee &amp;&amp; !alfred) || (way &amp;&amp; lee &amp;&amp; !alfred))</span><br><span class="line">//</span><br><span class="line">// 注意：url中，+(加号)会被解析成空格，所以要用 %2B ：</span><br><span class="line">// 查询索引my_index中一定包含lee，一定不包含alfred，可能包含way的文档</span><br><span class="line">GET my_index/_search?q=username:(way %2Blee -alfred)</span><br></pre></td></tr></table></figure></li><li><p>范围查询（支持数值和日期）</p><ul><li>区间写法：闭区间使用<code>[]</code>，开区间使用<code>{}</code><ol><li><code>age:[1 TO 10]</code>  // 1&lt;= age &lt;=10</li><li><code>age:[1 TO 10}</code>  // 1&lt;= age &lt;10</li><li><code>age:[1 TO ]</code>    // age &gt;=1</li><li><code>age:[* TO 10]</code>  // age &lt;=10</li></ol></li><li>算数符号写法：<ol><li><code>age:&gt;=1</code></li><li><code>age:(&gt;=1 &amp;&amp; &lt;= 10) / age:(+ &gt;= 1 + &lt;= 10)</code></li></ol></li><li>还可以对日期进行范围查询，注意：年/月是从1月1号/1号开始算的：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// a.查询索引my_index中username字段包含alfred_或_年龄大于20的文档</span><br><span class="line">GET my_index/_search?q=username:alfred age&gt;20</span><br><span class="line">//  </span><br><span class="line">// b.查询索引my_index中username字段包含alfred_且_年龄大于20的文档</span><br><span class="line">GET my_index/_search?q=username:alfred AND age&gt;20</span><br><span class="line">// </span><br><span class="line">// 查询索引my_index中birth字段在1985和1990之间的文档</span><br><span class="line">GET my_index/_search?q=birth:(&gt;1985 AND &lt; 1990)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通配符查询</p><ul><li><code>?</code>代表一个字符，<code>*</code>代表0个或多个字符，如：<code>name:a?lfred</code>或<code>name:a*d</code>或<code>name:alfred*</code></li><li>注意：通配符匹配的执行效率较低，且占用内存较多，不建议使用，如果没有特殊要求，也不要将?或者*放在最前面，因为意味着要匹配所有文档，可能会造成OOM。</li></ul></li><li><p>正则表达式/模糊匹配/近似度查询</p><ul><li>正则表达式：举例：<code>/[a]?l.*/</code></li><li>模糊匹配：<code>fuzzy query</code></li><li>近似度查询：<code>proximity search</code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 模糊匹配。匹配与alfred差一个字符的词，比如：alfreds、alfret等</span><br><span class="line">GET my_index/_search?q=username:alfred~1</span><br><span class="line">//</span><br><span class="line">// 近似度查询，查询字段username和"alfred way"差n个单词的文档</span><br><span class="line">GET my_index/_search?q=username:"alfred way" ~5</span><br></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>使用场景常见于用户输入词的纠错中。</p></blockquote><h4 id="4-2-Request-Body-Search"><a href="#4-2-Request-Body-Search" class="headerlink" title="4.2 Request Body Search"></a>4.2 Request Body Search</h4><p>ES自带的完备查询语句，将查询语句通过<code>http request body</code>发送到ES，主要参数有：</p><ol><li><code>query</code>：符合<code>Query DSL</code>语法的查询条件</li><li><code>from，size</code></li><li><code>timeout</code></li><li><code>sort</code></li></ol><ul><li><code>Query DSL</code>语法：<ul><li>基于<code>JSON</code>定义的查询语言，主要包含两个类型：<ol><li>字段类查询————如：<code>term</code>，<code>match</code>，<code>range</code>等。只针对一个字段进行查询</li><li>复合查询————如：<code>bool</code>查询等。包含一个/多个字段类查询/符合查询语句</li></ol></li></ul></li></ul><h5 id="4-2-1-字段类查询-全文匹配"><a href="#4-2-1-字段类查询-全文匹配" class="headerlink" title="4.2.1 字段类查询-全文匹配"></a>4.2.1 字段类查询-全文匹配</h5><p>针对<code>text</code>类型的字段进行全文检索，会对查询语句进行“先分词再查询”处理，如：<code>match</code>、<code>match_phrase</code>等</p><h6 id="4-2-1-1-match-query"><a href="#4-2-1-1-match-query" class="headerlink" title="4.2.1.1 match query"></a>4.2.1.1 match query</h6><ol><li>对字段进行全文检索(最基本和最常用的查询类型)，举例：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;  </span><br><span class="line">   "match":&#123;                 // 关键词</span><br><span class="line">    "username":"alfred way"  // 字段名和查询语句</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>从结果，可以返回匹配文件总数，返回文档列表，_score相关性得分等。<br>一般的执行流程为： 1.对查询语句分词==&gt;2.根据字段的倒排索引列表，进行匹配算分==&gt;3.汇总得分==&gt;4.根据得分排序，返回匹配文档</p></blockquote><ol start="2"><li><p>使用<code>operator</code>参数，可以控制单词间关系，有<code>and/or</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用operator参数控制单词间关系</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred way"</span>,</span><br><span class="line">   <span class="attr">"operator"</span>:<span class="string">"and"</span>    // and，同时包含alfred和way</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>minimum_should_match</code>参数控制需匹配的单词数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用minimum_should_match参数控制需匹配的单词数</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred way"</span>,</span><br><span class="line">   <span class="attr">"minimum_should_match"</span>:<span class="string">"2"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-2-1-2-相关性算分，其本质就是一个排序问题"><a href="#4-2-1-2-相关性算分，其本质就是一个排序问题" class="headerlink" title="4.2.1.2 相关性算分，其本质就是一个排序问题"></a>4.2.1.2 相关性算分，其本质就是一个排序问题</h6><ul><li>计算文档与待查询语句之间的相关度，一般有四个重要概念：<ol><li><code>Term Frequency</code> 词频(正相关)</li><li><code>Document Frequency</code> 文档频率(负相关)</li><li><code>Inverse Term Frequency</code> 逆文本频率(正相关)</li><li><code>Field-length Norm</code> 文档长度(负相关)</li></ol></li><li>目前ES有两个相关性算分的模型：<ol><li><code>TF/IDF</code>模型：经典模型。</li><li><code>BM25</code>模型：5.x版本后的默认模型，是对TF/IDF的优化模型。</li></ol></li></ul><ol><li><code>TF/IDF</code>模型：在使用kibana进行查询时，使用explain参数，可以查看具体的计算方法。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用explain参数，可以查看具体的相关性的得分是如何计算的</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> "explain":true,    // 设置为true</span><br><span class="line"> "query":&#123;</span><br><span class="line">  "match":&#123;</span><br><span class="line">   "username":"alfred"</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：ES计算相关性得分是根据<code>shard</code>进行的，即分片的分数计算相互独立，所以在使用的时候要注意分片数，可以通过设定分片数为1来避免这个问题，主要是为了观察，不代表之后所有的分片全都设为1。一般放在创建索引后，未加数据之前。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设定shards数量为1</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"settings"</span>:&#123;</span><br><span class="line">  <span class="attr">"number_of_shards"</span>:<span class="string">"1"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>BM25模型。5.x版本后的默认模型，是对TF/IDF的优化模型。<ul><li><code>best match，25</code>指：迭代了25次才计算。BM25的使用，降低了TF/IDF中因为TF过大导致的负面影响，在BM25中，一个单词的TF一直增长，到一定程度就趋于0变化。</li></ul></li></ol><h6 id="4-2-1-3-match-phrase-query"><a href="#4-2-1-3-match-phrase-query" class="headerlink" title="4.2.1.3 match phrase query"></a>4.2.1.3 match phrase query</h6><p>对字段做全文检索，有顺序要求。</p><ol><li><p>使用<code>match——phrase</code>查询词语</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  "match_phrase":&#123;    // 关键词</span><br><span class="line">   "job":"java engineer"</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过使用<code>slop</code>参数，可以控制单词间间隔：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match_phrase"</span>:&#123;</span><br><span class="line">   <span class="attr">"job"</span>:&#123;</span><br><span class="line">    <span class="attr">"query"</span>:<span class="string">"java engineer"</span>,</span><br><span class="line">    <span class="attr">"slop"</span>:<span class="string">"1"</span>    // 关键词，设定单词间隔</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-2-1-4-query-string-query"><a href="#4-2-1-4-query-string-query" class="headerlink" title="4.2.1.4 query string query"></a>4.2.1.4 query string query</h6><p>类似于<code>URI Search</code>中的q参数查询，举例：</p><ol><li>使用<code>query_string</code>查询<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"query_string"</span>:&#123;</span><br><span class="line">   <span class="attr">"default_field"</span>:<span class="string">"username"</span>,</span><br><span class="line">   "query":&#123;alfred AND way"</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">//* 或 */</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"query_string"</span>:&#123;</span><br><span class="line">   <span class="attr">"fileds"</span>:[<span class="string">"username"</span>,<span class="string">"job"</span>],</span><br><span class="line">   <span class="attr">"query"</span>:<span class="string">"alfred OR (java AND ruby)"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-2-1-5-simple-query-string-query"><a href="#4-2-1-5-simple-query-string-query" class="headerlink" title="4.2.1.5 simple query string query"></a>4.2.1.5 simple query string query</h6><p>类似于<code>query string</code>，但会忽略错误的查询语法，且仅支持部分查询语句。使用<code>+，|，-</code>分别代替<code>AND，OR，NOT</code>。</p><ol><li>使用simple query string query<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"simple_query_string"</span>:&#123;</span><br><span class="line">   <span class="attr">"fields"</span>:[username],</span><br><span class="line">   <span class="attr">"query"</span>:<span class="string">"alfred +way"</span>    #等价于 <span class="string">"query"</span>:<span class="string">"alfred AND way"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="4-2-2-字段类查询-单词匹配"><a href="#4-2-2-字段类查询-单词匹配" class="headerlink" title="4.2.2 字段类查询-单词匹配"></a>4.2.2 字段类查询-单词匹配</h5><h6 id="4-2-2-1-term-terms-query"><a href="#4-2-2-1-term-terms-query" class="headerlink" title="4.2.2.1 term/terms query"></a>4.2.2.1 term/terms query</h6><p>将待查询语句作为整个单词进行查询，不做分词处理，举例：</p><ol><li><p>使用term进行单查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"term"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用terms进行多查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"terms"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:[<span class="string">"alfred"</span>,<span class="string">"way"</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>此时如果直接使用<code>alfred way</code>作为<code>username</code>查询条件，是不会返回任何文档的。因为在<code>username</code>的倒排索引列表中，存在<code>&quot;alfred&quot;</code>和<code>&quot;way&quot;</code>的索引，但是不存在<code>&quot;alfred way&quot;</code>的索引。</p></blockquote><h6 id="4-2-2-2-range-query"><a href="#4-2-2-2-range-query" class="headerlink" title="4.2.2.2 range query"></a>4.2.2.2 range query</h6><ul><li>范围查询，主要针对数值类型和日期类型。<ul><li><strong><code>gt</code></strong>: greater than 大于</li><li><strong><code>gte</code></strong>: greate than or equal to 大于等于</li><li><strong><code>lt</code></strong>: less than 小于</li><li><strong><code>lte</code></strong>: less than or equal to 小于等于</li></ul></li></ul><ol><li><p>对数值的查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// range query对数值的查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"range"</span>:&#123;</span><br><span class="line">   <span class="attr">"age"</span>:&#123;</span><br><span class="line">    <span class="attr">"gte"</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">"lte"</span>:<span class="number">20</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对日期的查询</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// range query对日期的查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"range"</span>:&#123;</span><br><span class="line">   <span class="attr">"birth"</span>:&#123;</span><br><span class="line">    <span class="attr">"lte"</span>:<span class="string">"1988-01-01"</span> </span><br><span class="line">    // 或者使用"lte":"now-30y",这种Date Math类型</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong><code>Date Math</code>类型</strong>：针对日期提供的一种更友好的计算方式。<br>当前时间用<code>now</code>代替，具体时间的引用，需要使用<code>||</code>间隔。年、月、日、时、分、秒跟<code>date</code>一致：<code>y、M、w、d、h、m、s</code>。<br>举例：</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 假设当前时间为2019-01-02 12:00:00</span><br><span class="line">now+1h   =&gt;   2019-01-02 13:00:00</span><br><span class="line">now-1h   =&gt;   2019-01-02 11:00:00</span><br><span class="line">now-1h/d =&gt;   2019-01-02 00:00:00</span><br><span class="line">2019-01-01||+1M/d  =&gt; 2019-02-01 00:00:00</span><br></pre></td></tr></table></figure><h5 id="4-2-3-复合查询"><a href="#4-2-3-复合查询" class="headerlink" title="4.2.3 复合查询"></a>4.2.3 复合查询</h5><p>包含一个/多个字段类查询/符合查询语句</p><h6 id="4-2-3-1-constant-score-query"><a href="#4-2-3-1-constant-score-query" class="headerlink" title="4.2.3.1 constant_score query"></a>4.2.3.1 constant_score query</h6><ol><li><code>constant_score query</code>: 将内部的查询结果文档得分全部设定为1或boost的值。返回的相关性得分全部为1或boost<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用constant_score query</span><br><span class="line">GET my_index/_Search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  "constant_score":&#123;    #关键词</span><br><span class="line">   "match":&#123;</span><br><span class="line">    "username":"alfred"</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-2-3-2-bool-query"><a href="#4-2-3-2-bool-query" class="headerlink" title="4.2.3.2 bool query"></a>4.2.3.2 bool query</h6><p><code>bool query</code>: 由一个/多个布尔子句组成，主要包含以下四个：</p><ol><li><p><code>filter</code>: 只过滤符合条件的文档，不计算相关性得分，返回的相关性得分全部为0；</p><ul><li><code>ES</code>会对<code>filter</code>进行智能缓存，因此执行效率较高，在做简单匹配查询且不考虑得分的时候没推荐使用<code>filter</code>代替<code>query</code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 使用filter查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  "bool":&#123;    // 关键词</span><br><span class="line">   "filter":[</span><br><span class="line">    "term":&#123;</span><br><span class="line">     "username":"alfred"</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>must</code>: 文档必须符合<code>must</code>中的所有条件，影响相关性得分；</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 使用must进行查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"must"</span>:[    </span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"match"</span>:&#123;</span><br><span class="line">      <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"match"</span>:&#123;</span><br><span class="line">      <span class="attr">"job"</span>:<span class="string">"specialist"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>must_not</code>: 文档必须排除must_not中的所有条件； </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用must_not进行查询</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"must"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"match"</span>:&#123;</span><br><span class="line">     <span class="attr">"job"</span>:<span class="string">"java"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"must_not"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"match"</span>:&#123;</span><br><span class="line">     <span class="attr">"job"</span>:<span class="string">"ruby"</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>should</code>: 文档可以符合<code>should</code>中的条件，影响相关性得分，分为两种情况：同时配合<code>minimum_should_match</code>控制满足调价你的个数/百分比。</p><ol><li><code>bool</code>查询中只有<code>should</code>，不包含<code>must</code>的情况</li><li>bool查询中既有should，又包含must的情况，文档不必满足should中的条件，但是如果满足的话则会增加相关性得分。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// bool查询中只有should的情况</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"should"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"term"</span>:&#123;<span class="attr">"job"</span>:<span class="string">"java"</span>&#125;    // 条件<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"term"</span>:&#123;<span class="attr">"job"</span>:<span class="string">"ruby"</span>&#125;    // 条件<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"term"</span>:&#123;<span class="attr">"job"</span>:<span class="string">"specialist"</span>&#125;    // 条件<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"minimum_should_match"</span>:<span class="number">2</span>    // 至少需要满足两个条件</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// </span><br><span class="line">// bool查询中同时包含should和must</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"should"</span>:[    // 同时包含should</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"job"</span>:<span class="string">"ruby"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"must"</span>:[    // 同时包含must</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"usernmae"</span>:<span class="string">"alfred"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><blockquote><p>当一个查询语句位于query或filter上下文的时候，ES的执行结果也不同。<br>|-|-|-|<br>|———|———–|———|<br>| query   | 查找和查询语句最匹配的文档，<br>并对所有文档计算相关性得分 | query<br>bool中的：must/should |<br>| filter   | 查找和查询语句最匹配的文档 | bool中的：filter/must_not<br>constant_score中的：filter |</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// query和filter上下文</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"bool"</span>:&#123;</span><br><span class="line">   <span class="attr">"must"</span>:[    // query上下文</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"title"</span>:<span class="string">"Search"</span>&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"content"</span>:<span class="string">"ElasticSearch"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"filter"</span>:[    // filter上下文</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"term"</span>:&#123;<span class="attr">"status"</span>:<span class="string">"published"</span>&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">"range"</span>:&#123;</span><br><span class="line">     <span class="attr">"publish_date"</span>:&#123;</span><br><span class="line">      <span class="attr">"gte"</span>:<span class="string">"2015-01-01"</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-3-count-API"><a href="#4-2-3-3-count-API" class="headerlink" title="4.2.3.3 count API"></a>4.2.3.3 count API</h6><p><code>count API</code>: 获取符合条件的文档书，使用<code>endpoint：_count</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用_count获取符合条件的文档数</span><br><span class="line">GET my_index/_count    // 关键词</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"query"</span>:&#123;</span><br><span class="line">  <span class="attr">"match"</span>:&#123;</span><br><span class="line">   <span class="attr">"username"</span>:<span class="string">"alfred"</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-4-Source-Filtering"><a href="#4-2-3-4-Source-Filtering" class="headerlink" title="4.2.3.4 Source Filtering"></a>4.2.3.4 Source Filtering</h6><p><code>Source Filtering</code>: 过滤返回结果中的<code>_source</code>中的字段，主要由以下两种方式：</p><ol><li>GET my_index/_search?_source=username #url参数</li><li>使用Request Body Search：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 不返回_source</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"_source"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">// 返回_source部分字段</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"_source"</span>:[<span class="string">"username"</span>,<span class="string">"age"</span>]</span><br><span class="line">&#125;</span><br><span class="line">// 通配符匹配返回_source部分字段</span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"_source"</span>:&#123;</span><br><span class="line">  <span class="attr">"includes"</span>:<span class="string">"*I*"</span>,</span><br><span class="line">  <span class="attr">"encludes"</span>:<span class="string">"birth"</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;h4 id=&quot;1-1-ElasticStack特点&quot;&gt;&lt;a href=&quot;#1-1-ElasticStack特点&quot; class=&quot;headerlink&quot; title=&quot;1.1 ElasticStack特点&quot;&gt;&lt;/a&gt;1.1 ElasticStack特点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用门槛低，开发周期短，上线快&lt;/li&gt;
&lt;li&gt;性能好，查询快，实时展示结果&lt;/li&gt;
&lt;li&gt;扩容方便，快速支撑增长迅猛的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;1-2-ElasticStack（ELK）各组件作用&quot;&gt;&lt;a href=&quot;#1-2-ElasticStack（ELK）各组件作用&quot; class=&quot;headerlink&quot; title=&quot;1.2 ElasticStack（ELK）各组件作用&quot;&gt;&lt;/a&gt;1.2 ElasticStack（ELK）各组件作用&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ElasticSearch&lt;/code&gt;&lt;/strong&gt;(核心引擎): 数据存储、查询和分析&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;LogStash+beats&lt;/code&gt;&lt;/strong&gt;: 数据收集和处理（类似于ETL）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Kibana&lt;/code&gt;&lt;/strong&gt;: 数据探索与可视化分析
    
    </summary>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/categories/ElasticStack/"/>
    
    
      <category term="ElasticSearch" scheme="http://chaooo.github.io/tags/ElasticSearch/"/>
    
      <category term="Kibana" scheme="http://chaooo.github.io/tags/Kibana/"/>
    
      <category term="ElasticStack" scheme="http://chaooo.github.io/tags/ElasticStack/"/>
    
      <category term="LogStash" scheme="http://chaooo.github.io/tags/LogStash/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】NIO、Netty及websocket实现</title>
    <link href="http://chaooo.github.io/article/20191020.html"/>
    <id>http://chaooo.github.io/article/20191020.html</id>
    <published>2019-10-20T15:34:31.000Z</published>
    <updated>2019-11-16T15:11:33.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-BIO-NIO-AIO演变"><a href="#1-BIO-NIO-AIO演变" class="headerlink" title="1. BIO/NIO/AIO演变"></a>1. BIO/NIO/AIO演变</h3><p>Java IO 方式有很多种，基于不同的IO抽象模型和交互方式，可以进行简单区分。</p><table><thead><tr><th>IO类型</th><th>模型</th><th>客户端:线程数</th><th>API使用难度</th><th>调试难度</th><th>可靠性</th><th>吞吐量</th></tr></thead><tbody><tr><td>BIO</td><td>流，同步阻塞</td><td>1:1</td><td>简单</td><td>简单</td><td>很差</td><td>非常低</td></tr><tr><td>伪异步IO</td><td>同步阻塞</td><td>M:N</td><td>简单</td><td>简单</td><td>较差</td><td>中等</td></tr><tr><td>NIO</td><td>同步非阻塞</td><td>M:1</td><td>复杂</td><td>复杂</td><td>较高</td><td>高</td></tr><tr><td>AIO</td><td>异步非阻塞</td><td>M:0,被动回调</td><td>复杂</td><td>复杂</td><td>高</td><td>高</td></tr></tbody></table><ol><li>区分同步(synchronous)或异步(asynchronous)<ul><li>同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；</li><li>异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li></ul></li><li>区分阻塞(blocking)与非阻塞(non-blocking)<ul><li>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；</li><li>非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理</li></ul></li></ol><ul><li>传统的java.io包，它基于流模型实现，<strong>同步阻塞</strong>的交互方式，如File抽象、输入输出流等。好处是代码简单、直观，缺点是IO效率和扩展性局限性</li><li>很多时候，也把java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库，因为网络通信同样是IO行为。</li><li>伪异步IO：后端通过维护一个消息队列和N个活跃线程, 通过一个<strong>线程池</strong>来处理多个客户端的请求接入，通过线程池，可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入而导致的线程耗尽和宕机。</li><li>JDK4引入了NIO框架(java.nio)，提供了Channel、Selector、Buffer等新的抽象，可以构建<strong>多路复用</strong>的、<strong>同步非阻塞</strong>IO程序，同时提供了更接近操作系统底层的高性能数据操作方式。</li><li>JDK7中，NIO有了进一步的改进，引入了异步非阻塞IO方式，也叫AIO(Asynchronous IO)。异步IO操作基于事件和<strong>回调机制</strong>，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</li></ul><h4 id="1-1-NIO的主要组成部分："><a href="#1-1-NIO的主要组成部分：" class="headerlink" title="1.1 NIO的主要组成部分："></a>1.1 NIO的主要组成部分：</h4><ol><li>Buffer(缓冲区)，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现。<ul><li>Buffer最常见的类型是ByteBuffer，另外还有CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。</li></ul></li><li>Channel(通道)，是NIO中被用来支持批量式IO操作的一种抽象。<ul><li>和流不同，通道是双向的。数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</li></ul></li><li>Selector(多路复用器)，是NIO实现多路复用的基础，它允许单线程处理多个Channel。<ul><li>Selector是基于底层操作系统机制，不同模式、不同版本都存在区别。</li><li>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</li></ul></li></ol><h4 id="1-2-NIO多路复用的过程"><a href="#1-2-NIO多路复用的过程" class="headerlink" title="1.2 NIO多路复用的过程"></a>1.2 NIO多路复用的过程</h4><ol><li>通过Selector.open()创建一个Selector，作为类似调度员的角色。</li><li>创建一个ServerSocketChannel，并绑定监听端口，设置为非阻塞模式</li><li>将Channel向Selector注册，通过指定SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。</li><li>Selector循环阻塞在select操作，当有Channel发生接入请求，就会被唤醒。</li><li>调用selectedKeys方法获取就绪channel集合</li><li>通过SocketChannel和Buffer进行数据操作。</li></ol><h4 id="1-3-AIO"><a href="#1-3-AIO" class="headerlink" title="1.3 AIO"></a>1.3 AIO</h4><ul><li>AIO也叫NIO2.0 是一种非阻塞异步的通信模式。在NIO的基础上引入了新的<strong>异步通道</strong>的概念，并提供了异步文件通道和异步套接字通道的实现。<ul><li>没有采用NIO的多路复用器，而是使用异步通道的概念。</li><li>其read，write方法的返回类型都是Future对象。而Future模型是异步的，其核心思想是：去主函数等待时间。</li><li>AIO模型中通过AsynchronousSocketChannel和AsynchronousServerSocketChannel完成套接字通道的实现。非阻塞，异步。</li></ul></li></ul><h3 id="2-Netty框架"><a href="#2-Netty框架" class="headerlink" title="2. Netty框架"></a>2. Netty框架</h3><p>Netty是一个高性能事件驱动，异步非阻塞的IO开源框架，由Jboss提供，用于建立Tcp等底层的链接，基于Netty可以建立高性能的Http服务器，快速开发高性能、高可靠的网络服务器和客户端程序。支持Http、websocket，tcp，udp等协议。</p><ul><li>Netty使用场景：高性能领域（游戏，大数据分布式计算等）、多线程并发领域（多路复用模型，多线程模型，主从多线程模型）、异步通信领域</li><li>Netty 是一个吸收了多种协议（包括FTP、SMTP、HTTP等各种二进制文本协议）的实现经验，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。</li></ul><h4 id="2-1-Netty的核心概念"><a href="#2-1-Netty的核心概念" class="headerlink" title="2.1 Netty的核心概念"></a>2.1 Netty的核心概念</h4><ol><li>ServerBootstrap，服务器端程序的入口，这是 Netty 为简化网络程序配置和关闭等生命周期管理，所引入的 Bootstrapping 机制。我们通常要做的创建 Channel、绑定端口、注册 Handler 等，都可以通过这个统一的入口，以<strong>Fluent API</strong>等形式完成，相对简化了 API 使用。与之相对应， Bootstrap则是 Client 端的通常入口。</li><li>Channel，作为一个基于 NIO 的扩展框架，Channel 和 Selector 等概念仍然是 Netty 的基础组件，但是针对应用开发具体需求，提供了相对易用的抽象。</li><li>EventLoop，这是 Netty 处理事件的核心机制。例子中使用了 EventLoopGroup。我们在 NIO 中通常要做的几件事情，如注册感兴趣的事件、调度相应的 Handler 等，都是 EventLoop 负责。</li><li>ChannelFuture，这是 Netty 实现异步 IO 的基础之一，保证了同一个 Channel 操作的调用顺序。Netty 扩展了 Java 标准的 Future，提供了针对自己场景的特有Future定义。</li><li>ChannelHandler，这是应用开发者<strong>放置业务逻辑的主要地方</strong>，也是我上面提到的“Separation Of Concerns”原则的体现。</li><li>ChannelPipeline，它是 ChannelHandler 链条的容器，每个 Channel 在创建后，自动被分配一个 ChannelPipeline。在上面的示例中，我们通过 ServerBootstrap 注册了 ChannelInitializer，并且实现了 initChannel 方法，而在该方法中则承担了向 ChannelPipleline 安装其他 Handler 的任务。</li></ol><h4 id="2-2-对比-Java-标准-NIO-类库，Netty是如何实现更高性能的？"><a href="#2-2-对比-Java-标准-NIO-类库，Netty是如何实现更高性能的？" class="headerlink" title="2.2 对比 Java 标准 NIO 类库，Netty是如何实现更高性能的？"></a>2.2 对比 Java 标准 NIO 类库，Netty是如何实现更高性能的？</h4><p>单独从性能角度，Netty 在基础的 NIO 等类库之上进行了很多改进，例如：</p><ol><li>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</li><li>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</li><li>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li><li>在通信协议、序列化等其他角度的优化。</li></ol><p>Netty 的设计强调了 “Separation Of Concerns”，通过精巧设计的事件机制，将业务逻辑和无关技术逻辑进行隔离，并通过各种方便的抽象，一定程度上填补了了基础平台和业务开发之间的鸿沟，更有利于在应用开发中普及业界的最佳实践。另外，Netty &gt; java.nio + java. net！</p><p>除了核心的事件机制等，Netty 还额外提供了很多功能，例如：</p><ol><li>从网络协议的角度，Netty 除了支持传输层的 UDP、TCP、SCTP协议，也支持 HTTP(s)、WebSocket 等多种应用层协议，它并不是单一协议的 API。</li><li>在应用中，需要将数据从 Java 对象转换成为各种应用协议的数据格式，或者进行反向的转换，Netty 为此提供了一系列扩展的编解码框架，与应用开发场景无缝衔接，并且性能良好。</li><li>它扩展了 Java NIO Buffer，提供了自己的 ByteBuf 实现，并且深度支持 Direct Buffer 等技术，甚至 hack 了 Java 内部对 Direct Buffer 的分配和销毁等。同时，Netty 也提供了更加完善的 Scatter/Gather 机制实现。</li></ol><h3 id="3-基于Netty搭建简单的Http服务"><a href="#3-基于Netty搭建简单的Http服务" class="headerlink" title="3. 基于Netty搭建简单的Http服务"></a>3. 基于Netty搭建简单的Http服务</h3><ol><li>环境准备：<code>jdk1.8</code>、<code>Netty4.1.43.Final</code></li><li>代码编写：<code>MyChannelInitializer.java</code>、<code>MyClientHandler.java</code>、<code>NettyServer.java</code></li></ol><blockquote><p>MyChannelInitializer.java：添加了Http的处理协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数据解码操作</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line">        <span class="comment">// 数据编码操作</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的接收数据实现方法</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MyServerHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            DefaultHttpRequest request = (DefaultHttpRequest) msg;</span><br><span class="line">            System.out.println(<span class="string">"URI:"</span> + request.getUri());</span><br><span class="line">            System.err.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpContent) &#123;</span><br><span class="line">            LastHttpContent httpContent = (LastHttpContent) msg;</span><br><span class="line">            ByteBuf byteData = httpContent.content();</span><br><span class="line">            <span class="keyword">if</span> (!(byteData <span class="keyword">instanceof</span> EmptyByteBuf)) &#123;</span><br><span class="line">                <span class="comment">//接收msg消息</span></span><br><span class="line">                <span class="keyword">byte</span>[] msgByte = <span class="keyword">new</span> <span class="keyword">byte</span>[byteData.readableBytes()];</span><br><span class="line">                byteData.readBytes(msgByte);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(msgByte, StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String sendMsg = <span class="string">"不平凡的岁月终究来自你每日不停歇的刻苦拼搏，每一次真正成长都因看清脚下路而抉择出的生活。"</span>;</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                HttpVersion.HTTP_1_1,</span><br><span class="line">                HttpResponseStatus.OK,</span><br><span class="line">                Unpooled.wrappedBuffer(sendMsg.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">"text/plain;charset=UTF-8"</span>);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line">        ctx.write(response);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NettyServer().bing(<span class="number">7397</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bing</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置服务端NIO线程组</span></span><br><span class="line">        EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(parentGroup, childGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)<span class="comment">//非阻塞模式</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyChannelInitializer());</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">"http-netty server start done. "</span>);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            childGroup.shutdownGracefully();</span><br><span class="line">            parentGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>启动<code>NettyServer</code>，<code>Postman</code>访问<code>http://localhost:7397</code>并设置参数</p></blockquote><h3 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a>4. WebSocket</h3><p>WebSocket是一种H5协议规范，通过握手机制客户端与服务器之间就能够建立一个类似Tcp的连接，从而方便客户端与服务器之间的通信。</p><ul><li>它是一种解决客户端与服务端实时通信而产生的技术：WebSocket本质是一种基于TCP协议，先通过Http/Https发一个特殊的Http请求进行握手，握手后会创建一个用于交换数据的TCP链接，之后客户端和服务端使用该TCP链接进行实时通信。当WebSocket的客户端和服务端握手后 建立通信后，就不再需要之前的http请求参与。</li></ul><h4 id="4-1-WebSocket的优点："><a href="#4-1-WebSocket的优点：" class="headerlink" title="4.1 WebSocket的优点："></a>4.1 WebSocket的优点：</h4><ul><li>节省通信开销，之前WebServer实现通信，都使用轮询，需要不停的向服务器发送请求，而HttpRequest的handler很长，请求包含真正的数据可能很小，会占用很多额外的带宽和服务器资源。</li><li>建立连接后，服务器可主动传数据给客户端，客户端也可以随意向服务端传数据。交换数据时所携带的头信息很小。浏览器（客户端）和服务器只需要做一个握手的动作。</li><li>实时通信：WebSocket不仅限于Ajax方式通信。ajax方式需要浏览器发起请求。而WebSocket技术 服务端和客户端可以彼此相互推送信息，从而实现实时通信。</li></ul><h4 id="4-2-WebSocket建立连接过程："><a href="#4-2-WebSocket建立连接过程：" class="headerlink" title="4.2 WebSocket建立连接过程："></a>4.2 WebSocket建立连接过程：</h4><p><code>客户端发起握手请求 ---&gt; 服务端响应请求 ---&gt; 建立连接</code></p><ul><li>详细流程：建立一个WebSocket连接，客户端或浏览器首先向服务器发送一个特殊的Http请求(携带一些附加头信息)Upgrade:websocket，服务端解析附加头信息，产生应答消息，然后响应给客户端，之后客户端就与服务端建立响应的链接。</li></ul><h4 id="4-3-WebSocket生命周期："><a href="#4-3-WebSocket生命周期：" class="headerlink" title="4.3 WebSocket生命周期："></a>4.3 WebSocket生命周期：</h4><ol><li>打开事件：端点上建立新链接时，该事件是先于其他任何事件发生之前。该事件发生会产生三部分信息。<ol><li>创建WebSocket Session对象：用于表示已经建立好的链接</li><li>配置对象：包含配置端点的信息。</li><li>一组路径参数，用于打开节点握手时，WebSocket端入栈匹配的URI</li></ol></li><li>消息事件：主要是接收WebSocket对话中，另一端发送的消息。链接上的消息将会有三种形式抵达客户端。<ol><li>文本消息 用String处理</li><li>二进制消息 用byteBuffer或者byte[]处理</li><li>pong消息 用Java WebSocket API中的pong.message接口的实例来处理</li></ol></li><li>错误事件：WebSocket链接或者端点发生错误时产生。可以处理入栈消息时发生的各种异常。入栈消息可能产生的三种异常。<ol><li>WebSocket建立链接时发生错误：SessionException类型</li><li>WebSocket试图将入栈消息解码成开发人员使用的对象时 EncodeException类型</li><li>WebSocket端点的其他方法运行时产生的错误，WebSocket实现将记录端点操作过程中产生的任何异常</li></ol></li><li>关闭事件：WebSocket链接端点关闭，做一些清理工作，可以由参与连接的任意一个端点发出。</li></ol><h4 id="4-4-WebSocket如何关闭链接："><a href="#4-4-WebSocket如何关闭链接：" class="headerlink" title="4.4 WebSocket如何关闭链接："></a>4.4 WebSocket如何关闭链接：</h4><p>流程：当服务器被指示关闭WebSocket链接时，服务端会发起一个TCP Close操作， 客户端应该等待服务器的TCP Close</p><ul><li>关闭WebSocket连接，端点需关闭底层TCP连接。</li><li>底层TCP连接，在大多数正常情况下，应该首先被服务器关闭，服务器持有TIME_WAIT状态（因为这会防止它在2个报文最大生存时间（2MLS）内重新打开连接，然而当一个新的带有更高的seq number的SYN时没有对应的服务器影响TIME_WAIT连接被立即重新打开）。</li><li>在异常情况下（例如在一个合理的时间量后没有接收到服务器的TCP Close）,客户端可以发起<code>TCP Close</code>。</li></ul><h3 id="5-基于Netty搭建WebSocket多人聊天室"><a href="#5-基于Netty搭建WebSocket多人聊天室" class="headerlink" title="5. 基于Netty搭建WebSocket多人聊天室"></a>5. 基于Netty搭建WebSocket多人聊天室</h3><ol><li>使用SpringBoot+Netty+WebSocket搭建功能。</li><li>使用Netty提供的HttpServerCodec、HttpObjectAggregator、ChunkedWriteHandler进行编码解码处理。</li><li>环境准备：<code>jdk1.8</code>、<code>Netty4.1.43.Final</code>、<code>spring-boot-starter-web</code></li></ol><blockquote><p>目录结构</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">└── src.main</span><br><span class="line">       ├── java</span><br><span class="line">       │   └── top.chaooo.hellonetty</span><br><span class="line">       │       ├── domain</span><br><span class="line">       │       │    ├── ClientMsgProtocol.java</span><br><span class="line">       │       │    └── ServerMsgProtocol.java</span><br><span class="line">       │       ├── server</span><br><span class="line">       │       │    ├── MyChannelInitializer.java</span><br><span class="line">       │       │    ├── MyServerHandler.java</span><br><span class="line">       │       │    └── NettyServer.java</span><br><span class="line">       │       ├── util</span><br><span class="line">       │       │    ├── ChannelHandler.java</span><br><span class="line">       │       │    └── MsgUtil.java</span><br><span class="line">       │       ├── controller</span><br><span class="line">       │       │    └── NettyController.java    </span><br><span class="line">       │       └── NettyApplication.java</span><br><span class="line">       └── resources</span><br><span class="line">            ├── static(js,img)</span><br><span class="line">            ├── templates</span><br><span class="line">            │    └── index.html</span><br><span class="line">            └── application.yml</span><br></pre></td></tr></table></figure><blockquote><p>resources/application.yml：基础配置信息，包括了；应用端口、netty服务端端口等</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">netty:</span></span><br><span class="line"><span class="attr">  host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">7397</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  thymeleaf:</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">HTML5</span></span><br><span class="line"><span class="attr">    encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">    content-type:</span> <span class="string">text/html</span></span><br><span class="line"><span class="attr">    cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><blockquote><p>server/MyChannelInitializer.java：websocket处理协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel channel)</span> </span>&#123;</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"http-codec"</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));</span><br><span class="line">        channel.pipeline().addLast(<span class="string">"http-chunked"</span>, <span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的接收数据实现方法</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server/MyServerHandler.java：处理websocket消息信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> WebSocketServerHandshaker handshaker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端主动链接服务端的链接后，这个通道就是活跃的了。</span></span><br><span class="line"><span class="comment">     * 也就是客户端与服务端建立了通信通道并且可以传输数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) ctx.channel();</span><br><span class="line">        logger.info(<span class="string">"链接报告开始"</span>);</span><br><span class="line">        logger.info(<span class="string">"链接报告信息：有一客户端链接到本服务端"</span>);</span><br><span class="line">        logger.info(<span class="string">"链接报告IP:&#123;&#125;"</span>, channel.localAddress().getHostString());</span><br><span class="line">        logger.info(<span class="string">"链接报告Port:&#123;&#125;"</span>, channel.localAddress().getPort());</span><br><span class="line">        logger.info(<span class="string">"链接报告完毕"</span>);</span><br><span class="line">        ChannelUtil.channelGroup.add(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端主动断开服务端的链接后，这个通道就是不活跃的。</span></span><br><span class="line"><span class="comment">     * 也就是说客户端与服务端的关闭了通信通道并且不可以传输数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"客户端断开链接&#123;&#125;"</span>, ctx.channel().localAddress().toString());</span><br><span class="line">        ChannelUtil.channelGroup.remove(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//http</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest) &#123;</span><br><span class="line">            FullHttpRequest httpRequest = (FullHttpRequest) msg;</span><br><span class="line">            <span class="keyword">if</span> (!httpRequest.decoderResult().isSuccess()) &#123;</span><br><span class="line">                DefaultFullHttpResponse httpResponse = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST);</span><br><span class="line">                <span class="comment">// 返回应答给客户端</span></span><br><span class="line">                <span class="keyword">if</span> (httpResponse.status().code() != <span class="number">200</span>) &#123;</span><br><span class="line">                    ByteBuf buf = Unpooled.copiedBuffer(httpResponse.status().toString(), CharsetUtil.UTF_8);</span><br><span class="line">                    httpResponse.content().writeBytes(buf);</span><br><span class="line">                    buf.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是非Keep-Alive，关闭连接</span></span><br><span class="line">                ChannelFuture f = ctx.channel().writeAndFlush(httpResponse);</span><br><span class="line">                <span class="keyword">if</span> (httpResponse.status().code() != <span class="number">200</span>) &#123;</span><br><span class="line">                    f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            WebSocketServerHandshakerFactory wsFactory = <span class="keyword">new</span> WebSocketServerHandshakerFactory(<span class="string">"ws:/"</span> + ctx.channel() + <span class="string">"/websocket"</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            handshaker = wsFactory.newHandshaker(httpRequest);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == handshaker) &#123;</span><br><span class="line">                WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handshaker.handshake(ctx.channel(), httpRequest);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ws</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> WebSocketFrame) &#123;</span><br><span class="line">            WebSocketFrame webSocketFrame = (WebSocketFrame) msg;</span><br><span class="line">            <span class="comment">//关闭请求</span></span><br><span class="line">            <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> CloseWebSocketFrame) &#123;</span><br><span class="line">                handshaker.close(ctx.channel(), (CloseWebSocketFrame) webSocketFrame.retain());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ping请求</span></span><br><span class="line">            <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> PingWebSocketFrame) &#123;</span><br><span class="line">                ctx.channel().write(<span class="keyword">new</span> PongWebSocketFrame(webSocketFrame.content().retain()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只支持文本格式，不支持二进制消息</span></span><br><span class="line">            <span class="keyword">if</span> (!(webSocketFrame <span class="keyword">instanceof</span> TextWebSocketFrame)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"仅支持文本格式"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String request = ((TextWebSocketFrame) webSocketFrame).text();</span><br><span class="line">            System.out.println(<span class="string">"服务端收到："</span> + request);</span><br><span class="line">            ClientMsgProtocol clientMsgProtocol = JSON.parseObject(request, ClientMsgProtocol.class);</span><br><span class="line">            <span class="comment">//1请求个人信息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == clientMsgProtocol.getType()) &#123;</span><br><span class="line">                ctx.channel().writeAndFlush(MsgUtil.buildMsgOwner(ctx.channel().id().toString()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//群发消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> == clientMsgProtocol.getType()) &#123;</span><br><span class="line">                TextWebSocketFrame textWebSocketFrame = MsgUtil.buildMsgAll(ctx.channel().id().toString(), clientMsgProtocol.getMsgInfo());</span><br><span class="line">                ChannelUtil.channelGroup.writeAndFlush(textWebSocketFrame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抓住异常，当发生异常的时候，可以做一些相应的处理，比如打印日志、关闭链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        logger.info(<span class="string">"异常信息：\r\n"</span> + cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server/NettyServer.java：主服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"nettyServer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line">    <span class="comment">//配置服务端NIO线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bing</span><span class="params">(InetSocketAddress address)</span> </span>&#123;</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(parentGroup, childGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)    <span class="comment">//非阻塞模式</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyChannelInitializer());</span><br><span class="line">            channelFuture = b.bind(address).syncUninterruptibly();</span><br><span class="line">            channel = channelFuture.channel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != channelFuture &amp;&amp; channelFuture.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">"demo-netty server start done"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"demo-netty server start error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channelFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == channel) <span class="keyword">return</span>;</span><br><span class="line">        channel.close();</span><br><span class="line">        parentGroup.shutdownGracefully();</span><br><span class="line">        childGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>util/MsgUtil.java：消息构建工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title">buildMsgAll</span><span class="params">(String channelId, String msgInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟头像</span></span><br><span class="line">        <span class="keyword">int</span> i = Math.abs(channelId.hashCode()) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        ServerMsgProtocol msg = <span class="keyword">new</span> ServerMsgProtocol();</span><br><span class="line">        msg.setType(<span class="number">2</span>); <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        msg.setChannelId(channelId);</span><br><span class="line">        msg.setUserHeadImg(<span class="string">"head"</span> + i + <span class="string">".jpg"</span>);</span><br><span class="line">        msg.setMsgInfo(msgInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title">buildMsgOwner</span><span class="params">(String channelId)</span> </span>&#123;</span><br><span class="line">        ServerMsgProtocol msg = <span class="keyword">new</span> ServerMsgProtocol();</span><br><span class="line">        msg.setType(<span class="number">1</span>); <span class="comment">//链接信息;1链接信息、2消息信息</span></span><br><span class="line">        msg.setChannelId(channelId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>util/ChannelUtil.java：存储每一个客户端接入进来时的channel对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于存放用户Channel信息，也可以建立map结构模拟不同的消息群</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>domain/*MsgProtocol.java：省略get/set</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMsgProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;             <span class="comment">//链接信息;1:自发信息、2:群发消息</span></span><br><span class="line">    <span class="keyword">private</span> String channelId;     <span class="comment">//通信管道ID，实际使用中会映射成用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userHeadImg;   <span class="comment">//用户头像[模拟分配]</span></span><br><span class="line">    <span class="keyword">private</span> String msgInfo;       <span class="comment">//通信消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMsgProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;       <span class="comment">//1:请求个人信息，2:发送聊天信息</span></span><br><span class="line">    <span class="keyword">private</span> String msgInfo; <span class="comment">//消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>controller/NettyController.java：路由控制层</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>, <span class="string">"Dear"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>js逻辑：依赖jquery.min.js、jquery.serialize-object.min.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript Document</span></span><br><span class="line"><span class="keyword">var</span> socket;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;</span><br><span class="line">        <span class="built_in">window</span>.WebSocket = <span class="built_in">window</span>.MozWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;</span><br><span class="line">        alert(<span class="string">"您的浏览器不支持WebSocket协议！推荐使用谷歌浏览器进行测试。"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:7397/websocket"</span>);</span><br><span class="line">    socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> msg = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">        <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == msg.type)&#123;</span><br><span class="line">            jQuery.data(<span class="built_in">document</span>.body, <span class="string">'channelId'</span>, msg.channelId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> == msg.type)&#123;</span><br><span class="line">            <span class="keyword">var</span> channelId =    msg.channelId;</span><br><span class="line">            <span class="comment">//自己</span></span><br><span class="line">            <span class="keyword">if</span>(channelId == jQuery.data(<span class="built_in">document</span>.body, <span class="string">'channelId'</span>))&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = $(<span class="string">".msgBlockOwnerClone"</span>).clone();</span><br><span class="line">                <span class="built_in">module</span>.removeClass(<span class="string">"msgBlockOwnerClone"</span>).addClass(<span class="string">"msgBlockOwner"</span>).css(&#123;<span class="attr">display</span>: <span class="string">"block"</span>&#125;);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".headPoint"</span>).attr(<span class="string">"src"</span>, <span class="string">"res/img/"</span>+msg.userHeadImg);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_msgInfo .msgPoint"</span>).text(msg.msgInfo);</span><br><span class="line">                $(<span class="string">"#msgPoint"</span>).before(<span class="built_in">module</span>);</span><br><span class="line">                util.divScroll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//好友</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = $(<span class="string">".msgBlockFriendClone"</span>).clone();</span><br><span class="line">                <span class="built_in">module</span>.removeClass(<span class="string">"msgBlockFriendClone"</span>).addClass(<span class="string">"msgBlockFriend"</span>).css(&#123;<span class="attr">display</span>: <span class="string">"block"</span>&#125;);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".headPoint"</span>).attr(<span class="string">"src"</span>, <span class="string">"res/img/"</span>+msg.userHeadImg);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_channelId"</span>).text(<span class="string">"ID："</span>+msg.channelId);</span><br><span class="line">                <span class="built_in">module</span>.find(<span class="string">".msgBlock_msgInfo .msgPoint"</span>).text(msg.msgInfo);</span><br><span class="line">                $(<span class="string">"#msgPoint"</span>).before(<span class="built_in">module</span>);</span><br><span class="line">                util.divScroll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">"打开WebSoket 服务正常，浏览器支持WebSoket!"</span>);</span><br><span class="line">        <span class="keyword">var</span> clientMsgProtocol = &#123;&#125;;</span><br><span class="line">        clientMsgProtocol.type = <span class="number">1</span>;</span><br><span class="line">        clientMsgProtocol.msgInfo = <span class="string">"请求个人信息"</span>;</span><br><span class="line">        socket.send(<span class="built_in">JSON</span>.stringify(clientMsgProtocol));</span><br><span class="line">     &#125;;</span><br><span class="line">    socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">"WebSocket 关闭"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">13</span> == e.keyCode &amp;&amp; e.ctrlKey)&#123;</span><br><span class="line">            util.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">util = &#123;</span><br><span class="line">    send: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">window</span>.WebSocket)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">            <span class="keyword">var</span> clientMsgProtocol = &#123;&#125;;</span><br><span class="line">            clientMsgProtocol.type = <span class="number">2</span>;</span><br><span class="line">            clientMsgProtocol.msgInfo = $(<span class="string">"#sendBox"</span>).val();</span><br><span class="line">            socket.send(<span class="built_in">JSON</span>.stringify(clientMsgProtocol));</span><br><span class="line">            $(<span class="string">"#sendBox"</span>).val(<span class="string">""</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">"WebSocket 连接没有建立成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    divScroll: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>); </span><br><span class="line">        div.scrollTop = div.scrollHeight; </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>主要Html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span> <span class="attr">xmlns:sec</span>=<span class="string">"http://www.thymeleaf.org/extras/spring-security"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/jquery.serialize-object.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chatDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chat"</span> <span class="attr">style</span>=<span class="string">"width:529px; height:667px; background-color:#F5F5F5; float:right;"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 会话区域 begin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"show"</span> <span class="attr">style</span>=<span class="string">"width:529px; height:450px; float:left;overflow-y:scroll;"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息块；好友 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlockFriendClone"</span> <span class="attr">style</span>=<span class="string">" display:none; margin-left:30px; margin-top:15px; width:340px; height:auto; margin-bottom:15px; float:left;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_userHeadImg"</span> <span class="attr">style</span>=<span class="string">"float:left; width:35px; height:35px;border-radius:3px;-moz-border-radius:3px; background-color:#FFFFFF;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"headPoint"</span> <span class="attr">src</span>=<span class="string">"/img/head5.jpg"</span> <span class="attr">width</span>=<span class="string">"35px"</span> <span class="attr">height</span>=<span class="string">"35px"</span> <span class="attr">style</span>=<span class="string">"border-radius:3px;-moz-border-radius:3px;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_channelId"</span> <span class="attr">style</span>=<span class="string">"float:left; width:100px; margin-top:-5px; margin-left:10px; padding-bottom:2px; font-size:10px;"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 名称 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_msgInfo"</span> <span class="attr">style</span>=<span class="string">"height:auto;width:280px;float:left;margin-left:12px; margin-top:4px;border-radius:3px;-moz-border-radius:3px; "</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:4px; height:20px; background-color:#CC0000; float:left;border-radius:3px;-moz-border-radius:3px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgPoint"</span> <span class="attr">style</span>=<span class="string">"float:left;width:260px; padding:7px; background-color:#FFFFFF; border-radius:3px;-moz-border-radius:3px; height:auto; font-size:12px;display:block;word-break: break-all;word-wrap: break-word;"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息块；自己 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlockOwnerClone"</span> <span class="attr">style</span>=<span class="string">" display:none; margin-right:30px; margin-top:15px; width:340px; height:auto; margin-bottom:15px; float:right;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:right; width:35px; height:35px;border-radius:3px;-moz-border-radius:3px; background-color:#FFFFFF;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"headPoint"</span> <span class="attr">src</span>=<span class="string">"/img/head3.jpg"</span> <span class="attr">width</span>=<span class="string">"35px"</span> <span class="attr">height</span>=<span class="string">"35px"</span> <span class="attr">style</span>=<span class="string">"border-radius:3px;-moz-border-radius:3px;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgBlock_msgInfo"</span> <span class="attr">style</span>=<span class="string">"height:auto;width:280px;float:left;margin-left:12px; margin-top:4px;border-radius:3px;-moz-border-radius:3px; "</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"msgPoint"</span> <span class="attr">style</span>=<span class="string">"float:left;width:260px; padding:7px; background-color:#FFFFFF; border-radius:3px;-moz-border-radius:3px; height:auto; font-size:12px;display:block;word-break: break-all;word-wrap: break-word;"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:4px; height:20px; background-color:#CC0000; float:right;border-radius:3px;-moz-border-radius:3px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"msgPoint"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 会话区域 end --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:100%; height:2px; float:left; background-color:#CCCCCC;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin:0 auto; width:100%; height:149px; margin-top:5px;  background-color:#FFFFFF; float:left;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"sendBox"</span> <span class="attr">style</span>=<span class="string">"font-size:14px; border:0; width:499px; height:80px; outline:none; padding:15px;font-family:”微软雅黑”;resize: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:20px; float:right; margin-right:35px; padding:5px; padding-left:15px; padding-right:15px; font-size:12px; background-color:#F5F5F5;border-radius:3px;-moz-border-radius:3px; cursor:pointer;"</span> <span class="attr">onclick</span>=<span class="string">"javascript:util.send();"</span>&gt;</span>发送(S)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动SpringBoot，Netty会随着启动；</li><li>用不同浏览器访问 <code>http://localhost:8080/index</code> 测试多人实时聊天。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-BIO-NIO-AIO演变&quot;&gt;&lt;a href=&quot;#1-BIO-NIO-AIO演变&quot; class=&quot;headerlink&quot; title=&quot;1. BIO/NIO/AIO演变&quot;&gt;&lt;/a&gt;1. BIO/NIO/AIO演变&lt;/h3&gt;&lt;p&gt;Java IO 方式有很多种，基
      
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】阻塞队列 与 线程池</title>
    <link href="http://chaooo.github.io/article/20191014.html"/>
    <id>http://chaooo.github.io/article/20191014.html</id>
    <published>2019-10-14T15:04:54.000Z</published>
    <updated>2019-11-07T14:02:54.271Z</updated>
    
    <content type="html"><![CDATA[<ul><li>池和队列的关系<ul><li>线程池或者数据库连接池，都有最大限制。如果超出了限制数量，则新进来的申请连接都要放入额外的<strong>队列里</strong>，等到池空出来时，从队列中取出连接放进池里。<a id="more"></a></li></ul></li></ul><h3 id="1-BlockingQueue（阻塞队列）"><a href="#1-BlockingQueue（阻塞队列）" class="headerlink" title="1. BlockingQueue（阻塞队列）"></a>1. BlockingQueue（阻塞队列）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue接口</span><br><span class="line">    |———— BlockingQueue接口</span><br><span class="line">        |———— ArrayBlockingQueue类</span><br><span class="line">        |———— DelayQueue类</span><br><span class="line">        |———— LinkedBlockingQueue类</span><br><span class="line">        |———— PriorityBlockingQueue类</span><br><span class="line">        |———— SynchronousQueue类</span><br></pre></td></tr></table></figure><ul><li><code>BlockingQueue</code>继承了<code>Queue</code>接口，提供了一些阻塞方法，主要作用如下：<ul><li>当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）；</li><li>当线程从队列中取元素（删除队列元素）时，如果队列未空，则阻塞线程，直到队列有元素；</li></ul></li><li><code>BlockingQueue</code>在<code>Queue</code>方法基础上增加了两类和阻塞相关的方法：<code>put(e)</code>、<code>take()</code>；<code>offer(e, time, unit)</code>、<code>poll(time, unit)</code>。</li></ul><table><thead><tr><th>操作类型</th><th>抛出异常</th><th>返回特殊值</th><th>阻塞线程</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>读取</td><td>element()</td><td>peek()</td><td>/</td><td>/</td></tr></tbody></table><ul><li><strong><code>put(e)</code></strong>和<strong><code>take()</code></strong>方法会一直阻塞调用线程，直到线程被中断或队列状态可用；</li><li><strong><code>offer(e, time, unit)</code></strong>和<strong><code>poll(time, unit)</code></strong>方法会限时阻塞调用线程，直到超时或线程被中断或队列状态可用。</li><li>阻塞队列主要用在生产者/消费者的场景</li></ul><h4 id="1-1-ArrayBlockingQueue"><a href="#1-1-ArrayBlockingQueue" class="headerlink" title="1.1 ArrayBlockingQueue"></a>1.1 ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code>是一个有边界的阻塞队列，它的内部实现是一个数组。</p><ul><li>有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</li><li><code>ArrayBlockingQueue</code>是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</li></ul><h4 id="1-2-DelayQueue"><a href="#1-2-DelayQueue" class="headerlink" title="1.2 DelayQueue"></a>1.2 DelayQueue</h4><p><code>DelayQueue</code>阻塞的是其内部元素，<code>DelayQueue</code>中的元素必须实现<code>java.util.concurrent.Delayed</code>接口，<code>Delayed</code>接口继承了<code>Comparable</code>接口，这是因为<code>DelayedQueue</code>中的元素需要进行排序，一般情况，我们都是按元素过期时间的优先级进行排序。</p><ul><li><code>DelayQueue</code>应用场景：定时关闭连接、缓存对象，超时处理等</li></ul><h4 id="1-3-LinkedBlockingQueue"><a href="#1-3-LinkedBlockingQueue" class="headerlink" title="1.3 LinkedBlockingQueue"></a>1.3 LinkedBlockingQueue</h4><p><code>LinkedBlockingQueue</code>阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。</p><ul><li>说是无边界，其实是采用了默认大小为<code>Integer.MAX_VALUE</code>的容量 。它的内部实现是一个链表。</li><li>和<code>ArrayBlockingQueue</code>一样，<code>LinkedBlockingQueue</code> 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</li></ul><h4 id="1-4-PriorityBlockingQueue"><a href="#1-4-PriorityBlockingQueue" class="headerlink" title="1.4 PriorityBlockingQueue"></a>1.4 PriorityBlockingQueue</h4><p><code>PriorityBlockingQueue</code>是一个没有边界的队列，它的排序规则和<code>java.util.PriorityQueue</code>一样。需要注意，<code>PriorityBlockingQueue</code>中允许插入null对象。</p><ul><li>所有插入<code>PriorityBlockingQueue</code>的对象必须实现<code>java.lang.Comparable</code>接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。</li><li>从<code>PriorityBlockingQueue</code>获得一个迭代器<code>Iterator</code>，但这个迭代器并不保证按照优先级顺序进行迭代。</li></ul><h4 id="1-5-SynchronousQueue"><a href="#1-5-SynchronousQueue" class="headerlink" title="1.5 SynchronousQueue"></a>1.5 SynchronousQueue</h4><p><code>SynchronousQueue</code>队列内部仅允许容纳一个元素。</p><ul><li>当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</li></ul><h3 id="2-Callable-amp-Future"><a href="#2-Callable-amp-Future" class="headerlink" title="2. Callable &amp; Future"></a>2. Callable &amp; Future</h3><p><code>Callable</code>与<code>Runnable</code>的功能大致相似，<code>Callable</code>功能强大一些，就是被线程执行后，可以返回值，并且能抛出异常。</p><ul><li><code>Runnable</code>接口只有一个<code>run()</code>方法，实现类重写<code>run</code>方法，把一些费时操作写在其中，然后使用某个线程去执行该<code>Runnable</code>实现类即可实现多线程。</li><li><code>Callable</code>是一个泛型接口只有一个<code>call()</code>方法，返回的类型就是创建<code>Callable</code>传进来的V类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Callable</code>一般是和<code>ExecutorService</code>配合来使用的，在<code>ExecutorService</code>接口中声明了若干个<code>submit</code>方法的重载版本</p></blockquote><h4 id="2-1-Future-amp-FutureTask"><a href="#2-1-Future-amp-FutureTask" class="headerlink" title="2.1 Future &amp; FutureTask"></a>2.1 Future &amp; FutureTask</h4><p><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的<strong>执行结果</strong>进行取消、查询是否完成、获取结果。必要时可以通过<code>get</code>方法获取执行结果，该方法会阻塞直到任务返回结果。</p><ul><li>也就是说<code>Future</code>提供了三种功能：<ol><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ol></li><li>在<code>Future</code>接口中声明了5个方法：<strong><code>cancel</code></strong>、<strong><code>isCancelled</code></strong>、<strong><code>isDone</code></strong>、<strong><code>get</code></strong><ul><li><code>boolean</code> <strong><code>cancel(boolean mayInterruptIfRunning)</code></strong>;//用来取消任务，参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务。<ul><li>如果取消已经完成的任务会返回<code>false</code>；如果任务还没有执行会返回<code>true</code>；</li><li>如果任务正在执行，则返回<code>mayInterruptIfRunning</code>设置的值(<code>true/false</code>)；</li></ul></li><li><code>boolean</code> <strong><code>isCancelled()</code></strong>;//任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li><code>boolean</code> <strong><code>isDone()</code></strong>;//任务是否已经完成，若任务完成，则返回true；</li><li><code>V</code> <strong><code>get()</code></strong>;//获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li><code>V</code> <strong><code>get(long timeout, TimeUnit unit)</code></strong>;//获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul></li></ul><blockquote><p><code>Future</code>可以得到别的线程任务方法的返回值。<code>Future</code>是一个接口,引用对象指向的实际是<strong>FutureTask</strong>。</p></blockquote><h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3. FutureTask"></a>3. FutureTask</h3><p><strong><code>FutureTask</code></strong>的父类是<code>RunnableFuture</code>，而<code>RunnableFuture</code>继承了<code>Runnbale</code>和<code>Futrue</code>这两个接口</p><ul><li>从<code>FutureTask</code>构造方法可以了解到：<ol><li><code>FutureTask</code>最终都是执行<code>Callable</code>类型的任务。</li><li>如果构造函数参数是<code>Runnable</code>，会被<code>Executors.callable</code>方法转换为<code>Callable</code>类型。</li><li><code>Executors.callable</code>方法直接返回一个<code>RunnableAdapter</code>实例。</li><li><code>RunnableAdapter</code>是<code>FutureTask</code>的一个静态内部类并且实现了<code>Callable</code>，也就是说<code>RunnableAdapter</code>是<code>Callable</code>子类。</li><li><code>RunnableAdapter</code>的<code>call</code>方法实现代码是，执行<code>Runnable</code>的<code>run</code>方法，并返回构造<code>FutureTask</code>传入<code>result</code>参数。</li></ol></li><li><code>FutureTask</code>总结：<ul><li><code>FutureTask</code>实现了两个接口，<code>Runnable</code>和<code>Future</code>，所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值，这个组合的好处：假设有一个很费时逻辑需要计算并且返回这个值，同时这个值不是马上需要，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过<code>Future</code>得到！</li></ul></li></ul><blockquote><p>注意：</p><ul><li>通过<code>Executor</code>执行线程任务都是以<code>Callable</code>形式，如果传入<code>Runnable</code>都会转化为<code>Callable</code>。</li><li>通过<code>new Thread(runnable)</code>，只能是<code>Runnable</code>子类形式。</li></ul></blockquote><h3 id="4-Fork-Join"><a href="#4-Fork-Join" class="headerlink" title="4. Fork/Join"></a>4. Fork/Join</h3><p>从<code>JDK1.7</code>开始，Java提供<code>Fork/Join</code>框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。</p><ul><li>主要有两步：任务切分 -&gt; 结果合并<ol><li>第一步<strong><code>分割任务</code></strong>。首先我们需要有一个 <code>fork</code> 类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</li><li>第二步执行任务并<strong><code>合并结果</code></strong>。分割的子任务分别放在<strong>双端队列</strong>里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li></ol></li><li>工作窃取算法（<code>work-stealing</code>）是指某个线程从其他队列里窃取任务来执行。</li><li><code>Fork/Join</code> 使用两个类来完成以上两个步骤：<ol><li><strong><code>ForkJoinTask</code></strong>：我们要使用 <code>ForkJoin</code> 框架，必须首先创建一个 <code>ForkJoin</code> 任务。它提供在任务中执行 <code>fork()</code> 和 <code>join()</code> 操作的机制，通常情况下我们不需要直接继承 <code>ForkJoinTask</code> 类，而只需要继承它的子类，<code>Fork/Join</code> 框架提供了以下两个子类：<ul><li><code>RecursiveAction</code>：用于没有返回结果的任务。</li><li><code>RecursiveTask</code>：用于有返回结果的任务。</li></ul></li><li><strong><code>ForkJoinPool</code></strong>：<code>ForkJoinTask</code> 需要通过 <code>ForkJoinPool</code> 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li></ol></li></ul><h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5. 线程池"></a>5. 线程池</h3><p>线程池可以看作是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。</p><ul><li>一个线程池包括以下四个基本组成部分：<ol><li>线程池管理器（<code>ThreadPool</code>）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li><li>工作线程（<code>PoolWorker</code>）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li><li>任务接口（<code>Task</code>）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li><li>任务队列（<code>taskQueue</code>）：用于存放没有处理的任务。提供一种缓冲机制。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Executor接口</span><br><span class="line">    |———— ExecutorService接口</span><br><span class="line">        |———— AbstractExecutorService抽象类</span><br><span class="line">            |———— ForkJoinPool类</span><br><span class="line">            |———— ThreadPoolExecutor类</span><br><span class="line">        |———— ScheduledExecutorService接口</span><br><span class="line">            |———— ScheduledThreadPoolExecutor类</span><br><span class="line">Executors类</span><br></pre></td></tr></table></figure><h4 id="5-1-通过Executors工厂类中的六个静态方法创建线程池"><a href="#5-1-通过Executors工厂类中的六个静态方法创建线程池" class="headerlink" title="5.1 通过Executors工厂类中的六个静态方法创建线程池"></a>5.1 通过Executors工厂类中的六个静态方法创建线程池</h4><p>六大静态方法创建的<code>ThreadPoolExecutor</code>对象，返回的父接口的引用，即返回的<code>ExecutorService</code>的引用。六大静态方法内部都是直接或间接调用<code>ThreadPoolExecutor</code>类的构造方法创建线程池对象。</p><ol><li><code>newCachedThreadPool(ThreadPoolExecutor)</code>：创建一个可缓存的线程池<ul><li>如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）,<code>maximumPoolSize</code>最大可以至(<code>Integer.MAX_VALUE</code>),若达到该上限,直接OOM。</li></ul></li><li><code>newFixedThreadPool(ThreadPoolExecutor)</code>：创建固定大小的线程池。<ul><li>每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li></ul></li><li><code>newSingleThreadExecutor(ThreadPoolExecutor)</code>：创建一个单线程的线程池。<ul><li>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务,保证按任务的提交顺序依次执行。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li></ul></li><li><code>newScheduledThreadPool(ScheduledThreadPoolExecutor)</code>：创建一个支持定时及周期性任务执行的线程池。<ul><li>线程数最大至<code>Integer.MAX_ VALUE</code>,存在OOM风险,不回收工作线程.</li></ul></li><li><code>newSingleThreadScheduledExecutor(ScheduledThreadPoolExecutor)</code>：创建一个单线程用于定时以及周期性执行任务的需求。</li><li><code>newWorkStealingPool(ForkJoinPool)</code>：创建一个工作窃取<ul><li>JDK8 引入,创建持有足够线程的线程池支持给定的并行度;并通过使用多个队列减少竞争;</li></ul></li></ol><blockquote><p>Executors返回的线程池对象的弊端：</p><ol><li><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>：<ul><li>允许的<strong>请求队列长度</strong>为<code>Integer.MAX_VALUE</code>，可能会<strong>堆积大量的请求</strong>，从而导致OOM。</li></ul></li><li><code>CachedThreadPool</code>：<ul><li>允许的<strong>创建线程数量</strong>为<code>Integer.MAX_VALUE</code>，可能会<strong>创建大量的线程</strong>，从而导致OOM。</li></ul></li></ol></blockquote><h4 id="5-2-通过ThreadPoolExecutor构造方法创建线程池"><a href="#5-2-通过ThreadPoolExecutor构造方法创建线程池" class="headerlink" title="5.2 通过ThreadPoolExecutor构造方法创建线程池"></a>5.2 通过<code>ThreadPoolExecutor</code>构造方法创建线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,   //核心线程数，包括空闲线程</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, //线程空闲时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,      //时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//缓存队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,      //线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler  //拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? </span><br><span class="line">        <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-1-corePoolSize-核心线程数量"><a href="#5-2-1-corePoolSize-核心线程数量" class="headerlink" title="5.2.1 corePoolSize(核心线程数量)"></a>5.2.1 corePoolSize(核心线程数量)</h5><ul><li><code>corePoolSize</code>的设置非常关键：<ul><li><code>=0</code>：则任务执行完之后,没有任何请求进入时销毁线程池的线程</li><li><code>&gt;0</code>：即使本地任务执行完毕,核心线程也不会被销毁</li><li>设置过大会浪费资源; 设置过小会导致线程频繁地创建或销毁</li></ul></li><li>若设置了<code>allowCoreThreadTimeOut</code>这个参数,当提交一个任务到线程池时,若<code>线程数量(包括空闲线程)小于corePoolSize</code>,线程池会创建一个新线程放入<code>works(一个HashSet)</code>中执行任务,等到需要执行的任务数大于线程池基本大小时就不再创建,会尝试放入等待队列<code>workQueue</code>；如果调用线程池的<code>prestartAllCoreThreads()</code>,线程池会提前创建并启动所有核心线程</li></ul><h5 id="5-2-2-maximumPoolSize（线程池最大线程数）"><a href="#5-2-2-maximumPoolSize（线程池最大线程数）" class="headerlink" title="5.2.2 maximumPoolSize（线程池最大线程数）"></a>5.2.2 maximumPoolSize（线程池最大线程数）</h5><ul><li><code>maximumPoolSize</code>表示线程池能够容纳同时执行的最大线程数,必须&gt;=1.</li><li>若队列满,并且已创建的线程数小于最大线程数,则线程池会再创建新的线程放入<code>works</code>中执行任务,<code>CashedThreadPool</code>的关键,固定线程数的线程池无效</li><li>如果<code>maximumPoolSize = corePoolSize</code>,即是固定大小线程池.</li><li>若使用了无界任务队列,这个参数就没什么效果</li></ul><h5 id="5-2-3-keepAliveTime（线程池中的线程空闲时间）"><a href="#5-2-3-keepAliveTime（线程池中的线程空闲时间）" class="headerlink" title="5.2.3 keepAliveTime（线程池中的线程空闲时间）"></a>5.2.3 keepAliveTime（线程池中的线程空闲时间）</h5><ul><li>线程没有任务执行时最多保持多久时间终止（线程池的工作线程空闲后，保持存活的时间)</li><li>如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率</li><li>当空闲时间达到<code>keepAliveTime</code>时,线程会被销毁,直到只剩下<code>corePoolSize</code>个线程;避免浪费内存和句柄资源.</li><li>在默认情况下,当线程池的线程数大于<code>corePoolSize</code>时,<code>keepAliveTime</code>才起作用.</li><li>但是当<code>ThreadPoolExecutor</code>的<code>allowCoreThreadTimeOut=true</code>时,核心线程超时后也会被回收.</li></ul><h5 id="5-2-4-TimeUnit（时间单位）"><a href="#5-2-4-TimeUnit（时间单位）" class="headerlink" title="5.2.4 TimeUnit（时间单位）"></a>5.2.4 TimeUnit（时间单位）</h5><ul><li>keepAliveTime的时间单位通常是<code>TimeUnit.SECONDS</code></li><li>可选的单位：天(<code>DAYS</code>)、小时(<code>HOURS</code>)、分钟(<code>MINUTES</code>)、毫秒(<code>MILLISECONDS</code>)、微秒(<code>MICROSECONDS</code>，千分之一毫秒) 和 纳秒(<code>NANOSECONDS</code>，千分之一微秒)</li></ul><h5 id="5-2-5-workQueue（缓存队列）"><a href="#5-2-5-workQueue（缓存队列）" class="headerlink" title="5.2.5 workQueue（缓存队列）"></a>5.2.5 workQueue（缓存队列）</h5><ul><li>存储待执行任务的阻塞队列，这些任务必须是<code>Runnable</code>的对象（如果是<code>Callable</code>对象，会在<code>submit</code>内部转换为<code>Runnable</code>对象） </li><li>当请求的线程数大于<code>maximumPoolSize</code>时,线程进入<code>BlockingQueue</code>.</li><li>可以选择以下几个阻塞队列:<ul><li><code>LinkedBlockingQueue</code>:一个基于链表结构的阻塞队列,此队列按<code>FIFO</code>排序元素,吞吐量通常要高于<code>ArrayBlockingQueue</code>.静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列</li><li><code>SynchronousQueue</code>:一个不存储元素的阻塞队列.每个插入操作必须等到另一个线程调用移除操作,否则插入操作一直处于阻塞状态,吞吐量通常要高于<code>LinkedBlockingQueue</code>,静态工厂方法<code>Executors.newCachedThreadPoo</code>l使用了这个队列</li></ul></li></ul><h5 id="5-2-6-threadFactory-（线程工厂）"><a href="#5-2-6-threadFactory-（线程工厂）" class="headerlink" title="5.2.6 threadFactory （线程工厂）"></a>5.2.6 threadFactory （线程工厂）</h5><ul><li>用于设置创建线程的工厂;</li><li>线程池的命名是通过增加组名前缀来实现的，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li><li>在虚拟机栈分析时,就可以知道线程任务是由哪个线程工厂产生的.</li></ul><h5 id="5-2-7-RejectedExecutionHandler（拒绝策略）"><a href="#5-2-7-RejectedExecutionHandler（拒绝策略）" class="headerlink" title="5.2.7 RejectedExecutionHandler（拒绝策略）"></a>5.2.7 RejectedExecutionHandler（拒绝策略）</h5><ul><li>当队列和线程池都满,说明线程池饱和,必须采取一种策略处理提交的新任务；策略默认<strong><code>AbortPolicy</code></strong>,表无法处理新任务时抛出异常</li><li>当超过参数<code>workQueue</code>的任务缓存区上限的时候,就可以通过该策略处理请求,这是一种简单的限流保护.</li><li>友好的拒绝策略可以是如下三种:<ol><li>保存到数据库进行削峰填谷;在空闲时再提取出来执行</li><li>转向某个提示页面</li><li>打印日志</li></ol></li><li><code>AbortPolicy</code>：丢弃任务，抛出<code>RejectedExecutionException</code></li><li><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务,有反馈机制，使任务提交的速度变慢）。</li><li><code>DiscardOldestPolicy</code>：若没有发生shutdown,尝试丢弃队列里最近的一个任务,并执行当前任务, 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务</li><li><code>DiscardPolicy</code>:不处理,丢弃掉, 拒绝执行，不抛异常 </li><li>当然,也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略.如记录日志或持久化存储不能处理的任务</li></ul><h4 id="5-3-自定义一个ThreadPoolExecutor线程池"><a href="#5-3-自定义一个ThreadPoolExecutor线程池" class="headerlink" title="5.3 自定义一个ThreadPoolExecutor线程池"></a>5.3 自定义一个ThreadPoolExecutor线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">5</span>, <span class="comment">//核心线程数</span></span><br><span class="line">    Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="number">60</span>,<span class="comment">//线程空闲时间</span></span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.setName(<span class="string">"order-thread"</span>);<span class="comment">//设置有意义的线程名字</span></span><br><span class="line">            <span class="keyword">if</span>(t.isDaemon()) &#123;<span class="comment">//若是守护线程将其释放</span></span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.NORM_PRIORITY != t.getPriority()) &#123;</span><br><span class="line">                <span class="comment">//恢复线程优先级</span></span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            System.err.println(<span class="string">"拒绝策略:"</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><h4 id="5-3-1-线程池执行流程"><a href="#5-3-1-线程池执行流程" class="headerlink" title="5.3.1 线程池执行流程"></a>5.3.1 线程池执行流程</h4><ul><li>要求 线程池有上限，使用有限队列</li></ul><ol><li>当线程池核心线程数量用完，先扔进队列</li><li>队列也用完后，看最大线程数量</li><li>最大线程数量用完后，走拒绝策略</li><li>拒绝策略可以打印一些日志，做一些补偿</li><li>线程池用完一定要优雅的关闭</li></ol><blockquote><p>线程池要统一管理，不要用Executors工厂类，要用ThreadPoolExecutor自定义线程池</p></blockquote><h4 id="5-3-2-线程池配置-核心线程数量"><a href="#5-3-2-线程池配置-核心线程数量" class="headerlink" title="5.3.2 线程池配置-核心线程数量"></a>5.3.2 线程池配置-核心线程数量</h4><p>线程CPU时间所占比例越高，需要越少线程(CPU密集)。线程等待时间所占比例越高，需要越多线程(IO密集)。</p><ol><li><strong>CPU密集型</strong>：内存运算、不涉及IO操作等<ul><li>设置线程数为：<code>CPU核数+1</code> </li></ul></li><li><strong>IO密集型</strong>：数据读取、存取、数据库操作、持久化操作等<ul><li>最佳线程数目：<code>CPU核数/(1-阻塞系数)</code> 这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9。</li></ul></li></ol><blockquote><p>java.lang.<code>Runtime.availableProcessors()</code> 方法返回到Java虚拟机的可用的处理器数量(CPU核数)。此值可能会改变在一个特定的虚拟机调用。应用程序可用处理器的数量是敏感的，因此偶尔查询该属性，并适当地调整自己的资源使用情况.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;池和队列的关系&lt;ul&gt;
&lt;li&gt;线程池或者数据库连接池，都有最大限制。如果超出了限制数量，则新进来的申请连接都要放入额外的&lt;strong&gt;队列里&lt;/strong&gt;，等到池空出来时，从队列中取出连接放进池里。
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】AQS框架 与 锁框架（JUC.locks）</title>
    <link href="http://chaooo.github.io/article/20191010.html"/>
    <id>http://chaooo.github.io/article/20191010.html</id>
    <published>2019-10-10T15:00:24.000Z</published>
    <updated>2019-11-07T13:55:58.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-AQS（队列同步器）"><a href="#1-AQS（队列同步器）" class="headerlink" title="1. AQS（队列同步器）"></a>1. AQS（队列同步器）</h3><p><code>AbstractQueuedSynchronizer</code>：队列同步器，简称<code>AQS</code>。</p><ul><li><code>AQS</code>维护了一个<code>volatile int</code><strong><code>state</code></strong>(代表资源共享变量) 和一个<strong><code>FIFO</code>线程等待队列</strong>(多线程争用资源被阻塞时会进入此队列)。</li><li><code>AQS</code>定义了两种资源共享方式：<code>Exclusive</code>(独占)，<code>Share</code>(共享)<a id="more"></a></li><li><code>isHeldExclusively</code>方法：该线程是否正在独占资源</li><li><code>tryAcquire</code>/<code>tryRelease</code>：独占的方式尝试获取和释放资源</li><li><code>tryAcquireShared</code>/<code>tryReleaseShared</code>：共享的方式尝试获取和释放资源</li></ul><p>整个框架的核心就是<strong>如何管理线程阻塞队列</strong>，该队列是严格的<code>FIFO</code>队列，因此不支持线程优先级的同步。</p><ul><li><code>AQS</code>只有一个同步队列，可以有多个条件队列。<ul><li>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，同步队列选择了<strong><code>CLH</code></strong>作为实现的基础。</li><li>条件队列：<code>AQS</code>框架提供了一个<code>ConditionObject</code>类，给维护独占同步的类以及实现<code>Lock</code>接口的类使用。</li></ul></li><li>使用<code>Node</code>实现<strong><code>FIFO</code>双向队列</strong>，可以用于构建锁 或 其他同步装置的基础框架</li><li>内部有一个int变量表示的<strong><code>同步状态</code></strong>(同步状态通过<strong><code>getState</code></strong>、<strong><code>setState</code></strong>、<strong><code>compareAndSetState</code></strong>来维护，同时这三个方法能够保证线程安全)</li><li><code>AQS</code>是个<strong>抽象类</strong>（但没有抽象方法），同步组件一般通过维护<code>AQS</code>的<strong>继承子类来实现</strong>。</li><li><code>AQS</code><strong>既</strong>支持独占地获取同步状态(<strong>排它锁</strong>)，<strong>又</strong>支持共享地获取同步状态(<strong>共享锁</strong>)，从而实现不同类型的组件。</li><li><code>AQS</code>是<strong>基于模板方法</strong>，同步组件需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</li></ul><blockquote><p><code>Synchronizer</code>(同步器)：是一个对象，它根据本身的状态调节线程的控制流。常见类型的<code>Synchronizer</code>包括信号量、关卡和闭锁。</p></blockquote><h3 id="2-CountDownLatch（倒计时闭锁）"><a href="#2-CountDownLatch（倒计时闭锁）" class="headerlink" title="2. CountDownLatch（倒计时闭锁）"></a>2. CountDownLatch（倒计时闭锁）</h3><ul><li>闭锁(<code>latch</code>)是一种<code>Synchronizer</code>，它可以延迟线程的进度直到线程达到<strong>终止状态</strong>。</li><li><strong><code>CountDownLatch</code></strong>(倒计时闭锁)是一个灵活的闭锁实现。</li><li><code>CountDownLatch</code>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。</li><li><code>CountDownLatch</code><strong>原理</strong>：是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得<code>减1</code>。当计数器到达<code>0</code>时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。<ul><li><code>await()</code>，阻塞程序继续执行</li><li><code>countDown()</code>，计数器的值<code>减1</code>，当计数器值减至<code>零</code>时，所有因调用<code>await()</code>方法而处于等待状态的线程就会继续往下执行。</li></ul></li><li>计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用<code>CycliBarrier</code></li></ul><blockquote><p><code>CountDownLatch</code>使用场景：应用初始化</p></blockquote><h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><ul><li><strong><code>Semaphore</code></strong>(信号量)：用来<strong>控制同时访问</strong>特定资源的线程<strong>数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。</li><li><code>Semaphore</code><strong>原理</strong>：线程需要通过<code>acquire()</code>方法获取许可，而<code>release()</code>释放许可。如果许可数达到最大活动数，那么调用<code>acquire()</code>之后，便进入等待队列，等待已获得许可的线程释放许可，从而使得多线程能够合理的运行。<ul><li><code>acquire()</code>：获取权限，其底层实现与<code>CountDownLatch.countdown()</code>类似;</li><li><code>release()</code>：释放权限，其底层实现与<code>acquire()</code>是一个互逆的过程。</li></ul></li></ul><blockquote><p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。</p></blockquote><h3 id="4-CyclicBarrier（同步屏障）"><a href="#4-CyclicBarrier（同步屏障）" class="headerlink" title="4. CyclicBarrier（同步屏障）"></a>4. CyclicBarrier（同步屏障）</h3><ul><li><strong><code>CyclicBarrier</code></strong>(同步屏障)：可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所有被阻塞的线程才能继续执行。</li><li><code>CyclicBarrier</code>类似于<code>CountDownLatch</code>，它也是通过计数器来实现的。但是相比于<code>CountDownLatch</code>功能更加强大。</li><li><code>CyclicBarrier</code><strong>原理</strong>：当某个线程调用<code>await</code>方法时，该线程进入等待状态，且计数器加1，当计数器的值达到设置的初始值时，所有因调用<code>await</code>进入等待状态的线程被唤醒，继续执行后续操作。因为<code>CycliBarrier</code>在释放等待线程后可以重用，所以称为循环<code>barrier</code>。</li></ul><h4 id="4-1-CountDownLatch-和-CyclicBarrier-对比"><a href="#4-1-CountDownLatch-和-CyclicBarrier-对比" class="headerlink" title="4.1 CountDownLatch 和 CyclicBarrier 对比"></a>4.1 CountDownLatch 和 CyclicBarrier 对比</h4><ol><li><code>CountDownLatch</code>描述的是线程(1个或多个)等待其他线程的关系；<code>CyclicBarrier</code>描述的是多个线程相互等待的关系。</li><li><code>CountDownLatch</code>的计数器只能使用一次。而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置并复用。</li><li><code>CountDownLatch</code>方法比较少，操作比较简单，而<code>CyclicBarrier</code>提供的方法更多，比如：<ul><li><code>getNumberWaiting()</code>：获取阻塞的线程数量。</li><li><code>isBroken()</code>：获取阻塞线程的状态，被中断返回<code>true</code>，否则返回<code>false</code>。</li><li><code>CyclicBarrier</code>的构造方法可以传入<code>barrierAction</code>，指定当所有线程都到达时执行的业务功能；</li></ul></li></ol><blockquote><p><code>CyclicBarrier</code>可以用于多线程计算数据，最后合并计算结果的应用场景</p></blockquote><h3 id="5-JUC-locks-锁框架"><a href="#5-JUC-locks-锁框架" class="headerlink" title="5. JUC.locks 锁框架"></a>5. JUC.locks 锁框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks</span><br><span class="line">    |———— Lock接口</span><br><span class="line">        |———— ReentrantLock类</span><br><span class="line">            |———— ReentrantReadWriteLock.ReadLock内部类</span><br><span class="line">            |———— ReentrantReadWriteLock.WriteLock内部类</span><br><span class="line">    |———— Condition接口</span><br><span class="line">    |———— ReadWriteLock接口</span><br><span class="line">        |———— ReentrantReadWriteLock类</span><br><span class="line">    |———— LockSupport类</span><br></pre></td></tr></table></figure><ul><li><strong><code>Lock</code>接口</strong>核心方法：<code>lock()</code>，<code>unlock()</code>，<code>lockInterruptibly()</code>，<code>newCondition()</code>，<code>tryClock()</code><ul><li><code>lock()</code>方法类似于使用<code>synchronized</code>关键字加锁，如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</li><li><code>lockInterruptibly()</code>方法顾名思义，就是如果锁不可用，那么当前正在等待的线程是可以被中断的，这比<code>synchronized</code>关键字更加灵活。</li></ul></li><li><strong><code>Condition</code>接口</strong>核心方法：<code>awit()</code>，<code>signal()</code>，<code>signalAll()</code><ul><li>可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用</li></ul></li><li><strong><code>ReadWriteLock</code>接口</strong>核心方法：<code>readLock()</code>，<code>writeLock()</code><ul><li>获取读锁和写锁，注意除非使用<code>Java8</code>新锁，否则读读不互斥，读写是互斥的</li></ul></li></ul><h3 id="6-ReentrantLock（可重入锁）"><a href="#6-ReentrantLock（可重入锁）" class="headerlink" title="6. ReentrantLock（可重入锁）"></a>6. ReentrantLock（可重入锁）</h3><p><strong><code>ReentrantLock</code>重入锁</strong>使用<strong><code>AQS</code>同步状态</strong>来保存锁重复持有的次数</p><ul><li>底层代码分析：<ul><li><strong><code>state</code></strong>初始化为0，表示未锁定状态</li><li>A线程<code>lock()</code>时，会调用<code>tryAcquire(</code>)独占该锁并将<strong><code>state+1</code></strong></li><li>此后，其他线程再<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到<code>state=0</code>(即释放锁)为止，其他线程才有机会获取该锁</li><li>当然，锁释放之前，A线程自己是可以重复获取此锁的(<code>state</code>会累加)，这就是可重入的概念</li></ul></li></ul><p><code>synchronized</code>实现的锁的重入依赖于<code>JVM</code>，是一种重量级锁。<br><code>ReentrantLock</code>实现了在内存语义上的<code>synchronized</code>，使用<strong><code>AQS</code>同步状态</strong>来保存锁重复持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code>也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。</p><ul><li>公平锁和非公平锁<ul><li>公平锁还是非公平锁取决于<code>ReentrantLock</code>的构造方法，<strong>默认</strong>无参为<strong>非公平锁</strong>(<code>NonfairSync</code>)；含参构造方法，入参<code>true</code>为<code>FairSync</code>，入参<code>false</code>为<code>NonfairSync</code>。</li></ul></li><li>非公平锁中，抢到<code>AQS</code>的同步状态的未必是同步队列的首节点，只要线程通过<code>CAS</code>抢到了同步状态或者在<code>acquire</code>中抢到同步状态，就优先占有锁（插队），而相对同步队列这个严格的<code>FIFO</code>队列来说，所以会被认为是非公平锁。</li><li>公平锁的实现直接调用<code>AQS</code>的<code>acquire</code>方法，<code>acquire</code>中调用<code>tryAcquire</code>。和非公平锁相比，这里不会执行一次<code>CAS</code>，接下来在<code>tryAcquire</code>去抢占锁的时候，也会先调用<code>hasQueuedPredecessors</code>看看前面是否有节点已经在等待获取锁了，如果存在则同步队列的前驱节点优先（排队<code>FIFO</code>）。</li></ul><blockquote><p>虽然公平锁看起来在公平性上比非公平锁好，但是公平锁为此付出了大量线程切换的代价，而非公平锁在锁的获取上不能保证公平，就有可能出现锁饥饿，即有的线程多次获取锁而有的线程获取不到锁，没有大量的线程切换保证了非公平锁的吞吐量。</p></blockquote><h3 id="7-读写锁RRW（ReentrantReadWriteLock）"><a href="#7-读写锁RRW（ReentrantReadWriteLock）" class="headerlink" title="7. 读写锁RRW（ReentrantReadWriteLock）"></a>7. 读写锁RRW（ReentrantReadWriteLock）</h3><p><code>ReentrantLock</code>是独占锁，<code>ReentrantReadWriteLock</code>是读写锁。</p><ul><li>独占锁通过<code>state</code>变量的<code>0</code>和<code>1</code>两个状态来控制是否有线程占有锁，共享锁通过<code>state</code>变量<code>0</code>或者<code>非0</code>来控制多个线程访问。</li><li>读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</li><li><code>ReentrantReadWriteLock</code>的特殊之处其实就是用一个<code>int</code>值表示两种不同的状态（<code>低16</code>位表示写锁的重入次数，<code>高16</code>位表示读锁的使用次数），并通过两个内部类同时实现了<code>AQS</code>的两套<code>API</code>，核心部分与共享/独占锁并无什么区别。</li></ul><blockquote><p><code>ReentrantReadWriteLock</code>也会发生<strong>写请求饥饿</strong>的情况，因为写请求一样会排队，不管是公平锁还是非公平锁，在有读锁的情况下，都<strong>不能保证写锁</strong>一定能获取到，这样只要读锁一直占用，就会发生写饥饿的情况。<code>JDK8</code>中新增的改进读写锁<code>StampedLock</code>可解决饥饿问题</p></blockquote><h3 id="8-LockSupport工具类"><a href="#8-LockSupport工具类" class="headerlink" title="8. LockSupport工具类"></a>8. LockSupport工具类</h3><p>归根结底，<code>LockSupport</code>调用的<code>Unsafe</code>中的<code>native</code>代码：<code>park()</code>，<code>unpark()</code>；</p><ul><li><code>park</code>函数是将当前<code>Thread</code>阻塞，而<code>unpark</code>函数则是将另一个<code>Thread</code>唤醒。</li><li>与<code>Object</code>类的<code>wait/notify</code>机制相比，<code>park/unpark</code>有两个优点：<ol><li>以<code>thread</code>为操作对象更符合阻塞线程的直观定义；</li><li>操作更精准，可以准确地唤醒某一个线程（<code>Object</code>类的<code>notify</code>随机唤醒一个线程，<code>notifyAll</code>唤醒所有等待的线程），增加了灵活性</li></ol></li></ul><blockquote><p><code>park</code>方法的调用一般要在方法一个循环判断体里面。之所以这样做，是为了防止线程被唤醒后，不进行判断而意外继续向下执行，这其实是一种的多线程设计模式-Guarded Suspension。</p></blockquote><h3 id="9-StampedLock（Java8新型锁）"><a href="#9-StampedLock（Java8新型锁）" class="headerlink" title="9. StampedLock（Java8新型锁）"></a>9. StampedLock（Java8新型锁）</h3><p><code>ReentrantReadWriteLock</code>锁具有读写锁，问题在于<code>ReentrantReadWriteLock</code>使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的 ，很容易造成写锁获取不到资源(写请求饥饿)。</p><ul><li><code>Java8</code>引入了一个新的读写锁叫<code>StampedLock</code>. 不仅这个锁更快，而且它提供强大的乐观锁API。这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会阻塞写线程。</li><li><code>StampedLock</code>的主要特点：<ol><li>所有<strong>获取锁</strong>的方法，都返回一个邮戳（<code>Stamp</code>），<code>Stamp</code>为0表示获取失败，其余都表示成功；</li><li>所有<strong>释放锁</strong>的方法，都需要一个邮戳（<code>Stamp</code>），这个<code>Stamp</code>必须是和成功获取锁时得到的<code>Stamp</code>一致；</li><li><code>StampedLock</code>是<strong>不可重入</strong>的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li><li><code>StampedLock</code>有<strong>三种访问模式</strong>：<ul><li><code>Reading</code>（读模式）：功能和ReentrantReadWriteLock的读锁类似</li><li><code>Writing</code>（写模式）：功能和ReentrantReadWriteLock的写锁类似</li><li><code>Optimistic reading</code>（乐观读模式）：这是一种优化的读模式。</li></ul></li><li><code>StampedLock</code>支持读锁和写锁的相互转换</li><li><code>RRW</code>(ReentrantReadWriteLock)中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的；<code>StampedLock</code>提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</li><li>无论写锁还是读锁，都不支持<code>Conditon</code>等待</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-AQS（队列同步器）&quot;&gt;&lt;a href=&quot;#1-AQS（队列同步器）&quot; class=&quot;headerlink&quot; title=&quot;1. AQS（队列同步器）&quot;&gt;&lt;/a&gt;1. AQS（队列同步器）&lt;/h3&gt;&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;：队列同步器，简称&lt;code&gt;AQS&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AQS&lt;/code&gt;维护了一个&lt;code&gt;volatile int&lt;/code&gt;&lt;strong&gt;&lt;code&gt;state&lt;/code&gt;&lt;/strong&gt;(代表资源共享变量) 和一个&lt;strong&gt;&lt;code&gt;FIFO&lt;/code&gt;线程等待队列&lt;/strong&gt;(多线程争用资源被阻塞时会进入此队列)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AQS&lt;/code&gt;定义了两种资源共享方式：&lt;code&gt;Exclusive&lt;/code&gt;(独占)，&lt;code&gt;Share&lt;/code&gt;(共享)
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【并发编程】JUC并发容器类</title>
    <link href="http://chaooo.github.io/article/20191006.html"/>
    <id>http://chaooo.github.io/article/20191006.html</id>
    <published>2019-10-06T15:04:22.000Z</published>
    <updated>2019-11-07T13:49:18.769Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>java.util.concurrent</code>包中，提供了两种类型的并发集合：一种是阻塞式，另一种是非阻塞式。</p><ul><li>阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程将被阻塞，一直等到该方法可以被成功执行</li><li>非阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程不会被阻塞，而是直接则返回null或抛出异常。<a id="more"></a></li></ul><h3 id="1-线程安全相关容器"><a href="#1-线程安全相关容器" class="headerlink" title="1. 线程安全相关容器"></a>1. 线程安全相关容器</h3><h4 id="1-1-线程安全-同步容器："><a href="#1-1-线程安全-同步容器：" class="headerlink" title="1.1 线程安全-同步容器："></a>1.1 线程安全-同步容器：</h4><ol><li><code>ArrayList</code> –&gt; <code>Vector,Stack</code></li><li><code>HashMap</code> –&gt; <code>HashTable</code>(key、value不能为null)</li><li><code>Collections.synchronizedXXX</code>(List/Set/Map) //本质是对相应的容器进行包装，通过在方法中加synchronized同步锁来实现</li></ol><ul><li>同步容器的同步原理就是在方法上用<code>synchronized</code>修饰。<strong>性能开销大</strong>。</li><li>在<strong>单独</strong>使用里面的方法的时候，可以保证线程安全，但是，<strong>复合操作需要额外加锁</strong>来保证线程安全。</li></ul><h4 id="1-2-线程安全-并发容器："><a href="#1-2-线程安全-并发容器：" class="headerlink" title="1.2 线程安全-并发容器："></a>1.2 线程安全-并发容器：</h4><ol><li><code>ArrayList</code> –&gt; <strong><code>CopyOnWriteArrayList</code></strong>：保证<strong><code>最终一致性</code></strong>，写时复制，适用于<strong><code>读多写少</code></strong>的并发场景</li><li><code>HashSet</code>、<code>TreeSet</code> –&gt; <code>CopyOnWriteArraySet</code>、<code>ConcurrentSkipListSet</code>：</li><li><code>HashMap</code>、<code>TreeMap</code> –&gt; <strong><code>ConcurrentHashMap</code></strong>、<code>ConcurrentSkipListMap</code>：</li></ol><h4 id="1-3-安全共享对象策略"><a href="#1-3-安全共享对象策略" class="headerlink" title="1.3 安全共享对象策略"></a>1.3 安全共享对象策略</h4><ol><li>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有者修改</li><li>共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但不能修改</li><li>线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，其他线程无需额外的同步就可以通过公共接口随意访问它</li><li>被守护对象：被守护对象只能通过获取特定的锁来访问</li></ol><h3 id="2-CopyOnWrite机制"><a href="#2-CopyOnWrite机制" class="headerlink" title="2. CopyOnWrite机制"></a>2. CopyOnWrite机制</h3><p><code>CopyOnWrite</code>（简称COW），是计算机程序设计领域中的一种优化策略，也是一种思想–即<strong>写入时复制思想</strong>。</p><ul><li>在<code>CopyOnWrite</code>中，对容器的修改操作加锁后，通过copy一个新的容器副本来进行修改，修改完毕后将容器替换为新的容器即可。<ul><li>这种方式的好处显而易见：通过copy一个新的容器来进行修改，这样读操作就不需要加锁，可以并发读，因为在读的过程中是采用的旧的容器，即使新容器做了修改对旧容器也没有影响，同时也很好的解决了迭代过程中其他线程修改导致的并发问题。</li></ul></li><li>从JDK1.5开始，<code>java.util.concurrent</code>包中提供了两个<code>CopyOnWrite</code>机制容器，分别为<strong><code>CopyOnWriteArrayList</code></strong>和<strong><code>CopyOnWriteArraySet</code></strong></li><li><code>CopyOnWriteArrayList</code>通过使用<strong><code>ReentrantLock</code>锁</strong>来实现线程安全：<ul><li>在添加、获取元素时，使用<code>getArray()</code>获取底层数组对象，获取此时集合中的数组对象；使用<code>setArray()</code>设置底层数组，将原有数组对象指针指向新的数组对象—-实以此来实现<code>CopyOnWrite</code>副本概念</li><li><strong>添加元素</strong>: 在添加元素之前进行加锁操作，保证数据的原子性。在添加过程中，进行数组复制，修改操作，再将新生成的数组复制给集合中的<code>array</code>属性。最后，释放锁；<ul><li>由于<code>array</code>属性被<code>volatile</code>修饰，所以当添加完成后，其他线程就可以立刻查看到被修改的内容。</li></ul></li><li><strong>获取元素</strong>：在获取元素时，由于<code>array</code>属性被<code>volatile</code>修饰，所以每当获取线程执行时，都会拿到最新的数据。此外，添加线程在进行添加元素时，会将新的数组赋值给<code>array</code>属性，所以在获取线程中并不会因为元素的添加而导致本线程的执行异常。因为获取线程中的<code>array</code>和被添加后的<code>array</code>指向了不同的内存区域。</li></ul></li></ul><blockquote><p>在执行<code>add()</code>时，为什么还要在加锁的同时又copy了一分新的数组对象?</p><ul><li>因为，在<code>add()</code>时候加了锁，首先不会有多个线程同时进到<code>add</code>中去，这一点保证了数组的安全。当在一个线程执行<code>add</code>时，又进行了数组的复制操作，生成了一个新的数组对象，在<code>add</code>后又将新数组对象的指针指向了旧的数组对象指针，注意此时是指针的替换，原来旧的数组对象还存在。这样就实现了，添加方法无论如何操作数组对象，获取方法在获取到集合后，都不会受到其他线程添加元素的影响。</li></ul></blockquote><ul><li><code>CopyOnWrite</code>机制的优缺点<ul><li>优点: <code>CopyOnWriteArrayList</code>保证了数据在多线程操作时的<strong>最终一致性</strong>。</li><li>缺点: 缺点也同样显著，那就是内存空间的浪费：因为在写操作时，进行数组复制，在内存中产生了两份相同的数组。如果数组对象比较大，那么就会造成频繁的GC操作，进而影响到系统的性能；</li></ul></li></ul><blockquote><p>适用场景：<strong>读多写少</strong>的并发场景</p></blockquote><h3 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3. ConcurrentHashMap"></a>3. ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code>容器相较于CopyOnWrite容器在并发加锁粒度上有了更大一步的优化，它通过修改对<strong>单个hash桶元素加锁</strong>的达到了更细粒度的并发控制。</p><ul><li>在底层数据结构上，<code>ConcurrentHashMap</code>和<code>HashMap</code>都使用了数组+链表+红黑树的方式，只是在HashMap的基础上添加了并发相关的一些控制。</li><li>JDK1.8中<strong>取消</strong>了segment分段锁，而采用<code>CAS和synchronized</code>来保证并发安全。<code>synchronized</code>只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。并且初始化操作大大简化，修改为<code>lazy-load</code>形式。</li></ul><h4 id="3-1-put方法过程"><a href="#3-1-put方法过程" class="headerlink" title="3.1 put方法过程"></a>3.1 put方法过程</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>判断键值是否为<code>null</code>，为null抛出异常</li><li>调用<code>spread()</code>方法计算key的<code>hashCode()</code>获得哈希地址</li><li>判断<code>Node[]</code>数组(<code>table</code>)是否为空，若空则进行初始化操作<ul><li>需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong><code>尝试</code></strong>初始化<code>table</code>，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程</li></ul></li><li>使用<code>(容量大小-1 &amp; 哈希地址)</code>计算下标，如果没有碰撞，使用<code>CAS</code>原子性操作放入桶中；插入失败(被别的线程抢先插入了)则进入下次循环。</li><li>如果该下标上的节点(头节点)的哈希地址为<code>-1</code>，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果碰撞了(<code>bucket</code>不为空)且又不需要扩容，则进入到<code>bucket</code>中，且锁住该<code>bucket</code>，其他<code>bucket</code>不影响。</li><li>进入到<code>bucket</code>里面，首先判断这个<code>bucket</code>存储的是红黑树(哈希地址小于0)还是链表。</li><li>如果是链表，则遍历链表，若节点已经存在(<code>key</code>相同)就覆盖旧值，没有找到相同的节点就将新增的节点插入到链表尾部。如果是红黑树，则将节点插入。到这里释放锁。</li><li>判断该<code>bucket</code>上的链表长度是否链表长度超过阀值<code>（TREEIFY_THRESHOLD==8）</code>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树。</li><li>调用<code>addCount()</code>方法，作用是将<code>ConcurrentHashMap</code>的键值对数量+1，还有另一个作用是检查<code>ConcurrentHashMap</code>是否需要扩容。</li></ol><blockquote><p>总结：</p><ul><li>JDK8中的实现也是锁分离的思想，它把锁分的比<code>segment（JDK1.5）</code>更细一些，只要hash不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作<code>CAS</code>插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过<code>synchronized</code>获得头结点锁，进行后续的操作。<strong>性能比segment分段锁又再次提升</strong>。</li></ul></blockquote><h4 id="3-2-ConcurrentHashMap多线程环境下扩容"><a href="#3-2-ConcurrentHashMap多线程环境下扩容" class="headerlink" title="3.2 ConcurrentHashMap多线程环境下扩容"></a>3.2 ConcurrentHashMap多线程环境下扩容</h4><ul><li><code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持<strong>多线程扩容</strong>，而且也<strong>没有进行加锁</strong>，所以实现会变得有点儿复杂。整个扩容操作分为两步：<ul><li>构建一个<code>nextTable</code>，其大小为原来大小的两倍，这个步骤是在单线程环境下完成的</li><li>将原来<code>table</code>里面的内容复制到<code>nextTable</code>中，这个步骤是允许多线程操作的，所以性能得到提升，减少了扩容的时间消耗。</li></ul></li><li>扩容的时机：<ol><li>如果新增节点之后，所在链表的元素个数达到了阈值 8，则会调用treeifyBin方法把链表转换成红黑树，不过在结构转换之前，会对数组长度进行判断：<ul><li>如果数组长度n小于阈值<code>MIN_TREEIFY_CAPACITY</code>，默认是64，则会调用<code>tryPresize</code>方法把数组长度扩大到原来的两倍，并触发<code>transfer</code>方法，重新调整节点的位置。</li></ul></li><li>新增节点之后，会调用<code>addCount</code>方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发<code>transfer</code>方法，重新调整节点的位置。</li></ol></li><li>JDK8的源码里面就引入了一个<strong><code>ForwardingNode</code></strong>类，在一个线程发起扩容的时候，就会改变<code>sizeCtl</code>这个值，其含义如下： <ul><li><code>sizeCtl</code> ：默认为0，用来控制<code>table</code>的初始化和扩容操作，具体应用在后续会体现出来。</li><li><code>-1</code> 代表<code>table</code>正在初始化</li><li><code>-N</code> 表示有<code>N-1</code>个线程正在进行扩容操作</li><li>其余情况：  <ol><li>如果<code>table</code>未初始化，表示<code>table</code>需要初始化的大小。  </li><li>如果<code>table</code>初始化完成，表示<code>table</code>的容量，默认是<code>table</code>大小的<code>0.75</code>倍</li></ol></li></ul></li><li>扩容时候会判断<code>sizeCtl</code>的值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用<code>tabAt</code>方法获得i位置的元素f，初始化一个<code>forwardNode</code>实例<code>fwd</code>，如果<code>f == null</code>，则在<code>table</code>中的i位置放入<code>fwd</code>，否则采用头插法的方式把当前旧<code>table</code>数组的指定任务范围的数据给迁移到新的数组中，然后给旧<code>table</code>原位置赋值<code>fwd</code>。直到遍历过所有的节点以后就完成了复制工作，把<code>table</code>指向<code>nextTable</code>，并更新<code>sizeCtl</code>为新数组大小的<code>0.75</code>倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断<code>head</code>节点是否为<code>forwardNode</code>节点，如果是就<strong>帮助扩容</strong>。</li><li>在<strong>扩容时读写操作</strong>如何进行<ol><li>对于<code>get</code>读操作，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。如果当前链表已经迁移完成，那么头节点会被设置成<code>fwd</code>节点，此时<code>get</code>线程会帮助扩容。</li><li>对于<code>put</code>/<code>remove</code>写操作，如果当前链表已经迁移完成，那么头节点会被设置成<code>fwd</code>节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。 </li></ol></li></ul><blockquote><p>总结: <code>ConcurrentHashMap</code>扩容的原理是新生成原来<code>2倍</code>的数组，然后拷贝旧数组数据到新的数组里面，在多线程情况下，这里面如果注意线程安全问题，在解决安全问题的同时，我们也要关注其效率，这才是并发容器类的最出色的地方。 </p></blockquote><h4 id="3-3-size、mappingCount方法"><a href="#3-3-size、mappingCount方法" class="headerlink" title="3.3 size、mappingCount方法"></a>3.3 size、mappingCount方法</h4><ul><li><code>size</code>和<code>mappingCount</code>方法都是用来统计table的<code>size</code>的</li><li>这两者不同的地方在<code>size</code>返回的是一个<code>int类型</code>，即可以表示<code>size</code>的范围是<code>[-2^31，2^31-1]</code>，超过这个范围就返回int能表示的最大值</li><li><code>mappingCount</code>返回的是一个<code>long类型</code>，即可以表示<code>size</code>的范围是<code>[-2^63，2^63-1]</code>。</li><li>这两个方法都是调用的<code>sumCount()</code>方法实现统计。</li><li><strong>对于<code>size</code>和迭代器是弱一致性</strong><ul><li><code>volatile</code>修饰的数组引用是强可见的，但是其元素却不一定，所以，这导致<code>size</code>的根据<code>sumCount</code>的方法<strong>并不准确</strong>。</li><li>同理<code>Iteritor</code>的迭代器也一样，并不能准确反映最新的实际情况 </li></ul></li></ul><h3 id="4-ConcurrentSkipListMap"><a href="#4-ConcurrentSkipListMap" class="headerlink" title="4. ConcurrentSkipListMap"></a>4. ConcurrentSkipListMap</h3><p><code>ConcurrentSkipListMap</code>内部使用<strong>跳表（<code>SkipList</code>）</strong>这种数据结构来实现，他的结构相对红黑树来说非常简单理解，实现起来也相对简单，而且在理论上它的查找、插入、删除时间复杂度都为<code>log(n)</code>。在并发上，<code>ConcurrentSkipListMap</code>采用无锁的<strong><code>CAS+自旋</code></strong>来控制。</p><ul><li>跳表简单来说就是一个多层的链表，底层是一个普通的链表，然后逐层减少，通常通过一个简单的算法实现每一层元素是下一层的元素的二分之一，这样当搜索元素时从最顶层开始搜索，可以说是另一种形式的二分查找。</li><li><code>ConcurrentSkipListMap</code>的<strong><code>put</code></strong>(插入)：<ul><li>调用<code>doPut()</code>方法，可以分为3大步来理解：</li><li>第一步获取前继节点后通过<code>CAS</code>来插入节点；</li><li>第二步对<code>level</code>层数进行判断，如果大于最大层数，则插入一层；</li><li>第三步插入对应层的数据。整个插入过程全部通过<code>CAS</code>自旋的方式保证并发情况下的数据正确性。</li></ul></li></ul><h3 id="5-volatile-amp-Atmoic-amp-UnSafe"><a href="#5-volatile-amp-Atmoic-amp-UnSafe" class="headerlink" title="5. volatile &amp; Atmoic &amp; UnSafe"></a>5. volatile &amp; Atmoic &amp; UnSafe</h3><ul><li><strong><code>volatile</code></strong>作用：①多线程间的可见性、②阻止指令重排序</li><li><strong><code>Atmoic系列类</code></strong>提供了原子性操作，保障多线程下的安全</li><li><strong><code>UnSafe类</code></strong>的作用：①内存操作、②字段的定位与修改(底层)、③线程挂起与恢复、④<code>CAS</code>操作(乐观锁)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;java.util.concurrent&lt;/code&gt;包中，提供了两种类型的并发集合：一种是阻塞式，另一种是非阻塞式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程将被阻塞，一直等到该方法可以被成功执行&lt;/li&gt;
&lt;li&gt;非阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程不会被阻塞，而是直接则返回null或抛出异常。
    
    </summary>
    
      <category term="并发编程" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
      <category term="并发编程" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】常见集合类 的 数据结构</title>
    <link href="http://chaooo.github.io/article/20191003.html"/>
    <id>http://chaooo.github.io/article/20191003.html</id>
    <published>2019-10-03T14:53:06.000Z</published>
    <updated>2019-10-30T13:58:11.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合-Collection-Map"><a href="#集合-Collection-Map" class="headerlink" title="集合(Collection/Map)"></a>集合(Collection/Map)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection接口</span><br><span class="line">    |———— List接口</span><br><span class="line">        |———— ArrayList类</span><br><span class="line">        |———— Vector类</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">        |———— Stack类</span><br><span class="line">    |———— Set接口</span><br><span class="line">        |———— HashSet类</span><br><span class="line">        |———— TreeSet类</span><br><span class="line">        |———— LinkedHashSet类</span><br><span class="line">    |———— Queue接口</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">Map接口</span><br><span class="line">    |———— HashMap类</span><br><span class="line">    |———— TreeMap类</span><br><span class="line">    |———— LinkedHashMap类</span><br><span class="line">    |———— Hashtable类</span><br></pre></td></tr></table></figure><h4 id="0-1-List"><a href="#0-1-List" class="headerlink" title="0.1 List"></a>0.1 List</h4><ul><li><strong>Arraylist</strong>： 动态数组</li><li>Vector： 动态数组(线程安全)</li><li><strong>LinkedList</strong>： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><h4 id="0-2-Set"><a href="#0-2-Set" class="headerlink" title="0.2 Set"></a>0.2 Set</h4><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li><li>TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树)</li></ul><h4 id="0-3-Map"><a href="#0-3-Map" class="headerlink" title="0.3 Map"></a>0.3 Map</h4><ul><li><strong>HashMap</strong>： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间</li><li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，<strong>增加了一条双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>Hashtable： 数组+链表(线程安全)，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h4 id="0-4-如何选用集合"><a href="#0-4-如何选用集合" class="headerlink" title="0.4 如何选用集合"></a>0.4 如何选用集合</h4><p>主要根据集合的特点来选用：</p><ul><li>键值对就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.</li><li>只需要存放元素值时，就选用Collection接口下的集合，需要保证元素唯一时选择实现Set接口的集合（TreeSet或HashSet），不需要就选择实现List接口的ArrayList或LinkedList</li></ul><h4 id="0-5-对数公式log-与-时空复杂度"><a href="#0-5-对数公式log-与-时空复杂度" class="headerlink" title="0.5 对数公式log 与 时空复杂度"></a>0.5 对数公式log 与 时空复杂度</h4><ul><li>若<code>a^n = b</code> (a&gt;0,a≠1) 则 <code>n = log(a)b</code> , 如<code>log(2)8 = 3</code>; Java数据结构中log默认以2为底(个人理解,有待考证)</li><li>常用O(1), O(n), O(logn)表示对应算法的时间复杂度, 也用于表示空间复杂度。<ul><li><strong><code>O(1)</code></strong>: 最低的时空复杂度, 无论数据规模多大，都可以在一次计算后找到目标</li><li><strong><code>O(n)</code></strong>: 数据量增大n倍时，耗时增大n倍; 比如常见的遍历算法</li><li><strong><code>O(n^2)</code></strong>: 数据量增大n倍时，耗时增大n的平方倍; 比如冒泡排序，对n个数排序，需要扫描n×n次</li><li><strong><code>o(logn)</code></strong>: 当数据增大n倍时，耗时增大logn倍; 二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标(2^8=256)</li><li><strong><code>O(nlogn)</code></strong>: 同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度</li></ul></li></ul><h4 id="0-6-移位运算符"><a href="#0-6-移位运算符" class="headerlink" title="0.6  移位运算符"></a>0.6  移位运算符</h4><p>按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移) 和 &gt;&gt;&gt;(无符号右移)</p><ul><li><code>左移 &lt;&lt;</code> : 丢弃最高位,0补最低位；左移n位就相当于乘以2的n次方</li><li><code>右移 &gt;&gt;</code> : 符号位不变,高位补上符号位(正数0, 负数1)；右移n位相当于除以2的n次方</li><li><code>无符号右移 &gt;&gt;&gt;</code> : 忽略符号位，0补最高位(补码移位所得)</li></ul><blockquote><ul><li>正数的左移与右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。</li><li>负数的右移，就是补码高位补1,然后按位取反加1即可。</li></ul></blockquote><ul><li>运算规则：<ul><li>左移：高位移出(舍弃)，低位的空位补零；int类型时，每移动1位它的第31位就要被移出并且丢弃；long类型时，每移动1位它的第63位就要被移出并且丢弃；byte和short类型时，将自动把这些类型扩大为int型。</li><li>右移：低位移出(舍弃)，高位的空位补符号位，即正数补0，负数补1；当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。</li><li>无符号右移：补码移位，高位补0；正数和右移表现一致，负数变成了很大的正数；</li></ul></li></ul><h3 id="1-Arraylist"><a href="#1-Arraylist" class="headerlink" title="1. Arraylist"></a>1. Arraylist</h3><p>ArrayList的底层是数组队列，相当于<strong>动态数组</strong>。与数组相比，它的容量能动态增长。在添加大量元素前，应用程序使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p><ul><li><strong>数组</strong>时间复杂度: <strong>插入/删除:O(n)</strong>，<strong>增加(末尾)/随机访问: O(1)</strong></li><li>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的<strong>添加、删除、修改、遍历</strong>等功能</li><li>ArrayList 实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是<strong>快速随机访问</strong></li><li>ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，<strong>能被克隆</strong>。</li><li>ArrayList 实现java.io.Serializable 接口，这意味着ArrayList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>和 Vector 不同，ArrayList 中的操作<strong>不是线程安全的</strong>！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li></ul><h4 id="1-1-ArrayList扩容机制-（重点）"><a href="#1-1-ArrayList扩容机制-（重点）" class="headerlink" title="1.1 ArrayList扩容机制*（重点）"></a>1.1 ArrayList扩容机制*（重点）</h4><ul><li>以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组；当add第一个元素时，才真正分配容量(<strong>默认10</strong>)</li><li>ArrayList在每次增加元素(1个或一组)时，都要调用<code>ensureCapacityInternal()</code>方法来确保足够的容量</li><li>当容量不足以容纳当前的元素个数时，进入<code>grow()</code>方法进行扩容，首先设置新的容量为旧容量的<strong>1.5倍</strong></li><li>若设置后的新容量还不够，则设置新容量为<code>minCapacity</code>(所需最小容量)</li><li>比较新容量是否大于<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)，若大于，再比较<code>minCapacity</code>是否大于<code>MAX_ARRAY_SIZE</code>，若大于，设置新的容量为<code>Integer.MAX_VALUE</code>(Integer最大值)，否则设置新的容量为<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)</li><li>最后用<code>Arrays.copyof()</code>方法将元素拷贝到新的数组</li><li>(第<code>Integer.MAX_VALUE+1</code>次添加元素时，抛出<code>OutOfMemoryError</code>异常)</li></ul><blockquote><p><strong>System.arraycopy()和Arrays.copyOf()方法</strong><br>通过源码发现这两个实现数组复制的方法被广泛使用, 比如插入操作add(int index, E element)方法就很巧妙的用到了 System.arraycopy()方法让数组自己复制自己实现让index开始之后的所有成员后移一个位置</p><ul><li>Arrays.copyOf()内部也是调用了System.arraycopy()方法 </li><li>Arrays.copyOf()是系统自动在内部新建一个数组，并返回该数组</li><li>System.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li></ul></blockquote><h4 id="1-2-ensureCapacity"><a href="#1-2-ensureCapacity" class="headerlink" title="1.2 ensureCapacity"></a>1.2 ensureCapacity</h4><p>ArrayList对外提供了一个<code>ensureCapacity(int n)</code>方法</p><ul><li>最好在<code>add</code>大量元素之前用ensureCapacity方法，以<strong>减少增量重新分配的次数</strong></li><li>ensureCapacity一次性扩容到位，否则在添加大量元素的过程中，一点一点的进行扩容</li></ul><h4 id="1-3-内部类"><a href="#1-3-内部类" class="headerlink" title="1.3 内部类"></a>1.3 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span></span>&#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>ArrayList有四个内部类</p><ul><li>Itr 实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；</li><li>ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法</li><li>Iterator和ListIterator的区别: <ul><li>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</li></ul></li></ul><h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h3><p>LinkedList是基于<strong>双向链表</strong>实现的, 可以在任何位置进行高效地插入和移除操作的有序序列。</p><ul><li>复杂度: <strong>增加(末尾)/删除:O(1)</strong>，<strong>插入/获取: O(n)</strong></li><li>LinkedList 继承AbstractSequentialList的<strong>双向链表</strong>。它也可以被当作堆栈、队列或双端队列进行操作。</li><li>LinkedList 实现 List 接口，能对它进行<strong>队列操作</strong>。</li><li>LinkedList 实现 Deque 接口，即能将LinkedList当作<strong>双端队列</strong>使用。</li><li>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，<strong>能克隆</strong>。</li><li>LinkedList 实现java.io.Serializable接口，这意味着LinkedList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>LinkedList <strong>不是线程安全的</strong>，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法</li></ul><h4 id="2-1-LinkedList底层分析"><a href="#2-1-LinkedList底层分析" class="headerlink" title="2.1 LinkedList底层分析:"></a>2.1 LinkedList底层分析:</h4><p>LinkedList的底层是一个双向链表，链表中挂载着一个个的Node元素；可以从LinkedList的Node内部类看出奥秘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//尾指针</span></span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 数据域（当前节点的值）</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 后继（指向当前一个节点的后一个节点）</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 前驱（指向当前节点的前一个节点）</span></span><br><span class="line">    <span class="comment">// 构造函数，赋值前驱后继</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LinkedList 是基于链表结构实现，所以在类中包含了 first 和 last 两个指针(Node)。</li><li>Node 中包含了上一个节点和下一个节点的引用，这样就构成了双向的链表。</li></ul><h4 id="2-2-LinkedList增删改查"><a href="#2-2-LinkedList增删改查" class="headerlink" title="2.2 LinkedList增删改查"></a>2.2 LinkedList增删改查</h4><ul><li>链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。增加一定会修改modCount。</li><li>通过下标获取某个node的时候(add select)，会根据index处于前半段还是后半段<strong>进行一个折半</strong>，以提升查询效率</li><li>删也一定会修改modCount。 <ul><li>按下标删，也是先根据index找到Node，然后去链表上unlink掉这个Node。 </li><li>按元素删，会先去遍历链表寻找是否有该Node，如果有，去链表上unlink掉这个Node。</li></ul></li><li>改也是先根据index找到Node，然后替换值。不修改modCount。</li><li>CRUD操作里，都涉及到根据index去找到Node的操作。</li></ul><h4 id="2-2-unlink原理"><a href="#2-2-unlink原理" class="headerlink" title="2.2 unlink原理"></a>2.2 unlink原理</h4><ul><li>先判断该节点是否存在上一个节点，即是否有前驱节点。<ul><li>无前驱节点则说明要删除的节点为链表的第一节点，那么只需要把该节点的下一个节点设置为链表的第一个节点。</li><li>有前驱节点则需要把前驱节点的尾部引用指向该节点的下一个节点。</li></ul></li><li>再判断该节点是否存在下一个节点，即是否有后继节点。<ul><li>无后继节点则说明该节点是链表的最后一个节点，那么只需要把该节点前驱节点设置成链表的最后一个节点即可。</li><li>有后继节点则需要把后继节点的头部引用指向该节点的上一个节点。</li></ul></li><li>核心就是在于将要删除的节点的前驱节点尾部指向该节点的后继节点，将要删除的节点的后继节点的头部指向该节点的前驱节点。这样便完成了链表的删除操作。</li></ul><blockquote><p>删除和新增方法的实现基本是对该节点的上一个节点和下一个节点的引用设置，不需要操作其他节点，效率相对较高</p></blockquote><h4 id="2-3-offer与add的区别"><a href="#2-3-offer与add的区别" class="headerlink" title="2.3 offer与add的区别"></a>2.3 offer与add的区别</h4><ul><li>offer属于 offer in interface <strong>Deque</strong>。</li><li>add 属于 add in interface <strong>Collection</strong>。</li><li>当队列为空时候，使用add方法会报错，而offer方法会返回false。</li><li>作为List使用时,一般采用add / get方法来 压入/获取对象。</li><li>作为Queue使用时,才会采用 offer/poll/take等方法作为链表对象时,offer等方法相对来说没有什么意义这些方法是用于支持队列应用的。</li></ul><h4 id="2-2-对比Vector、ArrayList、LinkedList有何区别"><a href="#2-2-对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="2.2 对比Vector、ArrayList、LinkedList有何区别"></a>2.2 对比Vector、ArrayList、LinkedList有何区别</h4><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全</strong>的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据扩容为旧容量的<strong>2倍</strong>。</li><li>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。ArrayList 也是可以根据需要调整容量，在扩容为旧容量的<strong>1.5倍</strong>。</li><li>LinkedList 顾名思义是 Java 提供的双向链表，<strong>不需要扩容</strong>，它也不是线程安全的。LinkedList不支持高效的随机元素访问。</li></ul><h3 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3. HashMap"></a>3. HashMap</h3><p>HashMap是<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的, 用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。</p><ul><li>HashMap继承了AbstractMap类，实现了Map，Cloneable，Serializable接口</li><li>继承 abstractMap，也就是用来减轻实现Map接口的编写负担。</li><li>实现 Cloneable：能够使用Clone()方法，在HashMap中，实现的是<strong>浅层次拷贝</strong>，即对拷贝对象的改变会影响被拷贝的对象。</li><li>实现 Serializable：能够使之<strong>序列化</strong>，即可以将HashMap对象保存至本地，之后可以恢复状态。</li></ul><blockquote><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>，以实现O(logn)时间复杂读查找。</p></blockquote><p>HashMap类中有一个非常重要的字段，就是 Node[] table，即<strong>哈希桶数组</strong>，明显它是一个Node的数组。</p><ul><li>HashMap的实例有两个参数影响其性能:<ul><li>初始容量(默认16)：哈希表中桶的数量</li><li>加载因子(默认0.75)：哈希表在其容量自动增加之前可以达到多满的一种尺度</li></ul></li><li>当哈希表中条目数超出了当前容量*加载因子(其实就是HashMap的实际容量)时，则对该哈希表进行rehash操作，将哈希表扩充至两倍的桶数。</li></ul><h4 id="3-1-HashMap的-put-方法过程-（重点）"><a href="#3-1-HashMap的-put-方法过程-（重点）" class="headerlink" title="3.1 HashMap的 put 方法过程*（重点）"></a>3.1 HashMap的 put 方法过程*（重点）</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>对 Key 求 Hash 值，然后再计算下标。</li><li>如果没有碰撞，直接放入桶中，</li><li>如果碰撞了，若是树节点，就<code>putTreeVal</code>添加元素，若不是就遍历链表插入。</li><li>如果链表长度超过阀值（TREEIFY_THRESHOLD==8），就把链表转成红黑树。</li><li>如果节点已经存在就替换旧值，若未找到则继续</li><li>如果桶满了（容量 * 加载因子），就需要 resize(扩容为原来2倍并重新散列,元素的下标要么不变，要么变为【原下标+原容量】)。</li></ol><h4 id="3-2-HashMap-桶下标计算"><a href="#3-2-HashMap-桶下标计算" class="headerlink" title="3.2 HashMap 桶下标计算"></a>3.2 HashMap 桶下标计算</h4><ul><li><strong>下标</strong>：<code>hash(key) &amp; (table.length - 1)</code></li><li>扰动函数<strong>hash(key)</strong>：(key==null) ? 0 : <code>(key.hashCode()^(key.hashCode() &gt;&gt;&gt; 16))</code></li><li>低16位 和 高 16位 做了一个<strong>异或</strong>得到 hash值 与 (容器长度-1)进行<strong>取模(%)</strong>运算,得到下标。<ul><li>利用位运算代替取模运算，提高程序的计算效率：（当 b=2^n 时，a%b = a &amp; (b-1) ），也是因此，HashMap 才将初始长度设置为 16，且扩容只能是以 2 的倍数（2^n）扩容。</li></ul></li><li>有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以尽可能有效的避免哈希碰撞。</li></ul><blockquote><p>HashMap 的性能表现非常依赖于哈希码的有效性: equals相等，hashCode一定要相等。重写了 hashCode 也要重写 equals。hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</p></blockquote><h4 id="3-3-HashMap-容量、负载因子和树化"><a href="#3-3-HashMap-容量、负载因子和树化" class="headerlink" title="3.3 HashMap 容量、负载因子和树化"></a>3.3 HashMap 容量、负载因子和树化</h4><ul><li>容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。</li><li>如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。</li><li>计算条件：<strong>负载因子 * 容量 &gt; 元素数量</strong>；所以，预先设置的容量需要满足，大于“预估元素数量/负载因子”，同时它是<strong>2的幂数</strong></li><li>容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 <strong>1&lt;&lt;30</strong>，也就是2的30次方</li></ul><h5 id="3-3-1-HashMap-负载因子loadFactor"><a href="#3-3-1-HashMap-负载因子loadFactor" class="headerlink" title="3.3.1 HashMap 负载因子loadFactor"></a>3.3.1 HashMap 负载因子loadFactor</h5><ul><li>loadFactor加载因子是控制数组存放数据的疏密程度，越大越密，越小越稀疏。</li><li>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的<strong>默认值为0.75f</strong>是官方给出的一个比较好的临界值。</li><li>给定的默认容量为16，负载因子为0.75。当数量达到了 16*0.75 = 12 就需要将当前16的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li><li>而对于负载因子，建议：<ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</li><li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul></li></ul><h5 id="3-3-2-HashMap-门限值threshold"><a href="#3-3-2-HashMap-门限值threshold" class="headerlink" title="3.3.2 HashMap 门限值threshold"></a>3.3.2 HashMap 门限值threshold</h5><p><code>threshold = capacity * loadFactor</code>，当<code>Size&gt;=threshold</code>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</p><ul><li>门限值等于(负载因子 x 容量)，如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。</li><li>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="3-3-2-HashMap-树化改造"><a href="#3-3-2-HashMap-树化改造" class="headerlink" title="3.3.2 HashMap 树化改造"></a>3.3.2 HashMap 树化改造</h5><p>树化改造逻辑主要在 putVal 和 <code>treeifyBin</code> 中。</p><ul><li>链表结构（这里叫 bin）的数量大于 <code>TREEIFY_THRESHOLD</code>(默认为8) 时：<ul><li>如果容量小于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64) ，只会进行简单的扩容。</li><li>如果容量大于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64)，则会进行树化改造。</li></ul></li></ul><h4 id="3-4-HashMap-扩容resize"><a href="#3-4-HashMap-扩容resize" class="headerlink" title="3.4 HashMap 扩容resize"></a>3.4 HashMap 扩容resize</h4><ul><li>HashMap扩容条件：<ul><li>元素个数超出了加载因子与当前容量的乘积，并且发生了Hash碰撞</li></ul></li><li>HashMap扩容步骤：<ol><li>创建一个新的Entry空数组，长度是原来的2倍。</li><li>遍历原Entry数组，把所有的Entry重新Hash到新数组里。</li><li>重新散列的元素下标要么【不变】，要么变为【原下标+原容量】，取决于位运算((n - 1) &amp; hash)</li></ol></li></ul><blockquote><p>经过一次扩容处理后，元素会更加均匀的分布在各个桶中，会提升访问效率。<br>但会遍历所有的元素，时间复杂度很高；遍历元素所带来的坏处大于元素在桶中均匀分布所带来的好处。<br>尽量避免进行扩容处理。</p></blockquote><h4 id="3-5-常见的hash算法及冲突的解决"><a href="#3-5-常见的hash算法及冲突的解决" class="headerlink" title="3.5 常见的hash算法及冲突的解决"></a>3.5 常见的hash算法及冲突的解决</h4><p>hash函数，即散列函数。它可以将不定长的输入，通过散列算法转换成一个定长的输出，这个输出就是散列值(不保证唯一)。</p><ul><li>常见Hash算法：<ol><li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址（H(k)=ak+b）。</li><li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址（如一组出生日期，相较于年-月，月-日的差别要大得多，可以降低冲突概率）</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li><li>伪随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</li><li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址（H(k)=k%p, p&lt;=m; p一般取m或素数）。</li></ol></li><li>常见解决hash冲突的方法<ol><li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li><li>开放定址法：即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。</li><li>再哈希法：即发生冲突时，由其他的函数再计算一次哈希值。</li><li>建立公共溢出区：将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。</li></ol></li></ul><blockquote><p>HashMap就是使用链地址法来解决冲突的（JDK1.8增加了红黑树）</p></blockquote><h4 id="3-6-对比Hashtable、HashMap、TreeMap有什么不同"><a href="#3-6-对比Hashtable、HashMap、TreeMap有什么不同" class="headerlink" title="3.6 对比Hashtable、HashMap、TreeMap有什么不同"></a>3.6 对比Hashtable、HashMap、TreeMap有什么不同</h4><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</li><li>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</li><li>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O(log(n))的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集合-Collection-Map&quot;&gt;&lt;a href=&quot;#集合-Collection-Map&quot; class=&quot;headerlink&quot; title=&quot;集合(Collection/Map)&quot;&gt;&lt;/a&gt;集合(Collection/Map)&lt;/h3&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】Redis穿透、击穿、雪崩和数据一致性</title>
    <link href="http://chaooo.github.io/article/20190927.html"/>
    <id>http://chaooo.github.io/article/20190927.html</id>
    <published>2019-09-27T11:15:31.000Z</published>
    <updated>2019-11-04T07:25:49.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。</p><ul><li>解决方案：<ol><li>采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；</li><li>访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</li><li>接口限流与熔断、降级</li><li>使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））</li></ol></li></ul><h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><ul><li>解决方案<ol><li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li><li>建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</li><li>加锁排队，实现同上;</li></ol></li></ul><h3 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h3><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p><ul><li>解决方案<ul><li>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</li></ul></li></ul><h3 id="4-缓存并发竞争"><a href="#4-缓存并发竞争" class="headerlink" title="4. 缓存并发竞争"></a>4. 缓存并发竞争</h3><p>多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）</p><ul><li>解决方案<ol><li>如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。</li><li>如果对这个key操作，要求顺序：<ol><li>分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了）</li><li>利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）</li></ol></li></ol></li></ul><h3 id="5-缓存和数据库一致性解决方案"><a href="#5-缓存和数据库一致性解决方案" class="headerlink" title="5. 缓存和数据库一致性解决方案"></a>5. 缓存和数据库一致性解决方案</h3><h4 id="5-1-并发量、一致性要求都不是很高的场景"><a href="#5-1-并发量、一致性要求都不是很高的场景" class="headerlink" title="5.1 并发量、一致性要求都不是很高的场景"></a>5.1 并发量、一致性要求都不是很高的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，之后再<strong>异步将数据刷回缓存</strong></li><li>读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：实现起来简单，异步刷新，补缺补漏</li><li>缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</li></ol><h4 id="5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）"><a href="#5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）" class="headerlink" title="5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）"></a>5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，监听从库binlog，通过<strong>解析binlog来刷新缓存</strong></li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：容灾</li><li>缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读/写的时候，缓存中的数据已失效，此时又发生了更新）</li></ol><h4 id="5-3-业务只需要达到“最终一致性”要求的场景"><a href="#5-3-业务只需要达到“最终一致性”要求的场景" class="headerlink" title="5.3 业务只需要达到“最终一致性”要求的场景"></a>5.3 业务只需要达到“最终一致性”要求的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的<strong>数据标识</strong>，然后将<strong>数据标识写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：只能达到”最终一致性”</li></ol><h4 id="5-4-强一致性的场景"><a href="#5-4-强一致性的场景" class="headerlink" title="5.4 强一致性的场景"></a>5.4 强一致性的场景</h4><ul><li>写流程：我们把<strong>修改的数据通过Cache_0标记</strong>“正在被修改”，如果<strong>标记成功，写数据库，删除缓存，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识<strong>写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。</li><li>读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-缓存穿透&quot;&gt;&lt;a href=&quot;#1-缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;1. 缓存穿透&quot;&gt;&lt;/a&gt;1. 缓存穿透&lt;/h3&gt;&lt;p&gt;访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Redis" scheme="http://chaooo.github.io/categories/Redis/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】深入学习Redis及集群</title>
    <link href="http://chaooo.github.io/article/20190920.html"/>
    <id>http://chaooo.github.io/article/20190920.html</id>
    <published>2019-09-20T08:19:26.000Z</published>
    <updated>2019-11-04T07:25:07.911Z</updated>
    
    <content type="html"><![CDATA[<p>Redis本质上是一个Key-Value类型的<strong>内存数据库</strong>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。<a id="more"></a>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="1-Redis数据结构及命令操作"><a href="#1-Redis数据结构及命令操作" class="headerlink" title="1. Redis数据结构及命令操作"></a>1. Redis数据结构及命令操作</h3><h4 id="1-1-基本概念及操作"><a href="#1-1-基本概念及操作" class="headerlink" title="1.1 基本概念及操作"></a>1.1 基本概念及操作</h4><ul><li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库；</li><li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；</li><li>select命令切换数据库：select 0-15；</li><li>dbsize：查看当前数据库的key的数量；</li><li>flushdb：清空当前库；</li><li>flushall；通杀全部库；</li></ul><h4 id="1-2-Redis数据结构"><a href="#1-2-Redis数据结构" class="headerlink" title="1.2 Redis数据结构"></a>1.2 Redis数据结构</h4><p>redis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)</p><ol><li>String：set, get, del, append, strlen</li><li>Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall</li><li>List：lpush, rpush, lrange, lpop(删除), rpop, lindex</li><li>Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)</li><li>ZSet：zadd, zrange, zrem</li></ol><h4 id="1-3-Redis键-key-–常用命令介绍"><a href="#1-3-Redis键-key-–常用命令介绍" class="headerlink" title="1.3 Redis键(key)–常用命令介绍"></a>1.3 Redis键(key)–常用命令介绍</h4><ul><li>keys *：查看所有 key ；</li><li>exists key的名字：判断某个 key 是否存在；</li><li>move key dbID（0-15）： 当前库就没有了，被移除了；</li><li>expire key 秒钟： 为给定的 key 设置过期时间；</li><li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；</li><li>type key： 查看你的 key 是什么类型；</li></ul><h3 id="2-Redis持久化"><a href="#2-Redis持久化" class="headerlink" title="2. Redis持久化"></a>2. Redis持久化</h3><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。</p><h4 id="2-1-RDB（Redis-DataBase）"><a href="#2-1-RDB（Redis-DataBase）" class="headerlink" title="2.1 RDB（Redis DataBase）"></a>2.1 RDB（Redis DataBase）</h4><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p><ul><li>开启RDB持久化方式一：save命令，或bgsave(异步)</li><li>开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：<code>redis-server redis.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1     # 900s内至少达到一条写命令</span><br><span class="line">save 300 10    # 300s内至少达至10条写命令</span><br><span class="line">save 60 10000  # 60s内至少达到10000条写命令</span><br></pre></td></tr></table></figure><ul><li><p>RDB的几个优点</p><ul><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li></ul></li><li><p>RDB的几个缺点</p><ul><li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ul></li></ul><h4 id="2-2-AOF-Append-only-file"><a href="#2-2-AOF-Append-only-file" class="headerlink" title="2.2 AOF(Append-only file)"></a>2.2 AOF(Append-only file)</h4><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><ul><li>开启方式：在Redis配置文件redis.conf配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes                  # 开启aof机制</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # aof文件名</span><br><span class="line"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec(每秒写入一次)或no(操作系统处理)</span><br><span class="line">appendfsync always</span><br><span class="line">no-appendfsync-on-rewrite no    # 默认不重写aof文件</span><br><span class="line">dir ~/redis/                    # 保存目录</span><br></pre></td></tr></table></figure><ul><li>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令</li></ul><ul><li>AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li><li>AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。</li><li>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</li></ul><h5 id="2-2-1-AOF文件修复"><a href="#2-2-1-AOF文件修复" class="headerlink" title="2.2.1 AOF文件修复"></a>2.2.1 AOF文件修复</h5><ol><li>备份被写坏的AOF文件</li><li>运行redis-check-aof –fix进行修复</li><li>用diff -u来看下两个文件的差异，确认问题点</li><li>重启redis，加载修复后的AOF文件</li></ol><h3 id="3-Redis的高并发和快速原因"><a href="#3-Redis的高并发和快速原因" class="headerlink" title="3. Redis的高并发和快速原因"></a>3. Redis的高并发和快速原因</h3><ol><li>redis是基于内存的，内存的读写速度非常快；</li><li>redis是单线程的，省去了很多上下文切换线程的时间；</li><li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</li><li>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li><li>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li></ol><h3 id="4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用"><a href="#4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用" class="headerlink" title="4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用"></a>4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用</h3><ol><li>哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。<ol><li>集群监控：负责监控Redis master和slave进程是否正常工作</li><li>消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li><li>故障转移：如果master node挂掉了，会自动转移到slave node上</li><li>配置中心：如果故障转移发生了，通知client客户端新的master地址</li></ol></li><li>复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。<ol><li>从数据库向主数据库发送sync(数据同步)命令。</li><li>主数据库接收同步命令后，会保存快照，创建一个RDB文件。</li><li>当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。</li><li>主数据库将缓冲区的所有写命令发给从服务器执行。</li><li>以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。</li></ol></li></ol><h3 id="5-Redis-主从复制、哨兵和集群这三个有什么区别"><a href="#5-Redis-主从复制、哨兵和集群这三个有什么区别" class="headerlink" title="5. Redis 主从复制、哨兵和集群这三个有什么区别"></a>5. Redis 主从复制、哨兵和集群这三个有什么区别</h3><p>主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。</p><ol><li>主从模式：读写分离，备份，一个Master可以有多个Slaves。</li><li>哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li><li>集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li></ol><h3 id="6-Redis-Cluster集群"><a href="#6-Redis-Cluster集群" class="headerlink" title="6. Redis Cluster集群"></a>6. Redis Cluster集群</h3><p>Redis Cluster，是Redis 3.0开始引入的分布式存储方案。<br>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p><ul><li>集群的作用：<ol><li>数据分区：数据分区(或称数据分片)是集群最核心的功能。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</li></ol></li></ul><h4 id="6-1-Redis-Cluster集群的搭建可以分为四步："><a href="#6-1-Redis-Cluster集群的搭建可以分为四步：" class="headerlink" title="6.1 Redis Cluster集群的搭建可以分为四步："></a>6.1 Redis Cluster集群的搭建可以分为四步：</h4><ol><li><strong>启动节点</strong>：将节点以集群模式启动，此时节点是独立的，并没有建立联系；</li><li><strong>节点握手</strong>：让独立的节点连成一个网络；</li><li><strong>分配槽</strong>：将16384个槽分配给主节点；</li><li><strong>指定主从关系</strong>：为从节点指定主节点。</li></ol><h4 id="6-2-Redis-Cluster工作原理"><a href="#6-2-Redis-Cluster工作原理" class="headerlink" title="6.2 Redis Cluster工作原理"></a>6.2 Redis Cluster工作原理</h4><ul><li>客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点</li><li>根据公式<code>HASH_SLOT=CRC16(key) mod 16384</code>，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         CRC16(key)    |  0~5460   | &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">         mode 16384    |</span><br><span class="line">Client --------------&gt; | 5461~10922| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">                       |</span><br><span class="line">                       |10923~10383| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br></pre></td></tr></table></figure><h4 id="6-3-Redis-Cluster优点"><a href="#6-3-Redis-Cluster优点" class="headerlink" title="6.3 Redis Cluster优点:"></a>6.3 Redis Cluster优点:</h4><ol><li>无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master</li><li>可以进行水平扩容</li><li>支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。</li></ol><h4 id="6-4-Redis-Cluster缺点"><a href="#6-4-Redis-Cluster缺点" class="headerlink" title="6.4 Redis Cluster缺点:"></a>6.4 Redis Cluster缺点:</h4><ol><li>批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）</li><li>资源隔离性较差，容易出现相互影响的情况。</li></ol><h4 id="6-5-Redis-Cluster总结："><a href="#6-5-Redis-Cluster总结：" class="headerlink" title="6.5 Redis Cluster总结："></a>6.5 Redis Cluster总结：</h4><ol><li>Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。</li><li>单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。</li><li>不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。</li><li>如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。</li><li>Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。</li><li>Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis本质上是一个Key-Value类型的&lt;strong&gt;内存数据库&lt;/strong&gt;，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。
    
    </summary>
    
      <category term="Redis" scheme="http://chaooo.github.io/categories/Redis/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL事务处理与并发控制</title>
    <link href="http://chaooo.github.io/article/20190907.html"/>
    <id>http://chaooo.github.io/article/20190907.html</id>
    <published>2019-09-07T15:31:48.000Z</published>
    <updated>2019-11-03T15:42:24.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MySQL事务"><a href="#1-MySQL事务" class="headerlink" title="1. MySQL事务"></a>1. MySQL事务</h3><ol><li>事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；<a id="more"></a></li><li>事务的特性(ACID)：<ul><li><strong>原子性</strong>（Atomicity，或称不可分割性）：最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚</li><li><strong>一致性</strong>（Consistency）：事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则， 不会因为出现系统意外等原因导致状态的不一致</li><li><strong>隔离性</strong>（Isolation，又称独立性）：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）</li><li><strong>持久性</strong>（Durability）：事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失</li></ul></li><li>事务的开启与提交模式<ul><li>若参数autocommit=0，自动开启<strong>手动提交</strong></li><li>若参数autocommit=1（系统默认值），又分为两种状态：<ul><li><strong>自动开启自动提交</strong>：用户的每一个操作都是一个完整的事务周期。</li><li><strong>手动开启手动提交</strong>：从用户执行<code>start transaction</code>命令到用户执行<code>commit</code>命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。<ul><li><code>begin</code> 或者 <code>start transaction</code>   – 开启事务</li><li><code>commit</code> 或者 <code>rollback</code>           – 事务提交或回滚</li></ul></li></ul></li></ul></li></ol><h4 id="1-1-事务的隔离级别"><a href="#1-1-事务的隔离级别" class="headerlink" title="1.1 事务的隔离级别"></a>1.1 事务的隔离级别</h4><ul><li>查看/设置隔离级别<ul><li>查看：<code>SELECT @@tx_isolation</code></li><li>设置：<code>set tx_isolation=&#39;xxx&#39;</code></li></ul></li></ul><ol><li><strong>读未提交</strong>（Read Uncommitted）<ul><li>事务未提交对其他事务也是可见的，脏读（dirty read）</li></ul></li><li><strong>读提交</strong>（Read Committed）–解决脏读问题 <ul><li>一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）</li></ul></li><li><strong>可重复读</strong>（Repeatable Read）–解决不可重复读问题<ul><li>在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题</li></ul></li><li><strong>串行化</strong>（Serializable）–解决所有问题<ul><li>最高的隔离级别，通过强制事务的串行执行，但是会导致大量超时以及锁争用问题</li></ul></li></ol><blockquote><p>Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别。<br>事务的隔离级别的实现：锁、MVCC（多版本并发控制 Multiversion Currency Control）。</p></blockquote><h4 id="1-2-事务的七大传播行为"><a href="#1-2-事务的七大传播行为" class="headerlink" title="1.2 事务的七大传播行为"></a>1.2 事务的七大传播行为</h4><p>Spring在TransactionDefinition接口中规定了<strong>7种</strong>类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。</p><ul><li>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时<strong>事务如何传播</strong>。<ul><li><code>@Transactional(propagation = Propagation.REQUIRED)</code></li></ul></li></ul><ol><li>第一类：运行在同一个事务<ul><li><strong><code>REQUIRED</code></strong>（required）：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li><li><code>SUPPORTS</code>（supports）：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li><li><code>MANDATORY</code>（mandatory）：支持当前事务，如果当前没有事务，就抛出异常</li></ul></li><li>第二类：运行在不同事务<ul><li><strong><code>REQUIRES_NEW</code></strong>（requires new）：新建事务，如果当前存在事务，把当前事务挂起</li><li><code>NOT_SUPPORTED</code>(not supported)：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li><code>NEVER</code>（never）：以非事务方式执行，如果当前存在事务，则抛出异常</li></ul></li><li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul><li><strong><code>NESTED</code></strong>（nested）：如果当前事务存在，则嵌套事务执行</li></ul></li></ol><h3 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h3><p>锁是用于管理不同事务对共享资源的并发访问，InnoDB存储引擎支持行锁和表锁（InnoDB表锁是另类的行锁）</p><ul><li>InnoDB行锁<ul><li>共享锁（读锁）：Shared Locks</li><li>排它锁（写锁）：Exclusive Locks</li></ul></li><li>InnoDB表锁<ul><li>意向锁共享锁（IS）：Intention Shared Locks</li><li>意向锁排它锁（IX）：Intention Exclusive Locks</li><li>自增锁：AUTO-INC Locks</li></ul></li><li>行锁的算法<ul><li>记录锁 Record Locks</li><li>间隙锁 Gap Locks</li><li>临键锁 Next-key Locks</li></ul></li></ul><h4 id="2-1-共享锁-Shared-amp-排他锁-Exclusive"><a href="#2-1-共享锁-Shared-amp-排他锁-Exclusive" class="headerlink" title="2.1 共享锁(Shared) &amp; 排他锁(Exclusive)"></a>2.1 共享锁(Shared) &amp; 排他锁(Exclusive)</h4><p>它们都是标准的<strong>行级锁</strong>。</p><ul><li>共享锁（S锁）：读锁，读锁允许多个连接可以同一时刻<strong>并发的读</strong>取同一资源,互不干扰，但是只能读不能修改;<ul><li>加锁： <code>select * from users WHERE id=1</code><strong><code>LOCK IN SHARE MODE</code></strong>; </li><li>解锁：<strong><code>commit</code></strong>或<strong><code>rollback</code></strong></li></ul></li><li>排他锁（X锁）：写锁，一个写锁会<strong>阻塞</strong>其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。<ul><li>加锁： <code>select * from users WHERE id=1</code><strong><code>FOR UPDATE</code></strong>; </li><li><strong><code>delete/update/insert 默认上 X 锁</code></strong></li><li>解锁：<strong><code>commit</code></strong>或<strong><code>rollback</code></strong></li></ul></li></ul><blockquote><p>注意：所谓共享锁、排他锁其实均是<strong>锁机制本身的策略</strong>，通过这两种策略对锁做了区分。</p><ul><li>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的。</li><li>只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）</li></ul></blockquote><h4 id="2-2-意向锁-Intention-amp-自增锁-AUTO-INC"><a href="#2-2-意向锁-Intention-amp-自增锁-AUTO-INC" class="headerlink" title="2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)"></a>2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)</h4><p>它们都是标准的<strong>表级锁</strong>。</p><ul><li><strong>意向锁</strong>（Intention Locks）：表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，才被允许对该表加行锁(S或X)。(即一个数据行加锁前必须先取得该表的意向锁)<ul><li>意向锁(IS、IX)是InnoDB数据操作之前<strong>自动加的</strong>，不需要用户干预 </li><li>意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li></ul></li><li><strong>自增锁</strong>（AUTO-INC Locks）：针对自增列自增长的一个特殊的表级别锁<ul><li><code>show variables like &#39;innodb_autoinc_lock_mode&#39;</code>;</li><li>默认取值1，代表连续，事务未提交ID永久丢失</li></ul></li></ul><h4 id="2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key"><a href="#2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key" class="headerlink" title="2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)"></a>2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)</h4><ul><li><strong>临键锁 Next-key locks</strong>： <ul><li><strong>锁住记录+区间（左开右闭）</strong></li><li>Innodb<strong>默认</strong>行锁算法</li><li>当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、&lt;、&gt;等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，<strong>锁住索引的记录+区间（左开右闭）</strong></li></ul></li><li><strong>间隙锁 Gap locks</strong>：<ul><li><strong>锁住数据不存在的区间（左开右开）</strong></li><li>当记录不存在，临键锁<strong>退化</strong>为Gap锁</li><li>当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，Gap只在RR事务隔离级别存在，<strong>锁住索引不存在的区间（左开右开</strong>） </li></ul></li><li><strong>记录锁 Record locks</strong>： <ul><li><strong>锁住具体的索引项</strong></li><li>唯一性(主键/唯一)索引，条件为<strong>精准匹配，退化</strong>成Record锁</li><li>当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，<strong>锁住具体的索引项</strong></li></ul></li></ul><h4 id="2-4-死锁的产生与避免"><a href="#2-4-死锁的产生与避免" class="headerlink" title="2.4 死锁的产生与避免"></a>2.4 死锁的产生与避免</h4><ul><li>死锁<ul><li>在InnoDB中，锁是逐步获得的，就造成了死锁的可能（2个或以上并发事务）</li><li>每个事务都持有锁（或者是已经在等待锁）; </li><li>每个事务都需要再继续持有锁；<strong>事务之间产生加锁的循环等待</strong>，形成死锁。</li></ul></li><li>死锁的产生与避免<ol><li>类似的业务逻辑以固定的<strong>顺序访问</strong>表和行。</li><li>大事务拆小。大事务更倾向于死锁，如果业务允许，将<strong>大事务拆小</strong>。</li><li>在同<strong>一个事务</strong>中，尽可能做到<strong>一次锁定</strong>所需要的所有资源，减少死锁概 率。</li><li>降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择</li><li>为表添加<strong>合理的索引</strong>。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）</li></ol></li></ul><h3 id="3-MVCC-多版本并发控制"><a href="#3-MVCC-多版本并发控制" class="headerlink" title="3. MVCC(多版本并发控制)"></a>3. MVCC(多版本并发控制)</h3><p>Multiversion concurrency control (多版本并发控制)：</p><ul><li><strong>MVCC</strong> 就是 <strong>同一份数据临时保留多版本的一种方式，进而实现并发控制</strong></li><li>是行级锁的变种，它在普通读情况下<strong>避免了加锁操作</strong>，因此<strong>开销更低</strong>。</li><li>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用<strong>时间戳或者事务ID</strong>去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。<strong>读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据</strong>。</li></ul><h4 id="3-1-MVCC逻辑流程"><a href="#3-1-MVCC逻辑流程" class="headerlink" title="3.1 MVCC逻辑流程"></a>3.1 MVCC逻辑流程</h4><ul><li>在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列<ul><li><code>DB_TRX_ID</code>：数据行的版本号</li><li><code>DB_ROLL_PT</code>：删除版本号</li></ul></li></ul><ol><li>MVCC逻辑流程-插入<ul><li>在插入数据的时候，会把全局事务ID记录到列<code>DB_TRX_ID</code>中去</li></ul></li><li>MVCC逻辑流程-删除<ul><li>执行完删除SQL之后数据并没有被真正删除，而是对删除版本号(<code>DB_ROLL_PT</code>)做改变</li></ul></li><li>MVCC逻辑流程-修改<ul><li>修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前事务ID，最后把旧数据的删除版本号标记为新数据行版本号的值(即当前事务ID)。</li></ul></li><li>MVCC逻辑流程-查询<ul><li>查找数据行版本号早于当前事务ID的数据行记录</li><li>也就是说，数据行的版本号要小于或等于 当前事务ID，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据</li><li>查找删除版本号要么为NULL，要么大于当前事务版本号的记录</li><li>这样确保查询出来的数据行记录在事务开启之前没有被删除</li></ul></li></ol><blockquote><p>MySQL解决不可重复读和脏读并不是单纯利用 MVCC 机制来实现的。</p></blockquote><h3 id="4-MySQL事务日志-Undo-Log和Redo-Log"><a href="#4-MySQL事务日志-Undo-Log和Redo-Log" class="headerlink" title="4. MySQL事务日志(Undo Log和Redo Log)"></a>4. MySQL事务日志(Undo Log和Redo Log)</h3><p>innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。<br>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：</p><ol><li>redo log通常是<strong>物理日志</strong>，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</li><li>undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，根据每行记录进行记录。</li></ol><p>s</p><h4 id="4-1-Undo-Log"><a href="#4-1-Undo-Log" class="headerlink" title="4.1 Undo Log"></a>4.1 Undo Log</h4><ul><li>Undo Log定义：<ul><li>undo意为取消，以撤销操作为目的，返回指定某个状态的操作</li><li>undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log) </li></ul></li><li><strong>UndoLog是为了实现事务的原子性而出现的产物</strong></li><li>Undo Log实现事务原子性：<ul><li>事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份 将数据恢复到事务开始之前的状态</li></ul></li><li><strong>UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制</strong></li><li>Undo log实现多版本并发控制：<ul><li>事务未提交之前，Undo保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供 其他并发事务进行快照读</li></ul></li></ul><h4 id="4-2-当前读-amp-快照读"><a href="#4-2-当前读-amp-快照读" class="headerlink" title="4.2 当前读 &amp; 快照读"></a>4.2 当前读 &amp; 快照读</h4><ul><li>快照读：<ul><li>SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读 innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成 </li></ul></li><li>当前读：<ul><li>SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改 UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读</li></ul></li></ul><h4 id="4-3-Redo-Log"><a href="#4-3-Redo-Log" class="headerlink" title="4.3 Redo Log"></a>4.3 Redo Log</h4><ul><li>Undo Log定义： <ul><li>Redo，顾名思义就是重做。以恢复操作为目的，重现操作；</li><li>Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)</li></ul></li><li>Redo log的持久： <ul><li>不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体 的落盘策略可以进行配置</li></ul></li><li><strong>RedoLog是为了实现事务的持久性而出现的产物</strong></li><li>Redo Log实现事务持久性： <ul><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</li></ul></li><li>一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所 以Redo log的写入是日志文件循环写入的</li></ul><h3 id="附-58同城数据库设计30条军规"><a href="#附-58同城数据库设计30条军规" class="headerlink" title="附: 58同城数据库设计30条军规"></a>附: 58同城数据库设计30条军规</h3><ul><li>军规适用场景：并发量大、数据量大的互联网业务 </li><li>解读：讲解原因，<strong>解读比军规更重要</strong> </li></ul><h4 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h4><ol><li>必须使用InnoDB存储引擎<ul><li>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</li></ul></li><li>必须使用UTF8字符集 UTF-8MB4<ul><li>解读：万国码，无需转码，无乱码风险，节省空间</li></ul></li><li>数据表、数据字段必须加入中文注释<ul><li>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</li></ul></li><li>禁止使用存储过程、视图、触发器、Event<ul><li>解读：<strong>高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务 层”</strong>，并发量大的情况下，这些功能很可能将数据库拖死，<strong>业务逻辑放到服务层具备更好的 扩展性，能够轻易实现“增机器就加性能”</strong>。数据库擅长存储与索引，CPU计算还是上移吧</li></ul></li><li>禁止存储大文件或者大照片<ul><li>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI 多好</li></ul></li></ol><h4 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h4><ol start="6"><li>只允许<strong>使用内网域名，而不是ip连接数据库</strong></li><li>线上环境、开发环境、测试环境数据库内网域名遵循命名规范<ul><li>业务名称：xxx，线上环境：xxx.db，开发环境：xxx.rdb，测试环境：xxx.tdb </li><li>从库在名称后加-s标识，备库在名称后加-ss标识 线上从库：xxx-s.db 线上备库：xxx-sss.db</li></ul></li><li>库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止 拼音英文混用</li><li>表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</li></ol><h4 id="三、表设计规范"><a href="#三、表设计规范" class="headerlink" title="三、表设计规范"></a>三、表设计规范</h4><ol start="10"><li>单实例表数目必须小于500</li><li>单表列数目必须小于30</li><li>表必须有主键，例如自增主键<ul><li>解读：<ol><li>主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和 内存的使用</li><li>主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类 型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li><li>无主键的表删除，在row模式的主从架构，会导致备库夯住</li></ol></li></ul></li><li>禁止使用外键，如果有外键完整性约束，需要应用程序控制<ul><li>解读：<strong>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响 sql 的性能</strong>，甚至会造成死锁。高并发情况下容易造成数据库性能，<strong>大数据高并发业务场景 数据库使用以性能优先</strong></li></ul></li></ol><h4 id="四、字段设计规范"><a href="#四、字段设计规范" class="headerlink" title="四、字段设计规范"></a>四、字段设计规范</h4><ol start="14"><li>必须把字段定义为NOT NULL并且提供默认值<ul><li>解读： <ol><li>null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化</li><li>null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条 件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li><li>null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标 识</li><li>对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、 not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记 录，查询结果就不会包含name为null值的记录</li></ol></li></ul></li><li>禁止使用TEXT、BLOB类型<ul><li>解读：会浪费更多的磁盘和内存空间，<strong>非必要的大量的大字段查询会淘汰掉热数据，导致内 存命中率急剧降低，影响数据库性能</strong></li></ul></li><li>禁止使用小数存储货币<ul><li>解读：使用整数吧，小数容易导致钱对不上</li></ul></li><li>必须使用varchar(20)存储手机号<ul><li>解读：<ol><li>涉及到区号或者国家代号，可能出现+-()</li><li>手机号会去做数学运算么？</li><li>varchar可以支持模糊查询，例如：like“138%”</li></ol></li></ul></li><li>禁止使用ENUM，可使用TINYINT代替<ul><li>解读：<ol><li>增加新的ENUM值要做DDL操作</li><li>ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</li></ol></li></ul></li></ol><h4 id="五、索引设计规范"><a href="#五、索引设计规范" class="headerlink" title="五、索引设计规范"></a>五、索引设计规范</h4><ol start="19"><li>单表索引建议控制在5个以内</li><li>单索引字段数不允许超过5个<ul><li>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</li></ul></li><li>禁止在更新十分频繁、区分度不高的属性上建立索引<ul><li>解读：<ol><li>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</li><li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性 能与全表扫描类似</li></ol></li></ul></li><li>建立组合索引，必须把区分度高的字段放在前面<ul><li>解读：能够更加有效的过滤数据</li></ul></li></ol><h4 id="六、SQL使用规范"><a href="#六、SQL使用规范" class="headerlink" title="六、SQL使用规范"></a>六、SQL使用规范</h4><ol start="23"><li>禁止使用SELECT *，只获取必要的字段，需要显示说明列属性<ul><li>解读：<ol><li>读取不需要的列会增加CPU、IO、NET消耗</li><li>不能有效的利用覆盖索引</li></ol></li></ul></li><li>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性<ul><li>解读：容易在增加或者删除字段后出现程序BUG</li></ul></li><li>禁止使用属性隐式转换<ul><li>解读：SELECT uid FROM t_user WHERE phone=13812345678 <strong>会导致全表扫描</strong>，而不 能命中phone索引</li></ul></li><li>禁止在WHERE条件的属性上使用函数或者表达式<ul><li>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全 表扫描 正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</li></ul></li><li>禁止负向查询，以及%开头的模糊查询<ul><li>解读：<ol><li>负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</li><li>%开头的模糊查询，会导致全表扫描</li></ol></li></ul></li><li>禁止大表使用JOIN查询，禁止大表使用子查询<ul><li>解读：<strong>会产生临时表</strong>，消耗较多内存与CPU，极大影响数据库性能</li></ul></li><li>禁止使用OR条件，必须改为IN查询<ul><li>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费 更多的CPU帮助实施查询优化呢？</li></ul></li><li>应用程序必须捕获SQL异常，并有相应处理</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-MySQL事务&quot;&gt;&lt;a href=&quot;#1-MySQL事务&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL事务&quot;&gt;&lt;/a&gt;1. MySQL事务&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL索引的使用及优化</title>
    <link href="http://chaooo.github.io/article/20190905.html"/>
    <id>http://chaooo.github.io/article/20190905.html</id>
    <published>2019-09-05T09:04:12.000Z</published>
    <updated>2019-11-02T05:51:22.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-索引的基本概念"><a href="#1-索引的基本概念" class="headerlink" title="1. 索引的基本概念"></a>1. 索引的基本概念</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><ul><li>索引意义：<ol><li>索引能极大的减少存储引擎需要扫描的数据量</li><li>索引可以把随机IO变成顺序IO</li><li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表<a id="more"></a></li></ol></li><li>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引。</li></ul><h3 id="2-索引的适用场景"><a href="#2-索引的适用场景" class="headerlink" title="2. 索引的适用场景"></a>2. 索引的适用场景</h3><h4 id="2-1-适合建索引的场景"><a href="#2-1-适合建索引的场景" class="headerlink" title="2.1 适合建索引的场景"></a>2.1 适合建索引的场景</h4><ol><li>表的主键自动建立唯一索引</li><li>表的字段唯一约束</li><li>直接条件查询的字段（在SQL中用于条件约束的字段）</li><li>查询中与其它表关联的字段</li><li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li><li>查询中统计或分组统计的字段</li><li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li><li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li><li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li><li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li></ol><h4 id="2-2-不适合建索引的场景"><a href="#2-2-不适合建索引的场景" class="headerlink" title="2.2 不适合建索引的场景"></a>2.2 不适合建索引的场景</h4><ol><li>表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）</li><li>经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。</li><li>数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）</li></ol><h3 id="3-MySQl中索引的结构（B-树）"><a href="#3-MySQl中索引的结构（B-树）" class="headerlink" title="3. MySQl中索引的结构（B+树）"></a>3. MySQl中索引的结构（B+树）</h3><h4 id="3-1-基本概念："><a href="#3-1-基本概念：" class="headerlink" title="3.1 基本概念："></a>3.1 基本概念：</h4><ol><li>二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；</li><li>B树：多路搜索树，每个节点存储M/2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；</li><li>B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；</li><li>B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1/2提高到2/3；</li></ol><h4 id="3-2-B-树的特性："><a href="#3-2-B-树的特性：" class="headerlink" title="3.2 B+树的特性："></a>3.2 B+树的特性：</h4><ol><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>不可能在非叶子结点命中；</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>更适合文件索引系统；</li></ol><h4 id="3-3-B-树的三个特点："><a href="#3-3-B-树的三个特点：" class="headerlink" title="3.3 B+树的三个特点："></a>3.3 B+树的三个特点：</h4><ol><li>关键字数和子树相同<ul><li>在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</li></ul></li><li>非叶子节点仅用作索引，它的关键字和子节点有重复元素<ul><li>除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</li><li>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</li></ul></li><li>叶子节点用指针连在一起<ul><li>叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</li></ul></li></ol><blockquote><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。<br>B+ 树的查找必会查到叶子节点，更加稳定。<br>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p></blockquote><h4 id="3-4-B-树的三个优点："><a href="#3-4-B-树的三个优点：" class="headerlink" title="3.4 B+ 树的三个优点："></a>3.4 B+ 树的三个优点：</h4><ul><li>层级更低，IO 次数更少</li><li>每次都需要查询到叶子节点，查询性能稳定</li><li>叶子节点形成有序链表，范围查询方便</li></ul><h3 id="4-索引的优化"><a href="#4-索引的优化" class="headerlink" title="4. 索引的优化"></a>4. 索引的优化</h3><h4 id="4-1-优化法则（口诀）："><a href="#4-1-优化法则（口诀）：" class="headerlink" title="4.1 优化法则（口诀）："></a>4.1 优化法则（口诀）：</h4><ul><li>全值匹配我最爱，最左前缀要遵守</li><li>带头大哥不能死，中间兄弟不能断</li><li>索引列上无计算，范围之后全失效</li><li>like百分写最右，覆盖索引不写星</li><li>不等控制还有or，索引失效要少用</li><li>var引号不能丢，SQL优化也不难</li></ul><h4 id="4-2-具体描述"><a href="#4-2-具体描述" class="headerlink" title="4.2 具体描述"></a>4.2 具体描述</h4><ol><li>全值匹配<ul><li>怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多</li></ul></li><li>最佳左前缀法则<ul><li>指的是查询从索引的最左前列开始并且不跳过索引中的列。</li><li>例如：复合索引<code>A-&gt;B-&gt;C</code>，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。</li></ul></li><li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右面的列<ul><li>例如：<code>select t from test where A=1 and B&gt;2 and C=3</code>，那么B&gt;2后的查询条件失效。</li></ul></li><li>尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 <code>SELECT *</code>。</li><li>MySQL在使用不等于(<code>!=</code> 或<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描</li><li><code>is null</code>，<code>is not null</code> 也无法使用索引</li><li>like以通配符开头<code>(&#39;%abc...&#39;)</code>mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面<code>(&#39;abc...%&#39;)</code>的才能避免索引失效。</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li></ol><h3 id="5-in-和-exists区别及应用场景"><a href="#5-in-和-exists区别及应用场景" class="headerlink" title="5. in 和 exists区别及应用场景"></a>5. in 和 exists区别及应用场景</h3><h4 id="5-1-in-和-exists的区别"><a href="#5-1-in-和-exists的区别" class="headerlink" title="5.1 in 和 exists的区别:"></a>5.1 in 和 exists的区别:</h4><ul><li>如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。</li><li>其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</li><li>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</li></ul><h4 id="5-2-not-in-和not-exists"><a href="#5-2-not-in-和not-exists" class="headerlink" title="5.2 not in 和not exists"></a>5.2 not in 和not exists</h4><ul><li>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；</li><li>而not extsts 的子查询依然能用到表上的索引。</li><li>所以无论那个表大，用not exists都比not in要快</li></ul><h3 id="6-order-by-和-group-by-优化"><a href="#6-order-by-和-group-by-优化" class="headerlink" title="6. order by 和 group by 优化"></a>6. order by 和 group by 优化</h3><p>索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。</p><h4 id="6-1-提高ORDER-BY速度的技巧"><a href="#6-1-提高ORDER-BY速度的技巧" class="headerlink" title="6.1 提高ORDER BY速度的技巧"></a>6.1 提高ORDER BY速度的技巧</h4><ol><li>ORDER BY时不要使用SELECT *，只查需要的字段。</li><li>增大<code>sort_buffer_size</code>参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）</li><li>增大<code>max_length_for_sort_data</code>参数大小</li></ol><h4 id="6-2-GROUP-BY的优化"><a href="#6-2-GROUP-BY的优化" class="headerlink" title="6.2 GROUP BY的优化"></a>6.2 GROUP BY的优化</h4><ol><li>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。</li><li>当无法使用索引列，考虑增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>的参数设置。</li><li>WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。</li></ol><blockquote><p>注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)</p></blockquote><p>一般性建议：</p><ul><li>对于单值索引，尽量选择针对query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。</li><li>在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li></ul><blockquote><p>参考链接：<a href="https://www.zhihu.com/people/hen-six-49/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/hen-six-49/activities</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-索引的基本概念&quot;&gt;&lt;a href=&quot;#1-索引的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 索引的基本概念&quot;&gt;&lt;/a&gt;1. 索引的基本概念&lt;/h3&gt;&lt;p&gt;索引是为了加速对表中数据行的检索而创建的一种分散存储的&lt;strong&gt;数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引意义：&lt;ol&gt;
&lt;li&gt;索引能极大的减少存储引擎需要扫描的数据量&lt;/li&gt;
&lt;li&gt;索引可以把随机IO变成顺序IO&lt;/li&gt;
&lt;li&gt;索引可以帮助我们在进行分组、排序等操作时，避免使用临时表
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL性能优化基础</title>
    <link href="http://chaooo.github.io/article/20190901.html"/>
    <id>http://chaooo.github.io/article/20190901.html</id>
    <published>2019-09-01T13:36:46.000Z</published>
    <updated>2019-11-03T15:42:08.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MySQL基础操作"><a href="#1-MySQL基础操作" class="headerlink" title="1. MySQL基础操作"></a>1. MySQL基础操作</h3><h4 id="1-1-MySQL备份与恢复"><a href="#1-1-MySQL备份与恢复" class="headerlink" title="1.1 MySQL备份与恢复"></a>1.1 MySQL备份与恢复</h4><ol><li>备份：在mysql的安装目录的bin目录下有<strong>mysqldump命令</strong>，可以完成对数据库的备份。 <ul><li>语法：<code>mysqldump -u 用户名 -p 数据库名&gt; 磁盘SQL文件路径</code> <a id="more"></a></li><li>由于mysqldump命令不是sql命令，需要在<strong>dos窗口下使用</strong>。</li><li>仅仅只会备份数据库中的表和数据，恢复时需要先手动创建数据库。</li></ul></li><li>恢复：先手动创建数据库：<code>create database 数据库名</code><ul><li>然后dos窗口：<code>mysql -u 用户名-p 导入库名&lt; 磁盘SQL文件绝对路径</code></li></ul></li></ol><h4 id="1-2-MySQL事务基础"><a href="#1-2-MySQL事务基础" class="headerlink" title="1.2 MySQL事务基础"></a>1.2 MySQL事务基础</h4><ol><li>特性(ACID)：<strong>原子性</strong>（Atomicity，或称不可分割性）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation，又称独立性）、<strong>持久性</strong>（Durability）。</li><li>事务隔离级别：<strong>读未提交</strong>（Read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（Serializable）。</li><li>MYSQL事务处理主要有两种方法： <ol><li>用 BEGIN, ROLLBACK, COMMIT来实现:<ul><li>BEGIN 开始一个事务</li><li>COMMIT 事务确认 </li><li>ROLLBACK 事务回滚</li></ul></li><li>直接用 SET 来改变 MySQL 的自动提交模式: <ul><li>SET AUTOCOMMIT=0 禁止自动提交</li><li>SET AUTOCOMMIT=1 开启自动提交</li></ul></li></ol></li><li>事务并发操作出现几种问题: 丢失修改数据、读“脏”数据、数据不一致</li></ol><h4 id="1-3-查看设置MySQL编码"><a href="#1-3-查看设置MySQL编码" class="headerlink" title="1.3 查看设置MySQL编码"></a>1.3 查看设置MySQL编码</h4><ol><li><p>查看：<code>mysql&gt; show variables like &#39;character%&#39;</code></p></li><li><p>设置: # <code>vi /etc/my.cnf</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">character‐set‐server=utf8</span><br><span class="line">collation‐server=utf8_general_ci</span><br><span class="line">sql_mode=<span class="string">'NO_ENGINE_SUBSTITUTION'</span></span><br><span class="line">[mysql] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[mysql.server] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[mysqld_safe] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[client] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8</span><br></pre></td></tr></table></figure></li><li><p>mysql的主配置文件: <code>/etc/my.cnf</code></p></li><li><p>数据库文件存放位置: <code>/var/lib/mysql</code></p></li><li><p>数据库的日志输出存放位置: <code>/var/log/mysql</code></p></li><li><p>端口: <code>Netstat –nltp</code> 看是否能找到3306的端口</p></li></ol><h4 id="1-4-范式"><a href="#1-4-范式" class="headerlink" title="1.4 范式"></a>1.4 范式</h4><p>概念：范式就是符合某一规范级别的关系模式的集合。共有7种范式：<code>1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF⊃6NF</code></p><ol><li>第一范式(1NF, First Normal Form)：字段值具有<strong>原子性</strong>,不能再分(所有关系型数据库系统都满足第一范式);<ul><li>例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;</li></ul></li><li>第二范式(2NF, Second Normal Form)：一个表<strong>必须有主键</strong>,即每行数据都能被唯一的区分(2NF必须先满足第一范式);</li><li>第三范式(3NF, Third Normal Form)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表<strong>不能有冗余字段</strong>(3NF必须先满足第二范式);<ul><li>备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;</li><li>例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</li></ul></li></ol><h3 id="2-SQL语句优化"><a href="#2-SQL语句优化" class="headerlink" title="2. SQL语句优化"></a>2. SQL语句优化</h3><h4 id="2-1-通过慢查日志发现有问题的SQL"><a href="#2-1-通过慢查日志发现有问题的SQL" class="headerlink" title="2.1 通过慢查日志发现有问题的SQL"></a>2.1 通过慢查日志发现有问题的SQL</h4><ol><li>查询次数多且每次查询占用时间长的sql<ul><li>通常为<strong>pt-query-digest</strong>分析的前几个查询；该工具可以很清楚的看出每个SQL执行的次数及百分比等信息，执行的次数多，占比比较大的SQL</li></ul></li><li>IO大的sql<ul><li>注意pt-query-digest分析中的Rows examine项。扫描的行数越多，IO越大。</li></ul></li><li>未命中的索引的SQL<ul><li>注意pt-query-digest分析中的Rows examine 和Rows Send的对比。说明该SQL的索引命中率不高，对于这种SQL，我们要重点进行关注。</li></ul></li><li>通过explain查询分析SQL的执行计划, SQL的执行计划侧面反映出了SQL的执行效率，</li></ol><h4 id="2-2-常见SQL优化手段"><a href="#2-2-常见SQL优化手段" class="headerlink" title="2.2 常见SQL优化手段"></a>2.2 常见SQL优化手段</h4><ol><li>函数Max()的优化<ul><li>在求max的字段<strong>建索引</strong></li></ul></li><li>函数Count()的优化：<ul><li>Count(*):是包含null值；Count(id)：不包含null值</li></ul></li><li>子查询的优化<ul><li>子查询是我们在开发过程中经常使用的一种方式，在通常情况下，需要把<strong>子查询优化为join查询</strong>但在优化是需要注意关联键是否有一对多的关系，要注意重复数据(distinct去重)。</li><li>在用Join进行多表联合查询时，我们通常使用On来建立两个表的关系。其实还有一个更方便的关键字，那就是Using（如果两个表的关联字段名是一样）。</li></ul></li><li>group by的优化: <ul><li>最好使用同一表中的列，在子查询中分组</li></ul></li><li>Limit查询的优化：Limit常用于分页处理，时常会伴随order by从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。<ul><li>优化步骤1：使用有索引的列或主键进行order by操作，因为大家知道，innodb是按照主键的逻辑顺序进行排序的。可以避免很多的IO操作。</li><li>优化步骤2：记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）</li><li>注意事项：主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足一页的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可。</li></ul></li></ol><h3 id="3-索引的优化"><a href="#3-索引的优化" class="headerlink" title="3. 索引的优化"></a>3. 索引的优化</h3><h4 id="3-1-索引基础概念"><a href="#3-1-索引基础概念" class="headerlink" title="3.1 索引基础概念"></a>3.1 索引基础概念</h4><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><ul><li>索引的建立是表中<strong>比较有指向性的字段</strong>，相当于目录，比如说行政区域代码，同一个地域的行政区域代码都是相同的，那么给这一列加上索引，避免让它重复扫描，从而达到优化的目的！</li><li>创建索引：在执行create table语句时可以创建索引，也可以单独用create index或alter index来为表增加索引。<strong>不能用create index语句创建primary key索引</strong>。</li><li>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为primary key或unique索引。对于单列惟一性索引，这保证单列不包含重复的值。对于<strong>多列惟一性索引，保证多个值的组合不重复</strong>。</li><li>primary key索引和unique索引非常类似。事实上，<strong>primary key索引仅是一个具有名称PRIMARY的unique索引</strong>。</li><li>查看索引：<code>show index from tblname;</code>或<code>show keys from tblname;</code></li></ul><h4 id="3-2-索引的创建与删除"><a href="#3-2-索引的创建与删除" class="headerlink" title="3.2 索引的创建与删除"></a>3.2 索引的创建与删除</h4><ol><li>创建<strong>普通索引</strong>：<ul><li>方式1：<code>create index 索引名 on 表名(列名)</code></li><li>方式2：<code>alter table 表名 add index 索引名(列名)</code></li><li>方式3：创建表的时候直接指定: <code>,index [索引名] (列名)</code></li></ul></li><li>删除索引： <code>drop index [索引名] on 表名</code></li><li>唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>创建<strong>唯一索引</strong>：<ul><li>方式1：<code>create unique index 索引名 on 表名(列名)</code></li><li>方式2：<code>alter table 表名 add unique 索引名(列名)</code></li><li>方式3：创建表的时候直接指定: <code>,unique [索引名] (列名)</code></li></ul></li></ol><h4 id="3-3-使用索引的场景"><a href="#3-3-使用索引的场景" class="headerlink" title="3.3 使用索引的场景"></a>3.3 使用索引的场景</h4><ol><li>表的主键自动建立唯一索引</li><li>表的字段唯一约束</li><li>直接条件查询的字段（在SQL中用于条件约束的字段）</li><li>查询中与其它表关联的字段</li><li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li><li>查询中统计或分组统计的字段</li><li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li><li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li><li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li><li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li></ol><h4 id="3-4-索引的维护及优化（重复及冗余索引）"><a href="#3-4-索引的维护及优化（重复及冗余索引）" class="headerlink" title="3.4 索引的维护及优化（重复及冗余索引）"></a>3.4 索引的维护及优化（重复及冗余索引）</h4><p>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引</p><ul><li>重复索引：重复索引是指相同的列以相同的顺序建立的同类型的索引，如在primary key再建立唯一索引就是重复索引</li><li>冗余索引：冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，如对于innodb来说，每一个索引后面，实际上都会包含主键，这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。</li><li>工具：使用<strong><code>pt-duplicate-key-checker</code>工具检查重复及冗余索引</strong>: <code>pt-duplicate-key-checker -uroot -padmin -h 127.0.0.1</code></li><li>索引维护的方法: 由于业务变更，某些索引是后续不需要使用的，就要进行<strong>删除</strong>。</li><li>在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；<code>pt-index-usage -uroot -padmin /var/lib/mysql/mysql-host-slow.log</code></li></ul><h4 id="3-5-设计MySql索引的注意事项"><a href="#3-5-设计MySql索引的注意事项" class="headerlink" title="3.5 设计MySql索引的注意事项"></a>3.5 设计MySql索引的注意事项</h4><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p><ol><li><strong>创建索引</strong><ul><li>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。</li><li>但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</li></ul></li><li><strong>复合索引</strong><ul><li>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;</li><li>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为<strong>最佳左前缀特性</strong>。</li><li>因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</li></ul></li><li>索引不会包含有NULL值的列<ul><li>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有<strong>NULL值</strong>，那么这一列对于此复合索引就是<strong>无效</strong>的。所以我们在数据库设计时不要让字段的默认值为NULL。</li></ul></li><li>使用短索引<ul><li>对字符串列进行索引，如果可能应该<strong>指定一个前缀长度</strong>。</li><li>例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li></ul></li><li>排序的索引问题<ul><li>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列<strong>创建复合索引</strong>。</li></ul></li><li>like语句操作<ul><li>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” <strong>不会使用索引</strong>，而like “aaa%”可以使用索引。</li></ul></li><li>不要在列上进行运算<ul><li>select * from users where YEAR(adddate)</li></ul></li><li>不使用NOT IN操作<ul><li>NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以<strong>NOT EXISTS代替</strong></li></ul></li></ol><h3 id="4-MYSQL数据库设计规范与原则"><a href="#4-MYSQL数据库设计规范与原则" class="headerlink" title="4. MYSQL数据库设计规范与原则"></a>4. MYSQL数据库设计规范与原则</h3><h4 id="4-1-设计规范"><a href="#4-1-设计规范" class="headerlink" title="4.1 设计规范"></a>4.1 设计规范</h4><ol><li>命名规范<ul><li>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成</li><li>命名简洁明确,多个单词用下划线’_’分隔,长度不超过30个字符</li><li>除非是备份数据库可以加0-9的自然数,如：<code>&#39;user_db_20191210&#39;</code></li><li>表前缀可以有效的把相同关系的表显示在一起,如：<code>&#39;user_&#39;</code></li><li>每个表中必须有自增主键</li><li>表与表之间的相关联字段名称要求尽可能的相同</li></ul></li><li>字段类型规范<ul><li>用尽量少的存储空间来存数一个字段的数据, 例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);</li><li>IP地址最好使用int类型;</li><li>固定长度的类型最好使用char,例如：邮编;</li><li>能使用tinyint就不要使用smallint,int;</li><li>最好给每个字段一个默认值, 最好不能为null;</li></ul></li><li>索引规范<ul><li>命名简洁明确,例如：<code>user_login</code>表<code>user_name</code>字段的索引应为<code>user_name_index</code>唯一索引;</li><li>为每个表创建一个主键索引;</li><li>为每个表创建合理的索引;</li><li>建立复合索引请<strong>慎重</strong>;</li></ul></li></ol><h4 id="4-2-设计原则"><a href="#4-2-设计原则" class="headerlink" title="4.2 设计原则"></a>4.2 设计原则</h4><ol><li>核心原则<ul><li>不在数据库做运算;</li><li>cpu计算务必移至业务层;</li><li>控制列数量(字段少而精,字段数建议在20以内);</li><li>平衡范式与冗余(效率优先；往往牺牲范式)</li><li>拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch); </li></ul></li><li>字段类原则<ul><li>用好数值类型(用合适的字段类型节约空间);</li><li>字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);</li><li>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);</li><li>少用text类型(尽量使用varchar代替text字段); </li></ul></li><li>索引类原则<ul><li>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);</li><li>字符字段必须建前缀索引;</li><li>不在索引做列运算;</li><li>innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);</li><li>不用外键(由程序保证约束);</li></ul></li><li>sql类原则<ul><li>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);</li><li>简单的事务;</li><li>避免使用trig/func(触发器、函数不用客户端程序取而代之);</li><li>不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);</li><li>OR改写为IN(or的效率是n级别);</li><li>OR改写为UNION(mysql的索引合并很弱智);</li><li>避免负向%;</li><li>慎用count(*);</li><li>limit高效分页(limit越大，效率越低);</li><li>使用union all替代union(union有去重开销);</li><li>少用连接join;</li><li>使用group by;</li><li>请使用同类型比较;</li><li>打散批量更新;</li></ul></li></ol><h3 id="5-数据库结构的优化"><a href="#5-数据库结构的优化" class="headerlink" title="5. 数据库结构的优化"></a>5. 数据库结构的优化</h3><h4 id="5-1-选择合适的数据类型"><a href="#5-1-选择合适的数据类型" class="headerlink" title="5.1 选择合适的数据类型"></a>5.1 选择合适的数据类型</h4><p>数据类型的选择，重点在于“合适”二字</p><ol><li>使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）</li><li>使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）</li><li>尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）</li><li>尽量少用text类型，非用不可时最好考虑分表。</li></ol><h4 id="5-2-数据库表的范式化优化"><a href="#5-2-数据库表的范式化优化" class="headerlink" title="5.2 数据库表的范式化优化"></a>5.2 数据库表的范式化优化</h4><ol><li>表范式化<ul><li>范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</li></ul></li><li>反范式化<ul><li>反范式化是指为了查询效率的考虑把原本符合<strong>第三范式</strong>的表“适当”的<strong>增加冗余</strong>，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。</li></ul></li></ol><h4 id="5-3-数据库表的垂直拆分"><a href="#5-3-数据库表的垂直拆分" class="headerlink" title="5.3 数据库表的垂直拆分"></a>5.3 数据库表的垂直拆分</h4><p>所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。</p><ul><li>垂直拆分原则<ol><li>把不常用的字段表单独存放到一个表中。</li><li>把大字段独立存放到一个表中。</li><li>把经常一起使用的字段放到一起。</li></ol></li></ul><h4 id="5-4-数据库表的水平拆分"><a href="#5-4-数据库表的水平拆分" class="headerlink" title="5.4 数据库表的水平拆分"></a>5.4 数据库表的水平拆分</h4><p>表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的</p><ol><li>水平拆分原因<ul><li>如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。</li></ul></li><li>如何将数据平均分为N份<ol><li>对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。</li><li>针对不动的hashid把数据存储到不同的表中。</li></ol></li><li>水平拆分面临的挑战<ol><li>夸分区表进行数据查询<ul><li>前端业务统计：业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。</li></ul></li><li>统计及后台报表操作<ul><li>但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。</li></ul></li></ol></li></ol><h3 id="6-数据库系统配置优化"><a href="#6-数据库系统配置优化" class="headerlink" title="6. 数据库系统配置优化"></a>6. 数据库系统配置优化</h3><p>数据库是基于操作系统的，目前大多数MySQL都是安装在<strong>linux系统</strong>之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能</p><h4 id="6-1-操作系统的优化"><a href="#6-1-操作系统的优化" class="headerlink" title="6.1 操作系统的优化"></a>6.1 操作系统的优化</h4><p>网络方面的配置，要修改<code>/etc/sysctl.conf</code></p><ol><li>增加tcp支持的队列数<ul><li><code>net.ipv4.tcp_max_syn_backlog = 65535</code></li></ul></li><li>减少断开连接时，资源回收(tcp有连接状态)<ul><li><code>net.ipv4.tcp_max_tw_buckets = 8000</code></li><li><code>net.ipv4.tcp_tw_reuse = 1</code></li><li><code>net.ipv4.tcp_tw_recycle = 1</code></li><li><code>net.ipv4.tcp_fin_timeout = 10</code></li><li>说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。</li></ul></li></ol><h4 id="6-2-打开文件数的限制"><a href="#6-2-打开文件数的限制" class="headerlink" title="6.2 打开文件数的限制"></a>6.2 打开文件数的限制</h4><p>打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改<code>/etc/security/limits.conf</code>文件</p><ul><li>limits.conf中增加以下内容以修改打开文件数量的限制（永久生效）<ul><li><code>*Soft nofile 65535</code></li><li><code>*Hard nofile 65535</code></li></ul></li><li>如果一次有效，就要使用<code>ulimit –n 65535</code>即可。（默认情况是1024）</li><li>除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件</li></ul><h4 id="6-3-MySQL配置文件优化"><a href="#6-3-MySQL配置文件优化" class="headerlink" title="6.3 MySQL配置文件优化"></a>6.3 MySQL配置文件优化</h4><p>Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于<code>/etc/my.cnf</code>或<code>/etc/mysql/my.cnf</code></p><ul><li>MySQL<strong>查找配置文件的顺序</strong>可以通过以下命令获得：<ul><li><code>/usr/sbin/mysqld --verbose --help | grep -A 1 &#39;default options&#39;</code></li><li>注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。</li></ul></li></ul><h5 id="6-3-1-my-cnf常用-连接请求-参数"><a href="#6-3-1-my-cnf常用-连接请求-参数" class="headerlink" title="6.3.1 my.cnf常用 连接请求 参数"></a>6.3.1 <code>my.cnf</code>常用 连接请求 参数</h5><ol><li><code>max_connections</code>：最大连接数<ul><li>如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，MySQL会为每个连接提供连接缓冲区，连接数越多就会开销越多的内存，所以要<strong>适当调整该值</strong>，不能盲目提高设值。</li><li>数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</li><li><code>max_used_connections / max_connections * 100%</code>（<strong>理想值≈ 85%</strong>）: 响应的连接数/最大连接数</li></ul></li><li><code>back_log</code>：能暂存的连接数量<ul><li>如果MySQL的连接数据达到<code>max_connections</code>时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即<code>back_log</code>，如果等待连接的数量超过<code>back_log</code>，将不被授予连接资源。</li><li><strong>默认数值是50，可调优为128</strong>，对于Linux系统设置范围为小于512的整数。</li></ul></li><li><code>interactive_timeout</code>：服务器关闭<strong>交互式连接</strong>前等待活动的秒数<ul><li>默认数值是28800，可调优为7200。</li></ul></li><li><code>wait_timeout</code>：服务器关闭<strong>非交互连接</strong>之前等待活动的秒数<ul><li>指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</li></ul></li></ol><h5 id="6-3-1-my-cnf常用-缓冲区-参数"><a href="#6-3-1-my-cnf常用-缓冲区-参数" class="headerlink" title="6.3.1 my.cnf常用 缓冲区 参数"></a>6.3.1 <code>my.cnf</code>常用 缓冲区 参数</h5><ol><li><code>key_buffer_size</code>: 指定索引缓冲区的大小<ul><li>它决定索引处理的速度，尤其是索引读的速度。</li><li>它只对<strong>MyISAM表起作用</strong>。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值</li></ul></li><li><code>query_cache_size</code> ：查询缓存的内存<ul><li>使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。</li><li>通过检查状态值Qcache_*，可以知道<code>query_cache_size</code>设置是否合理（上述状态值可以使用<code>SHOW STATUS LIKE ‘Qcache%’</code>获得）。如果<code>Qcache_lowmem_prunes</code>的值非常大，则表明经常出现缓冲不够的情况，如果<code>Qcache_hits</code>的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果<code>Qcache_hits</code>的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入<code>SQL_NO_CACHE</code>可以明确表示不使用查询缓冲。</li><li>与查询缓冲有关的参数还有<code>query_cache_type</code>、<code>query_cache_limit</code>、<code>query_cache_min_res_unit</code>。<ul><li><code>query_cache_type</code>指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。</li><li><code>query_cache_limit</code>指定单个查询能够使用的缓冲区大小，缺省为1M。</li><li><code>query_cache_min_res_unit</code>指定分配缓冲区空间的最小单位，缺省为4K。检查状态值<code>Qcache_free_blocks</code>，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小<code>query_cache_min_res_unit</code>。</li></ul></li></ul></li><li><code>record_buffer_size</code>：顺序扫描缓冲区大小<ul><li>每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</li><li>默认数值是131072(128K)，可改为16773120 (16M)</li></ul></li><li><code>read_rnd_buffer_size</code>：随机读缓冲区大小<ul><li>当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M</li></ul></li><li><code>sort_buffer_size</code>：排序扫描缓冲区大小<ul><li>每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。</li><li>默认数值是2097144(2M)，可改为16777208 (16M)。</li></ul></li><li><code>join_buffer_size</code>：联合查询缓冲区大小<ul><li>联合查询操作所能使用的缓冲区大小。</li><li><code>record_buffer_size</code>，<code>read_rnd_buffer_size</code>，<code>sort_buffer_size</code>，<code>join_buffer_size</code>为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100</li></ul></li><li><code>table_cache</code>：表高速缓存的大小<ul><li>表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值<code>Open_tables</code>和<code>Opened_tables</code>，可以决定是否需要增加<code>table_cache</code>的值。如果你发现open_tables等于<code>table_cache</code>，并且opened_tables在不断增长，那么你就需要增加<code>table_cache</code>的值了（上述状态值可以使用<code>SHOW STATUS LIKE ‘Open%tables’</code>获得）。注意，不能盲目地把<code>table_cache</code>设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。</li><li>1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。</li></ul></li><li><code>max_heap_table_size</code>：用户可以创建的内存表(memory table)的大小<ul><li>这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#</li><li>这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。</li></ul></li><li><code>tmp_table_size</code>：临时表的大小<ul><li>通过设置<code>tmp_table_size</code>选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。</li><li>每次创建临时表，<code>Created_tmp_tables</code>增加，如果临时表大小超过<code>tmp_table_size</code>，则是在磁盘上创建临时表，<code>Created_tmp_disk_tables</code>也增加,<code>Created_tmp_files</code>表示MySQL服务创建的临时文件文件数</li><li>比较理想的配置是：<code>Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%</code>比如上面的服务器<code>Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%</code>，应该相当好了</li><li>默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞</li></ul></li><li><code>thread_cache_size</code>：可以复用的保存在中的线程的数量<ul><li>可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。</li><li>通过比较 Connections和<code>Threads_created</code>状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。</li></ul></li><li><code>thread_concurrency</code>：同一时间运行的线程系统提示所需数量的线程<ul><li>推荐设置为服务器 CPU核数的2倍，</li><li>例如双核的CPU, 那么<code>thread_concurrency</code>的应该为4；2个双核的cpu, <code>thread_concurrency</code>的值应为8。默认为8</li><li>这个参数<strong>已经在5.7.2版本的MySQL中被移除</strong></li></ul></li></ol><h5 id="6-3-1-my-cnf常用-配置InnoDB的-参数"><a href="#6-3-1-my-cnf常用-配置InnoDB的-参数" class="headerlink" title="6.3.1 my.cnf常用 配置InnoDB的 参数"></a>6.3.1 <code>my.cnf</code>常用 配置InnoDB的 参数</h5><ol><li><code>innodb_buffer_pool_size</code>：缓冲池大小<ul><li>对于InnoDB表来说，<code>innodb_buffer_pool_size</code>的作用就相当于<code>key_buffer_size</code>对于MyISAM表的作用一样。</li><li>InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。</li><li>根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。</li></ul></li><li><code>innodb_flush_log_at_trx_commit</code>：主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个<ul><li>设置为0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；</li><li>设置为1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；</li><li>设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。</li><li>实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。</li><li>根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</li></ul></li><li><code>innodb_log_buffer_size</code>：log缓存大小<ul><li>一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。</li></ul></li><li><code>innodb_additional_mem_pool_size</code>：内存池大小<ul><li>该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。</li><li>根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。</li><li><code>innodb_thread_concurrency=8</code>，推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8</li></ul></li><li><code>skip-name-resolve</code>：禁止域名解析<ul><li>禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</li><li>但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</li></ul></li></ol><h3 id="7-MySQL的执行顺序"><a href="#7-MySQL的执行顺序" class="headerlink" title="7. MySQL的执行顺序"></a>7. MySQL的执行顺序</h3><p>MySQL的语句一共分为<strong>11步</strong>，最<strong>先</strong>执行的总是<strong>FROM</strong>操作，最<strong>后</strong>执行的是<strong>LIMIT</strong>操作。</p><ul><li>其中<strong>每一个操作都会产生一张虚拟的表</strong>，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有<strong>最后一个虚拟的表才会被作为结果返回</strong>。</li><li>如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。<ul><li>⑧<code>select</code></li><li>⑨<code>distinct &lt;字段名&gt;</code></li><li>①<code>from &lt;表名&gt;</code></li><li>③<code>&lt;连接类型&gt;join &lt;表名&gt;</code></li><li>②<code>on&lt;连接条件&gt;</code></li><li>④<code>where&lt;查询条件&gt;</code></li><li>④<code>group by&lt;分组字段&gt;</code></li><li>⑥<code>with{cube|rollup}</code></li><li>⑦<code>having&lt;查询条件&gt;</code></li><li>⑩<code>order by&lt;排序字段&gt;</code></li><li>⑪<code>limit&lt;分页数量&gt;</code></li></ul></li></ul><p>查询处理的每一个阶段分析：</p><ol><li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算<strong>笛卡尔积</strong>。产生虚表VT1</li><li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<code>&lt;连接条件&gt;</code>的行才会被记录在虚表VT2中。</li><li><strong>JOIN</strong>：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li><li><strong>WHERE</strong>：对虚拟表VT3进行WHERE条件过滤。只有符合<code>&lt;where查询条件&gt;</code>的记录才会被插入到虚拟表VT4中。</li><li><strong>GROUP BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li><li><strong>CUBE | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li><li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<code>&lt;having查询条件&gt;</code>的记录才会被 插入到虚拟表VT7中。</li></ol><h3 id="8-MySQL执行引擎"><a href="#8-MySQL执行引擎" class="headerlink" title="8. MySQL执行引擎"></a>8. MySQL执行引擎</h3><h4 id="8-1-MyISAM存储引擎"><a href="#8-1-MyISAM存储引擎" class="headerlink" title="8.1 MyISAM存储引擎"></a>8.1 MyISAM存储引擎</h4><ul><li><strong>不支持事务、也不支持外键</strong>，优势是<strong>访问速度快</strong>，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表</li><li>支持3种不同的存储格式，分别是：静态表；动态表；压缩表</li><li>静态表：<ul><li>表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</li></ul></li><li>动态表：<ul><li>记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</li></ul></li><li>压缩表：<ul><li>因为每个记录是被单独压缩的，所以只有非常小的访问开支</li></ul></li></ul><h4 id="8-2-InnoDB存储引擎"><a href="#8-2-InnoDB存储引擎" class="headerlink" title="8.2 InnoDB存储引擎"></a>8.2 InnoDB存储引擎</h4><ul><li>提供了具有提交、回滚和崩溃恢复能力的<strong>事务安全</strong>。但是对比MyISAM引擎，<strong>写的处理效率会差一些</strong>，并且会占用更多的磁盘空间以保留数据和索引。 </li><li>InnoDB存储引擎的特点：<strong>支持自动增长列，支持外键约束</strong></li></ul><h4 id="8-3-MEMORY存储引擎"><a href="#8-3-MEMORY存储引擎" class="headerlink" title="8.3 MEMORY存储引擎"></a>8.3 MEMORY存储引擎</h4><ul><li>Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且<strong>默认使用HASH索引</strong>，但是<strong>一旦服务关闭，表中的数据就会丢失掉</strong>。 </li><li>MEMORY存储引擎的表可以选择使用<strong>BTREE索引</strong>或者<strong>HASH索引</strong>，两种不同类型的索引有其不同的使用范围</li><li>Hash索引优点： <ul><li>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 </li></ul></li><li>Hash索引缺点： <ul><li>那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；</li></ul></li><li>Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。</li></ul><h4 id="8-4-MERGE存储引擎"><a href="#8-4-MERGE存储引擎" class="headerlink" title="8.4 MERGE存储引擎"></a>8.4 MERGE存储引擎</h4><ul><li>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-MySQL基础操作&quot;&gt;&lt;a href=&quot;#1-MySQL基础操作&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL基础操作&quot;&gt;&lt;/a&gt;1. MySQL基础操作&lt;/h3&gt;&lt;h4 id=&quot;1-1-MySQL备份与恢复&quot;&gt;&lt;a href=&quot;#1-1-MySQL备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;1.1 MySQL备份与恢复&quot;&gt;&lt;/a&gt;1.1 MySQL备份与恢复&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;备份：在mysql的安装目录的bin目录下有&lt;strong&gt;mysqldump命令&lt;/strong&gt;，可以完成对数据库的备份。 &lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;mysqldump -u 用户名 -p 数据库名&amp;gt; 磁盘SQL文件路径&lt;/code&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库优化】MySQL慢日志查询分析</title>
    <link href="http://chaooo.github.io/article/20190829.html"/>
    <id>http://chaooo.github.io/article/20190829.html</id>
    <published>2019-08-28T16:26:43.000Z</published>
    <updated>2019-11-01T13:30:10.494Z</updated>
    
    <content type="html"><![CDATA[<p>同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。<a id="more"></a></p><ul><li>错误日志：记录启动、运行或停止mysqld时出现的问题。</li><li>通用日志：记录建立的客户端连接和执行的语句。</li><li>更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。</li><li>二进制日志：记录所有更改数据的语句。还用于复制。</li><li>慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询</li><li>Innodb日志：InnoDB redo log(记录了事务的行为，可以很好的通过其对页进行“重做”操作)</li></ul><h3 id="1-开启慢查询日志"><a href="#1-开启慢查询日志" class="headerlink" title="1. 开启慢查询日志"></a>1. 开启慢查询日志</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。<br>通过<code>show variables like &#39;slow_query%&#39;;</code>查询是否开了慢查询(默认禁用OFF)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%slow_query_log%';</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br><span class="line">| Variable_name       | Value                                                |</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br><span class="line">| slow_query_log      | OFF                                                  |</span><br><span class="line">| slow_query_log_file | D:\mysql-5.7.27-winx64\data\DESKTOP-E9F062A-slow.log |</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><blockquote><p><code>slow_query_log</code> 慢查询开启状态  OFF 未开启 ON 为开启<br><code>slow_query_log_file</code> 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</p></blockquote><p>开启慢查询，需要设置<code>slow_query_log</code>参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log = 1; //设置开启或者关闭，0为关闭，1为开启</span><br><span class="line">mysql&gt; set global long_query_time = 3;  //设置慢的阙值时间，默认10秒</span><br></pre></td></tr></table></figure><blockquote><p>如果通过终端命令设定的话，需要重新连接或新开一个会话才能看到修改值</p></blockquote><p>使用set global slow_query_log 命令开启慢查询日志，只对当前数据库生效，如果Mysql重启后则会失效。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1 <span class="comment">#开启</span></span><br><span class="line">slow_query_log_file = /mysql-5.7.27-winx64/data/mysql-slow.log <span class="comment">#默认host_name_show.log</span></span><br><span class="line">long_query_time = 3 <span class="comment">#默认10秒（查询超过多少秒才记录）</span></span><br><span class="line">log-queries-not-using-indexes = on <span class="comment">#如果值设置为ON，则会记录所有没有利用索引的查询，一般在性能调优的时候会暂时开启。</span></span><br><span class="line">log_output = 'FILE,TABLE' <span class="comment">#输出的格式(FILE:文本, TABLE:表中, FILE,TABLE:同时输出到文本和表中)</span></span><br></pre></td></tr></table></figure><p>插入一条测试慢查询</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(5);</span><br></pre></td></tr></table></figure><p>通过MySQL命令查看有多少慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like '%Slow_queries%';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Slow_queries  | 1     |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="2-慢查询日志分析工具"><a href="#2-慢查询日志分析工具" class="headerlink" title="2. 慢查询日志分析工具"></a>2. 慢查询日志分析工具</h3><table><thead><tr><th>工具</th><th>一般统计</th><th>高级统计</th><th>语言</th><th>优势</th><th>针对log</th></tr></thead><tbody><tr><td>mysqldumpslow</td><td><code>√</code></td><td><code>×</code></td><td>perl</td><td>mysql官方自带</td><td>slow</td></tr><tr><td>myprofi</td><td><code>√</code></td><td><code>×</code></td><td>php</td><td>简单</td><td>slow</td></tr><tr><td>mysql-log-filter</td><td><code>√</code></td><td>部分<code>√</code></td><td>python</td><td>简单</td><td>slow</td></tr><tr><td>mysql-explain-slow-log</td><td><code>√</code></td><td><code>×</code></td><td>perl</td><td>无</td><td>slow</td></tr><tr><td>mysqlbinlog</td><td><code>√</code></td><td><code>×</code></td><td>二进制</td><td>mysql官方自带</td><td>binary log</td></tr><tr><td>mysqlsla</td><td><code>√</code></td><td><code>√</code></td><td>perl</td><td>总能强大，使用简单，自定义能力强</td><td>所有日志，包括自定义日志</td></tr><tr><td>pt-query-digest</td><td><code>√</code></td><td><code>√</code></td><td>perl</td><td>总能强大，使用简单，自定义能力强</td><td>所有日志，包括自定义日志</td></tr></tbody></table><h4 id="2-1-mysqldumpslow"><a href="#2-1-mysqldumpslow" class="headerlink" title="2.1 mysqldumpslow"></a>2.1 mysqldumpslow</h4><ul><li>MySQL自带的慢查询日志分析工具mysqldumpslow主要功能是, 统计不同慢sql的:<ul><li>出现次数(Count),</li><li>执行最长时间(Time), </li><li>累计总耗费时间(Time),</li><li>等待锁的时间(Lock), </li><li>发送给客户端的行总数(Rows),</li><li>扫描的行总数(Rows), </li><li>用户以及sql语句本身(抽象了一下格式, 比如 limit 1, 20 用 limit N,N 表示).<br>安装后基本使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log  //得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /data/mysql/mysql-slow.log //得到访问次数最多的10个SQL </span><br><span class="line">mysqldumpslow -s t -t 10 -g "left join" /data/mysql/mysql-slow.log  //得到按照时间排序的前10条里面含有做了连接的查询SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log | more  //另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-2-mysqlsla"><a href="#2-2-mysqlsla" class="headerlink" title="2.2 mysqlsla"></a>2.2 mysqlsla</h4><p>hackmysql.com推出的一款日志分析工具(该网站还维护了 mysqlreport, mysqlidxchk 等比较实用的mysql工具)</p><ul><li>整体来说, 功能非常强大. 数据报表,非常有利于分析慢查询的原因, 包括执行频率, 数据量, 查询消耗等.</li></ul><p>安装后基本使用方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlsla -lt slow -sort t_sum -top 1000  /tmp/slow_query.log</span><br></pre></td></tr></table></figure><ul><li>结果选项说明：<ul><li>总查询次数 (queries total),</li><li>去重后的sql数量 (unique),</li><li>输出报表的内容排序(sorted by),</li><li>最重大的慢sql统计信息(包括 平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数)</li><li>Count, sql的执行次数及占总的slow log数量的百分比.</li><li>Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.</li><li>95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.</li><li>Lock Time, 等待锁的时间.</li><li>95% of Lock , 95%的慢sql等待锁时间.</li><li>Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.</li><li>Rows examined, 扫描的行数量.</li><li>Database, 属于哪个数据库</li><li>Users, 哪个用户,IP, 占到所有用户执行的sql百分比</li><li>Query abstract, 抽象后的sql语句</li><li>Query sample, sql语句</li></ul></li><li>mysqlsla常用参数说明：<ol><li><code>-log-type (-lt) type logs</code>:通过这个参数来制定log的类型，主要有slow, general, binary, msl, udl,分析slow log时通过制定为slow</li><li><code>-sort</code>:t_sum:按总时间排序(默认)，c_sum:按总次数排序c_sum_p: sql语句执行次数占总执行次数的百分比。</li><li><code>-top</code>:显示sql的数量，默认是10,表示按规则取排序的前多少条</li><li><code>–statement-filter (-sf) [+-][TYPE]</code>:过滤sql语句的类型，比如select、update、drop，[TYPE] 有SELECT, CREATE, DROP, UPDATE, INSERT，例如”+SELECT,INSERT”，不出现的默认是-，即不包括。</li><li><code>-db</code>：要处理哪个库的日志：</li></ol></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举个例子，只取funsion数据库的select语句，并按照总时间排序，取前1000条数据</span></span><br><span class="line"><span class="comment"># 保存到当前目录下的 slow_query.pretty.log文件中</span></span><br><span class="line">mysqlsla -lt slow  -sort t_sum  -sf "+<span class="keyword">select</span><span class="string">"  -db funsion  -top 1000  /tmp/slow_query.log &gt; ./slow_query.pretty.log</span></span><br></pre></td></tr></table></figure><blockquote><p>深度使用可参考： <a href="https://yq.aliyun.com/articles/59260" target="_blank" rel="noopener">MySQL日志分析神器之mysqlsla</a></p></blockquote><h4 id="2-3-pt-query-digest"><a href="#2-3-pt-query-digest" class="headerlink" title="2.3 pt-query-digest"></a>2.3 pt-query-digest</h4><p>pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析最近12小时内的查询：</span></span><br><span class="line">pt-query-digest  <span class="comment">--since=12h  slow.log &gt; slow_report2.log</span></span><br></pre></td></tr></table></figure><ol><li>pt-query-digest语法及重要选项<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest [OPTIONS] [FILES] [DSN]</span><br><span class="line">    <span class="comment">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class="line">    <span class="comment">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class="line">    <span class="comment">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span></span><br><span class="line">    <span class="comment">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span></span><br><span class="line">    <span class="comment">--host  mysql服务器地址</span></span><br><span class="line">    <span class="comment">--user  mysql用户名</span></span><br><span class="line">    <span class="comment">--password  mysql用户密码</span></span><br><span class="line">    <span class="comment">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span></span><br><span class="line">    <span class="comment">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span></span><br><span class="line">    <span class="comment">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span></span><br><span class="line">    <span class="comment">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span></span><br><span class="line">    <span class="comment">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span></span><br></pre></td></tr></table></figure></li></ol><p>分析pt-query-digest输出结果</p><ol><li>总体统计结果<ul><li>Overall：总共有多少条查询</li><li>Time range：查询执行的时间范围</li><li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li><li>total：总计   min：最小   max：最大  avg：平均</li><li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li><li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li></ul></li><li>查询分组统计结果<ul><li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li><li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li><li>Response：总的响应时间</li><li>time：该查询在本次分析中总的时间占比</li><li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li><li>R/Call：平均每次执行的响应时间</li><li>V/M：响应时间Variance-to-mean的比率</li><li>Item：查询对象</li></ul></li><li>每一种查询的详细统计结果<ul><li>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</li><li>ID：查询的ID号，和上图的Query ID对应</li><li>Databases：数据库名</li><li>Users：各个用户执行的次数（占比）</li><li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li><li>Tables：查询中涉及到的表</li><li>Explain：SQL语句</li></ul></li></ol><h3 id="3-explain查看执行计划"><a href="#3-explain查看执行计划" class="headerlink" title="3. explain查看执行计划"></a>3. explain查看执行计划</h3><p>在上面的慢查询中，我们已经将查询时间超过阀值的sql语句过滤了出来，<code>explain+查询语句</code>具体分析是哪里出了问题。<br>MySQL 提供了一个 <code>Explain</code> 命令, 它可以对 select 语句进行分析, 并输出 select 执行的详细信息, 以供开发人员针对性优化.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure><ol><li><p>各列的含义如下:</p><ul><li><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li><code>select_type</code>: SELECT 查询的类型.<ul><li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY, 表示此查询是最外层的查询</li><li>UNION, 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>SUBQUERY, 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><code>table</code>: 查询的是哪个表</li><li><code>partitions</code>: 匹配的分区</li><li><code>type</code>: join 类型<ul><li>type字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过<code>type</code>字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</li><li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li><li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li><li>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. </li><li>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.</li><li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li><li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li><li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难.</li></ul></li><li><code>possible_keys</code>: 此次查询中可能选用的索引<ul><li>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</li></ul></li><li><code>key</code>: 此字段是 MySQL 在当前查询时所真正使用到的索引.</li><li><code>key_len</code>: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</li><li><code>ref</code>: 哪个字段或常数与 key 一起被使用</li><li><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.<ul><li>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数, 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</li></ul></li><li><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</li><li><code>extra</code>: EXplain 中的很多额外的信息会在 Extra 字段显示<ul><li>Using filesort: 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li><li>Using index: “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li>Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ul></li></ul></li><li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:</p></li></ol><ul><li><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><ul><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</li></ul></li></ul><h3 id="4-MySQL性能分析语句show-profile"><a href="#4-MySQL性能分析语句show-profile" class="headerlink" title="4. MySQL性能分析语句show profile"></a>4. MySQL性能分析语句show profile</h3><p>Query Profile是MySQL自带的一种Query诊断分析工具，可以完整的显示一条sql执行的各方面的详细信息，默认关闭;</p><ol><li><p>看看当前的MySQL版本是否支持: <code>show variables like &#39;profiling&#39;;</code>或<code>show variables like &#39;profiling%&#39;;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'profiling%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>使用前需要开启: <code>set profiling = 1; (1:开 / 0:关)</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling = 1;</span><br></pre></td></tr></table></figure></li><li><p><strong>运行sql后</strong>，查询结果<code>show profiles;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILES\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Query_ID: 1</span><br><span class="line">Duration: 0.02949950</span><br><span class="line">   Query: <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">2</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.03405350</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">select</span> * <span class="keyword">from</span> housedemo</span><br><span class="line">*************************** <span class="number">3.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">3</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.07813800</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">select</span> * <span class="keyword">from</span> house</span><br><span class="line">*************************** <span class="number">4.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">4</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.00018150</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">show</span> prifiles</span><br></pre></td></tr></table></figure></li><li><p>诊断SQL, show profile <code>Type</code> io for query <code>Query_ID</code></p><ul><li>LIMIT部分的用法与SELECT中LIMIT子句一致，不赘述。</li><li>Type是可选的，取值范围可以如下：<ul><li><code>ALL</code> 显示所有性能信息</li><li><code>BLOCK IO</code> 显示块IO操作的次数</li><li><code>CONTEXT SWITCHES</code> 显示上下文切换次数，不管是主动还是被动</li><li><code>CPU</code> 显示用户CPU时间、系统CPU时间</li><li><code>IPC</code> 显示发送和接收的消息数量</li><li><code>MEMORY</code> [暂未实现]</li><li><code>PAGE FAULTS</code> 显示页错误数量</li><li><code>SOURCE</code> 显示源码中的函数名称与位置</li><li><code>SWAPS</code> 显示SWAP的次数</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 3;</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line">| starting             | 0.000077 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| checking permissions | 0.000013 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| Opening tables       | 0.031992 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| init                 | 0.000059 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| System <span class="keyword">lock</span>          | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| optimizing           | <span class="number">0.000007</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">statistics</span>           | <span class="number">0.000017</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| preparing            | <span class="number">0.008535</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| executing            | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>         | <span class="number">0.037234</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">end</span>                  | <span class="number">0.000011</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>            | <span class="number">0.000012</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| closing <span class="keyword">tables</span>       | <span class="number">0.000014</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000108</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000030</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br></pre></td></tr></table></figure><p>从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理的你工作，在这完全可以看到一条SQL的完整生命周期。</p><ol start="5"><li>日常开发需要注意<ul><li>如果show profile … for query id；出现了如下四个，则必须优化这条sql。<ol><li><code>converting HEAP to MyISAM</code> 查询结果太大， 内存都不够用了网磁盘上搬了</li><li><code>Creating tmp table</code> 创建临时表</li><li>拷贝数据到临时表：假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这个时候就是导致SQL变慢的罪魁祸首</li><li>用完再删除</li><li><code>Copying to tmp table on disk</code> 把内存中临时表复制到磁盘，危险！！！</li><li><code>locked</code></li></ol></li></ul></li></ol><h3 id="5-全局查询日志"><a href="#5-全局查询日志" class="headerlink" title="5. 全局查询日志"></a>5. 全局查询日志</h3><p>切记：<strong>永远不要再生产环境开启这个功能</strong>。<br>全局查询日志有时也能帮助我们来调SQL。但是，切记，这家伙只能在测试环境使用，绝不可以在生产环境使用。</p><ol><li><p>命令启用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global general_log=1; #开启后会把所有的SQL偷偷的记录</span><br><span class="line">mysql&gt; set global log_output='TABLE';</span><br></pre></td></tr></table></figure></li><li><p>配置启用,  在MySQL的my.cnf中，设置如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启</span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment">#记录日志文件的路径</span></span><br><span class="line">general_log_file=/path/logfile</span><br><span class="line"><span class="comment">#输出格式</span></span><br><span class="line">log_output=file</span><br></pre></td></tr></table></figure></li><li><p>此后，你所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mysql.general_log;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>场景：如果需要做系统的定案分析(今天下午2点-3点出的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。那么用general_log这个表来收集什么时间段发生了什么样的SQL，帮助我们定位收集。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】深入JVM(三)-内存模型JMM 与 锁机制</title>
    <link href="http://chaooo.github.io/article/20190827.html"/>
    <id>http://chaooo.github.io/article/20190827.html</id>
    <published>2019-08-27T09:30:45.000Z</published>
    <updated>2019-10-30T12:43:40.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型-Java-Memory-Model"><a href="#Java内存模型-Java-Memory-Model" class="headerlink" title="Java内存模型(Java Memory Model)"></a>Java内存模型(Java Memory Model)</h3><p>Java Memory Model(JMM)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节(可见性,有序性,原子性)。</p><ul><li>所有的变量都存储在主内存中</li><li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li><li>JMM规定：<ul><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。<a id="more"></a></li></ul></li></ul><p><img src="http://cdn.chaooo.top/Java/JMM.png" alt></p><h3 id="1-JMM-同步八种操作"><a href="#1-JMM-同步八种操作" class="headerlink" title="1. JMM-同步八种操作"></a>1. JMM-同步八种操作</h3><p>JMM模型下,线程间通信必须要经过主内存。<br>JMM数据原子操作:<code>lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock</code></p><ol><li><strong>lock</strong>（锁定）：将<strong>主内存</strong>变量加锁，标识为线程独占状态</li><li><strong>read</strong>（读取）：从<strong>主内存</strong>读取数据到工作内存</li><li><strong>load</strong>（载入）：将读取的数据写入<strong>工作内存</strong></li><li><strong>use</strong>（使用）：将<strong>工作内存</strong>数据传递给执行引擎来计算</li><li><strong>assign</strong>（赋值）：将计算好的值赋值给<strong>工作内存</strong>的变量</li><li><strong>store</strong>（存储）：把<strong>工作内存</strong>数据存储到主内存</li><li><strong>write</strong>（写入）：把store过来的变量值赋值给<strong>主内存</strong>的变量</li><li><strong>unlock</strong>（解锁）：将<strong>主内存</strong>变量解锁，释放后的变量才可以被其他线程锁定。</li></ol><p>在执行上述八种基本操作时，必须满足如下规则：</p><ol><li>从主复制到工作,必须按顺序执行<code>read-&gt;load</code>操作; 从工作同步到主内存,必须按顺序执行<code>store-&gt;write</code>操作; 但不保证必须是连续执行</li><li>不允许<code>read-&gt;load</code>、<code>store-&gt;write</code>操作之一单独出现</li><li>assign操作改变数据后必须同步到主内存,不允许把没有发生过assign操作的数据同步到主内存</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作,lock和unlock必须成对出现</li><li>lock操作会清空工作内存中此变量的值，执行引擎使用前需要重新执行load或assign操作初始化变量的值</li><li>不允许去unlock一个未被锁定 或 被其他线程锁定的变量</li><li>unlock之前，必须先同步到主内存中（执行store和write操作）</li></ol><h3 id="2-JMM-原子性"><a href="#2-JMM-原子性" class="headerlink" title="2. JMM-原子性"></a>2. JMM-原子性</h3><p>和数据库事务中的原子性一样，满足原子性特性的操作是不可中断的，要么全部执行成功要么全部执行失败。<br>Synchronized能够实现：<strong>原子性</strong>(同步) 和 可见性</p><ul><li>JMM关于synchronized的两条规定：<ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li></ol></li><li>线程执行互斥代码的过程：<ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存</li><li>执行代码</li><li>将更改后的共享变量的值刷新到主内存</li><li>释放互斥锁</li></ol></li></ul><h3 id="2-JMM-可见性"><a href="#2-JMM-可见性" class="headerlink" title="2. JMM-可见性"></a>2. JMM-可见性</h3><p>多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值。<br>volatile能够实现<strong>可见性</strong>，但不保证原子性</p><ul><li><p>深入来说：通过加入内存屏障和禁止重排序优化来实现的。</p><ul><li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li><li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li></ul></li><li><p>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</p></li><li><p>线程写volatile变量的过程：</p><ol><li>改变线程工作内存中volatile变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ol></li><li><p>线程读volatile变量的过程：</p><ol><li>从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ol></li></ul><h4 id="2-1-happens-before规则"><a href="#2-1-happens-before规则" class="headerlink" title="2.1 happens-before规则"></a>2.1 happens-before规则</h4><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这2个操作之间必须要存在happens-before关系。</p><ul><li>定义: 如果一个操作在另一个操作之前发生(happens-before),那么第一个操作的执行结果将对第二个操作可见, 而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><ul><li>happens-before规则：<ol><li>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；论是单线程还是多线程，必须要先释放锁，然后其他线程才能进行lock操作</li><li>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见</li><li>线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断</li><li>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</li></ol></li></ul><h3 id="3-JMM-有序性"><a href="#3-JMM-有序性" class="headerlink" title="3. JMM-有序性"></a>3. JMM-有序性</h3><p>编译器和处理器为了优化程序性能而对指令序列进行重排序，也就是你编写的代码顺序和最终执行的指令顺序是不一致的，重排序可能会导致多线程程序出现内存可见性问题。</p><ul><li>我们编写的源代码到最终执行的指令，会经过三种重排序:<ul><li>源代码–&gt;<strong>编译器优化重排序</strong>–&gt;<strong>指令级并行重排序</strong>–&gt;<strong>内存系统重排序</strong>–&gt;最终执行的指令</li></ul></li></ul><h4 id="3-1-as-if-serial语义"><a href="#3-1-as-if-serial语义" class="headerlink" title="3.1 as-if-serial语义"></a>3.1 as-if-serial语义</h4><p>as-if-serial语义：不管怎么重排序(编译器和处理器为了提高并行度做的优化),(单线程)程序的执行结果不会改变。编译器、runtime和处理器都必须遵守as-if-serial语义。<br>多线程中程序交错执行时, 重排序可能造成内存可见性问题, 可能会改变程序的执行结果。</p><ul><li><p>有序性规则表现在以下两种场景: 线程内和线程间</p><ol><li>线程内: 指令会按照一种“串行”(as-if-serial)的方式执行，此种方式已经应用于顺序编程语言。</li><li>线程间: 一个线程“观察”到其他线程并发地执行非同步的代码时，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块以及volatile字段的操作仍维持相对有序。</li></ol></li><li><p>As-if-serial只是保障单线程不会出问题，所以有序性保障，可以理解为把As-if-serial扩展到多线程，那么在多线程中也不会出现问题</p><ul><li>从底层的角度来看，是借助于处理器提供的相关指令内存屏障来实现的</li><li>对于Java语言本身来说，Java已经帮我们与底层打交道，我们不会直接接触内存屏障指令，java提供的关键字synchronized和volatile，可以达到这个效果，保障有序性（借助于显式锁Lock也是一样的，Lock逻辑与synchronized一致）</li></ul></li></ul><h4 id="3-2-著名的双检锁-double-checked-locking-模式实现单例"><a href="#3-2-著名的双检锁-double-checked-locking-模式实现单例" class="headerlink" title="3.2 著名的双检锁(double-checked locking)模式实现单例"></a>3.2 著名的双检锁(double-checked locking)模式实现单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile保证happens-before规则,重排序被禁止</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例没创建,才进入内部的synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 判断其他线程是否已经创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不用volatile修饰INSTANCE,可能造成访问的是一个初始化未完成的对象; 使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。</p></blockquote><h3 id="4-锁机制"><a href="#4-锁机制" class="headerlink" title="4. 锁机制"></a>4. 锁机制</h3><ul><li>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是<strong>锁的升级是单向的</strong>，也就是说只能从低到高升级，不会出现锁的降级）。</li><li>锁的状态是通过对象监视器在<strong>对象头</strong>中的字段来表明的。 四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。 这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(<strong>使用synchronized时</strong>)。</li></ul><h4 id="4-1-对象头Mark"><a href="#4-1-对象头Mark" class="headerlink" title="4.1 对象头Mark"></a>4.1 对象头Mark</h4><ul><li>Mark Word,对象头的标记,32位: 描述对象的hash,锁信息,垃圾回收标记,分代年龄<ul><li>指向锁记录的指针</li><li>指向monitor的指针</li><li>GC标记</li><li>偏向锁线程ID</li></ul></li></ul><h4 id="4-2-偏向锁"><a href="#4-2-偏向锁" class="headerlink" title="4.2 偏向锁"></a>4.2 偏向锁</h4><p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优</p><ul><li>大部分情况锁是没有竞争的,所以可以通过偏向锁来提高性能; </li><li>所谓偏向,就是偏心,即锁会偏向于当前已经占有锁的线程,总是由同一线程多次获得; </li><li>会在对象头和栈帧中的锁记录里存储锁偏向的线程ID</li><li>只要没有竞争,获得偏向锁的线程,在将来进入同步块,不需要做同步</li><li>当其他线程请求相同的锁时,偏向模式结束</li><li>-XX:+UseBiasedLocking(默认开启)</li><li>在竞争激烈的场合,偏向锁会增加系统负担</li></ul><h4 id="4-3-轻量级锁"><a href="#4-3-轻量级锁" class="headerlink" title="4.3 轻量级锁"></a>4.3 轻量级锁</h4><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><ul><li>普通的锁处理性能不够理想,轻量级锁是一种快速的锁定方法.</li><li>过程: 如果对象没有被锁定:<ol><li>将对象头的Mark指针保存到锁对象中</li><li>将对象头设置为指向锁的指针(在线程栈空间中)</li></ol></li><li>如果轻量级锁失败,表示存在竞争,升级为重量级锁(常规锁)</li><li>在没有锁竞争的情况下,减少传统锁使用OS互斥量产生的性能损耗</li><li>在竞争激烈的场合,轻量级锁会多做很多额外操作,导致性能下降</li></ul><h4 id="4-4-自旋锁"><a href="#4-4-自旋锁" class="headerlink" title="4.4 自旋锁"></a>4.4 自旋锁</h4><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><ul><li>当竞争存在时,如果线程可以很快获得锁,那么可以不在OS层挂起线程,让线程做几个空操作(自旋)</li><li>如果同步块很长,自旋失败,会降低系统性能</li><li>如果同步块很短,自旋成功,节省线程挂起切换时间,提升系统性能</li></ul><h4 id="4-5-重量级锁"><a href="#4-5-重量级锁" class="headerlink" title="4.5 重量级锁"></a>4.5 重量级锁</h4><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h4 id="4-6-synchronized的执行过程："><a href="#4-6-synchronized的执行过程：" class="headerlink" title="4.6 synchronized的执行过程："></a>4.6 synchronized的执行过程：</h4><ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li><li>如果自旋成功则依然处于轻量级状态。</li><li>如果自旋失败，则升级为重量级锁。</li></ol><blockquote><p>以上几种锁都是JVM自己内部实现，当我们执行synchronized同步块的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；</p></blockquote><h3 id="5-Java语言层面对锁的优化"><a href="#5-Java语言层面对锁的优化" class="headerlink" title="5. Java语言层面对锁的优化"></a>5. Java语言层面对锁的优化</h3><ol><li><strong>减少锁持有时间</strong><ul><li>不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</li></ul></li><li><strong>减少锁的粒度</strong><ul><li>它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；</li><li>java中很多数据结构都是采用这种方法提高并发操作的效率：<ul><li>ConcurrentHashMap: 使用Segment数组,Segment继承自ReenTrantLock，所以每个Segment就是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</li><li>LongAdder:实现思路也类似ConcurrentHashMap，LongAdder有一个根据当前并发状况动态改变的Cell数组，Cell对象里面有一个long类型的value用来存储值;开始没有并发争用的时候或者是cells数组正在初始化的时候，会使用cas来将值累加到成员变量的base上，在并发争用的情况下，LongAdder会初始化cells数组，在Cell数组中选定一个Cell加锁，数组有多少个cell，就允许同时有多少线程进行修改，最后将数组中每个Cell中的value相加，在加上base的值，就是最终的值；cell数组还能根据当前线程争用情况进行扩容，初始长度为2，每次扩容会增长一倍，直到扩容到大于等于cpu数量就不再扩容，这也就是为什么LongAdder比cas和AtomicInteger效率要高的原因，后面两者都是volatile+cas实现的，他们的竞争维度是1，LongAdder的竞争维度为“Cell个数+1”为什么要+1？因为它还有一个base，如果竞争不到锁还会尝试将数值加到base上；</li></ul></li><li>拆锁的粒度不能无限拆，最多可以将一个锁拆为当前CPU数量即可；</li></ul></li><li><strong>锁粗化</strong><ul><li>大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度(如:循环内的操作);</li></ul></li><li><strong>锁分离</strong><ul><li>使用读写锁: ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写；</li><li>读写分离: CopyOnWriteArrayList 、CopyOnWriteArraySet<ul><li>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</li><li>CopyOnWrite并发容器用于读多写少的并发场景，因为，读的时候没有锁，但是对其进行更改的时候是会加锁的，否则会导致多个线程同时复制出多个副本，各自修改各自的；</li></ul></li><li>LinkedBlockingQueue: LinkedBlockingQueue也体现了这样的思想，在队列头入队，在队列尾出队，入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高；</li></ul></li><li><strong>锁消除</strong><ul><li>在即时编译时,如果发现不可能被共享的对象,则可以消除对象的锁操作</li></ul></li><li><strong>无锁</strong>(如CAS)<ul><li>如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用CAS效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+CAS操作会是非常高效的选择；</li></ul></li><li>消除缓存行的伪共享<ul><li>除了我们在代码中使用的同步锁和jvm自己内置的同步锁外，还有一种隐藏的锁就是缓存行，它也被称为性能杀手。在多核cup的处理器中，每个cup都有自己独占的一级缓存、二级缓存，甚至还有一个共享的三级缓存，为了提高性能，cpu读写数据是以缓存行为最小单元读写的；32位的cpu缓存行为32字节，64位cup的缓存行为64字节，这就导致了一些问题。</li></ul></li></ol><h3 id="6-CAS与原子类"><a href="#6-CAS与原子类" class="headerlink" title="6. CAS与原子类"></a>6. CAS与原子类</h3><p>CAS即<code>Compare and Swap</code>翻译过来就是比较并替换, 它体现了一种乐观锁的思想 (synchronized为悲观锁思想); </p><ul><li>结合CAS和volatile可以实现<strong>无锁并发</strong>(非阻塞同步),适用于竞争不激烈,多核CPU的场景下(竞争激烈,重试频繁发生会影响效率);</li><li>CAS算法涉及到三个操作数: 内存值V, 旧值A, 新值B; 当且仅当V==A时，CAS用新值B来更新V，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</li><li>CAS底层依赖一个Unsafe类来直接调用操作系统底层的CAS指令;</li></ul><h4 id="6-1-Unsafe类"><a href="#6-1-Unsafe类" class="headerlink" title="6.1 Unsafe类"></a>6.1 Unsafe类</h4><p>java中CAS操作依赖于Unsafe类，Unsafe类所有方法都是native的，直接调用操作系统底层资源执行相应任务，它可以像C一样操作内存指针，是非线程安全的。</p><ul><li>Unsafe里的CAS 操作相关实现: compareAndSwapObject,compareAndSwapInt,compareAndSwapLong<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，</span></span><br><span class="line"><span class="comment">//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">long</span> expected,<span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-原子操作类"><a href="#6-2-原子操作类" class="headerlink" title="6.2 原子操作类"></a>6.2 原子操作类</h4><p>并发包JUC(java.util.concurrent)中的原子操作类(Atomic系列),底层是基于<code>CAS + volatile</code>实现的.</p><ul><li>AtomicBoolean：原子更新布尔类型</li><li>AtomicInteger：原子更新整型</li><li>AtomicLong：原子更新长整型</li></ul><p>下面看AtomicInteger类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取指针类Unsafe    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe(); </span><br><span class="line">    <span class="comment">//省略...获取内存偏移量等</span></span><br><span class="line">    <span class="comment">//如果当前值为expect，则设置为update(当前值指的是value变量)    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//当前值加1返回旧值，底层CAS操作    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger基本是基于Unsafe类中CAS相关操作实现的，是无锁操作。<br>再看Unsafe类中的getAndAddInt()方法，该方法执行一个CAS操作，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unsafe类中的getAndAddInt方法(JDK8)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> v;        </span><br><span class="line">    <span class="keyword">do</span> &#123;            </span><br><span class="line">        v = getIntVolatile(o, offset);        </span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));        </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出getAndAddInt通过一个while循环不断的重试更新要设置的值，直到成功为止，调用的是Unsafe类中的compareAndSwapInt方法，是一个CAS操作方法。</p><h4 id="6-3-CAS操作中可能会带来的ABA问题"><a href="#6-3-CAS操作中可能会带来的ABA问题" class="headerlink" title="6.3 CAS操作中可能会带来的ABA问题"></a>6.3 CAS操作中可能会带来的ABA问题</h4><p>ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。</p><ul><li><strong>无法正确判断这个变量是否已被修改过</strong>，一般称这种情况为ABA问题。</li><li>ABA问题一般不会有太大影响，产生几率也比较小。但是并不排除极特殊场景下会造成影响，因此需要解决方法：<ul><li>AtomicStampedReference类</li><li>AtomicMarkableReference类</li></ul></li><li><strong>AtomicStampedReference类</strong>: 一个带有时间戳的对象引用，每次修改时，不但会设置新的值，还会记录修改时间。在下一次更新时，不但会对比当前值和期望值，还会对比当前时间和期望值对应的修改时间，只有二者都相同，才会做出更新。解决了反复读写时，无法预知值是否已被修改的窘境。<ul><li>底层实现为：一个键值对Pair存储数据和时间戳，并构造volatile修饰的私有实例；两者都符合预期才会调用Unsafe的compareAndSwapObject方法执行数值和时间戳替换。</li></ul></li><li>AtomicMarkableReference类: 一个boolean值的标识，true和false两种切换状态表示是否被修改。不靠谱。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java内存模型-Java-Memory-Model&quot;&gt;&lt;a href=&quot;#Java内存模型-Java-Memory-Model&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型(Java Memory Model)&quot;&gt;&lt;/a&gt;Java内存模型(Java Memory Model)&lt;/h3&gt;&lt;p&gt;Java Memory Model(JMM)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节(可见性,有序性,原子性)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的变量都存储在主内存中&lt;/li&gt;
&lt;li&gt;每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)&lt;/li&gt;
&lt;li&gt;JMM规定：&lt;ul&gt;
&lt;li&gt;线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。&lt;/li&gt;
&lt;li&gt;不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】深入JVM(二)-类文件结构 与 类加载机制</title>
    <link href="http://chaooo.github.io/article/20190825.html"/>
    <id>http://chaooo.github.io/article/20190825.html</id>
    <published>2019-08-25T11:29:48.000Z</published>
    <updated>2019-10-29T08:11:29.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h3><p>Class文件是一组以 <strong>8 位字节</strong>为基础单位的二进制流，各个数据<strong>严格按照顺序紧凑的排列</strong>在 Class 文件中，中间无任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，会按照高位在前的方式分割成若干个 8 位字节进行存储。<br>Java 虚拟机规范规定 Class 文件格式采用一种类似与 C 语言结构体的伪结构体来存储数据，这种伪结构体中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。<a id="more"></a></p><ul><li><strong>无符号数</strong>：属于基本数据类型，以u1、u2、u4、u8来代表1个字节、2个字节、4个字节、8个字节的无符号数， 无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li><strong>表</strong>：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以「_info」结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件就是一张表。</li></ul><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                <span class="comment">//Class文件的标志(魔数)</span></span><br><span class="line">    u2             minor_version;        <span class="comment">//Class的小版本号</span></span><br><span class="line">    u2             major_version;        <span class="comment">//Class的大版本号</span></span><br><span class="line">    u2             constant_pool_count;  <span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;         <span class="comment">//Class的访问标记</span></span><br><span class="line">    u2             this_class;           <span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;          <span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;     <span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;          <span class="comment">//Class文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];  <span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;         <span class="comment">//Class文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;      <span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.chaooo.top/Java/JVM-class.png" alt></p><h4 id="1-1-魔数-Magic-Number"><a href="#1-1-魔数-Magic-Number" class="headerlink" title="1.1 魔数 (Magic Number)"></a>1.1 魔数 (Magic Number)</h4><ul><li>Class文件的<strong>0~3字节</strong>(前四个字节: ca fe ba be)</li><li>作用: 确定这个文件是否为一个能被虚拟机接收的Class文件</li></ul><h4 id="1-2-Class文件版本"><a href="#1-2-Class文件版本" class="headerlink" title="1.2 Class文件版本"></a>1.2 Class文件版本</h4><ul><li><strong>4~7字节</strong>, 其中4<del>5次版本号,6</del>7主版本号(如jdk8主版本号是: 00 34)</li></ul><h4 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h4><ul><li><strong>8~9字节</strong>表示16进制常量池数量,其后紧跟具体常量池, 常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）</li><li>常量池主要存放两大常量: <strong>字面量</strong>和<strong>符号引用</strong><ul><li>字面量: Java语言层面的常量概念(String,final等)</li><li>符号引用: 编译原理方面的概念(类和接口的全限定名\字段的名称和描述符\方法的名称和描述符)</li></ul></li><li>常量池中每一项常量都是一个表，这<strong>14种表</strong>有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型</strong></li><li>.class文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)</li></ul><h4 id="1-4-类的访问标志与继承信息"><a href="#1-4-类的访问标志与继承信息" class="headerlink" title="1.4 类的访问标志与继承信息"></a>1.4 类的访问标志与继承信息</h4><ul><li>在常量池结束之后，紧接着的<strong>两个字节</strong>代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等.</li><li>access_flags中一共有16个标志位可以使用，当前只定义了其中的8个，没有使用到的标志位要求一律为0。</li></ul><h4 id="1-5-当前类索引-this-父类索引-super-与接口索引集合-interfaces"><a href="#1-5-当前类索引-this-父类索引-super-与接口索引集合-interfaces" class="headerlink" title="1.5 当前类索引(this),父类索引(super)与接口索引集合(interfaces)"></a>1.5 当前类索引(<code>this</code>),父类索引(<code>super</code>)与接口索引集合(<code>interfaces</code>)</h4><ul><li>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</li><li>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</li></ul><h4 id="1-6-成员变量信息-Feild"><a href="#1-6-成员变量信息-Feild" class="headerlink" title="1.6 成员变量信息(Feild)"></a>1.6 成员变量信息(Feild)</h4><ul><li>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li><li>字段信息包括：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称，以上修饰符都是布尔类型。</li><li>方法和字段的描述符作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</li><li>根描述规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，对象类型使用字符L加对象的全限定名来表示。<ul><li>B: 基本类型byte</li><li>C: 基本类型char</li><li>D: 基本类型double</li><li>F: 基本类型float</li><li>I: 基本类型</li><li>J: 基本类型long</li><li>S: 基本类型short</li><li>Z: 基本类型boolean</li><li>V: 特殊类型void</li><li>L: 对象类型，如Ljava/lang/Object</li></ul></li></ul><h4 id="1-7-方法信息-Method"><a href="#1-7-方法信息-Method" class="headerlink" title="1.7 方法信息(Method)"></a>1.7 方法信息(Method)</h4><ul><li><code>methods_count</code> 表示方法的数量，而 <code>method_info</code> 表示的方法表。</li><li>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</li></ul><h4 id="1-8-附加属性信息"><a href="#1-8-附加属性信息" class="headerlink" title="1.8 附加属性信息"></a>1.8 附加属性信息</h4><ul><li><code>attributes_count</code>表示属性表中的属性个数, <code>attribute_info</code> 表示属性表</li><li>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</li></ul><h3 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h3><p>Java字节码指令就是Java虚拟机能够识别、可执行的指令，可以说是Jvm的最小执行单元。javac命令会将Java源文件编译成字节码文件，即.class文件，其中就包含了大量的字节码指令，javap命令可以解析字节码(.class文件)，将字节码内部逻辑以可读的方式呈现出来 (<code>javap -v -p HelloWorld</code>)。</p><ul><li>按指令的功能分为如下几类：<ol><li><strong>存储和加载类指令</strong>：主要包括load系列(将一个局部变量加载到操作数栈)、store系列(将一个数值从操作数栈存储到局部变量表)和ldc/push/const系列(将一个常量加载到操作数栈)，主要用于在<strong>局部变量表</strong>、<strong>操作数栈</strong>和<strong>常量池</strong>三者之间进行<strong>数据调度</strong>；<ul><li>例如: <code>iload_0</code>表示从当前栈帧局部变量表中0号位置取int类型的数值加载到操作数栈</li></ul></li><li><strong>对象操作指令</strong>（创建与读写访问）：比如我们刚刚的putfield和getfield就属于读写访问的指令，此外还有putstatic/getstatic，还有new系列指令，以及instanceof等指令。</li><li><strong>操作数栈管理指令</strong>：如pop和dup，他们只对操作数栈进行操作。</li><li>类型转换指令和运算指令：如add(加)/sub(减)/mul(乘)/div(除)/l2i/d2f等系列指令，实际上这类指令一般也只对操作数栈进行操作。</li><li>控制跳转指令：这类里包含常用的if系列指令以及goto类指令。</li><li><strong>方法调用和返回指令</strong>：主要包括invoke系列指令和return系列指令。这类指令也意味这一个方法空间的开辟和结束，即invoke会唤醒一个新的java方法小宇宙（新的栈和局部变量表），而return则意味着这个宇宙的结束回收。</li></ol></li><li>从指令操作的数据类型来讲：指令开头或尾部的一些字母，就往往表明了它所能操作的数据类型：<ul><li>a对应对象，表示指令操作对象性数据，比如aload和astore、areturn等等。</li><li>i对应整形。也就有iload，istore等i系列指令。</li><li>f对应浮点型，l对应long，b对应byte，d对应double，c对应char。</li><li>ia对应int array，aa对应object array，da对应double array。</li></ul></li></ul><h3 id="3-编译期处理-语法糖"><a href="#3-编译期处理-语法糖" class="headerlink" title="3. 编译期处理(语法糖)"></a>3. 编译期处理(语法糖)</h3><p><strong>语法糖</strong>: 指Java编译器把.java源码编译为.class字节码过程中,自动生成和转换的一些代码. 如:默认构造器,自动拆装箱等.</p><ol><li><strong>默认构造器</strong>: <code>public class Candy{}</code> 编译后为: <code>public class Candy{public Candy(){super();}}</code> </li><li><strong>自动拆装箱</strong>: <code>Integer x=1;int y=x;</code> 编译后为: <code>Integer x=Integer.valueOf(1);int y=x.intValue();</code></li><li><strong>泛型擦除</strong>: 擦除的是字节码上的泛型信息.</li><li><strong>泛型反射</strong>: 通过反射获得泛型信息</li><li><strong>可变参数</strong>: <code>String... args</code> 可以是一个<code>String[] args</code></li><li><strong>foreach</strong>: 集合相当于获取迭代器Iterator</li><li><strong>switch</strong>: Jdk7开始可以配合String和枚举<ul><li>switch-String: 执行了两遍switch,第一遍根据字符串的hashCode和equals将字符串转换为相应的byte类型,第二遍利用byte执行比较.</li><li>switch-枚举: 会为当前类生成一个静态内部类(合成类,仅JVM使用,对我们不可见),用来映射枚举类的枚举编号(从0开始)与数组元素的关系,数组大小即为枚举元素的个数,里面存储case用来对比的数字,根据这个数字执行switch</li></ul></li><li><strong>枚举类</strong>: 继承Enum并且用final修饰类,构造方法私有,枚举量被编译成本类的final类变量,定义私有静态枚举量数组$VALUES,静态方法values()用来返回定义的枚举量数组的clone(),静态方法valueOf()调用父类valueOf(本类.class,名称)根据类型和名称得到相应实例</li><li><strong>try-with-resources</strong>: 无论try块的异常还是关闭资源时的异常都不会丢。可以在 try-with-resources 语句中同时处理多个资源。<ul><li>在 Java 7/8 ，try-with-resources 语句中必须声明要关闭的资源。通过这种方式声明的资源属于隐式 final。</li><li>Java 9 中甚至能使用预先创建的资源，只要所引用的资源声明为 final 或者是 effective final。</li><li>在幕后施展魔法的是 AutoCloseable 或者 Closeable 接口，它们与 try-with-resources 语句协同工作。</li></ul></li><li><strong>重写桥接</strong>: 子类重写方法返回值可以是父类返回值的子类,JVM内部使用了桥接方法(synthetic bridge修饰)重写父类方法并返回子类重写的同名方法,并且没有命名冲突,仅对jvm可见.</li><li><strong>匿名内部类</strong>: 内部创建了final修饰的实现类, 匿名内部类引用局部变量时,局部变量必须是final的:因为内部创建实现类时,将值赋给其对象的valx属性,valx属性没有机会再跟着一起变化.</li></ol><h3 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4. 类加载阶段"></a>4. 类加载阶段</h3><ol><li>隐式加载：new</li><li>显式加载：loadClass、forName等(需要调用Class的newInstance方法获取实例)</li><li>类的装载阶段：<strong><code>加载 --&gt; 链接 --&gt; 初始化</code></strong><ul><li>加载：通过Classloader加载class文件字节码，生成class对象</li><li>链接：校验–&gt;准备–&gt;解析<ul><li>校验：检查加载的Class的正确性和安全性</li><li>准备：为变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池内的符号引用转换为直接引用</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ul></li></ol><h4 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h4><ul><li>将类的字节码载入方法区中,内部采用C++的instanceKlass描述java类, 它的重要field有:<ul><li><code>_java_mirror</code>:Java类的镜像, <code>_super</code>:父类, <code>_field</code>:成员变量, <code>_methods</code>:方法, <code>_constants</code>:常量池, <code>_class_loader</code>:类加载器, <code>_vtable</code>:虚方法表, <code>_itable</code>:接口方法表</li></ul></li><li>如果这个类还有父类没加载,先加载父类</li><li><strong>加载和链接可能是交替运行的</strong></li></ul><blockquote><p><code>instanceKlass</code>这样的元数据是存储在方法区(元空间),但<code>_java_mirror</code>存储在堆中; 可通过HSDB工具查看.</p></blockquote><h4 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h4><ol><li>验证: 验证类是否符合JVM规范,安全性检查</li><li>准备: 为static变量分配空间,设置默认值<ul><li>jdk7开始, static变量存储于<code>_java_mirror</code>末尾, jdk7之前是instanceKlass末尾.</li><li>static变量分配空间和赋值是两个步骤, 分配空间在准备阶段完成,赋值在初始化阶段完成</li><li>如果static变量是final的<strong>基本类型或字符串常量</strong>,那么编译阶段值就确定了,赋值在准备阶段完成</li><li>如果static变量是final的<strong>引用类型</strong>,那么赋值还是会在初始化阶段完成</li></ul></li><li>解析: 将常量池中的符号引用解析为直接引用(确切知道类,方法,属性在内存中的位置)</li></ol><h4 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h4><ul><li>初始化即调用<code>&lt;cinit&gt;()V</code>方法,虚拟机会<strong>保证</strong>这个类的[<strong>构造方法</strong>]<strong>线程安全</strong></li><li><strong>发生的时机</strong>: 概括的说,类初始化是[<strong>懒惰的</strong>]<ul><li>main方法所在的类的,总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化, 如果父类没有初始化,会引发</li><li>子类访问父类静态变量, 只会触发父类的初始化</li><li>Class.forName 和 new操作 导致初始化</li></ul></li><li><strong>不会</strong>导致类初始化的情况<ul><li>访问类的static final 静态常量(基本类型和字符串常量)<strong>不会</strong>触发初始化</li><li>类对象.class 不会</li><li>创建该类的数组 不会</li><li>类加载器的loadClass方法 不会</li><li>Class.forName的第二个参数为false时 不会</li></ul></li></ul><h4 id="4-4-应用实例-懒惰初始化单例模式-线程安全"><a href="#4-4-应用实例-懒惰初始化单例模式-线程安全" class="headerlink" title="4.4 应用实例-懒惰初始化单例模式(线程安全)"></a>4.4 应用实例-懒惰初始化单例模式(线程安全)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 内部类中保存单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次调用getInstance,才会导致内部类加载和初始化其静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5. 类加载器"></a>5. 类加载器</h3><p>以JDK8为例:</p><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>启动类加载器, 最顶层, 打印显示为null</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>扩展类加载器, 第二级, 打印显示为$ExtClassLoader</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>应用程序类加载器, 第三级, 打印显示为$AppClassLoader</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="5-1-类加载器-双亲委派机制"><a href="#5-1-类加载器-双亲委派机制" class="headerlink" title="5.1 类加载器-双亲委派机制"></a>5.1 类加载器-双亲委派机制</h4><ul><li>类加载器在接到加载类的请求时，首先将加载任务<strong>委托给上级加载器</strong>，依次递归，如果上级加载器可以完成类加载任务，就成功返回；只有上级加载器无法完成此加载任务时，才自己去加载。</li><li>这种双亲委派模式的好处，一个可以避免类的重复加载，另外也避免了java的核心API被篡改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * loadClass方法的实现方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//【1】 检查该类是否已经加载</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//【2】 有上级的话,委派上级 loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//【3】 如果没有上级了(ExtClassLoader),则委派BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//【4】 每一级都找不到,调用findClass(每个类加载器自己扩展)来加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-线程上下文类加载器"><a href="#5-2-线程上下文类加载器" class="headerlink" title="5.2 线程上下文类加载器"></a>5.2 线程上下文类加载器</h4><ul><li>Java 提供了很多服务提供者接口(Service Provider Interface，SPI),允许第三方为这些接口提供实现(常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等)。</li><li>SPI接口中的代码经常需要加载具体的实现类; SPI的接口由Java核心库来提供，实现类可能是作为Java应用所依赖的jar包被包含进来，可以通过类路径（CLASSPATH）来找到。</li><li>SPI的接口是Java核心库的一部分，是由引导类加载器来加载的；引导类加载器是无法找到SPI的实现类的,这时候需要抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类。</li><li>类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。</li><li>Java默认的 线程上下文类加载器 是 应用程序类加载器(AppClassLoader)。</li></ul><h4 id="5-3-何时使用Thread-getContextClassLoader"><a href="#5-3-何时使用Thread-getContextClassLoader" class="headerlink" title="5.3 何时使用Thread.getContextClassLoader()?"></a>5.3 何时使用Thread.getContextClassLoader()?</h4><ul><li>总的说来动态加载资源时，一般只有两种选择，当前类加载器和线程上下文类加载器。当前类加载器是指当前方法所在类的加载器。这个类加载器是运行时类解析使用的加载器，Class.forName(String)和Class.getResource(String)也使用该类加载器。代码中X.class的写法使用的类加载器也是这个类加载器。</li><li>该如何选择类加载器？<ul><li>如若代码是限于某些特定框架，这些框架有着特定加载规则，则不要做任何改动，让框架开发者来保证其工作（比如应用服务器提供商，尽管他们并不能总是做对）。如在Web应用和EJB中，要使用Class.gerResource来加载资源。</li><li>在其他情况下，我们可以自己来选择最合适的类加载器。可以使用策略模式来设计选择机制。其思想是将“总是使用上下文类加载器”或者“总是使用当前类加载器”的决策同具体实现逻辑分离开。往往设计之初是很难预测何种类加载策略是合适的，该设计能够让你可以后来修改类加载策略。</li><li>一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程。</li></ul></li></ul><h4 id="5-4-类加载器与Web容器"><a href="#5-4-类加载器与Web容器" class="headerlink" title="5.4 类加载器与Web容器"></a>5.4 类加载器与Web容器</h4><p>以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。<strong>该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类</strong>。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p><ul><li>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：<ol><li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li><li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li><li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li></ol></li></ul><h4 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h4><ol><li>什么时候需要自定义类加载器<ul><li>加载非classpath路径的任意路径类文件</li><li>都是通过接口来使用实现,希望解耦时,常用于框架设计</li><li>这些类希望予以隔离,不同应用的同名类都可以加载,不冲突,常见于tomcat容器</li></ul></li><li>如何自定义类加载器<ol><li>继承ClassLoader类</li><li>重写findClass(String className)方法</li><li>读取(加载)类文件的字节码。</li><li>调用ClassLoader超类的defineClass方法，向虚拟机提供字节码。</li><li>使用者调用该自定义类加载器的loadClass方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 类名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String cname = <span class="string">"E:\\myclasspath\\"</span> + name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] classBytes = Files.readAllBytes(Paths.get(cname));</span><br><span class="line">            Class&lt;?&gt; cl = defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">            <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.print(e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-运行期JVM自动优化"><a href="#6-运行期JVM自动优化" class="headerlink" title="6. 运行期JVM自动优化"></a>6. 运行期JVM自动优化</h3><p>Java程序最初是通过解释器进行解释执行的，当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。<strong>解释执行节约内存，编译执行提升效率</strong>。 同时，解释器可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，则通过逆优化退回到解释状态继续执行。<br>HotSpot虚拟机中内置了两个即时编译器，分别称为<strong>Client Compiler(C1编译器)</strong>和<strong>Server Compiler(C2编译器)</strong>，默认采用Interpreter(解释器)与其中一个编译器直接配合的方式工作，使用哪个编译器取决于虚拟机运行的模式，也可以自己去指定。</p><ul><li><p>分层编译策略, JVM将执行状态分成了5个层次:</p><ol><li>0层, 解释执行</li><li>1层, 使用C1即时编译器编译执行(不带profiling)</li><li>2层, 使用C1即时编译器编译执行(带基本的profiling)</li><li>3层, 使用C1即时编译器编译执行(带完全的profiling)</li><li>4层, 使用C2即时编译器编译执行<blockquote><p>profiling是指在运行过程中收集一些程序执行状态的数据,例如[方法的调用次数],[循环的回边次数]等</p></blockquote></li></ol></li><li><p>即时编译器(JIT)与解释器的区别</p><ul><li>解释器是将字节码解释为机器码,下次即便遇到相同的字节码,仍会执行重复的解释</li><li>JIT是将一些字节码编译为机器码并存入CodeCache,下次遇到相同的代码,直接执行,无需再编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT会根据平台类型,生成平台特定的机器码</li></ul></li><li><p>对于占据大部分的不常用的代码,我们无需耗费时间将其编译成机器码,而是采用解释执行的方式运行;另一方面,对于占据小部分的热点代码,我们则可以将其编译成机器码,以达到理想的运行速度;</p></li><li><p>执行效率: <code>Interpreter &lt; C1 &lt; C2</code>, 总的目标是发现热点代码(hotpot名称的由来)优化之.</p></li></ul><h4 id="6-1-公共子表达式消除"><a href="#6-1-公共子表达式消除" class="headerlink" title="6.1 公共子表达式消除"></a>6.1 公共子表达式消除</h4><p>如果一个表达式E已经计算过了，并且先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共表达式，可以直接用之前的结果替换。<br>例：int d = (c * b) * 12 + a + (a + b * c) =&gt; int d = E * 12 + a + (a + E)</p><h4 id="6-2-数组边界检查消除"><a href="#6-2-数组边界检查消除" class="headerlink" title="6.2 数组边界检查消除"></a>6.2 数组边界检查消除</h4><p>Java语言中访问数组元素都要进行上下界的范围检查，每次读写都有一次条件判定操作，这无疑是一种负担。编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组长度以内，那么整个循环中就可以把上下界检查消除，这样可以省很多次的条件判断操作。</p><h4 id="6-3-方法内联"><a href="#6-3-方法内联" class="headerlink" title="6.3 方法内联"></a>6.3 方法内联</h4><p>方法内联能去除方法调用的成本，同时也为其他优化建立了良好的基础，因此各种编译器一般会把内联优化放在优化序列的最靠前位置，然而由于Java对象的方法默认都是虚方法，在编译期无法确定方法版本，就无法内联。</p><ul><li>因此方法调用都需要在运行时进行多态选择，为了解决虚方法的内联问题，Java虚拟机团队引入了“类型继承关系分析(CHA)”的技术。<ol><li>在内联时，若是非虚方法，则可以直接内联  </li><li>遇到虚方法，首先根据CHA判断此方法是否有多个目标版本，若只有一个，可以直接内联，但是需要预留一个“逃生门”，称为守护内联，若在程序的后续执行过程中，加载了导致继承关系发生变化的新类，就需要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</li><li>若CHA判断此方法有多个目标版本，则编译器会使用“内联缓存”，第一次调用缓存记录下方法接收者的版本信息，并且每次调用都比较版本，若一致则可以一直使用，若不一致则取消内联，查找虚方法表进行方法分派。</li></ol></li></ul><h4 id="6-4-逃逸分析"><a href="#6-4-逃逸分析" class="headerlink" title="6.4 逃逸分析"></a>6.4 逃逸分析</h4><p>分析对象动态作用域，当一个方法被定以后，它可能被外部方法所引用，称为方法逃逸，甚至还有可能被外部线程访问到，称为线程逃逸。</p><ul><li>若能证明一个对象不会逃逸到方法或线程之外，这可以通过栈上分配、同步消除、标量替换来进行优化。<ol><li>栈上分配：如果确定一个对象不会逃逸，则可以让它分配在栈上，对象所占用的内存空间就可以随栈帧出栈而销毁。这样可以减小垃圾收集系统的压力。  </li><li>同步消除：线程同步相对耗时，如果确定一个变量不会逃逸出线程，那这个变量的读写不会有竞争，则对这个变量实施的同步措施也就可以消除掉。  </li><li>标量替换：如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那么程序真正执行的时候可以不创建这个对象，改为直接创建它的成员变量，这样就可以在栈上分配。</li></ol></li></ul><h3 id="7-反射机制"><a href="#7-反射机制" class="headerlink" title="7. 反射机制"></a>7. 反射机制</h3><p>简单说，反射机制是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。<br>Class反射对象描述的是类的语义结构，通过class对象，可以获取构造器，成员变量，方法等类元素的反射对象，并且可以用编程的方法通过这些反射对象对目标对象进行操作。<br>这些反射类在java.lang.reflect包中定义，下面是最主要的三个类：</p><ol><li>Constructor：类的构造函数反射类：<ul><li>通过Class#getConstructors()方法可以获得类的所有构造函数的反射对象数组。</li><li>其中最主要的方法是newInstance(Object[] args),通过该方法可以创建一个对象类的实例，功能和new一样。在jdk5.0之后，提供了newInstance(Object…args)更为灵活。</li></ul></li><li>Method：类方法的反射类。<ul><li>通过Class#getDeclaredMethods()方法可以获取所有方法的反射类对象数组Method[].其中最主要的方法是:</li><li>invoke(String name,class parameterTypes),和invoke(Object obj,Object…args)。同时也还有很多其他方法</li><li>Class getReturnType（）：获取方法的返回值类型</li><li>Class[] getParameterTypes（）：获取方法的参数数组</li></ul></li><li>Field：类成员变量的反射类，<ul><li>通过Class#getDeclareFields（）可以获取类成员变量反射的数组。</li><li>Class#getDeclareField（String  name）获取某特定名称的反射对象。</li><li>最主要的方法是：set(Object obj,Object value),为目标对象的成员变量赋值。如果是基础类型还可以这样赋值setInt(),setString()…</li></ul></li></ol><ul><li>java还提供了包的反射类和注解的反射类。</li><li>总结:java反射体系保证了通过程序化的方式访问目标对象的所有元素，对于private 和protected成员变量或者方法，也是可以访问的。</li></ul><h4 id="7-1-反射中，Class-forName和classloader的区别"><a href="#7-1-反射中，Class-forName和classloader的区别" class="headerlink" title="7.1 反射中，Class.forName和classloader的区别"></a>7.1 反射中，Class.forName和classloader的区别</h4><ul><li>Class.forName()得到的Class是完成初始化的</li><li>而ClassLoader.loadClass()得到的Class是还没有链接的。</li><li>Spring IoC为了加快初始化速度，因此大量使用了延时加载技术。而使用classloader不需要执行类中的初始化代码，可以加快加载速度，把类的初始化工作留到实际使用到这个类的时候。</li></ul><h4 id="7-2-哪里用到反射机制？"><a href="#7-2-哪里用到反射机制？" class="headerlink" title="7.2 哪里用到反射机制？"></a>7.2 哪里用到反射机制？</h4><ul><li>JDBC中，利用反射动态加载了数据库驱动程序。</li><li>Web服务器中利用反射调用了Sevlet的服务方法。</li><li>Eclispe等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。</li><li>很多框架都用到反射机制，注入属性，调用方法，如Spring。</li></ul><h4 id="7-3-反射机制的优缺点？"><a href="#7-3-反射机制的优缺点？" class="headerlink" title="7.3 反射机制的优缺点？"></a>7.3 反射机制的优缺点？</h4><p>优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。<br>缺点：对性能有影响，这类操作总是慢于直接执行java代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-类文件结构&quot;&gt;&lt;a href=&quot;#1-类文件结构&quot; class=&quot;headerlink&quot; title=&quot;1. 类文件结构&quot;&gt;&lt;/a&gt;1. 类文件结构&lt;/h3&gt;&lt;p&gt;Class文件是一组以 &lt;strong&gt;8 位字节&lt;/strong&gt;为基础单位的二进制流，各个数据&lt;strong&gt;严格按照顺序紧凑的排列&lt;/strong&gt;在 Class 文件中，中间无任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，会按照高位在前的方式分割成若干个 8 位字节进行存储。&lt;br&gt;Java 虚拟机规范规定 Class 文件格式采用一种类似与 C 语言结构体的伪结构体来存储数据，这种伪结构体中只有两种数据类型：&lt;strong&gt;无符号数&lt;/strong&gt;和&lt;strong&gt;表&lt;/strong&gt;。
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】深入JVM(一)-运行时数据区 与 垃圾回收机制</title>
    <link href="http://chaooo.github.io/article/20190823.html"/>
    <id>http://chaooo.github.io/article/20190823.html</id>
    <published>2019-08-23T15:15:19.000Z</published>
    <updated>2019-10-27T15:59:59.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java虚拟机运行时数据区"><a href="#Java虚拟机运行时数据区" class="headerlink" title="Java虚拟机运行时数据区"></a>Java虚拟机运行时数据区</h3><ol><li>程序计数器（Program Counter Register）</li><li>本地方法栈（Native Method Stack）</li><li>Java虚拟机栈（VM Stack）</li><li>Java堆（Heap）（线程共享）</li><li>方法区（Method Area）（线程共享）<a id="more"></a></li></ol><p><img src="http://cdn.chaooo.top/Java/JVM.png" alt></p><h4 id="Java运行过程"><a href="#Java运行过程" class="headerlink" title="Java运行过程"></a>Java运行过程</h4><ol><li><code>Java源代码</code> 经过<strong>Javac</strong>编译成 字节码（bytecode)<code>.class文件</code>;</li><li>在运行时，通过 <strong>虚拟机(JVM)内嵌的解释器</strong> 将<code>字节码</code>转换成为最终的<code>机器码</code>。</li></ol><blockquote><p>常见的JVM，都提供了 JIT(Just-In-Time)编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成机器码，所以准确的说Java代码会<code>解释执行或编译执行</code>。</p></blockquote><h3 id="1-程序计数器（Program-Counter-Register）"><a href="#1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.程序计数器（Program Counter Register）"></a>1.程序计数器（Program Counter Register）</h3><ul><li>线程私有</li><li>不会内存溢出</li><li>作用：记住下一条JVM指令的执行地址。</li></ul><h3 id="2-Java虚拟机栈（VM-Stack）"><a href="#2-Java虚拟机栈（VM-Stack）" class="headerlink" title="2.Java虚拟机栈（VM Stack）"></a>2.Java虚拟机栈（VM Stack）</h3><ul><li>线程私有</li><li>LIFO（后进先出）</li><li>存储栈帧，支撑Java方法的调用、执行和退出</li><li>可能出现OutOfMemoryError异常（如果被设计成动态扩展，而扩展又未申请到足够的内存抛出）和StackOverflowError异常（如线程请求的栈深度大于最大深度抛出）</li></ul><p><img src="http://cdn.chaooo.top/Java/JVM-stack.png" alt></p><h4 id="2-1-栈帧（Frame）"><a href="#2-1-栈帧（Frame）" class="headerlink" title="2.1 栈帧（Frame）"></a>2.1 栈帧（Frame）</h4><ul><li>Java虚拟机栈中存储的内容，它被用于存储数据和部分过程结构的数据结构，同时也被用来处理动态链接、方法返回值 和 异常分派</li><li>一个完整的栈帧包含：<strong>局部变量表</strong>、<strong>操作数栈</strong>、动态连接信息、方法正常完成和异常完成的信息</li><li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="2-2-局部变量表"><a href="#2-2-局部变量表" class="headerlink" title="2.2 局部变量表"></a>2.2 局部变量表</h4><ul><li>由若干个Slot组成，长度由编译期决定</li><li>单个Slot可以储存一个类型为boolean、byte、char、short、float、reference、returnAddress 的数据，两个Slot可以存储一个类型为long或double的数据</li><li>局部变量表用于方法间参数的传递，以及方法执行过程中存储基础数据类型的值和对象的引用</li></ul><h4 id="2-3-操作数栈"><a href="#2-3-操作数栈" class="headerlink" title="2.3 操作数栈"></a>2.3 操作数栈</h4><ul><li>一个后进先出栈，由若干个Entry组成，长度由编译期决定</li><li>单个Entry即可以存储一个Java虚拟机中定义的任意数据类型的值，包括long和double类型，但是存储long和double类型的Entry深度为2，其他类型深度为1</li><li>在方法执行过程中，栈帧用于存储计算参数和计算结果；在方法调用时，操作数栈也用来准备调用方法的参数以及接收方法返回结果</li></ul><h4 id="2-4-栈的内存溢出（StackOverflowError）"><a href="#2-4-栈的内存溢出（StackOverflowError）" class="headerlink" title="2.4 栈的内存溢出（StackOverflowError）"></a>2.4 栈的内存溢出（StackOverflowError）</h4><ol><li>栈帧过多导致内存溢出（方法的递归调用）</li><li>栈帧过大导致内存溢出</li><li>JSON数据转换可能导致内存溢出（可用@JsonIgnore忽略不能转换的属性）</li></ol><h4 id="2-5-线程诊断"><a href="#2-5-线程诊断" class="headerlink" title="2.5 线程诊断"></a>2.5 线程诊断</h4><ol><li>案例1：cpu占用过高<ul><li>Linux下，<code>top</code>打印所有进程，筛选cpu占用高的进程号，如：32655</li><li>用<code>ps H -eo pid,tid,%cpu | grep 32655</code>打印32655的所有线程，定位到具体cpu占用过高的线程</li><li><code>jstack 进程id</code>打印该线程的所有线程详情</li><li>将线程id换算成16进制，对比打印出的线程详情，定位到具体线程，进一步定位到源代码具体代码行号。</li></ul></li><li>案例2：程序运行很长时间没有结果<ul><li>前面步骤同上，<code>jstack 进程id</code>打印该线程的所有线程详情</li><li>在最后一段找到了 Found one Java-level <strong>deadlock</strong>，定位死锁的具体行号。</li></ul></li></ol><h3 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.本地方法栈（Native Method Stack）"></a>3.本地方法栈（Native Method Stack）</h3><ul><li>线程私有</li><li>LIFO（后进先出）</li><li>支撑Native方法的调用、执行和退出</li><li>可能出现OutOfMemoryError异常 和 StackOverflowError异常</li><li>有一些虚拟机（如HotSpot）将Java虚拟机栈和本地方法栈合并实现</li></ul><h4 id="3-1-Java虚拟机栈和本地方法栈可能发生的异常情况："><a href="#3-1-Java虚拟机栈和本地方法栈可能发生的异常情况：" class="headerlink" title="3.1 Java虚拟机栈和本地方法栈可能发生的异常情况："></a>3.1 Java虚拟机栈和本地方法栈可能发生的异常情况：</h4><ul><li>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量时，Java虚拟机将会抛出一个StackOverflowError异常</li><li>如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</li></ul><h3 id="4-Java堆（Heap）"><a href="#4-Java堆（Heap）" class="headerlink" title="4.Java堆（Heap）"></a>4.Java堆（Heap）</h3><ul><li>全局共享</li><li>通常是Java虚拟机中最大的一块内存区域</li><li>作用是作为Java对象的主要存储区域（通过new创建的对象都会使用堆内存）</li><li>有垃圾回收机制</li></ul><p><img src="http://cdn.chaooo.top/Java/JVM-heap.png" alt></p><h4 id="4-1-Java堆可能发生的异常"><a href="#4-1-Java堆可能发生的异常" class="headerlink" title="4.1 Java堆可能发生的异常"></a>4.1 Java堆可能发生的异常</h4><ul><li>如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那Java虚拟机将会抛出一个OutOfMemoryError异常。</li></ul><h4 id="4-2-堆内存诊断"><a href="#4-2-堆内存诊断" class="headerlink" title="4.2 堆内存诊断"></a>4.2 堆内存诊断</h4><ol><li><strong>jps工具</strong>：查看当前系统中有哪些Java进程</li><li><strong>jmap工具</strong>：查看堆内存占用情况<code>jmap -head 进程id</code></li><li><strong>jconsole工具</strong>：图形界面，多功能的监测工具，可以连续监测</li></ol><ul><li>案例：垃圾回收后，内存占用仍然很高<ul><li>jps工具定位进程，<code>jmap -head 进程id</code>查看堆使用情况，</li><li>可以用jconsole工具手动执行GC</li><li>用jvirsualvm抓取堆dump(快照，抓取堆里面有哪些类型的对象及个数等信息)</li></ul></li></ul><h4 id="4-3-字符串常量池-StringTable"><a href="#4-3-字符串常量池-StringTable" class="headerlink" title="4.3 字符串常量池 (StringTable)"></a>4.3 字符串常量池 (StringTable)</h4><ul><li>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；</li><li>在JDK7.0版本，字符串常量池被移到了堆中</li><li>字符串手动入池:  调用<code>String.intern()</code></li></ul><h3 id="5-方法区（Method-Area）"><a href="#5-方法区（Method-Area）" class="headerlink" title="5.方法区（Method Area）"></a>5.方法区（Method Area）</h3><ul><li>全局共享</li><li>作用是存储Java类的结构信息</li><li>JVMS不要求该区域实现自动内存管理，但是商用Java虚拟机都能够自动管理该区域内存</li><li>在JDK1.8后，方法区由元空间实现</li></ul><blockquote><p>方法区内存溢出场景：spring、mabatis等动态加载类的场景使用不当会导致方法区内存溢出</p></blockquote><h4 id="5-1-运行时常量池"><a href="#5-1-运行时常量池" class="headerlink" title="5.1 运行时常量池"></a>5.1 运行时常量池</h4><ul><li>全局共享</li><li>是方法区的一部分</li><li>作用是存储Java类文件常量池中的符号信息</li><li>可能出现OutOfMemoryError异常</li></ul><h4 id="5-2-永久代与方法区"><a href="#5-2-永久代与方法区" class="headerlink" title="5.2 永久代与方法区"></a>5.2 永久代与方法区</h4><ul><li>在JDK1.2~6，HotSpot使用永久代实现方法区</li><li>在JDK1.7，开始移除（符号表被到Native Heap，字符串常量和类的静态引用被移到Java Head中）</li><li>在JDK1.8，永久代被元空间（Metaspace）所替代</li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h3><ul><li>全局共享</li><li>并非JVMS定义的标准Java运行时内存区域, 属于操作系统内存</li><li>JDK1.4引入NIO，目的是避免Java堆 和 Native堆 中来回 复制数据 带来的性能损耗。</li><li>能被自动管理，但是在检测手段上可能会由一些简陋</li><li>可能出现OutOfMemoryError异常</li><li>常用于NIO操作时，用于数据缓冲区</li><li>分配回收成本高，但读写性能高，不受JVM内存回收管理</li></ul><h3 id="7-可回收对象的判定"><a href="#7-可回收对象的判定" class="headerlink" title="7.可回收对象的判定"></a>7.可回收对象的判定</h3><ol><li>引用计数法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就+1，当引用失效就-1，任何时候计数器为0时就是可回收对象。</li><li>可达性分析：通过一系列名为GC Roots的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则称该对象是不可达的。</li></ol><blockquote><p>目前主流Java虚拟机中<strong>并没有</strong>选用引用计数法，其中最重要的原因是它很难解决<strong>循环引用问题</strong></p></blockquote><h4 id="7-1-Java语言中的GC-Roots"><a href="#7-1-Java语言中的GC-Roots" class="headerlink" title="7.1 Java语言中的GC Roots"></a>7.1 Java语言中的GC Roots</h4><ul><li>在虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>在方法区中的类静态属性引用的对象。</li><li>在方法区中的常量引用的对象。</li><li>在本地方法栈中JNI（即一般说的Native方法）的引用对象。</li></ul><h4 id="7-2-Java引用类型"><a href="#7-2-Java引用类型" class="headerlink" title="7.2 Java引用类型"></a>7.2 Java引用类型</h4><ol><li>强引用：Java中默认声明的就是强引用<ul><li>垃圾回收器将永远<strong>不会</strong>回收被【强引用】对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。可以赋值为null中断强引用。</li></ul></li><li>软引用（SoftReference）：用来描述一些非必需但仍有用的对象，用java.lang.ref.SoftReference类来表示软引用<ul><li>垃圾回收后，在内存<strong>不足时会</strong>再次触发垃圾回收，回收【软引用】对象，仍不足，才会抛出内存溢出异常。可以配合引用队列来释放软引用自身。</li></ul></li><li>弱引用（WeakReference）：用 java.lang.ref.WeakReference 来表示弱引用<ul><li>垃圾回收器将永远<strong>都会</strong>回收被【弱引用】对象，无论内存是否足够。可以配合引用队列来释放弱引用自身。</li></ul></li><li>虚引用（PhantomReference）：最弱的一种引用关系，用 PhantomReference 类来表示<ul><li><strong>必须配合引用队列</strong>使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存。</li></ul></li></ol><h3 id="8-垃圾回收算法"><a href="#8-垃圾回收算法" class="headerlink" title="8.垃圾回收算法"></a>8.垃圾回收算法</h3><ol><li>标记清除算法（Mark-Sweep）</li><li>标记整理算法(Mark-Compact)</li><li>复制算法（copying）</li></ol><h4 id="8-1-分代垃圾回收（Java堆分为新生代和老年代）"><a href="#8-1-分代垃圾回收（Java堆分为新生代和老年代）" class="headerlink" title="8.1 分代垃圾回收（Java堆分为新生代和老年代）"></a>8.1 分代垃圾回收（Java堆分为新生代和老年代）</h4><ol><li>对象首先分配在新生代的<code>Eden区</code></li><li>新生代空间不足时，触发 <code>Minor GC</code>，Eden区和From幸存区(Survivor)存活的对象使用coping复制到To幸存区中，存活的年龄+1 并且交换From和To。</li><li>Minor GC会引发 <code>STW(Stop the world)</code>，暂停其他用户的线程，等垃圾回收结束后，用户线程才恢复运行</li><li>当对象<code>寿命超过阈值</code>时，会晋升至老年代，最大寿命15(4bit)</li><li>当老年代空间不足，会先尝试触发 Minor GC，如果之后空间仍不足，那么触发 <code>Full GC</code>，STW的时间更长</li></ol><h4 id="8-2-相关JVM参数"><a href="#8-2-相关JVM参数" class="headerlink" title="8.2 相关JVM参数"></a>8.2 相关JVM参数</h4><ol><li>堆初始大小：         <code>-Xms</code></li><li>堆最大大小：         <code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></li><li>新生代大小：         <code>-Xmn</code> 或 <code>(-XX:NewSize=size + -XX:MaxNewSize=size)</code></li><li>幸存区比例（动态）：  <code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></li><li>幸存区比例：         <code>-XX:SurvivorRatio=ratio</code></li><li>晋升阈值：           <code>-XX:MaxTenuringThreshold=threshold</code></li><li>晋升详情：           <code>-XX:+PrintTenuringDistribution</code></li><li>GC详情：            <code>-XX:+PrintGCDetils -verbose:gc</code></li><li>FullGC 前 MinorGC： <code>-XX:+ScavengeBeforeFullGC</code></li></ol><h3 id="9-垃圾回收器"><a href="#9-垃圾回收器" class="headerlink" title="9.垃圾回收器"></a>9.垃圾回收器</h3><ol><li>串行（开启：<code>-XX:+UseSerialGC=Serial + SerialOld</code>）<ul><li>单线程</li><li>适合堆内存较小，适合个人电脑</li></ul></li><li>吞吐量优先<ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>让单位时间内，总STW的时间最短</li></ul></li><li>响应时间优先<ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽量让单次STW的时间最短</li></ul></li></ol><h4 id="9-1-吞吐量优先（并行）回收器"><a href="#9-1-吞吐量优先（并行）回收器" class="headerlink" title="9.1 吞吐量优先（并行）回收器"></a>9.1 吞吐量优先（并行）回收器</h4><ol><li>开启(默认开启)： <code>-XX:+UseParallelGC</code> ~ <code>-XX:+UseParallelOldGC</code></li><li>动态调整堆大小：<code>-XX:+UseAdaptiveSizePolicy</code></li><li>目标吞吐量：<code>-XX:GCTimeRatio=ratio</code> </li><li>最大暂停时间的目标值：<code>-XX:MaxGCPauseMillis=ms</code></li><li>线程数：<code>-XX:ParallelGCThreads=n</code></li></ol><h4 id="9-2-响应时间优先（并发）回收器"><a href="#9-2-响应时间优先（并发）回收器" class="headerlink" title="9.2 响应时间优先（并发）回收器"></a>9.2 响应时间优先（并发）回收器</h4><p>可以和用户线程<strong>并发</strong>执行，工作在老年代</p><ol><li>开启：<code>-XX:+UseConcMarkSweepGC</code> 配合 <code>-XX:UseParNewGC</code> ~ <code>SerialOld</code></li><li>并行和并发线程数：<code>-XX:ParallelGCThreads=n</code> ~ <code>-XX:ConsGCThreads=threads</code></li><li>回收时机（内存占比）:<code>-XX:CMSInitiatingOccupancyFraction=percent</code></li><li>重新标记前对新生代先做垃圾回收：<code>-XX:+CMSScavengeBeforeRemark</code></li></ol><h4 id="9-3-G1（Garbage-First）（并发）"><a href="#9-3-G1（Garbage-First）（并发）" class="headerlink" title="9.3 G1（Garbage First）（并发）"></a>9.3 G1（Garbage First）（并发）</h4><ol><li>G1回收器 适用场景<ul><li>同时注重 吞吐量(Throughput)和低延迟(Low latency)，默认暂停目标是200ms</li><li>超大堆内存，会将堆划分为多个大小相等的区域(Region)</li><li>整体上是标记+整理算法，两个区域之间是复制算法</li></ul></li><li>相关JVM参数<ul><li>开启（JDK9默认）：<code>-XX:+UseG1GC</code></li><li>区域大小：<code>-XX:G1HeapRegionSize=size</code></li><li>最大暂停时间：<code>-XX:MaxGCPauseMillis=time</code></li></ul></li><li>G1垃圾回收阶段（三个阶段循环）<ol><li><strong><code>Young Collection</code></strong>：新生代GC（会STW）</li><li><strong><code>Young Collection + Concurrent Mark</code></strong>：<ul><li>在YoungGC时会进行<code>GC Root</code>的初始标记</li><li>老年代占用堆空间比例达到阈值值，进行并发标记(不会STW)，由下面的JVM参数决定</li><li><code>-XX:InitiatingHeadOccupancyPercent=percent</code>(默认45%)</li></ul></li><li><strong><code>Mixed Collection</code></strong>：会对Eden、Survivor、Old进行全面垃圾回收<ul><li>最终标记(Remark)会STW</li><li>拷贝存活(Evacuation)会STW</li><li>为达到最大暂停时间短的目标，Old区是优先回收垃圾最多的区域</li></ul></li></ol></li></ol><h4 id="9-4-Minor-GC-和-Full-GC"><a href="#9-4-Minor-GC-和-Full-GC" class="headerlink" title="9.4 Minor GC 和 Full GC"></a>9.4 Minor GC 和 Full GC</h4><ol><li>SerialGC<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：Full GC</li></ul></li><li>ParallelGC<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：Full GC</li></ul></li><li>CMS<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：分两种情况（回收速度高于内存产生速度不会触发Full GC）</li></ul></li><li>G1<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：分两种情况（回收速度高于内存产生速度不会触发Full GC）</li></ul></li></ol><blockquote><ul><li><code>Minor GC</code>：当Eden区满时，触发Minor GC</li><li><code>Full GC</code>：<ul><li>System.gc()方法的调用</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、From幸存区 向 To幸存区 复制时，对象大小大于To区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li></ul></blockquote><h3 id="10-垃圾回收调优"><a href="#10-垃圾回收调优" class="headerlink" title="10.垃圾回收调优"></a>10.垃圾回收调优</h3><ol><li>调优领域：内存、锁竞争、CPU占用、IO</li><li>调优目标：【低延迟】还是【高吞吐量】（高吞吐量:ParallelGC，低延迟:CMS,G1,ZGC）</li><li>最快的GC是不发生GC：查看Full GC前后的内存占用（内存数据太多？数据表示太臃肿？内存泄漏？）</li><li>新生代调优：new操作内存分配廉价、死亡对象回收代价是零、大部分对象用过即死、MinorGC时间远低于FullGC</li></ol><h4 id="10-1-新生代调优"><a href="#10-1-新生代调优" class="headerlink" title="10.1 新生代调优"></a>10.1 新生代调优</h4><ol><li>理想情况：新生代能容纳所有【并发量*(请求-响应)】的数据</li><li>幸存区大到能够保留【当前活跃对象+需要晋升对象】</li><li>【晋升阈值配置】得当，让长时间存活的对象尽快晋升<ul><li>调整最大晋升阈值：<code>-XX:MaxTenuringThreshold=threshold</code></li><li>打印晋升详情：<code>-XX:+PrintTenuringDistribution</code></li></ul></li></ol><h4 id="10-2-老年代调优"><a href="#10-2-老年代调优" class="headerlink" title="10.2 老年代调优"></a>10.2 老年代调优</h4><p>以CMS为例：</p><ol><li>CMS的老年代内存越大越好（避免浮动垃圾引起的并发失败）</li><li>先尝试不做调优，如果没有FullGC那么已经OK，否则先尝试调优新生代</li><li>观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3<ul><li><code>-XX:CMSInitiatingOccupancyPercent=percent</code></li></ul></li></ol><h4 id="10-3-调优案例"><a href="#10-3-调优案例" class="headerlink" title="10.3 调优案例"></a>10.3 调优案例</h4><ol><li>案例1：FullGC 和 MinorGC频繁<ul><li>可能原因：空间紧张，若业务高峰期时，新生代空间紧张，幸存区的晋升阈值会降低，大量本来生存短对象晋升老年区，进一步触发老年代FullGC的频繁发生</li><li>解决方法：经过分析，观察堆空间大小，先试着增大新生代内存，同时增大幸存区的空间以及晋升阈值。</li></ul></li><li>案例2：请求高峰期发生了FullGC，单次暂停时间特别长（CMS）<ul><li>查看日志，看CMS哪个阶段暂停时间长（重新标记阶段），解决：打开开关参数CMSScavengeBeforeRemark</li><li>重新标记前对新生代先做垃圾回收：<code>-XX:+CMSScavengeBeforeRemark</code></li></ul></li></ol><h4 id="10-4-G1调优最佳实践"><a href="#10-4-G1调优最佳实践" class="headerlink" title="10.4 G1调优最佳实践"></a>10.4 G1调优最佳实践</h4><ol><li>不要设置新生代和老年代的大小<ul><li>G1收集器在运行的时候会调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间目标。设置了新生代大小相当于放弃了G1为我们做的自动调优。我们需要做的只是设置整个堆内存的大小，剩下的交给G1自己去分配各个代的大小。</li></ul></li><li>不断调优暂停时间指标<ul><li>通过XX:MaxGCPauseMillis=x可以设置启动应用程序暂停的时间，G1在运行的时候会根据这个参数选择CSet来满足响应时间的设置。一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。</li></ul></li><li>关注Evacuation Failure<ul><li>Evacuation Failure类似于CMS里面的晋升失败，堆空间的垃圾太多导致无法完成Region之间的拷贝，于是不得不退化成Full GC来做一次全局范围内的垃圾收集。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java虚拟机运行时数据区&quot;&gt;&lt;a href=&quot;#Java虚拟机运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机运行时数据区&quot;&gt;&lt;/a&gt;Java虚拟机运行时数据区&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;程序计数器（Program Counter Register）&lt;/li&gt;
&lt;li&gt;本地方法栈（Native Method Stack）&lt;/li&gt;
&lt;li&gt;Java虚拟机栈（VM Stack）&lt;/li&gt;
&lt;li&gt;Java堆（Heap）（线程共享）&lt;/li&gt;
&lt;li&gt;方法区（Method Area）（线程共享）
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】网络协议</title>
    <link href="http://chaooo.github.io/article/20190815.html"/>
    <id>http://chaooo.github.io/article/20190815.html</id>
    <published>2019-08-15T13:04:33.000Z</published>
    <updated>2019-10-20T05:59:00.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分层网络协议"><a href="#1-分层网络协议" class="headerlink" title="1. 分层网络协议"></a>1. 分层网络协议</h3><ol><li>OSI七层网络协议：物理层，数据链路层，网络层，传输层(TCP/UDP)，会话层，表示层，应用层</li><li>TCP/IP协议分层(可以理解为OSI的一种实现)：网络接口层，网络层，传输层(TCP/UDP)，应用层<a id="more"></a></li></ol><h3 id="2-TCP通信协议简介："><a href="#2-TCP通信协议简介：" class="headerlink" title="2. TCP通信协议简介："></a>2. TCP通信协议简介：</h3><ul><li>面向连接的、可靠的、基于字节流的 传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来校验数据在传输过程中是否有误</li><li>报文头中的ACK(确认序号标志)，SYN(同步序号，用于建立连接过程)</li></ul><h3 id="3-TCP建立连接的三次握手"><a href="#3-TCP建立连接的三次握手" class="headerlink" title="3. TCP建立连接的三次握手"></a>3. TCP建立连接的三次握手</h3><ol><li>第一次：建立连接时，客户端发送<code>SYN包(syn=j)</code>到服务器，并进入<code>SYS_SEND</code>状态，等待服务器确认；</li><li>第二次：服务器收到<code>SYN包</code>，必须确认客户的<code>SYN(ack=j+1)</code>，同时自己也发送一个<code>SYN包(syn=k)</code>，即 <code>SYN+ACK包</code>，此时服务器进入<code>SYN_RECV</code>状态；</li><li>第三次：客户端收到<code>SYN+ACK包</code>，向服务器发送确认包<code>ACK(ack=k+1)</code>，此包发送完毕，客户端和服务端进入<code>ESTABLISHED</code>状态，完成三次握手。</li></ol><h3 id="4-为什么需要三次握手"><a href="#4-为什么需要三次握手" class="headerlink" title="4. 为什么需要三次握手"></a>4. 为什么需要三次握手</h3><ul><li>为了初始化Sequence Number的初始值（通信双方要互相通知对方自己的Sequence Number，要作为以后数据通信的序号，以保证接收到的数据不会因为网络传输问题而乱序，TCP会用这个序号拼接数据）</li></ul><h3 id="5-首次握手的隐患—SYN超时"><a href="#5-首次握手的隐患—SYN超时" class="headerlink" title="5. 首次握手的隐患—SYN超时"></a>5. 首次握手的隐患—SYN超时</h3><ul><li>服务端收到客户端的SYN，回复SYN-ACK的时候未收到ACK确认</li><li>服务端不断尝试(重发SYN-ACK)直至超时，Linux默认等待63秒才断开连接(默认重试5次，重试间隔1s开始，每次翻倍，即1+2+4+8+16+32=63)</li><li>可能遭受SYN Flood的风险(syn攻击，又称为ddos攻击)</li></ul><h3 id="6-什么是SYN-Flood攻击"><a href="#6-什么是SYN-Flood攻击" class="headerlink" title="6. 什么是SYN Flood攻击"></a>6. 什么是SYN Flood攻击</h3><ul><li>客户端恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB，从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。而攻击发起方的资源消耗相比较可忽略不计。</li><li>SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一。</li></ul><h3 id="7-Linux针对SYN-Flood的防护措施"><a href="#7-Linux针对SYN-Flood的防护措施" class="headerlink" title="7. Linux针对SYN Flood的防护措施"></a>7. Linux针对SYN Flood的防护措施</h3><ul><li>SYN队列满后，通过tcp_syncookies参数回发SYN Cookies</li><li>若为正常连接则客户端会回发SYN Cookies，直接建立连接</li></ul><h3 id="8-建立连接后，客户端出现故障怎么办（保活机制）"><a href="#8-建立连接后，客户端出现故障怎么办（保活机制）" class="headerlink" title="8. 建立连接后，客户端出现故障怎么办（保活机制）"></a>8. 建立连接后，客户端出现故障怎么办（保活机制）</h3><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测树仍未收到响应则中断连接</li></ul><h3 id="9-TCP终止连接的四次挥手（以客户端主动为例）"><a href="#9-TCP终止连接的四次挥手（以客户端主动为例）" class="headerlink" title="9. TCP终止连接的四次挥手（以客户端主动为例）"></a>9. TCP终止连接的四次挥手（以客户端主动为例）</h3><ol><li>第一次：客户端发送一个<code>FIN(seq=u)</code>，用来关闭客户端到服务器的数据传送，客户端进入<code>FIN_WAIT_1</code>状态；</li><li>第二次：服务器收到<code>FIN</code>，发回一个<code>ACK(ack=u+1)</code>，确认序号为收到的序号+1(和SYN一样，一个FIN将占用一个序号)，服务端进入<code>CLOSE_WAIT</code>状态；</li><li>第三次：服务端发送一个<code>FIN(seq=w)</code>，用来关闭服务端到客户端的数据传送，服务端进入<code>LAST_ACK</code>状态；</li><li>第四次：客户端收到<code>FIN</code>，发回一个<code>ACK(ack=w+1)</code>，将确认序号设置为收到序号+1，客户端进入<code>TIME_WAIT</code>状态，服务端进入<code>CLOSED</code>状态，完成四次挥手。</li></ol><h3 id="10-存在TIME-WAIT状态的原因"><a href="#10-存在TIME-WAIT状态的原因" class="headerlink" title="10. 存在TIME_WAIT状态的原因"></a>10. 存在TIME_WAIT状态的原因</h3><ul><li>保证TCP全双工连接的可靠释放，确保有足够时间让对方收到ACK包</li><li>避免新旧来凝结混淆，使旧数据包在网络中因过期而失效</li></ul><h3 id="11-为什么需要四次挥手"><a href="#11-为什么需要四次挥手" class="headerlink" title="11. 为什么需要四次挥手"></a>11. 为什么需要四次挥手</h3><ul><li>因为全双工，发送方和接收方都需要FIN报文和ACK报文</li></ul><h3 id="12-服务器出现大量CLOSE-WAIT状态的原因"><a href="#12-服务器出现大量CLOSE-WAIT状态的原因" class="headerlink" title="12. 服务器出现大量CLOSE_WAIT状态的原因"></a>12. 服务器出现大量CLOSE_WAIT状态的原因</h3><ul><li>对方关闭socket连接，我方忙于读或写，没有及时关闭连接<ul><li>检查代码，特别是释放资源的代码</li><li>检查配置，特别是处理请求的线程配置</li></ul></li></ul><h3 id="13-UDP简介"><a href="#13-UDP简介" class="headerlink" title="13. UDP简介"></a>13. UDP简介</h3><ul><li>面向非连接</li><li>不维护连接状态，支持同时向多个客户端传输相同消息</li><li>数据包报头只有8个字节，额外开销小</li><li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠性，不需要维持复杂的链接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或者合并</li></ul><h3 id="14-TCP和UDP的区别"><a href="#14-TCP和UDP的区别" class="headerlink" title="14. TCP和UDP的区别"></a>14. TCP和UDP的区别</h3><ul><li>面向连接 vs 无连接</li><li>可靠性和有序性 vs 不保证</li><li>全双工的字节流 vs 全双工的数据报</li><li>效率低 vs 速度快</li><li>重量级 vs 轻量级</li></ul><h3 id="15-Http协议简介"><a href="#15-Http协议简介" class="headerlink" title="15. Http协议简介"></a>15. Http协议简介</h3><ul><li>基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），Hyper Text Transfer Protocol（超文本传输协议）的缩写。</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法(GET、HEAD、POST等)和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li><strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</li><li><strong>支持B/S及C/S模式</strong>。</li></ul><h3 id="16-HTTP-请求-响应的步骤"><a href="#16-HTTP-请求-响应的步骤" class="headerlink" title="16. HTTP 请求/响应的步骤"></a>16. HTTP 请求/响应的步骤</h3><ol><li>客户端连接到Web服务器<ul><li>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="https://chaooo.github.io">https://chaooo.github.io</a>。</li></ul></li><li>发送HTTP请求<ul><li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li></ul></li><li>服务器接受请求并返回HTTP响应<ul><li>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li></ul></li><li>释放连接TCP连接<ul><li>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li></ul></li><li>客户端浏览器解析HTML内容<ul><li>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li></ul></li></ol><h3 id="17-在浏览器地址栏键入URL，按下回车之后会经历以下流程："><a href="#17-在浏览器地址栏键入URL，按下回车之后会经历以下流程：" class="headerlink" title="17. 在浏览器地址栏键入URL，按下回车之后会经历以下流程："></a>17. 在浏览器地址栏键入URL，按下回车之后会经历以下流程：</h3><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li><li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li><li>释放 TCP连接;</li><li>浏览器将该 html 文本并显示内容; 　</li></ol><h3 id="18-HTTP之状态码"><a href="#18-HTTP之状态码" class="headerlink" title="18. HTTP之状态码"></a>18. HTTP之状态码</h3><ol><li>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<ul><li>1xx：指示信息–表示请求已接收，继续处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li>5xx：服务器端错误–服务器未能实现合法的请求</li></ul></li><li>常见状态码：<ul><li>200 OK                    //客户端请求成功</li><li>400 Bad Request           //客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized          //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li><li>403 Forbidden             //服务器收到请求，但是拒绝提供服务</li><li>404 Not Found             //请求资源不存在，eg：输入了错误的URL</li><li>500 Internal Server Error //服务器发生不可预期的错误</li><li>503 Server Unavailable    //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul></li></ol><h3 id="19-HTTPS和HTTP的区别："><a href="#19-HTTPS和HTTP的区别：" class="headerlink" title="19. HTTPS和HTTP的区别："></a>19. HTTPS和HTTP的区别：</h3><ol><li>https协议需要到CA申请证书(收费)，http不需要。</li><li>https密文传输，http明文传输。</li><li>http使用80端口，https默认使用443端口。</li><li>https = http + 加密 + 认证 + 完整性保护</li></ol><h3 id="20-Socket简介"><a href="#20-Socket简介" class="headerlink" title="20. Socket简介"></a>20. Socket简介</h3><ul><li><p>Socket是对TCP/IP协议的抽象，是操作系统对外开发的接口</p></li><li><p>基于tcp协议的编程模型</p><ul><li>服务器：<ol><li>创建ServerSocket类型的对象并提供端口号；</li><li>等待客户端的连接请求，调用accept方法；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li><li>客户端：<ol><li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li></ul></li><li><p>基于udp协议的编程模型</p><ul><li>主机A(接收方):<ol><li>创建DatagramSocket类型的对象，并提供端口号；</li><li>创建DatagramPacket类型的对象，用于接收发来的数据；</li><li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li><li>主机B(发送方)<ol><li>创建DatagramSocket类型的对象；</li><li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li><li>通过Socket发送数据，调用<strong>send()</strong>方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-分层网络协议&quot;&gt;&lt;a href=&quot;#1-分层网络协议&quot; class=&quot;headerlink&quot; title=&quot;1. 分层网络协议&quot;&gt;&lt;/a&gt;1. 分层网络协议&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;OSI七层网络协议：物理层，数据链路层，网络层，传输层(TCP/UDP)，会话层，表示层，应用层&lt;/li&gt;
&lt;li&gt;TCP/IP协议分层(可以理解为OSI的一种实现)：网络接口层，网络层，传输层(TCP/UDP)，应用层
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】JSON Web Token 入门</title>
    <link href="http://chaooo.github.io/article/20190806.html"/>
    <id>http://chaooo.github.io/article/20190806.html</id>
    <published>2019-08-06T07:50:53.000Z</published>
    <updated>2019-10-20T05:56:22.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON-Web-Token"><a href="#JSON-Web-Token" class="headerlink" title="JSON Web Token"></a>JSON Web Token</h2><p>JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。</p><a id="more"></a><ul><li>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</li><li>此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</li><li>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</li></ul><h3 id="1-JWT数据结构"><a href="#1-JWT数据结构" class="headerlink" title="1. JWT数据结构"></a>1. JWT数据结构</h3><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。</p><ul><li>例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<code>.</code>eyJhdWQiOiJjaGFvIiwidWlkIjoyOSwiZXhwIjoxNTY3OTM2NzgwfQ<code>.</code>6zvimBNs_MCiov4MOkkUodgKmRFBS2dVhmhIb1MV6m4。</li></ul><p>JWT 的三个部分(<code>Header.Payload.Signature</code>)依次如下:</p><ol><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ol><h4 id="1-1-Header（头部）"><a href="#1-1-Header（头部）" class="headerlink" title="1.1 Header（头部）"></a>1.1 Header（头部）</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>alg</code>：签名的算法（algorithm），默认是 HMAC SHA256（写成<code>HS256</code>）</li><li><code>typ</code>：表示这个令牌（token）的类型（type），JWT令牌统一写为<code>JWT</code>。</li></ul><p>最后，将上面的 JSON 对象使用 <code>Base64URL算法</code>转成字符串。</p><h4 id="1-2-Payload（负载）"><a href="#1-2-Payload（负载）" class="headerlink" title="1.2 Payload（负载）"></a>1.2 Payload（负载）</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段(Reserved claims)，供选用。标准中建议使用这些字段，但不强制。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号，JWT唯一标识，能用于防止JWT重复使用</li></ul><p>除了官方字段，还有公共声明的字段（见：<a href="http://www.iana.org/assignments/jwt/jwt.xhtml" target="_blank" rel="noopener">http://www.iana.org/assignments/jwt/jwt.xhtml</a>）也可以定义私有字段，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p></blockquote><p>这个 JSON 对象也要使用 <code>Base64URL算法</code>转成字符串。</p><h4 id="1-3-Signature（签名）"><a href="#1-3-Signature（签名）" class="headerlink" title="1.3 Signature（签名）"></a>1.3 Signature（签名）</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。该签名信息是通过header和payload，加上secret，通过算法加密生成。</p><ul><li>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<ul><li><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></li></ul></li><li>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</li></ul><h3 id="2-Base64URL算法"><a href="#2-Base64URL算法" class="headerlink" title="2. Base64URL算法"></a>2. Base64URL算法</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h3 id="3-JWT-的使用方式及特点"><a href="#3-JWT-的使用方式及特点" class="headerlink" title="3. JWT 的使用方式及特点"></a>3. JWT 的使用方式及特点</h3><ol><li><p>认证原理：</p><ul><li>客户端向服务器申请授权，服务器认证以后，生成一个token字符串并返回给客户端，此后客户端在请求受保护的资源时携带这个token，服务端进行验证再从这个token中解析出用户的身份信息。</li></ul></li><li><p>JWT的使用方式：</p><ul><li>客户端收到服务器返回的JWT，存储在浏览器（Cookie或localStorage）</li><li>此后，客户端每次与服务器通信，都要带上这个JWT。<ol><li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul><li><code>Authorization: &lt;token&gt;</code></li><li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li></ul></li><li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li></ol></li></ul></li><li><p>对JWT实现token续签的做法：</p><ol><li>额外生成一个refreshToken用于获取新token，refreshToken需存储于服务端，其过期时间比JWT的过期时间要稍长。</li><li>用户携带refreshToken参数请求token刷新接口，服务端在判断refreshToken未过期后，取出关联的用户信息和当前token。</li><li>使用当前用户信息重新生成token，并将旧的token置于黑名单中，返回新的token。</li></ol></li><li><p>JWT 的几个特点</p><ol><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ol></li></ol><h3 id="4-Java中JWT的使用"><a href="#4-Java中JWT的使用" class="headerlink" title="4. Java中JWT的使用"></a>4. Java中JWT的使用</h3><p>java-jwt工具包提供了<strong>JWT算法的封装</strong></p><ol><li>导入java-jwt，选择一种算法（HMAC256为例）<ul><li><strong><code>Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);</code></strong></li><li>算法定义了一个令牌是如何被签名和验证的。</li></ul></li><li>创建一个签名的<code>JWT token</code>（通过调用jwt.create()创建一个JWTCreator实例）<ul><li><strong><code>String token = JWT.create().withIssuer(&quot;auth0&quot;).sign(algorithm);</code></strong></li><li><em>如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出<strong>JWTCreationException</strong>异常</em></li></ul></li><li>验证令牌（调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。方法build()返回的实例是可重用的，因此可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token）<ul><li><strong><code>JWTVerifier verifier = JWT.require(algorithm).withIssuer(&quot;auth0&quot;).build();</code></strong></li><li><strong><code>verifier.verify(token);</code></strong></li><li><em>如果令牌有一个无效的签名，或者没有满足Claim要求，那么将会抛出<strong>JWTVerificationException</strong>异常</em></li></ul></li><li>jwt时间的验证（当验证一个令牌时，时间验证会自动发生；JWT令牌可能包括可用于验证的DateNumber字段）<ul><li><code>&quot;iat&quot; &lt; TODAY</code>：这个令牌发布了一个过期的时间</li><li><code>&quot;exp&quot; &gt; TODAY</code>：这个令牌还没过期</li><li><code>&quot;nbf&quot; &gt; TODAY</code>：这个令牌已经被使用了</li></ul></li><li>解码一个jwt令牌<ul><li><code>DecodedJWT jwt = JWT.decode(token);</code></li><li><code>jwt.getAlgorithm();</code>:返回jwt的算法值,如果没有定义则返回null</li><li><code>jwt.getType();</code>:返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）</li><li><em>如果令牌有无效的语法，或者消息头或有效负载不是JSONs，那么将会抛出<strong>JWTDecodeException</strong>异常</em></li></ul></li></ol><h3 id="5-Java中JWT的使用实例"><a href="#5-Java中JWT的使用实例" class="headerlink" title="5. Java中JWT的使用实例"></a>5. Java中JWT的使用实例</h3><p>封装一个JWT工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT; <span class="comment">//导入java-jwt</span></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.JWTVerifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.entity.User; <span class="comment">//引入User实体类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置过期时间，这里设置15分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">15</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//服务端的私钥secret,在任何场景都不应该流露出去</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_SECRET = <span class="string">"zhengchao"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **User**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **password**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createToken</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">            <span class="comment">// 私钥和加密算法</span></span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">// 设置头部信息</span></span><br><span class="line">            Map&lt;String, Object&gt; header = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            header.put(<span class="string">"typ"</span>, <span class="string">"JWT"</span>);</span><br><span class="line">            header.put(<span class="string">"alg"</span>, <span class="string">"HS256"</span>);</span><br><span class="line">            <span class="comment">// 返回token字符串</span></span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">"aud"</span>, user.getName())</span><br><span class="line">                    .withClaim(<span class="string">"uid"</span>, user.getId())</span><br><span class="line">                    .withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验token是否正确</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **token**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVerify</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出uid信息,用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseTokenUid</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"uid"</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出aud信息,用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseTokenAud</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"aud"</span>).asString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录成功后，生成token给浏览器，存储在浏览器（Cookie或localStorage）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String token = JwtUtil.createToken(user);</span><br></pre></td></tr></table></figure><p>此后，客户端每次与服务器通信（需权限的资源），都要带上这个JWT。</p><ol><li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul><li><code>Authorization: &lt;token&gt;</code></li><li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li></ul></li><li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li></ol><blockquote><p>jwt 适合做简单的 restful api 认证，颁发一个固定有效期的 jwt，降低 jwt 暴露的风险，尽量不要对 jwt 做服务端的状态管理，这样才能体现出 jwt 无状态的优势。</p></blockquote><h3 id="附：java-jwt已经实现的算法"><a href="#附：java-jwt已经实现的算法" class="headerlink" title="附：java-jwt已经实现的算法"></a>附：java-jwt已经实现的算法</h3><table><thead><tr><th>JWS</th><th>算法</th><th>介绍</th></tr></thead><tbody><tr><td>HS256</td><td>HMAC256</td><td>HMAC with SHA-256</td></tr><tr><td>HS384</td><td>HMAC384</td><td>HMAC with SHA-384</td></tr><tr><td>HS512</td><td>HMAC512</td><td>HMAC with SHA-512</td></tr><tr><td>RS256</td><td>RSA256</td><td>RSASSA-PKCS1-v1_5 with SHA-256</td></tr><tr><td>RS384</td><td>RSA384</td><td>RSASSA-PKCS1-v1_5 with SHA-384</td></tr><tr><td>RS512</td><td>RSA512</td><td>RSASSA-PKCS1-v1_5 with SHA-512</td></tr><tr><td>ES256</td><td>ECDSA256</td><td>ECDSA with curve P-256 and SHA-256</td></tr><tr><td>ES384</td><td>ECDSA384</td><td>ECDSA with curve P-384 and SHA-384</td></tr><tr><td>ES512</td><td>ECDSA512</td><td>ECDSA with curve P-521 and SHA-512</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JSON-Web-Token&quot;&gt;&lt;a href=&quot;#JSON-Web-Token&quot; class=&quot;headerlink&quot; title=&quot;JSON Web Token&quot;&gt;&lt;/a&gt;JSON Web Token&lt;/h2&gt;&lt;p&gt;JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】MD5算法加盐实现用户密码加密</title>
    <link href="http://chaooo.github.io/article/20190728.html"/>
    <id>http://chaooo.github.io/article/20190728.html</id>
    <published>2019-07-28T13:49:28.000Z</published>
    <updated>2019-10-20T05:56:04.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MD5加密算法介绍"><a href="#1-MD5加密算法介绍" class="headerlink" title="1. MD5加密算法介绍"></a>1. MD5加密算法介绍</h3><p>MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。</p><a id="more"></a> <h3 id="2-MD5加密算法特点："><a href="#2-MD5加密算法特点：" class="headerlink" title="2. MD5加密算法特点："></a>2. MD5加密算法特点：</h3><ol><li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li><li>容易计算：从原数据计算出MD5值很容易。</li><li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ol><h3 id="3-盐（Salt）"><a href="#3-盐（Salt）" class="headerlink" title="3. 盐（Salt）"></a>3. 盐（Salt）</h3><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p><h3 id="4-java-security-MessageDigest类"><a href="#4-java-security-MessageDigest类" class="headerlink" title="4. java.security.MessageDigest类"></a>4. java.security.MessageDigest类</h3><p>JDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。</p><ul><li>MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。</li><li>MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。</li><li>对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。</li></ul><h3 id="5-封装一个MD5加密工具类"><a href="#5-封装一个MD5加密工具类" class="headerlink" title="5. 封装一个MD5加密工具类"></a>5. 封装一个MD5加密工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s：待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化MessageDigest的MD5算法对象</span></span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="comment">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = md.digest(s.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="comment">//将字节数组转换为16进制字符串并返回</span></span><br><span class="line">            <span class="keyword">return</span> toHex(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随即盐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">salt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用UUID生成随机盐</span></span><br><span class="line">        UUID uuid = UUID.randomUUID();</span><br><span class="line">        <span class="comment">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class="line">        String[] arr = uuid.toString().split(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转换为16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] HEX_DIGITS = <span class="string">"0123456789ABCDEF"</span>.toCharArray();</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class="line">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]);</span><br><span class="line">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class="number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-使用封装的MD5工具类完成用户注册-主要代码"><a href="#6-使用封装的MD5工具类完成用户注册-主要代码" class="headerlink" title="6. 使用封装的MD5工具类完成用户注册(主要代码)"></a>6. 使用封装的MD5工具类完成用户注册(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">register</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">//设置用户名</span></span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="comment">//密码加密后再保存</span></span><br><span class="line">    String salt = MD5Util.salt();</span><br><span class="line">    String md5Password = MD5Util.md5(password+salt);</span><br><span class="line">    <span class="comment">//存入MD5加密后的密码</span></span><br><span class="line">    user.setPassword(md5Password);</span><br><span class="line">    <span class="comment">//随机盐存入数据库，用于登录校验</span></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line">    <span class="comment">//最后将用户数据数据存入数据库</span></span><br><span class="line">    <span class="keyword">int</span> row = userDao.insert(user);</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-使用封装的MD5工具类完成用户登录-主要代码"><a href="#7-使用封装的MD5工具类完成用户登录-主要代码" class="headerlink" title="7. 使用封装的MD5工具类完成用户登录(主要代码)"></a>7. 使用封装的MD5工具类完成用户登录(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据用户名在数据库查找用户</span></span><br><span class="line">    User user = userDao.selectByName(name);</span><br><span class="line">    <span class="comment">//取出用户信息比对</span></span><br><span class="line">    String dbPassword = user.getPassword();</span><br><span class="line">    String  salt = user.getSalt();</span><br><span class="line">    <span class="comment">//通过密码+盐 重新生成 MD5密码</span></span><br><span class="line">    String md5Password = MD5Util.md5(password+salt);</span><br><span class="line">    <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">        <span class="comment">//登录成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-扩展：MessageDigest类常用方法"><a href="#8-扩展：MessageDigest类常用方法" class="headerlink" title="8. 扩展：MessageDigest类常用方法"></a>8. 扩展：MessageDigest类常用方法</h3><h4 id="8-1-构造方法摘要"><a href="#8-1-构造方法摘要" class="headerlink" title="8.1 构造方法摘要"></a>8.1 构造方法摘要</h4><p><code>MessageDigest(String algorithm)</code> –创建具有指定算法名称的MessageDigest 实例对象。</p><ul><li>MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有”MD5”，”SHA”等。</li></ul><h4 id="8-2-成员方法摘要："><a href="#8-2-成员方法摘要：" class="headerlink" title="8.2 成员方法摘要："></a>8.2 成员方法摘要：</h4><table><thead><tr><th>返回值</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Object</td><td><code>clone()</code></td><td>如果实现是可复制的，则返回一个副本。</td></tr><tr><td>byte[]</td><td><code>digest()</code></td><td>通过执行诸如填充之类的最终操作完成哈希计算。</td></tr><tr><td>byte[]</td><td><code>digest(byte[] input)</code></td><td>使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。</td></tr><tr><td>int</td><td><code>digest(byte[] buf, int offset, int len)</code></td><td>通过执行诸如填充之类的最终操作完成哈希计算。</td></tr><tr><td>String</td><td><code>getAlgorithm()</code></td><td>返回标识算法的独立于实现细节的字符串。</td></tr><tr><td>int</td><td><code>getDigestLength()</code></td><td>返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm)</code></td><td>生成实现指定摘要算法的 MessageDigest 对象。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm, Provider provider)</code></td><td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm, String provider)</code></td><td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td></tr><tr><td>Provider</td><td><code>getProvider()</code></td><td>返回此信息摘要对象的提供程序。</td></tr><tr><td>static boolean</td><td><code>isEqual(byte[] digesta, byte[] digestb)</code></td><td>比较两个摘要的相等性。</td></tr><tr><td>void</td><td><code>reset()</code></td><td>重置摘要以供再次使用。</td></tr><tr><td>String</td><td><code>toString()</code></td><td>返回此信息摘要对象的字符串表示形式。</td></tr><tr><td>void</td><td><code>update(byte input)</code></td><td>使用指定的字节更新摘要。</td></tr><tr><td>void</td><td><code>update(byte[] input)</code></td><td>使用指定的字节数组更新摘要。</td></tr><tr><td>void</td><td><code>update(byte[] input, int offset, int len)</code></td><td>使用指定的字节数组，从指定的偏移量开始更新摘要。</td></tr><tr><td>void</td><td><code>update(ByteBuffer input)</code></td><td>使用指定的 ByteBuffer 更新摘要。</td></tr></tbody></table><blockquote><p>★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-MD5加密算法介绍&quot;&gt;&lt;a href=&quot;#1-MD5加密算法介绍&quot; class=&quot;headerlink&quot; title=&quot;1. MD5加密算法介绍&quot;&gt;&lt;/a&gt;1. MD5加密算法介绍&lt;/h3&gt;&lt;p&gt;MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。&lt;/p&gt;
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】嵌入式SQL语言</title>
    <link href="http://chaooo.github.io/article/20190716.html"/>
    <id>http://chaooo.github.io/article/20190716.html</id>
    <published>2019-07-16T06:32:28.000Z</published>
    <updated>2019-10-20T05:35:37.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，</li><li>然而，交互式SQL本身也有很多局限：<a id="more"></a><ul><li>从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以</li><li>从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</li></ul></li><li>因此，高级语言+SQL语言：<ul><li>既继承高级语言的过程控制性</li><li>又结合SQL语言的复杂结果集操作的非过程性</li><li>同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作</li></ul></li><li>嵌入式SQL语言<ul><li>将SQL语言嵌入到某一种高级语言中使用</li><li>这种高级语言，如C/C++, Java, PowerBuilder等，又称宿主语言(Host Language)</li><li>嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式</li></ul></li></ul><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol><li><a href="#id1">变量声明与数据库连接</a></li><li><a href="#id2">事务Transaction</a></li><li><a href="#id3">数据集与游标</a></li><li><a href="#id4">状态捕获及错误处理机制</a></li><li><a href="#id5">动态SQL</a></li><li><a href="#id6">数据字典与SQLDA</a></li><li><a href="#id7">ODBC简介</a></li><li><a href="#id8">JDBC简介</a></li><li><a href="#id9">嵌入式SQL-ODBC-JDBC三者比较</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-变量声明与数据库连接"><a href="#1-变量声明与数据库连接" class="headerlink" title="1. 变量声明与数据库连接"></a>1. 变量声明与数据库连接</h3><ol><li>以宿主语言<strong>C语言</strong>为例，对比交互式SQL语言与嵌入式SQL语言<ul><li>交互式SQL:<code>select Sname, Sage from Student where Sname=&#39;张三&#39;;</code></li><li>嵌入式SQL:<code>exec sql select Sname, Sage into :vSname, :vSage from Student where Sname=&#39;张三&#39;;</code></li></ul></li><li>典型特点<ul><li><strong>exec sql</strong>引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句</li><li>增加一 <strong>into子句</strong>: 该子句用于指出接收SQL语句检索结果的程序变量</li><li>由冒号引导的<strong>程序变量</strong>,如: ‘:vSname’, ‘:vSage’</li></ul></li></ol><h4 id="1-1-变量的声明与使用"><a href="#1-1-变量的声明与使用" class="headerlink" title="1.1 变量的声明与使用"></a>1.1 变量的声明与使用</h4><ul><li><p>在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">    char vSname[10], specName[10]="张三";</span><br><span class="line">    int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br></pre></td></tr></table></figure></li><li><p>变量声明和赋值中，要注意：</p><ul><li>宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为’\0’，而程序中用双引号来描述。</li><li>宿主程序变量类型与数据库字段类型之间有些是有差异的,有些DBMS可支持自动转换，有些不能。</li></ul></li><li><p>声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。</p></li><li><p>嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">    char vSname[10], specName[10]="张三";</span><br><span class="line">    int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">//用户可在此处基于键盘输入给specName赋值</span><br><span class="line">exec sql <span class="keyword">select</span> Sname, Sage <span class="keyword">into</span> :vSname, :vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname = :specName;</span><br><span class="line">//比较相应的交互式SQL语句：</span><br><span class="line"><span class="keyword">select</span> Sname, Sage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-程序与数据库的连接和断开"><a href="#1-2-程序与数据库的连接和断开" class="headerlink" title="1.2 程序与数据库的连接和断开"></a>1.2 程序与数据库的连接和断开</h4><h5 id="1-2-1-数据库的连接connect"><a href="#1-2-1-数据库的连接connect" class="headerlink" title="1.2.1 数据库的连接connect"></a>1.2.1 数据库的连接connect</h5><p>在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异</p><ol><li>SQL标准中建议的连接语法为：<ul><li><code>execsql connecttotarget-server asconnect-name useruser-name;</code></li><li>或 <code>execsql connecttodefault;</code></li></ul></li><li>Oracle中数据库连接:<ul><li><code>execsql connect:user_name identified by :user_pwd;</code></li></ul></li><li>DB2 UDB中数据库连接:<ul><li><code>execsql connecttomydb user:user_name using:user_pwd;</code></li></ul></li></ol><h5 id="1-2-1-数据库的断开disconnect"><a href="#1-2-1-数据库的断开disconnect" class="headerlink" title="1.2.1 数据库的断开disconnect"></a>1.2.1 数据库的断开disconnect</h5><p>在嵌入式SQL程序执行之后，需要与数据库断开连接</p><ol><li>SQL标准中建议的断开连接的语法为：<ul><li><code>exec sql disconnect connect-name;</code></li><li>或 <code>exec sql disconnect current;</code></li></ul></li><li>Oracle中断开连接:<ul><li><code>exec sql commit release;</code></li><li>或 <code>exec sql rollback release;</code></li></ul></li><li>DB2 UDB中断开连接:<ul><li><code>exec sql connect reset;</code></li><li><code>exec sql disconnect current;</code></li></ul></li></ol><h4 id="1-3-SQL执行的提交与撤消"><a href="#1-3-SQL执行的提交与撤消" class="headerlink" title="1.3 SQL执行的提交与撤消"></a>1.3 SQL执行的提交与撤消</h4><p>SQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果</p><ol><li>SQL执行的提交：<ul><li><code>execsql commitwork;</code></li></ul></li><li>SQL执行的撤消：<ul><li><code>execsql rollbackwork;</code></li></ul></li><li>为此，很多DBMS都设计了捆绑提交/撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：<ul><li><code>execsql commitrelease;</code></li><li>或 <code>execsql rollbackrelease;</code></li></ul></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-事务Transaction"><a href="#2-事务Transaction" class="headerlink" title="2. 事务Transaction"></a>2. 事务Transaction</h3><ol><li>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务</li><li>从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li><li>简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；<strong>事务是一个不可分割的工作逻辑单元</strong>。</li></ol><h4 id="2-1-事务的特性-ACID"><a href="#2-1-事务的特性-ACID" class="headerlink" title="2.1 事务的特性: ACID"></a>2.1 事务的特性: ACID</h4><ol><li><strong>原子性</strong>Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行</li><li><strong>一致性</strong>Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的</li><li><strong>隔离性</strong>Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。</li><li><strong>持久性</strong>Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。</li></ol><blockquote><p>换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。</p></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-数据集与游标"><a href="#3-数据集与游标" class="headerlink" title="3. 数据集与游标"></a>3. 数据集与游标</h3><p>读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)</p><ol><li>检索单行结果，可将结果直接传送到宿主程序的变量中(Into)<ul><li>示例：<code>exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;</code></li></ul></li><li>检索多行结果，则需使用游标(Cursor)<ul><li>游标是指向某检索记录集的指针</li><li>通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕</li><li>读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取</li><li>记录集有结束标识EOF, 用来标记后面已没有记录了</li></ul></li></ol><ul><li>游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭</li><li>游标可以定义一次，多次打开(多次执行)，多次关闭</li></ul><h4 id="3-1-游标的使用方法"><a href="#3-1-游标的使用方法" class="headerlink" title="3.1 游标的使用方法"></a>3.1 游标的使用方法</h4><ol><li><p>Cursor的定义：declare cursor</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    Subquery</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">    [<span class="keyword">FOR</span> [ <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> columnname [, columnname…]]]];</span><br><span class="line">//示例:</span><br><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass= :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br></pre></td></tr></table></figure></li><li><p>Cursor的打开和关闭：open cursor //close cursor</p><ul><li>EXEC SQL OPEN cursor_name;</li><li>EXEC SQL CLOSE cursor_name;</li></ul></li><li><p>Cursor的数据读取：Fetch</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH cursor_name</span><br><span class="line">    INTO host-variable , [host-variable, …];</span><br><span class="line">//示例:</span><br><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass= :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br><span class="line">exec sql open cur_student;</span><br><span class="line">…</span><br><span class="line">exec sql fetch cur_student into :vSno, :vSname, :vSage</span><br><span class="line">…</span><br><span class="line">exec sql close cur_student;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-可滚动游标"><a href="#3-2-可滚动游标" class="headerlink" title="3.2 可滚动游标"></a>3.2 可滚动游标</h4><ol><li>ODBC支持的可滚动Cursor<ul><li>标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开</li><li>ODBC(OpenDataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口</li><li>许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能</li></ul></li><li>可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标<ul><li>可滚动游标移动时需判断是否到结束位置，或到起始位置<ul><li>可通过判断是否到EOF位置(最后一条记录的后面),或BOF位置(起始记录的前面)</li><li>如果不需区分，可通过whenevernotfound语句设置来检测</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name [INSENSITIVE] [<span class="keyword">SCROLL</span>] <span class="keyword">CURSOR</span></span><br><span class="line">[<span class="keyword">WITH</span> HOLD] <span class="keyword">FOR</span> Subquery</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> columnname [,</span><br><span class="line">columnname ]…];</span><br><span class="line">EXEC SQL FETCH</span><br><span class="line">[ NEXT | PRIOR | FIRST | LAST</span><br><span class="line">| [ABSOLUTE | RELATIVE] value_spec ]</span><br><span class="line">FROM cursor_name INTO host-variable [, host-variable …];</span><br></pre></td></tr></table></figure><ul><li><code>NEXT</code>向结束方向移动一条；</li><li><code>PRIOR</code>向开始方向移动一条；</li><li><code>FIRST</code>回到第一条；</li><li><code>LAST</code>移动到最后一条；</li><li><code>ABSOLUTvalue_spec</code>定向检索指定位置的行,value_spec由1至当前记录集最大值；</li><li><code>RELATIVEvalue_spec</code>相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动</li></ul><h4 id="3-3-数据库记录的增删改"><a href="#3-3-数据库记录的增删改" class="headerlink" title="3.3 数据库记录的增删改"></a>3.3 数据库记录的增删改</h4><ol><li>数据库记录的删除<ul><li>一种是查找删除(与交互式DELETE语句相同)，一种是定位删除</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">WHERE</span> search_condition | <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line">//示例：查找删除</span><br><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city = ‘Harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid);</span><br><span class="line">//示例：定位删除</span><br><span class="line">exec sql <span class="keyword">declare</span> delcust <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> cid <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city =‘harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> cid;</span><br><span class="line">exec sql open delcust</span><br><span class="line">While (TRUE) &#123;</span><br><span class="line">    exec sql fetch delcust into :cust_id;</span><br><span class="line">    exec sql delete from customers where current of delcust ; &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>数据库记录的更新<ul><li>一种是查找更新(与交互式Update语句相同)，一种是定位更新</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">UPDATE</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">SET</span> columnname = expr [, columnname = expr …]</span><br><span class="line">    [ <span class="keyword">WHERE</span> search_condition ] | <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line">//示例：查找更新</span><br><span class="line">exec sql <span class="keyword">update</span> student s <span class="keyword">set</span> sclass = ‘<span class="number">035102</span>’</span><br><span class="line">    <span class="keyword">where</span> s.sclass = ‘<span class="number">034101</span>’</span><br><span class="line">// 示例：定位更新</span><br><span class="line">exec <span class="keyword">sql</span> <span class="keyword">declare</span> stud <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.sclass =‘<span class="number">034101</span>’</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> sclass;</span><br><span class="line">exec sql open stud</span><br><span class="line">While (TRUE) &#123;</span><br><span class="line">    exec sql fetch stud into :vSno, :vSname, :vSclass;</span><br><span class="line">    exec sql update student set sclass = ‘035102’ where current of stud ; &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>数据库记录的插入<ul><li>只有一种类型的插入语句</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename [ (columnname [,columnname, …] )]</span><br><span class="line">    [ <span class="keyword">VALUES</span> (expr [ , expr , …] ) | subqurey ] ;</span><br><span class="line">//示例：插入语句</span><br><span class="line">exec sql <span class="keyword">insert</span> <span class="keyword">into</span> student ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">values</span> (‘<span class="number">03510128</span>’, ‘张三’, ‘<span class="number">035101</span>’) ;</span><br><span class="line">//示例：插入语句</span><br><span class="line">exec sql <span class="keyword">insert</span> <span class="keyword">into</span> masterstudent ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">select</span> sno, sname, sclass <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-状态捕获及错误处理机制"><a href="#4-状态捕获及错误处理机制" class="headerlink" title="4. 状态捕获及错误处理机制"></a>4. 状态捕获及错误处理机制</h3><h4 id="4-1-基本机制"><a href="#4-1-基本机制" class="headerlink" title="4.1 基本机制"></a>4.1 基本机制</h4><ul><li><p>状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理</p></li><li><p>嵌入式 SQL程序中，状态捕获及处理有三部分构成</p><ol><li>设置SQL通信区:一般在嵌入式SQL程序的开始处便设置<ul><li><code>exec sql include sqlca;</code></li></ul></li><li>设置状态捕获语句:在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域<ul><li><code>exec sql whenever sqlerror goto report_error;</code></li></ul></li><li>状态处理语句:某一段程序以应对SQL操作的某种状态<ul><li><code>report_error: exec sql rollback;</code></li></ul></li></ol></li><li><p>SQL通信区: SQLCA</p><ol><li>SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理</li><li>SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一</li></ol></li><li><p>状态捕获语句: <code>exec sql whenever condition action;</code></p><ul><li>Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).<ul><li>SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS</li><li>NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现</li><li>SQLWARNING: 不是错误，但应引起注意的条件</li></ul></li><li>如果满足condition, 则要采取一些动作(由action指出)<ul><li>CONTINUE: 忽略条件或错误，继续执行</li><li>GOTO 标号: 转移到标号所指示的语句，去进行相应的处理</li><li>STOP: 终止程序运行、撤消当前的工作、断开数据库的连接</li><li>DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行</li></ul></li></ul></li><li><p>状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    exec sql whenever sqlerror <span class="keyword">stop</span>;</span><br><span class="line">    … …</span><br><span class="line">    goto s1</span><br><span class="line">    … …</span><br><span class="line">    exec sql whenever sqlerror continue;</span><br><span class="line">    s1: exec sql <span class="keyword">update</span> agents <span class="keyword">set</span> <span class="keyword">percent</span> = <span class="keyword">percent</span> + <span class="number">1</span>;</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br><span class="line">//S1标号指示的语句受第二个Whenever语句约束。</span><br><span class="line">//注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)</span><br></pre></td></tr></table></figure></li><li><p>状态捕获语句Whenever的使用容易引发无限循环</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    exec sql whenever sqlerror goto handle_error;</span><br><span class="line">    exec sql <span class="keyword">create</span> <span class="keyword">table</span> customers(cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cname <span class="built_in">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">    … …</span><br><span class="line">    handle_error:</span><br><span class="line">        exec sql whenever sqlerror continue;// 控制是否无限循环：无，则可能；有，则不会</span><br><span class="line">        exec sql <span class="keyword">drop</span> customers;</span><br><span class="line">        exec sql disconnect;</span><br><span class="line">        fprintf(stderr,”could not <span class="keyword">create</span> customers <span class="keyword">table</span>\n”);</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-状态信息"><a href="#4-2-状态信息" class="headerlink" title="4.2 状态信息"></a>4.2 状态信息</h4><p>典型DBMS系统记录状态信息的三种方法</p><ul><li>状态记录:<ol><li><code>sqlcode</code>: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。<ul><li>sqlcode== 0, successful call;</li><li>sqlcode &lt; 0, error, e.g., from connect, database does not exist , –16;</li><li>sqlcode &gt; 0, warning, e.g., no rows retrieved from fetch</li></ul></li><li><code>sqlca.sqlcode</code>: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录</li><li><code>sqlstate</code>: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate</li></ol></li><li>当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)</li><li>但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)</li></ul><h4 id="4-3-程序自身进行错误信息的处理"><a href="#4-3-程序自身进行错误信息的处理" class="headerlink" title="4.3 程序自身进行错误信息的处理"></a>4.3 程序自身进行错误信息的处理</h4><p>正确的显式状态处理示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> declar <span class="keyword">section</span>;</span><br><span class="line">    char SQLSTATE[6];</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">exec sql whenever sqlerror goto handle_error;</span><br><span class="line">… …</span><br><span class="line">exec sql whenever sqlerror continue;</span><br><span class="line">exec sql <span class="keyword">create</span> <span class="keyword">table</span> custs</span><br><span class="line">    (cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>, cname <span class="built_in">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">if (strcmp(SQLSTATE, “82100”)==0)</span><br><span class="line">    &lt;处理82100错误的程序&gt;</span><br><span class="line">    … …</span><br></pre></td></tr></table></figure><p>上述的if语句是能被执行的，因为createtable发生错误时是继续向下执行的。</p><p><span id="id5"><span></span></span></p><h3 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h3><h4 id="5-1-动态SQL的概念"><a href="#5-1-动态SQL的概念" class="headerlink" title="5.1 动态SQL的概念"></a>5.1 动态SQL的概念</h4><p>动态SQL是相对于静态SQL而言的</p><ul><li>静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)</li><li>动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量</li></ul><h4 id="5-2-动态SQL的两种执行方式"><a href="#5-2-动态SQL的两种执行方式" class="headerlink" title="5.2 动态SQL的两种执行方式"></a>5.2 动态SQL的两种执行方式</h4><p>如SQL语句已经被构造在host-variable字符串变量中,则：</p><ol><li><strong>立即执行语句</strong>: 运行时编译并执行<ul><li><code>EXEC SQL EXECUTE IMMEDIATE :host-variable;</code></li></ul></li><li><strong>Prepare-Execute-Using语句</strong>:PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句<ul><li><code>EXEC SQL PREPARE sql_temp FROM :host-variable;</code></li><li><code>EXEC SQL EXECUTE sql_temp USING :cond-variable</code></li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-数据字典与SQLDA"><a href="#6-数据字典与SQLDA" class="headerlink" title="6. 数据字典与SQLDA"></a>6. 数据字典与SQLDA</h3><h4 id="6-1-数据字典的概念"><a href="#6-1-数据字典的概念" class="headerlink" title="6.1 数据字典的概念"></a>6.1 数据字典的概念</h4><p>数据字典(Data dictionary)，又称为系统目录(System Catalogs)</p><ul><li>是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等,这些信息又称数据库的元数据–关于数据的数据。</li><li>不同DBMS术语不一样：数据字典(DataDictionary(Oracle))、目录表(DB2UDB)、系统目录(INFORMIX)、系统视图(X/Open)</li><li>不同DBMS中系统目录存储方式可能是不同的,但会有一些信息对DBA公开。这些公开的信息,DBA可以使用一些特殊的SQL命令来检索。</li></ul><h4 id="6-2-数据字典的内容构成"><a href="#6-2-数据字典的内容构成" class="headerlink" title="6.2 数据字典的内容构成"></a>6.2 数据字典的内容构成</h4><p>数据字典通常存储的是数据库和表的元数据，即模式本身的信息：</p><ol><li>与关系相关的信息<ul><li>关系名字</li><li>每一个关系的属性名及其类型</li><li>视图的名字及其定义</li><li>完整性约束</li></ul></li><li>用户与账户信息，包括密码</li><li>统计与描述性数据：如每个关系中元组的数目</li><li>物理文件组织信息：<ul><li>关系是如何存储的(顺序/无序/散列等)</li><li>关系的物理位置</li></ul></li><li>索引相关的信息</li></ol><h4 id="6-3-数据字典的结构"><a href="#6-3-数据字典的结构" class="headerlink" title="6.3 数据字典的结构"></a>6.3 数据字典的结构</h4><ol><li>也是存储在磁盘上的关系</li><li>专为内存高效访问设计的特定的数据结构</li></ol><ul><li>可能的字典数据结构<ul><li><code>Relation_metadata</code> = <code>(relation_name, number_of_attributes, storage_organization, location)</code></li><li><code>Attribute_metadata</code> = <code>(attribute_name, relation_name, domain_type, position, length)</code></li><li><code>User_metadata</code> = <code>(user_name, encrypted_password, group)</code></li><li><code>Index_metadata</code> = <code>(index_name, relation_name, index_type, index_attributes)</code></li><li><code>View_metadata</code> = <code>(view_name, definition)</code></li></ul></li></ul><h4 id="6-4-X-Open标准的系统目录"><a href="#6-4-X-Open标准的系统目录" class="headerlink" title="6.4 X/Open标准的系统目录"></a>6.4 X/Open标准的系统目录</h4><ol><li>X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息<ul><li><code>Table_Schem</code>：表的模式名(通常是表所有者的用户名)</li><li><code>Table_Name</code>：表名</li><li><code>Table_Type</code>：<code>&#39;Base_Table&#39;</code>或<code>&#39;View&#39;</code></li></ul></li><li>可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：<ul><li><code>Select Table_Name From Tables;</code></li></ul></li><li>模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。</li><li>一般而言，一个用户有一个模式。可以使用CreateSchema语句来创建模式(用法参见相关文献)，在CreateTable等语句可以使用所定义的模式名称。</li></ol><h4 id="6-5-Oracle的数据字典"><a href="#6-5-Oracle的数据字典" class="headerlink" title="6.5 Oracle的数据字典"></a>6.5 Oracle的数据字典</h4><ol><li>Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识<ul><li><code>USER_</code> :用户视图，用户所拥有的对象，在用户模式中</li><li><code>ALL_</code>  :扩展的用户视图，用户可访问的对象</li><li><code>DBA_</code>  :DBA视图(所有用户都可访问的DBA对象的子集)</li></ul></li><li>Oracle数据字典中定义了三个视图<code>USER_Tables</code>,<code>ALL_Tables</code>,和<code>DBA_Tables</code>供DBA和用户使用数据字典中关于<strong>表的信息</strong></li><li>同样,Oracle数据字典中也定义了三个视图<code>USER_TAB_Columns</code>,<code>ALL_TAB_Columns</code>(<code>Accessible_Columns</code>),和<code>DBA_TAB_Columns</code>供DBA和用户使用数据字典中关于表的<strong>列的信息</strong></li><li>可以使用SQL语句来访问这些表中的信息：<ul><li><code>Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;</code></li></ul></li><li>Oracle数据字典中还定义了其他视图<ul><li><code>TABLE_PRIVILEDGE</code>(或<code>ALL_TAB_GRANTS</code>)</li><li><code>COLUMN_PRIVILEDGE</code>(或<code>ALL_COL_GRANTS</code>)可访问表的权限，列的权限</li><li><code>CONSTRAINT_DEFS</code>(或<code>ALL_CONSTRAINTS</code>)可访问表的各种约束</li></ul></li><li>可以使用下述命令获取Oracle定义的所有视图信息<ul><li><code>Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;</code></li></ul></li><li>如果用户使用Oracle,可使用其提供的<code>SQL*PLUS</code>进行交互式访问</li><li>动态SQL: 表和列都已知，动态构造检索条件。</li><li>动态SQL:检索条件可动态构造，表和列也可动态构造。</li></ol><h4 id="6-6-SQLDA"><a href="#6-6-SQLDA" class="headerlink" title="6.6 SQLDA"></a>6.6 SQLDA</h4><p>构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息</p><ol><li>SQLDA: SQLDescriptorArea,SQL描述符区域。<ul><li>SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等</li><li>通过读取SQLDA信息可以进行更为复杂的动态SQL的处理</li><li>不同DBMS提供的SQLDA格式并不是一致的。</li></ul></li></ol><p><span id="id7"><span></span></span></p><h3 id="7-ODBC简介"><a href="#7-ODBC简介" class="headerlink" title="7. ODBC简介"></a>7. ODBC简介</h3><h4 id="7-1-ODBC定义"><a href="#7-1-ODBC定义" class="headerlink" title="7.1 ODBC定义"></a>7.1 ODBC定义</h4><p>ODBC：Open DataBase Connection，ODBC是一种标准—不同语言的应用程序与不同数据库服务器之间通讯的标准。</p><ul><li>一组API(应用程序接口)，支持应用程序与数据库服务器的交互</li><li>应用程序通过调用ODBC API, 实现<ol><li>与数据服务器的连接</li><li>向数据库服务器发送SQL命令</li><li>一条一条的提取数据库检索结果中的元组传递给应用程序的变量</li></ol></li><li>具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。</li><li>ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；</li></ul><h4 id="7-2-通过ODBC连接数据库"><a href="#7-2-通过ODBC连接数据库" class="headerlink" title="7.2 通过ODBC连接数据库"></a>7.2 通过ODBC连接数据库</h4><ol><li>ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中</li><li>当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果</li><li>ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄</li><li>应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:<ul><li><code>connection handle</code>, 连接句柄</li><li><code>the server</code>，要连接的数据库服务器</li><li><code>the user identifier</code>，用户</li><li><code>password</code> ，密码</li><li><code>SQL_NTS</code> 类型说明前面的参数是空终止的字符串</li></ul></li><li>示例<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int ODBCexample()&#123;</span><br><span class="line">    RETCODE error; <span class="comment">/* 返回状态吗 */</span></span><br><span class="line">    HENV env; <span class="comment">/* 环境变量 */</span></span><br><span class="line">    HDBC conn; <span class="comment">/* 连接句柄 */</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line">    //分配数据库连接环境</span><br><span class="line">    SQLConnect(conn, "aura.bell-labs.com", SQL_NTS, "avi", SQL_NTS, avipasswd", SQL_NTS);</span><br><span class="line">    //打开一个数据库连接</span><br><span class="line">    &#123; …. Do actual work … &#125;</span><br><span class="line">    //与数据库通讯</span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">    //断开连接与释放环境</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-3-通过ODBC与数据库服务器进行通讯"><a href="#7-3-通过ODBC与数据库服务器进行通讯" class="headerlink" title="7.3 通过ODBC与数据库服务器进行通讯"></a>7.3 通过ODBC与数据库服务器进行通讯</h4><ol><li>应用程序使用SQLExecDirect()向数据库发送SQL命令；</li><li>使用SQLFetch()获取产生的结果元组；</li><li>使用SQLBindCol()绑定C语言变量与结果中的属性<ul><li>当获取一个元组时，属性值会自动地传送到相应的C语言变量中</li></ul></li><li>SQLBindCol()的参数：<ul><li>ODBC定义的stmt变量,查询结果中的属性位置</li><li>SQL到C的类型变换,变量的地址.</li><li>对于类似字符数组一样的可变长度类型，应给出<ul><li>•变量的最大长度</li><li>•当获取到一个元组后，实际长度的存储位置.</li><li>•注:当返回实际长度为负数，说明是一个空值。</li></ul></li></ul></li><li>示例<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">char branchname[80]; float balance;</span><br><span class="line">int lenOut1, lenOut2;</span><br><span class="line">HSTMT stmt;</span><br><span class="line">SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line">//分配一个与指定数据库连接的新的语句句柄</span><br><span class="line">char * sqlquery = "select branch_name, sum (balance)</span><br><span class="line">    from account</span><br><span class="line">    group by branch_name";</span><br><span class="line">error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line">//执行查询，stmt句柄指向结果集合</span><br><span class="line">if (error == SQL_SUCCESS) &#123;</span><br><span class="line">SQLBindCol(stmt, 1, SQL_C_CHAR, branchname , 80, &amp;lenOut1);</span><br><span class="line">SQLBindCol(stmt, 2, SQL_C_FLOAT, &amp;balance, 0 , &amp;lenOut2);</span><br><span class="line">//绑定高级语言变量与stmt句柄中的属性</span><br><span class="line">while (SQLFetch(stmt) &gt;= SQL_SUCCESS) &#123;</span><br><span class="line">//提取一条记录，结果数据被存入高级语言变量中</span><br><span class="line">    printf (" %s %g\n", branchname, balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SQLFreeStmt(stmt, SQL_DROP);</span><br><span class="line">//释放语句句柄</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-4-ODBC的其他功能"><a href="#7-4-ODBC的其他功能" class="headerlink" title="7.4 ODBC的其他功能"></a>7.4 ODBC的其他功能</h4><ol><li>动态SQL语句的预编译-动态参数传递功能</li><li>获取元数据特性<ul><li>发现数据库中的所有关系的特性 以及</li><li>发现每一个查询结果的列的名字和类型等；</li></ul></li><li>默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。<ul><li>应用程序可以关闭一个连接的自动提交特性<ul><li><code>SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)}</code></li></ul></li><li>此时事务要显式地给出提交和撤销的命令<ul><li><code>SQLTransact(conn, SQL_COMMIT)</code> or <code>SQLTransact(conn, SQL_ROLLBACK)</code></li></ul></li></ul></li></ol><p><span id="id8"><span></span></span></p><h3 id="8-JDBC简介"><a href="#8-JDBC简介" class="headerlink" title="8. JDBC简介"></a>8. JDBC简介</h3><h4 id="8-1-JDBC定义"><a href="#8-1-JDBC定义" class="headerlink" title="8.1 JDBC定义"></a>8.1 JDBC定义</h4><p>JDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。</p><ul><li>JDBCAPI分成两个程序包：<ul><li>Java.sql 核心API –J2SE(Java2标准版)的一部分。使用<code>java.sql.DriverManager</code>类、<code>java.sql.Driver</code>和<code>java.sql.Connection</code>接口连接到数据库</li><li>Javax.sql 可选扩展API–J2EE(Java2企业版)的一部分。包含了基于<code>JNDI(JavaNamingandDirectoryInterface,Java命名和目录接口)</code>的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。</li></ul></li></ul><h4 id="8-2-JDBC的功能"><a href="#8-2-JDBC的功能" class="headerlink" title="8.2 JDBC的功能"></a>8.2 JDBC的功能</h4><ol><li><code>java.sql.DriverManager</code>——处理驱动的调入并且对产生新数据库连接提供支持</li><li><code>Java.sql.Driver</code>——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。</li><li><code>java.sql.Connection</code>——代表对特定数据库的连接。</li><li><code>Try {…} Catch {…}</code> ——异常捕获及其处理</li><li><code>java.sql.Statement</code>——对特定的数据库执行SQL语句</li><li><code>java.sql.PreparedStatement</code> —— 用于执行预编译的SQL语句</li><li><code>java.sql.CallableStatement</code> ——用于执行对数据库内嵌过程的调用。</li><li><code>java.sql.ResultSet</code>——从当前执行的SQL语句中返回结果数据。</li></ol><h4 id="8-3-使用JDBC-API访问数据库的过程"><a href="#8-3-使用JDBC-API访问数据库的过程" class="headerlink" title="8.3 使用JDBC API访问数据库的过程"></a>8.3 使用JDBC API访问数据库的过程</h4><ol><li><p>概念性的基本过程</p><ul><li>打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制</li></ul></li><li><p>具体实施过程</p><ol><li>•传递一个Driver给DriverManager，加载数据库驱动。<ul><li><code>Class.forName()</code></li></ul></li><li>•通过URL得到一个Connection对象, 建立数据库连接<ul><li><code>DriverManager.getConnection(sDBUrl)</code></li><li><code>DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)</code></li></ul></li><li>•接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<ul><li><code>Statement stmt=con.createStatement()</code></li></ul></li><li>•查询返回一个ResultSet。<ul><li><code>ResultSet rs=stmt.executeQuery(sSQL)</code></li></ul></li></ol></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">try</span> &#123; <span class="comment">//错误捕获</span></span><br><span class="line">    Class.forName (<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    Connection conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span>, userid, passwd);</span><br><span class="line">    <span class="comment">//加载数据库驱动，建立数据库连接</span></span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    <span class="comment">//创建一个语句对象</span></span><br><span class="line">    … Do Actual Work ….</span><br><span class="line">    <span class="comment">//进行SQL语句的执行与处理工作</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    <span class="comment">//关闭语句对象，关闭连接</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">    System.out.println(<span class="string">"SQLException : "</span> + sqle); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完整的示例程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName (<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    Connection conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span>, userid, passwd);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt.executeUpdate( <span class="string">"insert into instructor values</span></span><br><span class="line"><span class="string">        (‘77987', ‘Kim', ‘Physics’,98000)"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">"插入错误:"</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">    ResultSet rset = stmt.executeQuery(</span><br><span class="line">        <span class="string">"select dept_name, avg(salary) from instructor group by dept_name"</span>);</span><br><span class="line">    <span class="keyword">while</span> ( rset.next() ) &#123;</span><br><span class="line">        System.out.println(rset.getString(“dept_name<span class="string">") + "</span> <span class="string">" + rset.getFloat(2));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    stmt.close();</span></span><br><span class="line"><span class="string">    conn.close();</span></span><br><span class="line"><span class="string">&#125; catch (SQLException sqle) &#123;</span></span><br><span class="line"><span class="string">    System.out.println("</span>SQLException:<span class="string">" + sqle);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id9"><span></span></span></p><h3 id="9-嵌入式SQL-ODBC-JDBC三者比较"><a href="#9-嵌入式SQL-ODBC-JDBC三者比较" class="headerlink" title="9. 嵌入式SQL-ODBC-JDBC三者比较"></a>9. 嵌入式SQL-ODBC-JDBC三者比较</h3><p>执行一条SQL语句，读取执行的结果集合</p><ol><li>嵌入式SQL的思维模式<ol><li>建立数据库连接</li><li>声明一个游标</li><li>打开游标</li><li>读取一条记录(循环)</li><li>关闭游标</li><li>断开数据库连接</li></ol></li><li>ODBC的思维模式<ol><li>建立数据库连接</li><li>分配语句句柄</li><li>用句柄执行SQL</li><li>建立高级语言变量与句柄属性的对应</li><li>读取一条记录(循环)</li><li>释放语句句柄</li><li>断开数据库连接</li></ol></li><li>JDBC的思维模式<ol><li>建立数据库连接</li><li>创建语句对象</li><li>用语句对象执行SQL，并返回结果对象</li><li>从结果对象获取一条记录</li><li>提取对象的属性值传给高级语言变量(返回上一步)</li><li>释放语句对象</li><li>断开数据库连接</li></ol></li></ol><ul><li>相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致</li><li>不同点, 操作方式的不同:<ul><li>嵌入式SQL按照语句进行操作</li><li>ODBC按照函数来进行操作</li><li>JDBC按照对象来进行操作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，&lt;/li&gt;
&lt;li&gt;然而，交互式SQL本身也有很多局限：
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】数据库语言SQL</title>
    <link href="http://chaooo.github.io/article/20190701.html"/>
    <id>http://chaooo.github.io/article/20190701.html</id>
    <published>2019-07-01T11:36:31.000Z</published>
    <updated>2019-10-20T05:35:08.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h3><p><strong>结构化查询语言</strong>(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p><ul><li>SQL语言是集DDL、DML和DCL于一体的数据库语言<a id="more"></a><ol><li><strong>DDL语句</strong>引导词：Create(建立),Alter(修改),Drop(撤消)<ul><li>模式的定义和删除，包括定义Database,Table,View,Index,完整性约束条件等，也包括定义对象(RowType行对象,Type列对象)</li></ul></li><li><strong>DML语句</strong>引导词：Insert ,Delete, Update, Select<ul><li>各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入</li><li>各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等</li><li>各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等</li></ul></li><li><strong>DCL语句</strong>引导词：Grant,Revoke<ul><li>安全性控制：授权和撤消授权</li></ul></li></ol></li></ul><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol><li><a href="#id1">利用SQL建立数据库</a></li><li><a href="#id2">利用SQL简单查询</a></li><li><a href="#id3">利用SQL多表联合查询</a></li><li><a href="#id4">利用SQL进行增-删-改</a></li><li><a href="#id5">利用SQL语言修正与撤销数据库</a></li><li><a href="#id6">SQL Server介绍</a></li><li><a href="#id7">SQL语言-子查询</a></li><li><a href="#id8">SQL语言-结果计算与聚集计算</a></li><li><a href="#id9">SQL语言-分组查询与分组过滤</a></li><li><a href="#id10">SQL语言实现关系代数操作</a></li><li><a href="#id11">SQL语言之视图及其应用</a></li><li><a href="#id12">数据库完整性</a></li><li><a href="#id13">数据库的静态完整性(约束)</a></li><li><a href="#id14">数据库的动态完整性(触发器)</a></li><li><a href="#id15">数据库索引</a></li><li><a href="#id16">数据库序列</a></li><li><a href="#id17">数据库安全性</a></li><li><a href="#id18">数据库自主安全性机制</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-利用SQL建立数据库"><a href="#1-利用SQL建立数据库" class="headerlink" title="1. 利用SQL建立数据库"></a>1. 利用SQL建立数据库</h3><p>DDL：数据定义语言（Data Definition Language)，<br>DDL通常由<strong>DBA(数据库管理员)</strong>来使用，也有经DBA授权后由应用程序员来使用</p><ol><li>创建数据库(DB)：<strong>Create Database</strong><ul><li>数据库(Database)是若干具有相互关联关系的Table/Relation的集合</li><li>简单语法形式：<code>create database database 数据库名;</code></li></ul></li><li>创建DB中的Table(定义关系模式)：<strong>Create Table</strong><ul><li><code>Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);</code><ul><li><code>[]</code>表示其括起的内容可以省略，<code>|</code>表示其隔开的两项可取其一</li><li><code>Primary key</code>: 主键约束。每个表只能创建一个主键约束</li><li><code>Unique</code>: 唯一性约束(即候选键)。可以有多个唯一性约束</li><li><code>Not null</code>: 非空约束。</li></ul></li></ul></li><li><strong>数据类型</strong>（SQL-92标准）<ul><li><code>char(n)</code>:固定长度的字符串</li><li><code>varchar(n)</code>:可变长字符串</li><li><code>int</code>:整数 //有时不同系统也写作integer</li><li><code>numeric(p，q)</code>:固定精度数字，小数点左边p位，右边(p-q)位</li><li><code>real</code>:浮点精度数字 //有时不同系统也写作<code>float(n)</code>，小数点后保留n位</li><li><code>date</code>:日期 (如 2003-09-12)</li><li><code>time</code>:时间 (如 23:15:003)<blockquote><p>注意: 现行商用DBMS的数据类型有时有些差异</p></blockquote></li></ul></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-利用SQL简单查询"><a href="#2-利用SQL简单查询" class="headerlink" title="2. 利用SQL简单查询"></a>2. 利用SQL简单查询</h3><p>DML：数据操纵语言（Data Manipulation Language)，<br>DML通常由<strong>用户或应用程序员</strong>使用，访问经授权的数据库</p><ol><li><p>向Table中添加数据(追加元组)：<strong>Insert into</strong></p><ul><li><strong><code>insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);</code></strong><ul><li>values值的排列，须与列名排列一致</li><li>若所有列名省略，则values值的排列须与该表存储中的列名排列一致</li></ul></li></ul></li><li><p>单表查询<strong>Select</strong></p><ul><li><strong><code>Select Select 列名[[,列名] …] From 表名[Where 检索条件];</code></strong><ul><li>语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。</li><li>相当于：<code>Π[列名,...,列名](σ检索条件(表名))</code></li></ul></li><li>Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。</li></ul></li><li><p>检索条件的书写<strong>Where</strong></p><ul><li>与选择运算<code>σF(R)</code>的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。</li><li><code>Select Tname From Teacher Where Salary &gt; 2000 and D# = ’03’;</code>//检索教师表中所有工资大于2000元 并且是03系的教师姓名</li></ul></li><li><p>排重(<code>DISTINCT</code>)</p><ul><li>关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。</li><li>在Table中要求无重复元组是通过定义Primary key或Unique来保证的;</li><li>而在检索结果中要求无重复元组, 是通过<strong>DISTINCT保留字</strong>的使用来实现的。</li><li><code>Select DISTINCT S# From SC Where Score &gt; 80;</code></li></ul></li><li><p>排序(<code>ORDER BY</code>)</p><ul><li>Select语句中结果排序是通过增加<strong>order by</strong>子句实现的</li><li><code>order by 列名 [asc|desc]</code></li><li>意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。</li></ul></li><li><p>模糊查询(<code>*LIKE*</code>)</p><ul><li><code>_</code>：一个字符，<code>%</code>：任意长度字符。</li><li><code>Select Sname From Student Where Sname Like &#39;张_ _&#39;;</code>//检索名字为张某某的所有同学姓名</li><li><code>Select Sname From Student Where Sname Not Like &#39;张%&#39;;</code>//检索名字不姓张的所有同学姓名</li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-利用SQL多表联合查询"><a href="#3-利用SQL多表联合查询" class="headerlink" title="3. 利用SQL多表联合查询"></a>3. 利用SQL多表联合查询</h3><p>多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。</p><ul><li>检索语句: <strong><code>Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;</code></strong></li><li>相当于<code>Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))</code></li><li>检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接</li></ul><ol><li><p>θ-连接之<strong>等值连接</strong></p><ul><li>多表连接时，如两个表的属性名相同，则需采用<strong><code>表名.属性名</code></strong>方式来限定该属性是属于哪一个表</li><li><code>Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#=&#39;001&#39; Order By Score DESC;</code>//按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)</li></ul></li><li><p>属性重名重名处理(表别名)</p><ul><li>连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用<strong><code>别名</code></strong>以便区分</li><li><code>Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;</code></li><li>当定义了别名后，在检索条件中可以使用别名来限定属性</li><li>as 可以省略</li></ul></li><li><p>θ-连接之<strong>不等值连接</strong></p><ul><li><code>Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary&gt;T2.Salary;</code>//求有薪水差额的任意两位教师</li></ul></li><li><p>实例：</p><ul><li><code>Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#=&#39;001&#39; and S2.C#=&#39;002&#39; and S1.Score &gt; S2.Score;</code>//求“001”号课成绩比“002”号课成绩高的所有学生的学号</li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-利用SQL进行增-删-改"><a href="#4-利用SQL进行增-删-改" class="headerlink" title="4. 利用SQL进行增-删-改"></a>4. 利用SQL进行增-删-改</h3><ol><li>SQL-之<strong>更新操作</strong><ul><li>元组新增Insert：新增一个或一些元组到数据库的Table中</li><li>元组更新Update:对某些元组中的某些属性值进行重新设定</li><li>元组删除Delete：删除某些元组</li></ul></li></ol><blockquote><ul><li>SQL-DML既能单一记录操作，也能对记录集合进行批更新操作</li><li>SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等</li></ul></blockquote><ol start="2"><li>SQL-之<strong>INSERT</strong><ul><li>单一元组新增命令形式：插入一条指定元组值的元组<ul><li><strong><code>insert into 表名 [(列名[,列名]…)] values (值 [,值]…);</code></strong></li></ul></li><li>批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。<ul><li><strong><code>insert into 表名 [(列名[，列名]…)] 子查询;</code></strong></li><li>示例：<code>Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like &#39;%伟&#39;;</code>//将检索到的满足条件的同学新增到该表中</li></ul></li></ul></li></ol><blockquote><p>注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。</p></blockquote><ol start="3"><li><p>SQL-之<strong>DELETE</strong></p><ul><li>元组删除Delete命令: 删除满足指定条件的元组</li><li><strong><code>Delete From 表名 [ Where 条件表达式];</code></strong></li><li>如果Where条件省略，则删除所有的元组(清空表)。</li><li>示例：<code>Delete From Student Where S# in ( Select S# From SC Where Score &lt; 60 Group by S# Having Count(*)&gt;= 4);</code>//删除有四门不及格课程的所有同学</li></ul></li><li><p>SQL-之<strong>UPDATE</strong></p><ul><li>元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值</li><li><strong><code>Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];</code></strong></li><li>如果Where条件省略，则更新所有的元组。</li><li>示例：<code>Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname=&#39;计算机&#39;);</code>//将所有计算机系的教师工资上调10%</li></ul></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-利用SQL语言修正与撤销数据库"><a href="#5-利用SQL语言修正与撤销数据库" class="headerlink" title="5. 利用SQL语言修正与撤销数据库"></a>5. 利用SQL语言修正与撤销数据库</h3><ol><li><p>修正基本表的定义</p><ul><li><strong><code>alter table tablename</code></strong></li><li><strong><code>[add {colname datatype, …}]</code></strong> //增加新列</li><li><strong><code>[drop {完整性约束名}]</code></strong> //删除完整性约束</li><li><strong><code>[modify {colname datatype, …}]</code></strong> //修改列定义</li><li>示例：<code>Alter Table Student Drop Unique(Sname);</code>删除学生姓名必须取唯一值的约束</li><li>示例：<code>Alter Table Student Add Saddr char[40],PID char[18];</code>在学生表Student上增加二列Saddr, PID</li></ul></li><li><p>SQL-DDL之撤销与修改</p><ul><li><code>drop table 表名;</code> //撤消基本表</li><li><code>drop database 数据库名;</code> //撤消数据库</li></ul></li><li><p>SQL-DDL之数据库指定与关闭命令</p><ul><li>有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。</li><li><code>use 数据库名;</code> //指定当前数据库</li><li><code>close 数据库名;</code> //关闭当前数据库</li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-SQL-Server介绍"><a href="#6-SQL-Server介绍" class="headerlink" title="6. SQL Server介绍"></a>6. SQL Server介绍</h3><p>SQL Server 是 Microsoft提供的一款关系数据库管理系统</p><ol><li>SQL Server 的系统数据库<ul><li>Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。</li><li>Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。</li><li>Msdb：代理服务数据库，提供一个存储空间。</li><li>Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。</li></ul></li><li>SQL Server的数据库<ul><li>文件：有三种文件扩展名：.mdf、.ndf、.ldf<ul><li>主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。</li><li>辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。</li><li>日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。</li></ul></li><li>页面：是SQL Server存储的最小单位。一页为8K或8192字节。</li><li>空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位</li></ul></li></ol><h4 id="6-1-SQL-Server数据库的创建-删除与维护"><a href="#6-1-SQL-Server数据库的创建-删除与维护" class="headerlink" title="6.1 SQL Server数据库的创建-删除与维护"></a>6.1 SQL Server数据库的创建-删除与维护</h4><ol><li>创建数据库<ul><li>语法形式：Create Database 库名</li><li>可视化操作(查询分析器)：Database(鼠标右键) -&gt; new Database… -&gt; 填写数据库名及配置</li><li>创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。</li><li>创建数据库的用户自动成为数据库的拥有者。</li></ul></li><li>删除数据库<ul><li>语法形式：Drop Database 库名</li><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Delete</li><li>对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。</li><li>当数据库处于正在使用或正在恢复状态时，不能删除。</li></ul></li><li>备份数据库<ul><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Back Up…</li><li>备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。<ul><li>完全数据库备份：完全备份数据文件和日志文件。</li><li>差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。</li><li>事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。</li><li>数据库文件和文件组备份：用在数据库相当大的情况下。</li></ul></li></ul></li><li>恢复数据库<ul><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Restore</li><li>数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。</li><li>数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。</li><li>可以通过企业管理器来完成数据库恢复。</li></ul></li><li>数据库授权: <ul><li>语法形式：grant 权限 on 表名 to 用户名</li><li>权限有：select,update,insert,delete,exec,dri。</li><li>对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.</li></ul></li></ol><h4 id="6-2-SQL-Server数据表的创建-与增-删-改-查"><a href="#6-2-SQL-Server数据表的创建-与增-删-改-查" class="headerlink" title="6.2 SQL Server数据表的创建-与增/删/改/查"></a>6.2 SQL Server数据表的创建-与增/删/改/查</h4><ol><li>创建表<ul><li>同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。</li><li>用T-SQL语句创建表，语法形式：<code>CREATE TABLE [数据库名.所有者名.]表名 ({&lt;列名 数据类型&gt;} [缺省值][约束][是否为空] …)</code><blockquote><p>注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持</p></blockquote></li><li>可视化操作(查询分析器)：数据库名 -&gt; Tables -&gt; New Table…</li></ul></li><li>增加、修改表字段<ul><li>语法形式：<code>ALTER TABLE ADD | ALTER 字段名 &lt;类型&gt;</code></li></ul></li><li>创建、删除与修改约束<ul><li>约束是SQL提供自动保持数据库完整性的一种方法，共5种。</li><li>用T-SQL语句建立约束，语法形式：<code>CONSTRAINT 约束名 约束类型 (列名)</code><ul><li>约束名：在库中应该唯一，如不指定，系统会给出</li><li>约束类型 (5种)：<ul><li>primary key constraint (主键值)</li><li>unique constraint (唯一性)</li><li>check constraint (检查性)</li><li>default constraint (默认)</li><li>foreign key constraint (外部键)</li></ul></li><li>列名：要约束的字段名</li></ul></li><li>示例:<code>Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));</code></li></ul></li></ol><p><span id="id7"><span></span></span></p><h3 id="7-SQL语言-子查询"><a href="#7-SQL语言-子查询" class="headerlink" title="7. SQL语言-子查询"></a>7. SQL语言-子查询</h3><ul><li>子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。</li><li>三种类型的子查询：(NOT) IN-子查询；θ-Some/θ-All子查询；(NOT) EXISTS子查询</li></ul><h4 id="7-1-NOT-IN子查询"><a href="#7-1-NOT-IN子查询" class="headerlink" title="7.1 (NOT) IN子查询"></a>7.1 (NOT) IN子查询</h4><ol><li>基本语法：<code>表达式 [not] in (子查询)</code><ul><li>语法中，表达式的最简单形式就是列名或常数。</li><li>语义：判断某一表达式的值是否在子查询的结果中。</li><li>示例：<ul><li><code>Select * From Student Where Sname in (&#39;张三&#39;, &#39;王三&#39;);</code>//列出张三、王三同学的所有信息</li><li><code>Select S#, Sname From Student Where S# in (Select S# From SC Where C#=&#39;001&#39;);</code>//列出选修了001号课程的学生的学号和姓名</li></ul></li></ul></li><li>非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询</li><li>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询</li><li>外层向内层传递的参量需要使用外层的表名或表别名来限定<ul><li>示例：<code>Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#=&#39;001&#39;);</code>//求学过001号课程的同学的姓名</li></ul></li></ol><blockquote><p>注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。</p></blockquote><h4 id="7-2-θ-Some-θ-All子查询"><a href="#7-2-θ-Some-θ-All子查询" class="headerlink" title="7.2 θ-Some/θ-All子查询"></a>7.2 θ-Some/θ-All子查询</h4><ol><li>基本语法：<code>表达式 θ some (子查询)</code> / <code>表达式 θ all (子查询)</code><ul><li>语法中，θ是比较运算符：<code>&lt;, &gt;, &gt;=, &lt;=, =, &lt;&gt;</code>。</li><li>语义：将表达式的值与子查询的结果进行比较：<ul><li>如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则<code>表达式 θ some (子查询)</code>的结果便为真</li><li>如果表达式的值与子查询结果的所有值相比较都满足 关系，则<code>表达式 θ all (子查询)</code>的结果便为真</li></ul></li><li>示例：<ul><li><code>Select Tname From Teacher Where Salary &lt;= all ( Select Salary From Teacher);</code>//找出工资最低的教师姓名</li><li><code>Select S# From SC Where C# = “001” and Score &lt; some ( Select Score From SC Where C#=&#39;001&#39;);</code>//找出001号课成绩不是最高的所有学生的学号</li></ul></li></ul></li></ol><blockquote><p>在SQL标准中，也有θ-Any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。</p></blockquote><ol start="2"><li>等价性变换需要注意<ul><li><code>表达式 = some (子查询)</code>和<code>表达式 in (子查询)</code>含义<strong>相同</strong></li><li><code>表达式 &lt;&gt; some (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>不同</strong></li><li><code>表达式 &lt;&gt; all (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>相同</strong></li></ul></li></ol><h4 id="7-3-NOT-EXISTS子查询"><a href="#7-3-NOT-EXISTS子查询" class="headerlink" title="7.3 (NOT) EXISTS子查询"></a>7.3 (NOT) EXISTS子查询</h4><ol><li>基本语法：<code>[not] Exists [not] Exists (子查询)</code><ul><li>语义：子查询结果中有无元组存在</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：检索选修了赵三老师主讲课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC, Course, Teacher</span><br><span class="line">        <span class="keyword">Where</span> SC.C<span class="comment">#=Course.C# and SC. S#=Student.S#</span></span><br><span class="line">        <span class="keyword">and</span> Course.T<span class="comment"># = Teacher.T# and Tname='赵三');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--示例：检索学过001号教师主讲的所有课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> //不存在</span><br><span class="line">        ( <span class="keyword">Select</span> * <span class="keyword">From</span> Course //有一门<span class="number">001</span>教师主讲课程</span><br><span class="line">        <span class="keyword">Where</span> Course.T<span class="comment"># = ‘001’ and not exists //该同学没学过</span></span><br><span class="line">            ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC</span><br><span class="line">            <span class="keyword">Where</span> S<span class="comment"># = Student.S# and C# = Course.C#));</span></span><br><span class="line"><span class="comment">--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过</span></span><br></pre></td></tr></table></figure><p><span id="id8"><span></span></span></p><h3 id="8-SQL语言-结果计算与聚集计算"><a href="#8-SQL语言-结果计算与聚集计算" class="headerlink" title="8. SQL语言-结果计算与聚集计算"></a>8. SQL语言-结果计算与聚集计算</h3><h4 id="8-1-结果计算"><a href="#8-1-结果计算" class="headerlink" title="8.1 结果计算"></a>8.1 结果计算</h4><p>Select-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算</p><ul><li><code>Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];</code><ul><li>expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书</li><li>agfunc()是一些聚集函数</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求有差额(差额&gt;0)的任意两位教师的薪水差额</span></span><br><span class="line"><span class="keyword">Select</span> T1.Tname <span class="keyword">as</span> TR1, T2.Tname <span class="keyword">as</span> TR2, T1.Salary – T2.Salary</span><br><span class="line">    <span class="keyword">From</span> Teacher T1, Teacher T2</span><br><span class="line">    <span class="keyword">Where</span> T1.Salary &gt; T2.Salary;</span><br></pre></td></tr></table></figure><h4 id="8-2-聚集函数"><a href="#8-2-聚集函数" class="headerlink" title="8.2 聚集函数"></a>8.2 聚集函数</h4><p>SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc,分别是：COUNT、SUM、AVG、MAX、MIN</p><table><thead><tr><th>聚合函数</th><th>支持的数据类型</th><th>描述</th></tr></thead><tbody><tr><td>count()</td><td>任何类型/*</td><td>计算结果集中的总行数</td></tr><tr><td>sum()</td><td>Numeric</td><td>计算指定列中所有非空值的总和</td></tr><tr><td>avg()</td><td>numeric</td><td>计算指定列中所有非空值的平均值</td></tr><tr><td>max()</td><td>char/numeric</td><td>返回指定列中最大值</td></tr><tr><td>min()</td><td>char/numeric</td><td>返回指定列中最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Sum</span>(Salary) <span class="keyword">From</span> Teacher;</span><br><span class="line"><span class="comment">--示例：求计算机系教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Sum</span>(Salary) <span class="keyword">From</span> Teacher T, Dept</span><br><span class="line">    <span class="keyword">Where</span> Dept.Dname = ‘计算机’ <span class="keyword">and</span> Dept.D<span class="comment"># = T.D#;</span></span><br><span class="line"><span class="comment">--示例：求数据库课程的平均成绩</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">AVG</span>(Score) <span class="keyword">From</span> Course C, SC</span><br><span class="line">    <span class="keyword">Where</span> C.Cname = ‘数据库’ <span class="keyword">and</span> C.C<span class="comment"># = SC.C#;</span></span><br></pre></td></tr></table></figure><p><span id="id9"><span></span></span></p><h3 id="9-SQL语言-分组查询与分组过滤"><a href="#9-SQL语言-分组查询与分组过滤" class="headerlink" title="9. SQL语言-分组查询与分组过滤"></a>9. SQL语言-分组查询与分组过滤</h3><h4 id="9-1-分组查询"><a href="#9-1-分组查询" class="headerlink" title="9.1 分组查询"></a>9.1 分组查询</h4><p>分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。</p><ol><li><p>分组的基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 ] ;</span><br></pre></td></tr></table></figure></li><li><p>分组条件可以是：<code>列名1, 列名2, …</code></p></li><li><p>示例： 求每一个学生的平均成绩</p><ul><li><code>Select S#, AVG(Score) From SC Group by S#;</code></li></ul></li></ol><h4 id="9-2-分组过滤"><a href="#9-2-分组过滤" class="headerlink" title="9.2 分组过滤"></a>9.2 分组过滤</h4><p>聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤</p><ul><li>分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。</li><li>Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。</li></ul><ol><li><p>基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 [ <span class="keyword">Having</span> <span class="keyword">Having</span> 分组过滤条件] ] ;</span><br></pre></td></tr></table></figure></li><li><p>示例：求不及格课程超过两门的同学的学号</p><ul><li><code>Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2;</code> </li></ul></li></ol><h4 id="9-3-where子句与having子句的区别"><a href="#9-3-where子句与having子句的区别" class="headerlink" title="9.3 where子句与having子句的区别"></a>9.3 where子句与having子句的区别</h4><ol><li>聚合函数是比较where、having 的关键。在from后面的执行顺序：<ul><li><code>where -&gt; 聚合函数(sum,min,max,avg,count) -&gt;having</code></li></ul></li><li>列出group by来比较二者:<ul><li>where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。</li><li>having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。</li></ul></li></ol><blockquote><p>注意事项 ： </p><ol><li>where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 </li><li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 </li><li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</li></ol></blockquote><p><span id="id10"><span></span></span></p><h3 id="10-SQL语言实现关系代数操作"><a href="#10-SQL语言实现关系代数操作" class="headerlink" title="10. SQL语言实现关系代数操作"></a>10. SQL语言实现关系代数操作</h3><p>SQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。</p><ul><li>基本语法形式：<ul><li><code>子查询 {Union [ALL] | Intersect [ALL] | Except [ALL] 子查询}</code></li></ul></li><li>通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。<ul><li>假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：<ul><li>子查询1 Union ALL 子查询2 ，出现m + n次</li><li>子查询1 Intersect ALL 子查询2 ，出现min(m,n)次</li><li>子查询1 Except ALL 子查询2 ，出现max(0, m – n)次</li></ul></li></ul></li></ul><blockquote><p>UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但<strong>有些DBMS并不支持</strong>这些运算，使用时要注意。</p></blockquote><h4 id="10-1-SQL并运算-UNION"><a href="#10-1-SQL并运算-UNION" class="headerlink" title="10.1 SQL并运算(UNION)"></a>10.1 SQL并运算(UNION)</h4><ol><li>示例：已知两个表<ul><li>Customers(Cid, Cname, City, Discnt)</li><li>Agents(Aid, Aname, City, Percent)</li></ul></li><li>求客户所在的或者代理商所在的城市<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Customers</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Agents;</span><br></pre></td></tr></table></figure></li></ol><h4 id="10-2-SQL交运算-INTERSECT"><a href="#10-2-SQL交运算-INTERSECT" class="headerlink" title="10.2 SQL交运算(INTERSECT)"></a>10.2 SQL交运算(INTERSECT)</h4><ol><li><p>示例：求既学过002号课，又学过003号课的同学学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘002’</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘003’;</span></span><br></pre></td></tr></table></figure></li><li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p><ul><li><code>Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);</code></li></ul></li><li><p>交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。</p></li></ol><h4 id="10-3-SQL差运算-EXCEPT"><a href="#10-3-SQL差运算-EXCEPT" class="headerlink" title="10.3 SQL差运算(EXCEPT)"></a>10.3 SQL差运算(EXCEPT)</h4><ol><li><p>示例： 假定所有学生都有选课，求没学过002号课程的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S<span class="comment"># From SC</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘002’;</span></span><br></pre></td></tr></table></figure></li><li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S<span class="comment"># From SC SC1</span></span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC</span><br><span class="line">        <span class="keyword">Where</span> C<span class="comment"># = ‘002’ and S# = SC1.S#);</span></span><br></pre></td></tr></table></figure></li><li><p>差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。</p></li></ol><h4 id="10-4-空值的处理"><a href="#10-4-空值的处理" class="headerlink" title="10.4 空值的处理"></a>10.4 空值的处理</h4><p>空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p><ol><li>在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。</li><li>空值检测：<ul><li><code>is [not ] null</code> //测试指定列的值是否为空值</li></ul></li><li>示例：找出年龄值为空的学生姓名<ul><li><code>Select Sname From Student Where Sage is null;</code></li></ul></li><li>现行DBMS的空值处理小结<ul><li>除is[not]null之外，空值不满足任何查找条件</li><li>如果null参与算术运算，则该算术表达式的值为null</li><li>如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown</li><li>如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li></ul></li></ol><h4 id="10-5-内连接、外连接"><a href="#10-5-内连接、外连接" class="headerlink" title="10.5 内连接、外连接"></a>10.5 内连接、外连接</h4><ol><li><p>标准SQL语言中连接运算通常为：</p><ul><li><code>Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;</code></li><li>即相当于采用<code>Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))</code>。</li></ul></li><li><p>SQL的高级语法中引入了内连接与外连接运算，具体形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 [ [, 列名] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [<span class="keyword">NATURAL</span>]</span><br><span class="line">    [ <span class="keyword">INNER</span> | &#123; <span class="keyword">LEFT</span> | <span class="keyword">RIGHT</span> | <span class="keyword">FULL</span>&#125; [<span class="keyword">OUTER</span>]] <span class="keyword">JOIN</span> 表名<span class="number">2</span></span><br><span class="line">    &#123; <span class="keyword">ON</span> 连接条件 | <span class="keyword">Using</span> (Colname &#123;, Colname …&#125;) &#125;</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ] … ;</span><br></pre></td></tr></table></figure></li><li><p>由 <strong>连接类型</strong> 和 <strong>连接条件</strong> 构成连接运算。</p><ul><li><strong><code>Natural</code></strong>：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次</li><li><strong><code>Inner Join</code></strong>: 即关系代数中的θ-连接运算</li><li><strong><code>Left Outer Join, Right Outer Join, Full Outer Join</code></strong>: 即关系代数中的外连接运算</li><li><strong><code>on &lt;连接条件&gt;</code></strong>：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li><li><strong><code>using (Col1, Col2, …, Coln)</code></strong>：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次</li></ul></li><li><p>示例:</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher.T<span class="comment">#, Tname, Cname</span></span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Inner</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T<span class="comment"># = Course.T#</span></span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T<span class="comment"># ASC;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher. T<span class="comment">#, Tname, Cname</span></span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Left</span> <span class="keyword">Outer</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T<span class="comment"># = Course.T#</span></span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T<span class="comment"># ASC ;</span></span><br></pre></td></tr></table></figure><p><span id="id11"><span></span></span></p><h3 id="11-SQL语言之视图及其应用"><a href="#11-SQL语言之视图及其应用" class="headerlink" title="11. SQL语言之视图及其应用"></a>11. SQL语言之视图及其应用</h3><ol><li>数据库的三级模式两层映像<ul><li>三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成</li><li>应用–&gt; <strong>外模式</strong>(多个) –&gt; <strong>概念模式</strong>(一个) –&gt; <strong>内模式</strong>(一个) –&gt; 数据库</li><li>两层映像：<code>E-C</code>映像(外模式-&gt;概念模式)、<code>C-I</code>映像(概念模式-&gt;内模式)。</li></ul></li><li>对应概念模式的数据在SQL中被称为<strong>基本表(Table)</strong>,而对应外模式的数据称为<strong>视图(View)</strong>。<strong>视图不仅包含外模式，而且包含其E-C映像</strong>。</li><li><strong>基本表</strong>是实际存储于存储文件中的表，基本表中的<strong>数据是需要存储的</strong></li><li><strong>视图</strong>在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其<strong>数据并不存储</strong>，而是在运行过程中动态产生与维护的</li><li>对视图数据的更改最终要反映在对基本表的更改上。</li></ol><h4 id="11-1-视图的定义"><a href="#11-1-视图的定义" class="headerlink" title="11.1 视图的定义"></a>11.1 视图的定义</h4><p>视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。</p><ol><li>定义视图: <code>create view view_name [(列名[列名] …)] as 子查询 [with check option]</code><ul><li>如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。</li><li>with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式</li></ul></li><li>示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> CompStud <span class="keyword">AS</span></span><br><span class="line">    (<span class="keyword">Select</span> * <span class="keyword">From</span> Student</span><br><span class="line">        <span class="keyword">Where</span> D<span class="comment"># in (Select D# From Dept</span></span><br><span class="line">            <span class="keyword">Where</span> Dname = ‘计算机’));</span><br></pre></td></tr></table></figure></li></ol><h4 id="11-2-视图的使用"><a href="#11-2-视图的使用" class="headerlink" title="11.2 视图的使用"></a>11.2 视图的使用</h4><p>使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用</p><ul><li>示例：检索计算机系的所有学生，我们可使用CompStud<ul><li><code>Select * From CompStud;</code></li></ul></li><li>示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud<ul><li><code>Select * From CompStud Where Sage&lt;20;</code></li></ul></li></ul><h4 id="11-3-视图的更新"><a href="#11-3-视图的更新" class="headerlink" title="11.3 视图的更新"></a>11.3 视图的更新</h4><p>SQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。</p><ol><li>SQL视图更新的可执行性<ul><li>如果视图的select目标列包含聚集函数，则不能更新</li><li>如果视图的select子句使用了unique或distinct，则不能更新</li><li>如果视图中包括了groupby子句，则不能更新</li><li>如果视图中包括经算术表达式计算出来的列，则不能更新</li><li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li></ul></li><li>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新</li><li>可更新SQL视图示例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CStud(S<span class="comment">#, Sname, Sclass)</span></span><br><span class="line"><span class="keyword">as</span> ( <span class="keyword">select</span> S<span class="comment">#, Sname, Sclass from Student where D# ='03');</span></span><br><span class="line"><span class="comment">-- 更新视图</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> CStud <span class="keyword">Values</span> (<span class="string">'98030104'</span>, <span class="string">'张三丰'</span>, <span class="string">'980301'</span>);</span><br><span class="line"><span class="comment">-- 更新视图 将转换为 更新基本表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span> (<span class="string">'98030104'</span>, <span class="string">'张三丰'</span>, <span class="literal">Null</span>, <span class="literal">Null</span>, <span class="string">'03'</span>, <span class="string">'980301'</span>)</span><br></pre></td></tr></table></figure><h4 id="11-4-视图的撤销"><a href="#11-4-视图的撤销" class="headerlink" title="11.4 视图的撤销"></a>11.4 视图的撤销</h4><p>已经定义的视图也可以撤消</p><ul><li>撤消视图：<code>Drop View view_name</code></li></ul><p>不仅视图可以撤消，基本表、数据库等都可以撤消</p><ul><li>撤消基本表：<code>Drop Table 表名</code></li></ul><p><span id="id12"><span></span></span></p><h3 id="12-数据库完整性"><a href="#12-数据库完整性" class="headerlink" title="12. 数据库完整性"></a>12. 数据库完整性</h3><p>数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性–在任何情况下的正确性、有效性和一致性</p><ul><li>广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等</li><li>狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。</li></ul><h4 id="12-1-基本概念"><a href="#12-1-基本概念" class="headerlink" title="12.1 基本概念"></a>12.1 基本概念</h4><p>关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性</p><ol><li>数据库完整性管理的作用<ul><li>防止和避免数据库中不合理数据的出现</li><li>DBMS应尽可能地自动防止DB中语义不合理现象</li><li>如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担</li></ul></li><li>DBMS怎样自动保证完整性：<ul><li>DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)</li><li>当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性</li></ul></li><li><strong>完整性约束条件</strong>(或称完整性约束规则)的一般形式：Integrity Constraint::=(O,P,A,R)<ul><li>O：数据集合：约束的对象(列、多列(元组)、元组集合)</li><li>P：谓词条件：需要定义什么样的约束</li><li>A：触发条件：默认更新时检查</li><li>R：响应动作：默认拒绝</li></ul></li></ol><h4 id="12-2-数据库完整性的分类"><a href="#12-2-数据库完整性的分类" class="headerlink" title="12.2 数据库完整性的分类"></a>12.2 数据库完整性的分类</h4><ol><li><p>按约束对象分类:</p><ul><li>域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的</li><li>关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断</li></ul></li><li><p>按约束来源分类:</p><ul><li>结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；</li><li>内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。</li></ul></li><li><p>按约束状态分类:</p><ul><li>静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。</li><li>动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。</li></ul></li></ol><p><span id="id13"><span></span></span></p><h3 id="13-数据库的静态完整性-约束"><a href="#13-数据库的静态完整性-约束" class="headerlink" title="13. 数据库的静态完整性(约束)"></a>13. 数据库的静态完整性(约束)</h3><ol><li><p>SQL语言支持的约束类别：</p><ul><li>静态约束<ul><li>列完整性—域完整性约束</li><li>表完整性–关系完整性约束</li></ul></li><li>动态约束<ul><li>触发器</li></ul></li></ul></li><li><p>CreateTable有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性</p><ul><li>定义完整性约束条件：列完整性、表完整性</li></ul></li><li><p>列约束：一种<strong>域约束类型</strong>，对单一列的值进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; NOT NULL |                  //列值非空</span><br><span class="line">[ CONSTRAINT constraintname ] //为约束命名，便于以后撤消</span><br><span class="line">&#123; UNIQUE                      //列值是唯一</span><br><span class="line">| PRIMARY KEY                 //列为主键</span><br><span class="line">| <span class="keyword">CHECK</span> (search_cond)         //列值满足条件,条件只能使用列当前值</span><br><span class="line">| <span class="keyword">REFERENCES</span> tablename [(colname) ]</span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">DELETE</span> &#123; <span class="keyword">CASCADE</span> | <span class="keyword">SET</span> <span class="literal">NULL</span> &#125; ] &#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>表约束：一种<strong>关系约束类型</strong>，对多列或元组的值进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ CONSTRAINT constraintname ]       //为约束命名，便于以后撤消</span><br><span class="line">&#123; UNIQUE (colname &#123;,colname…&#125;)      //几列值组合在一起是唯一</span><br><span class="line">| PRIMARY KEY (colname &#123;,colname…&#125;) //几列联合为主键</span><br><span class="line">| <span class="keyword">CHECK</span> (search_condition)          //元组多列值共同满足条件</span><br><span class="line">                                    //条件中只能使用同一元组的不同列当前值</span><br><span class="line">| <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (colname &#123;,colname…&#125;)</span><br><span class="line"><span class="keyword">REFERENCES</span> tablename [(colname &#123;,colname…&#125;)]//引用另一表tablename的若干列的值作为外键</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。</p></blockquote><ol start="5"><li><p>Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)</p><ul><li>示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)<ul><li><code>Alter Table SC DROP CONSTRAINT ctscore;</code></li></ul></li><li>有些DBMS支持独立的追加约束,注意书写格式可能有些差异<ul><li>示例：<code>Alter Table SC Add Constraint nctscore check (Score&gt;=0.0 and Score&lt;=150.0));</code></li></ul></li></ul></li><li><p>现约束的方法-断言ASSERTION</p><ul><li>一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件</li><li>表约束和列约束就是一些特殊的断言</li><li>SQL还提供了复杂条件表达的断言。其语法形式为：<ul><li><code>CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt;</code></li></ul></li><li>当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">assertion</span> sum_constraint <span class="keyword">check</span></span><br><span class="line">    (<span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> branch</span><br><span class="line">    <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">sum</span>(amount ) <span class="keyword">from</span> loan</span><br><span class="line">        <span class="keyword">where</span> loan.branch_name = branch.branch_name )</span><br><span class="line">    &gt;= (<span class="keyword">select</span> <span class="keyword">sum</span> (balance ) <span class="keyword">from</span> <span class="keyword">account</span></span><br><span class="line">        <span class="keyword">where</span> account.branch_name = branch.branch_name )))</span><br><span class="line"><span class="comment">-- 数据表：</span></span><br><span class="line"><span class="keyword">account</span>(branch_name, account_number,…, balance) //分行，账户及其余额</span><br><span class="line">loan(branch_name , loan_number, amount,) //分行的每一笔贷款</span><br><span class="line">branch(branch_name, … ) //分行</span><br></pre></td></tr></table></figure><blockquote><p>断言测试增加了数据库维护的负担，要小心使用复杂的断言。</p></blockquote><p><span id="id14"><span></span></span></p><h3 id="14-数据库的动态完整性-触发器"><a href="#14-数据库的动态完整性-触发器" class="headerlink" title="14. 数据库的动态完整性(触发器)"></a>14. 数据库的动态完整性(触发器)</h3><p>实现数据库动态完整的方法—触发器Trigger</p><ol><li><p>触发器Trigger</p><ul><li>Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger</li><li>Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。</li></ul></li><li><p>基本语法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span></span><br><span class="line">    &#123; <span class="keyword">INSERT</span> | <span class="keyword">DELETE</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> colname &#123;, colname...&#125;] &#125;</span><br><span class="line">    <span class="keyword">ON</span> tablename [<span class="keyword">REFERENCING</span> corr_name_def &#123;, corr_name_def...&#125; ]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> | <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span>]</span><br><span class="line">                //对更新操作的每一条结果(前者)，或整个更新操作完成(后者)</span><br><span class="line">    [<span class="keyword">WHEN</span> (search_condition)]           //检查条件，如满足执行下述程序</span><br><span class="line">    &#123; <span class="keyword">statement</span>         //单行程序直接书写，多行程序要用下行方式</span><br><span class="line">    | BEGIN ATOMIC statement; &#123; statement;...&#125; END &#125;</span><br></pre></td></tr></table></figure></li><li><p>触发器Trigger意义：</p><ul><li>当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件<code>search_condition</code>,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用<code>corr_name_def</code>来限定。</li></ul></li><li><p>事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}</p><ul><li>当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发</li><li>操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由<code>corr_name_def</code>的使用来区分</li></ul></li><li><p><code>corr_name_def</code>的定义</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; OLD [ROW] [AS] old_row_corr_name //更新前的旧元组命别名为</span><br><span class="line">| NEW [ROW] [AS] new_row_corr_name //更新后的新元组命别名为</span><br><span class="line">| OLD TABLE [AS] old_table_corr_name //更新前的旧Table命别名为</span><br><span class="line">| NEW TABLE [AS] new_table_corr_name //更新后的新Table命别名为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>corr_name_def</code>将在检测条件或后面的动作程序段中被引用处理</p></blockquote><ol start="6"><li><p>示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> teacher_chgsal <span class="keyword">before</span> <span class="keyword">update</span> <span class="keyword">of</span> salary</span><br><span class="line">    <span class="keyword">on</span> teacher</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> x, <span class="keyword">old</span> y</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">when</span> (x.salary &lt; y.salary)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    raise_application_error(<span class="number">-20003</span>, <span class="string">'invalid salary on update'</span>);</span><br><span class="line">    //此条语句为Oracle的错误处理函数</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> sumc <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> sc</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> <span class="keyword">row</span> newi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> SumCourse = SumCourse + <span class="number">1</span></span><br><span class="line">    <span class="keyword">where</span> S<span class="comment"># = :newi.S# ;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> delS<span class="comment"># after delete on Student</span></span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">old</span> oldi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> sc <span class="keyword">where</span> S<span class="comment"># = :oldi.S# ;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li></ol><p><span id="id15"><span></span></span></p><h3 id="15-数据库索引"><a href="#15-数据库索引" class="headerlink" title="15. 数据库索引"></a>15. 数据库索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种<strong>数据结构</strong>（最常见的是B-Tree）</p><ol><li>索引的作用<ol><li>快速取数据；</li><li>保证数据记录的唯一性；</li><li>实现表与表之间的参照完整性；</li><li>在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。</li></ol></li><li>创建索引：<code>CREATE INDEX  索引名称  on 表名(字段名);</code></li><li>删除索引：<code>DROP INDEX 索引名称</code></li><li>索引注意事项：<ol><li>查询时减少使用<code>*</code>返回全部列，不要返回不需要的列</li><li>where表达式子句包含索引的表达式置前</li><li>避免在Order by中使用表达式</li><li>索引技术是数据库自动使用，一个表格只存在一个索引就够了</li></ol></li><li>缺点<ol><li>索引的缺点是创建和维护索引需要耗费时间和空间</li><li>索引可以提高查询速度，会减慢写入速度</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li></ol></li></ol><h4 id="15-1-索引主要种类"><a href="#15-1-索引主要种类" class="headerlink" title="15.1 索引主要种类"></a>15.1 索引主要种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p><ol><li>唯一索引<ul><li>唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</li></ul></li><li>主键索引<ul><li>数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</li></ul></li><li>聚集索引<ul><li>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</li></ul></li><li>索引列<ul><li>可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</li></ul></li></ol><p><span id="id16"><span></span></span></p><h3 id="16-数据库序列"><a href="#16-数据库序列" class="headerlink" title="16. 数据库序列"></a>16. 数据库序列</h3><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要<code>CREATE SEQUENCE</code>系统权限。</p><h4 id="16-1-Oracle中的序列（Sequence）"><a href="#16-1-Oracle中的序列（Sequence）" class="headerlink" title="16.1 Oracle中的序列（Sequence）"></a>16.1 Oracle中的序列（Sequence）</h4><ol><li><p>创建序列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> 序列名 </span><br><span class="line">    [<span class="keyword">increment</span> <span class="keyword">by</span> n]   <span class="comment">--每次增加n个，默认为1</span></span><br><span class="line">    [<span class="keyword">start</span> <span class="keyword">with</span> n]     <span class="comment">--起始值n，默认为1</span></span><br><span class="line">    [&#123;maxvalue n | <span class="keyword">nomaxvalue</span>&#125;]  <span class="comment">--最大值设置，递增默认10的27次方，递减默认-1</span></span><br><span class="line">    [&#123;<span class="keyword">minvalue</span> n | <span class="keyword">nominvalue</span>&#125;]  <span class="comment">--最小值设置，递增默认1，递减默认-10的26次方</span></span><br><span class="line">    [&#123;<span class="keyword">cycle</span> | <span class="keyword">nocycle</span>&#125;]   <span class="comment">--是否循环</span></span><br><span class="line">    [&#123;<span class="keyword">cache</span> n | nocache&#125;] <span class="comment">--是否对序列进行内存缓冲，默认为20</span></span><br></pre></td></tr></table></figure></li><li><p>查询序列</p><ul><li><code>NEXTVAL</code>:返回序列中下一个有效的值，任何用户都可以引用。</li><li><code>CURRVAL</code>:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询下一个将要使用的序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.nextval <span class="keyword">from</span> dual</span><br><span class="line"><span class="comment">--查询当前序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.currval <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure><blockquote><ul><li>Oracle将sequence的定义存储在数据字典之中。</li><li>Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。</li></ul></blockquote><ol start="3"><li>删除序列：<code>Drop sequence 序列名</code></li><li>更改序列：<code>Alter sequence 序列名 [其余参数同创建序列]</code></li><li>使用序列示例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.直接使用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person (<span class="keyword">id</span>, <span class="keyword">name</span>, <span class="keyword">password</span>) <span class="keyword">values</span> (序列名.nextval, <span class="string">'张三'</span>, <span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值</span></span><br><span class="line"><span class="comment">-- 2.1创建触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> 触发器名 <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> person</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> 序列名.nextval <span class="keyword">into</span> :new.id <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 2.2插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person ( username, age, <span class="keyword">password</span>) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="number">20</span>, <span class="string">'zhang123'</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>注意点：<ul><li>一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。</li><li>当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。</li><li>大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。</li></ul></li></ol><h4 id="16-2-Mysql中的序列（AUTO-INCREMENT）"><a href="#16-2-Mysql中的序列（AUTO-INCREMENT）" class="headerlink" title="16.2 Mysql中的序列（AUTO_INCREMENT）"></a>16.2 Mysql中的序列（AUTO_INCREMENT）</h4><p>MySQL中最简单使用序列的方法就是使用<code>AUTO_INCREMENT</code>来定义列。</p><ol><li>orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。</li><li>首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。</li><li>mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.</li><li>mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。</li></ol><p><span id="id17"><span></span></span></p><h3 id="17-数据库安全性"><a href="#17-数据库安全性" class="headerlink" title="17. 数据库安全性"></a>17. 数据库安全性</h3><p>数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏</p><ol><li>数据库安全性管理涉及许多方面<ol><li>社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法</li><li>公共政策/制度方面：例如，政府或组织的信息公开或非公开制度</li><li>安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)</li><li>数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)</li><li>数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制</li></ol></li><li>DBMS的安全机制<ol><li><strong>自主安全性机制</strong>：存取控制(AccessControl)<ul><li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li></ul></li><li><strong>强制安全性机制</strong>：<ul><li>通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据</li></ul></li><li>推断控制机制：<ul><li>防止通过历史信息，推断出不该被其知道的信息；</li><li>防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li></ul></li><li>数据加密存储机制：<ul><li>通过加密、解密保护数据，密钥、加密/解密方法与传输</li></ul></li></ol></li><li>DBA的责任和义务<ul><li>熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略</li><li>规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，</li><li><strong>划分好数据的安全级别以及用户的安全级别</strong></li><li>实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等</li></ul></li></ol><p><span id="id18"><span></span></span></p><h3 id="18-数据库自主安全性机制"><a href="#18-数据库自主安全性机制" class="headerlink" title="18. 数据库自主安全性机制"></a>18. 数据库自主安全性机制</h3><ul><li>通常情况下，自主安全性是通过授权机制来实现的。</li><li>用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。<ul><li>授权者：决定用户权利的人</li><li>授权：授予用户访问的权利</li></ul></li></ul><ol><li>DBMS自动实现自主安全性：<ul><li>DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)</li><li>当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问</li></ul></li><li>DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制<ul><li><code>AccessRule ::=(S, O, t, P)</code><ul><li>S: 请求主体(用户)</li><li>O: 访问对象</li><li>t: 访问权利</li><li>P: 谓词</li></ul></li><li>{AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;</li><li>用户多时，可以按用户组建立访问规则</li><li>访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库</li><li>权利：包括创建、增、删、改、查等</li><li>谓词：拥有权利需满足的条件</li></ul></li><li><strong>示例</strong>：员工管理数据库的安全性控制示例<code>Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)</code><ul><li>示例要求：<ul><li>员工管理人员：能访问该数据库的所有内容，便于维护员工信息</li><li>收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问</li><li>每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改</li><li>部门领导：能够查询其所领导部门人员的所有情况</li><li>高层领导：能访问该数据库的所有内容，但只能读</li></ul></li><li>两种控制示例<ul><li>按名控制安全性：存储矩阵</li><li>按内容控制安全性：视图</li></ul></li><li>视图是安全性控制的重要手段</li><li>通过视图可以限制用户对关系中某些数据项的存取,例如：<ul><li>视图1：CreateEmpV1as select*fromEmployee</li><li>视图2：CreateEmpV2as selectPname,D#fromEmployee</li></ul></li><li>通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：<ul><li>视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId</li><li>视图2： CreateEmpV4asselect*fromEmployeewhereHead=:UserId</li></ul></li><li>用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述</li></ul></li></ol><h4 id="18-1-SQL语言的用户与权利"><a href="#18-1-SQL语言的用户与权利" class="headerlink" title="18.1 SQL语言的用户与权利"></a>18.1 SQL语言的用户与权利</h4><ol><li><p>SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴</p></li><li><p>授权机制—自主安全性；视图的运用</p></li><li><p>关系级别(普通用户) &lt;– 账户级别(程序员用户) &lt;– 超级用户(DBA) </p><ul><li>(级别1)Select : 读(读DB, Table, Record, Attribute, … )</li><li>(级别2)Modify : 更新<ul><li>Insert : 插入(插入新元组, … )</li><li>Update : 更新(更新元组中的某些值, …)</li><li>Delete : 删除(删除元组, …)</li></ul></li><li>(级别3)Create : 创建(创建表空间、模式、表、索引、视图等)<ul><li>Create : 创建</li><li>Alter : 更新</li><li>Drop : 删除</li></ul></li></ul></li><li><p>级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。</p></li><li><p>授权命令<code>GRANT</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &#123;<span class="keyword">all</span> <span class="keyword">PRIVILEGES</span> | privilege &#123;,privilege…&#125;&#125;</span><br><span class="line">    <span class="keyword">ON</span> [<span class="keyword">TABLE</span>] tablename | viewname</span><br><span class="line">    <span class="keyword">TO</span> &#123;<span class="keyword">public</span> | <span class="keyword">user</span>-<span class="keyword">id</span> &#123;, <span class="keyword">user</span>-<span class="keyword">id</span>…&#125;&#125;</span><br><span class="line">    [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure><ul><li>user-id ，某一个用户账户，由DBA创建的合法账户</li><li>public, 允许所有有效用户使用授予的权利</li><li>privilege是下面的权利<ul><li>SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES</li></ul></li><li>WITH GRANT OPTION选项是允许被授权者传播这些权利</li></ul></li><li><p>SQL-DCL的控制安全性-授权示例:</p><ul><li>假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)<ul><li>Grant All Priviledges ON Employee TO Emp2001;</li><li>Grant SELECT ON EmpV2 TO Emp5001;</li><li>Grant SELECT ON EmpV3 TO public;</li><li>Grant SELECT ON EmpV4 TO Emp0021;</li></ul></li><li>授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)</li><li>授权者授予的权利必须是授权者已经拥有的权利</li></ul></li><li><p>收回授权命令<code>REVOKE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &#123;<span class="keyword">all</span> <span class="keyword">privilEges</span> | priv &#123;, priv…&#125; &#125; </span><br><span class="line">    <span class="keyword">ON</span> tablename | viewname</span><br><span class="line">    <span class="keyword">FROM</span> &#123;<span class="keyword">public</span> | <span class="keyword">user</span> &#123;, <span class="keyword">user</span>…&#125; &#125;;</span><br></pre></td></tr></table></figure><ul><li>示例: <code>revoke select on employee from UserB;</code></li></ul></li></ol><h4 id="18-2-自主安全性的授权过程及其问题"><a href="#18-2-自主安全性的授权过程及其问题" class="headerlink" title="18.2 自主安全性的授权过程及其问题"></a>18.2 自主安全性的授权过程及其问题</h4><h5 id="18-2-1-授权过程"><a href="#18-2-1-授权过程" class="headerlink" title="18.2.1 授权过程:"></a>18.2.1 授权过程:</h5><ol><li>第一步：DBA创建DB, 并为每一个用户创建一个账户<ul><li>假定建立了五个用户：UserA, UserB, UserC, UserD, UserE</li></ul></li><li>第二步：DBA授予某用户账户级别的权利<ul><li>假定授予UserA</li></ul></li><li>第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利<ul><li>假定UserA创建了Employee, 则UserA就是Employee表的属主账户</li></ul></li><li>第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…<ul><li>假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。</li></ul></li></ol><ul><li>注意授权的传播范围<ul><li>传播范围包括两个方面：水平传播数量和垂直传播数量<ul><li>水平传播数量是授权者的再授权用户数目(树的广度)</li><li>垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)</li></ul></li><li>有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。</li><li>当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回</li><li>如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。</li></ul></li></ul><h5 id="18-2-2-强制安全性机制"><a href="#18-2-2-强制安全性机制" class="headerlink" title="18.2.2 强制安全性机制"></a>18.2.2 强制安全性机制</h5><ol><li>强制安全性机制<ul><li>强制安全性通过对数据对象进行安全性分级<ul><li>绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)</li></ul></li><li>同时对用户也进行上述的安全性分级</li><li>从而强制实现不同级别用户访问不同级别数据的一种机制</li></ul></li><li>强制安全性机制的实现<ul><li>DBMS引入强制安全性机制, 可以通过扩展关系模式来实现<ul><li>关系模式: R(A1: D1, A2: D2, …, An:Dn)</li><li>对属性和元组引入安全性分级特性或称分类特性<ul><li>R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性</li></ul></li></ul></li><li>这样, 关系中的每个元组, 都将扩展为带有安全分级的元组</li><li>强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL语言概述&quot;&gt;&lt;a href=&quot;#SQL语言概述&quot; class=&quot;headerlink&quot; title=&quot;SQL语言概述&quot;&gt;&lt;/a&gt;SQL语言概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;结构化查询语言&lt;/strong&gt;(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL语言是集DDL、DML和DCL于一体的数据库语言
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
</feed>
