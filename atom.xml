<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路，走过去，前面是个天！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chaooo.github.io/"/>
  <updated>2019-10-30T13:58:11.606Z</updated>
  <id>http://chaooo.github.io/</id>
  
  <author>
    <name>郑超(Charles·Zheng)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java知识梳理】常见集合类 的 数据结构</title>
    <link href="http://chaooo.github.io/article/20191003.html"/>
    <id>http://chaooo.github.io/article/20191003.html</id>
    <published>2019-10-03T14:53:06.000Z</published>
    <updated>2019-10-30T13:58:11.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合-Collection-Map"><a href="#集合-Collection-Map" class="headerlink" title="集合(Collection/Map)"></a>集合(Collection/Map)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection接口</span><br><span class="line">    |———— List接口</span><br><span class="line">        |———— ArrayList类</span><br><span class="line">        |———— Vector类</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">        |———— Stack类</span><br><span class="line">    |———— Set接口</span><br><span class="line">        |———— HashSet类</span><br><span class="line">        |———— TreeSet类</span><br><span class="line">        |———— LinkedHashSet类</span><br><span class="line">    |———— Queue接口</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">Map接口</span><br><span class="line">    |———— HashMap类</span><br><span class="line">    |———— TreeMap类</span><br><span class="line">    |———— LinkedHashMap类</span><br><span class="line">    |———— Hashtable类</span><br></pre></td></tr></table></figure><h4 id="0-1-List"><a href="#0-1-List" class="headerlink" title="0.1 List"></a>0.1 List</h4><ul><li><strong>Arraylist</strong>： 动态数组</li><li>Vector： 动态数组(线程安全)</li><li><strong>LinkedList</strong>： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><h4 id="0-2-Set"><a href="#0-2-Set" class="headerlink" title="0.2 Set"></a>0.2 Set</h4><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li><li>TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树)</li></ul><h4 id="0-3-Map"><a href="#0-3-Map" class="headerlink" title="0.3 Map"></a>0.3 Map</h4><ul><li><strong>HashMap</strong>： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间</li><li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，<strong>增加了一条双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>Hashtable： 数组+链表(线程安全)，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h4 id="0-4-如何选用集合"><a href="#0-4-如何选用集合" class="headerlink" title="0.4 如何选用集合"></a>0.4 如何选用集合</h4><p>主要根据集合的特点来选用：</p><ul><li>键值对就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.</li><li>只需要存放元素值时，就选用Collection接口下的集合，需要保证元素唯一时选择实现Set接口的集合（TreeSet或HashSet），不需要就选择实现List接口的ArrayList或LinkedList</li></ul><h4 id="0-5-对数公式log-与-时空复杂度"><a href="#0-5-对数公式log-与-时空复杂度" class="headerlink" title="0.5 对数公式log 与 时空复杂度"></a>0.5 对数公式log 与 时空复杂度</h4><ul><li>若<code>a^n = b</code> (a&gt;0,a≠1) 则 <code>n = log(a)b</code> , 如<code>log(2)8 = 3</code>; Java数据结构中log默认以2为底(个人理解,有待考证)</li><li>常用O(1), O(n), O(logn)表示对应算法的时间复杂度, 也用于表示空间复杂度。<ul><li><strong><code>O(1)</code></strong>: 最低的时空复杂度, 无论数据规模多大，都可以在一次计算后找到目标</li><li><strong><code>O(n)</code></strong>: 数据量增大n倍时，耗时增大n倍; 比如常见的遍历算法</li><li><strong><code>O(n^2)</code></strong>: 数据量增大n倍时，耗时增大n的平方倍; 比如冒泡排序，对n个数排序，需要扫描n×n次</li><li><strong><code>o(logn)</code></strong>: 当数据增大n倍时，耗时增大logn倍; 二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标(2^8=256)</li><li><strong><code>O(nlogn)</code></strong>: 同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度</li></ul></li></ul><h4 id="0-6-移位运算符"><a href="#0-6-移位运算符" class="headerlink" title="0.6  移位运算符"></a>0.6  移位运算符</h4><p>按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移) 和 &gt;&gt;&gt;(无符号右移)</p><ul><li><code>左移 &lt;&lt;</code> : 丢弃最高位,0补最低位；左移n位就相当于乘以2的n次方</li><li><code>右移 &gt;&gt;</code> : 符号位不变,高位补上符号位(正数0, 负数1)；右移n位相当于除以2的n次方</li><li><code>无符号右移 &gt;&gt;&gt;</code> : 忽略符号位，0补最高位(补码移位所得)</li></ul><blockquote><ul><li>正数的左移与右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。</li><li>负数的右移，就是补码高位补1,然后按位取反加1即可。</li></ul></blockquote><ul><li>运算规则：<ul><li>左移：高位移出(舍弃)，低位的空位补零；int类型时，每移动1位它的第31位就要被移出并且丢弃；long类型时，每移动1位它的第63位就要被移出并且丢弃；byte和short类型时，将自动把这些类型扩大为int型。</li><li>右移：低位移出(舍弃)，高位的空位补符号位，即正数补0，负数补1；当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。</li><li>无符号右移：补码移位，高位补0；正数和右移表现一致，负数变成了很大的正数；</li></ul></li></ul><h3 id="1-Arraylist"><a href="#1-Arraylist" class="headerlink" title="1. Arraylist"></a>1. Arraylist</h3><p>ArrayList的底层是数组队列，相当于<strong>动态数组</strong>。与数组相比，它的容量能动态增长。在添加大量元素前，应用程序使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p><ul><li><strong>数组</strong>时间复杂度: <strong>插入/删除:O(n)</strong>，<strong>增加(末尾)/随机访问: O(1)</strong></li><li>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的<strong>添加、删除、修改、遍历</strong>等功能</li><li>ArrayList 实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是<strong>快速随机访问</strong></li><li>ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，<strong>能被克隆</strong>。</li><li>ArrayList 实现java.io.Serializable 接口，这意味着ArrayList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>和 Vector 不同，ArrayList 中的操作<strong>不是线程安全的</strong>！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li></ul><h4 id="1-1-ArrayList扩容机制-（重点）"><a href="#1-1-ArrayList扩容机制-（重点）" class="headerlink" title="1.1 ArrayList扩容机制*（重点）"></a>1.1 ArrayList扩容机制*（重点）</h4><ul><li>以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组；当add第一个元素时，才真正分配容量(<strong>默认10</strong>)</li><li>ArrayList在每次增加元素(1个或一组)时，都要调用<code>ensureCapacityInternal()</code>方法来确保足够的容量</li><li>当容量不足以容纳当前的元素个数时，进入<code>grow()</code>方法进行扩容，首先设置新的容量为旧容量的<strong>1.5倍</strong></li><li>若设置后的新容量还不够，则设置新容量为<code>minCapacity</code>(所需最小容量)</li><li>比较新容量是否大于<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)，若大于，再比较<code>minCapacity</code>是否大于<code>MAX_ARRAY_SIZE</code>，若大于，设置新的容量为<code>Integer.MAX_VALUE</code>(Integer最大值)，否则设置新的容量为<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)</li><li>最后用<code>Arrays.copyof()</code>方法将元素拷贝到新的数组</li><li>(第<code>Integer.MAX_VALUE+1</code>次添加元素时，抛出<code>OutOfMemoryError</code>异常)</li></ul><blockquote><p><strong>System.arraycopy()和Arrays.copyOf()方法</strong><br>通过源码发现这两个实现数组复制的方法被广泛使用, 比如插入操作add(int index, E element)方法就很巧妙的用到了 System.arraycopy()方法让数组自己复制自己实现让index开始之后的所有成员后移一个位置</p><ul><li>Arrays.copyOf()内部也是调用了System.arraycopy()方法 </li><li>Arrays.copyOf()是系统自动在内部新建一个数组，并返回该数组</li><li>System.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li></ul></blockquote><h4 id="1-2-ensureCapacity"><a href="#1-2-ensureCapacity" class="headerlink" title="1.2 ensureCapacity"></a>1.2 ensureCapacity</h4><p>ArrayList对外提供了一个<code>ensureCapacity(int n)</code>方法</p><ul><li>最好在<code>add</code>大量元素之前用ensureCapacity方法，以<strong>减少增量重新分配的次数</strong></li><li>ensureCapacity一次性扩容到位，否则在添加大量元素的过程中，一点一点的进行扩容</li></ul><h4 id="1-3-内部类"><a href="#1-3-内部类" class="headerlink" title="1.3 内部类"></a>1.3 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span></span>&#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>ArrayList有四个内部类</p><ul><li>Itr 实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；</li><li>ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法</li><li>Iterator和ListIterator的区别: <ul><li>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</li></ul></li></ul><h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h3><p>LinkedList是基于<strong>双向链表</strong>实现的, 可以在任何位置进行高效地插入和移除操作的有序序列。</p><ul><li>复杂度: <strong>增加(末尾)/删除:O(1)</strong>，<strong>插入/获取: O(n)</strong></li><li>LinkedList 继承AbstractSequentialList的<strong>双向链表</strong>。它也可以被当作堆栈、队列或双端队列进行操作。</li><li>LinkedList 实现 List 接口，能对它进行<strong>队列操作</strong>。</li><li>LinkedList 实现 Deque 接口，即能将LinkedList当作<strong>双端队列</strong>使用。</li><li>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，<strong>能克隆</strong>。</li><li>LinkedList 实现java.io.Serializable接口，这意味着LinkedList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>LinkedList <strong>不是线程安全的</strong>，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法</li></ul><h4 id="2-1-LinkedList底层分析"><a href="#2-1-LinkedList底层分析" class="headerlink" title="2.1 LinkedList底层分析:"></a>2.1 LinkedList底层分析:</h4><p>LinkedList的底层是一个双向链表，链表中挂载着一个个的Node元素；可以从LinkedList的Node内部类看出奥秘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//尾指针</span></span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 数据域（当前节点的值）</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 后继（指向当前一个节点的后一个节点）</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 前驱（指向当前节点的前一个节点）</span></span><br><span class="line">    <span class="comment">// 构造函数，赋值前驱后继</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LinkedList 是基于链表结构实现，所以在类中包含了 first 和 last 两个指针(Node)。</li><li>Node 中包含了上一个节点和下一个节点的引用，这样就构成了双向的链表。</li></ul><h4 id="2-2-LinkedList增删改查"><a href="#2-2-LinkedList增删改查" class="headerlink" title="2.2 LinkedList增删改查"></a>2.2 LinkedList增删改查</h4><ul><li>链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。增加一定会修改modCount。</li><li>通过下标获取某个node的时候(add select)，会根据index处于前半段还是后半段<strong>进行一个折半</strong>，以提升查询效率</li><li>删也一定会修改modCount。 <ul><li>按下标删，也是先根据index找到Node，然后去链表上unlink掉这个Node。 </li><li>按元素删，会先去遍历链表寻找是否有该Node，如果有，去链表上unlink掉这个Node。</li></ul></li><li>改也是先根据index找到Node，然后替换值。不修改modCount。</li><li>CRUD操作里，都涉及到根据index去找到Node的操作。</li></ul><h4 id="2-2-unlink原理"><a href="#2-2-unlink原理" class="headerlink" title="2.2 unlink原理"></a>2.2 unlink原理</h4><ul><li>先判断该节点是否存在上一个节点，即是否有前驱节点。<ul><li>无前驱节点则说明要删除的节点为链表的第一节点，那么只需要把该节点的下一个节点设置为链表的第一个节点。</li><li>有前驱节点则需要把前驱节点的尾部引用指向该节点的下一个节点。</li></ul></li><li>再判断该节点是否存在下一个节点，即是否有后继节点。<ul><li>无后继节点则说明该节点是链表的最后一个节点，那么只需要把该节点前驱节点设置成链表的最后一个节点即可。</li><li>有后继节点则需要把后继节点的头部引用指向该节点的上一个节点。</li></ul></li><li>核心就是在于将要删除的节点的前驱节点尾部指向该节点的后继节点，将要删除的节点的后继节点的头部指向该节点的前驱节点。这样便完成了链表的删除操作。</li></ul><blockquote><p>删除和新增方法的实现基本是对该节点的上一个节点和下一个节点的引用设置，不需要操作其他节点，效率相对较高</p></blockquote><h4 id="2-3-offer与add的区别"><a href="#2-3-offer与add的区别" class="headerlink" title="2.3 offer与add的区别"></a>2.3 offer与add的区别</h4><ul><li>offer属于 offer in interface <strong>Deque</strong>。</li><li>add 属于 add in interface <strong>Collection</strong>。</li><li>当队列为空时候，使用add方法会报错，而offer方法会返回false。</li><li>作为List使用时,一般采用add / get方法来 压入/获取对象。</li><li>作为Queue使用时,才会采用 offer/poll/take等方法作为链表对象时,offer等方法相对来说没有什么意义这些方法是用于支持队列应用的。</li></ul><h4 id="2-2-对比Vector、ArrayList、LinkedList有何区别"><a href="#2-2-对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="2.2 对比Vector、ArrayList、LinkedList有何区别"></a>2.2 对比Vector、ArrayList、LinkedList有何区别</h4><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全</strong>的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据扩容为旧容量的<strong>2倍</strong>。</li><li>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。ArrayList 也是可以根据需要调整容量，在扩容为旧容量的<strong>1.5倍</strong>。</li><li>LinkedList 顾名思义是 Java 提供的双向链表，<strong>不需要扩容</strong>，它也不是线程安全的。LinkedList不支持高效的随机元素访问。</li></ul><h3 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3. HashMap"></a>3. HashMap</h3><p>HashMap是<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的, 用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。</p><ul><li>HashMap继承了AbstractMap类，实现了Map，Cloneable，Serializable接口</li><li>继承 abstractMap，也就是用来减轻实现Map接口的编写负担。</li><li>实现 Cloneable：能够使用Clone()方法，在HashMap中，实现的是<strong>浅层次拷贝</strong>，即对拷贝对象的改变会影响被拷贝的对象。</li><li>实现 Serializable：能够使之<strong>序列化</strong>，即可以将HashMap对象保存至本地，之后可以恢复状态。</li></ul><blockquote><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>，以实现O(logn)时间复杂读查找。</p></blockquote><p>HashMap类中有一个非常重要的字段，就是 Node[] table，即<strong>哈希桶数组</strong>，明显它是一个Node的数组。</p><ul><li>HashMap的实例有两个参数影响其性能:<ul><li>初始容量(默认16)：哈希表中桶的数量</li><li>加载因子(默认0.75)：哈希表在其容量自动增加之前可以达到多满的一种尺度</li></ul></li><li>当哈希表中条目数超出了当前容量*加载因子(其实就是HashMap的实际容量)时，则对该哈希表进行rehash操作，将哈希表扩充至两倍的桶数。</li></ul><h4 id="3-1-HashMap的-put-方法过程-（重点）"><a href="#3-1-HashMap的-put-方法过程-（重点）" class="headerlink" title="3.1 HashMap的 put 方法过程*（重点）"></a>3.1 HashMap的 put 方法过程*（重点）</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>对 Key 求 Hash 值，然后再计算下标。</li><li>如果没有碰撞，直接放入桶中，</li><li>如果碰撞了，若是树节点，就<code>putTreeVal</code>添加元素，若不是就遍历链表插入。</li><li>如果链表长度超过阀值（TREEIFY_THRESHOLD==8），就把链表转成红黑树。</li><li>如果节点已经存在就替换旧值，若未找到则继续</li><li>如果桶满了（容量 * 加载因子），就需要 resize(扩容为原来2倍并重新散列,元素的下标要么不变，要么变为【原下标+原容量】)。</li></ol><h4 id="3-2-HashMap-桶下标计算"><a href="#3-2-HashMap-桶下标计算" class="headerlink" title="3.2 HashMap 桶下标计算"></a>3.2 HashMap 桶下标计算</h4><ul><li><strong>下标</strong>：<code>hash(key) &amp; (table.length - 1)</code></li><li>扰动函数<strong>hash(key)</strong>：(key==null) ? 0 : <code>(key.hashCode()^(key.hashCode() &gt;&gt;&gt; 16))</code></li><li>低16位 和 高 16位 做了一个<strong>异或</strong>得到 hash值 与 (容器长度-1)进行<strong>取模(%)</strong>运算,得到下标。<ul><li>利用位运算代替取模运算，提高程序的计算效率：（当 b=2^n 时，a%b = a &amp; (b-1) ），也是因此，HashMap 才将初始长度设置为 16，且扩容只能是以 2 的倍数（2^n）扩容。</li></ul></li><li>有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以尽可能有效的避免哈希碰撞。</li></ul><blockquote><p>HashMap 的性能表现非常依赖于哈希码的有效性: equals相等，hashCode一定要相等。重写了 hashCode 也要重写 equals。hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</p></blockquote><h4 id="3-3-HashMap-容量、负载因子和树化"><a href="#3-3-HashMap-容量、负载因子和树化" class="headerlink" title="3.3 HashMap 容量、负载因子和树化"></a>3.3 HashMap 容量、负载因子和树化</h4><ul><li>容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。</li><li>如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。</li><li>计算条件：<strong>负载因子 * 容量 &gt; 元素数量</strong>；所以，预先设置的容量需要满足，大于“预估元素数量/负载因子”，同时它是<strong>2的幂数</strong></li><li>容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 <strong>1&lt;&lt;30</strong>，也就是2的30次方</li></ul><h5 id="3-3-1-HashMap-负载因子loadFactor"><a href="#3-3-1-HashMap-负载因子loadFactor" class="headerlink" title="3.3.1 HashMap 负载因子loadFactor"></a>3.3.1 HashMap 负载因子loadFactor</h5><ul><li>loadFactor加载因子是控制数组存放数据的疏密程度，越大越密，越小越稀疏。</li><li>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的<strong>默认值为0.75f</strong>是官方给出的一个比较好的临界值。</li><li>给定的默认容量为16，负载因子为0.75。当数量达到了 16*0.75 = 12 就需要将当前16的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li><li>而对于负载因子，建议：<ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</li><li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul></li></ul><h5 id="3-3-2-HashMap-门限值threshold"><a href="#3-3-2-HashMap-门限值threshold" class="headerlink" title="3.3.2 HashMap 门限值threshold"></a>3.3.2 HashMap 门限值threshold</h5><p><code>threshold = capacity * loadFactor</code>，当<code>Size&gt;=threshold</code>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</p><ul><li>门限值等于(负载因子 x 容量)，如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。</li><li>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="3-3-2-HashMap-树化改造"><a href="#3-3-2-HashMap-树化改造" class="headerlink" title="3.3.2 HashMap 树化改造"></a>3.3.2 HashMap 树化改造</h5><p>树化改造逻辑主要在 putVal 和 <code>treeifyBin</code> 中。</p><ul><li>链表结构（这里叫 bin）的数量大于 <code>TREEIFY_THRESHOLD</code>(默认为8) 时：<ul><li>如果容量小于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64) ，只会进行简单的扩容。</li><li>如果容量大于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64)，则会进行树化改造。</li></ul></li></ul><h4 id="3-4-HashMap-扩容resize"><a href="#3-4-HashMap-扩容resize" class="headerlink" title="3.4 HashMap 扩容resize"></a>3.4 HashMap 扩容resize</h4><ul><li>HashMap扩容条件：<ul><li>元素个数超出了加载因子与当前容量的乘积，并且发生了Hash碰撞</li></ul></li><li>HashMap扩容步骤：<ol><li>创建一个新的Entry空数组，长度是原来的2倍。</li><li>遍历原Entry数组，把所有的Entry重新Hash到新数组里。</li><li>重新散列的元素下标要么【不变】，要么变为【原下标+原容量】，取决于位运算((n - 1) &amp; hash)</li></ol></li></ul><blockquote><p>经过一次扩容处理后，元素会更加均匀的分布在各个桶中，会提升访问效率。<br>但会遍历所有的元素，时间复杂度很高；遍历元素所带来的坏处大于元素在桶中均匀分布所带来的好处。<br>尽量避免进行扩容处理。</p></blockquote><h4 id="3-5-常见的hash算法及冲突的解决"><a href="#3-5-常见的hash算法及冲突的解决" class="headerlink" title="3.5 常见的hash算法及冲突的解决"></a>3.5 常见的hash算法及冲突的解决</h4><p>hash函数，即散列函数。它可以将不定长的输入，通过散列算法转换成一个定长的输出，这个输出就是散列值(不保证唯一)。</p><ul><li>常见Hash算法：<ol><li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址（H(k)=ak+b）。</li><li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址（如一组出生日期，相较于年-月，月-日的差别要大得多，可以降低冲突概率）</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li><li>伪随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</li><li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址（H(k)=k%p, p&lt;=m; p一般取m或素数）。</li></ol></li><li>常见解决hash冲突的方法<ol><li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li><li>开放定址法：即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。</li><li>再哈希法：即发生冲突时，由其他的函数再计算一次哈希值。</li><li>建立公共溢出区：将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。</li></ol></li></ul><blockquote><p>HashMap就是使用链地址法来解决冲突的（JDK1.8增加了红黑树）</p></blockquote><h4 id="3-6-对比Hashtable、HashMap、TreeMap有什么不同"><a href="#3-6-对比Hashtable、HashMap、TreeMap有什么不同" class="headerlink" title="3.6 对比Hashtable、HashMap、TreeMap有什么不同"></a>3.6 对比Hashtable、HashMap、TreeMap有什么不同</h4><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</li><li>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</li><li>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O(log(n))的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集合-Collection-Map&quot;&gt;&lt;a href=&quot;#集合-Collection-Map&quot; class=&quot;headerlink&quot; title=&quot;集合(Collection/Map)&quot;&gt;&lt;/a&gt;集合(Collection/Map)&lt;/h3&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【并发】Redis穿透、击穿、雪崩和数据一致性</title>
    <link href="http://chaooo.github.io/article/20190927.html"/>
    <id>http://chaooo.github.io/article/20190927.html</id>
    <published>2019-09-27T11:15:31.000Z</published>
    <updated>2019-10-20T13:21:42.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。</p><ul><li>解决方案：<ol><li>采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；</li><li>访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</li><li>接口限流与熔断、降级</li><li>使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））</li></ol></li></ul><h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><ul><li>解决方案<ol><li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li><li>建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</li><li>加锁排队，实现同上;</li></ol></li></ul><h3 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h3><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p><ul><li>解决方案<ul><li>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</li></ul></li></ul><h3 id="4-缓存并发竞争"><a href="#4-缓存并发竞争" class="headerlink" title="4. 缓存并发竞争"></a>4. 缓存并发竞争</h3><p>多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）</p><ul><li>解决方案<ol><li>如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。</li><li>如果对这个key操作，要求顺序：<ol><li>分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了）</li><li>利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）</li></ol></li></ol></li></ul><h3 id="5-缓存和数据库一致性解决方案"><a href="#5-缓存和数据库一致性解决方案" class="headerlink" title="5. 缓存和数据库一致性解决方案"></a>5. 缓存和数据库一致性解决方案</h3><h4 id="5-1-并发量、一致性要求都不是很高的场景"><a href="#5-1-并发量、一致性要求都不是很高的场景" class="headerlink" title="5.1 并发量、一致性要求都不是很高的场景"></a>5.1 并发量、一致性要求都不是很高的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，之后再<strong>异步将数据刷回缓存</strong></li><li>读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：实现起来简单，异步刷新，补缺补漏</li><li>缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</li></ol><h4 id="5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）"><a href="#5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）" class="headerlink" title="5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）"></a>5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，监听从库binlog，通过<strong>解析binlog来刷新缓存</strong></li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：容灾</li><li>缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读/写的时候，缓存中的数据已失效，此时又发生了更新）</li></ol><h4 id="5-3-业务只需要达到“最终一致性”要求的场景"><a href="#5-3-业务只需要达到“最终一致性”要求的场景" class="headerlink" title="5.3 业务只需要达到“最终一致性”要求的场景"></a>5.3 业务只需要达到“最终一致性”要求的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的<strong>数据标识</strong>，然后将<strong>数据标识写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：只能达到”最终一致性”</li></ol><h4 id="5-4-强一致性的场景"><a href="#5-4-强一致性的场景" class="headerlink" title="5.4 强一致性的场景"></a>5.4 强一致性的场景</h4><ul><li>写流程：我们把<strong>修改的数据通过Cache_0标记</strong>“正在被修改”，如果<strong>标记成功，写数据库，删除缓存，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识<strong>写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。</li><li>读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-缓存穿透&quot;&gt;&lt;a href=&quot;#1-缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;1. 缓存穿透&quot;&gt;&lt;/a&gt;1. 缓存穿透&lt;/h3&gt;&lt;p&gt;访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="并发" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="并发" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【并发】深入学习Redis及集群</title>
    <link href="http://chaooo.github.io/article/20190920.html"/>
    <id>http://chaooo.github.io/article/20190920.html</id>
    <published>2019-09-20T08:19:26.000Z</published>
    <updated>2019-10-20T11:14:10.407Z</updated>
    
    <content type="html"><![CDATA[<p>Redis本质上是一个Key-Value类型的<strong>内存数据库</strong>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。<a id="more"></a>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="1-Redis数据结构及命令操作"><a href="#1-Redis数据结构及命令操作" class="headerlink" title="1. Redis数据结构及命令操作"></a>1. Redis数据结构及命令操作</h3><h4 id="1-1-基本概念及操作"><a href="#1-1-基本概念及操作" class="headerlink" title="1.1 基本概念及操作"></a>1.1 基本概念及操作</h4><ul><li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库；</li><li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；</li><li>select命令切换数据库：select 0-15；</li><li>dbsize：查看当前数据库的key的数量；</li><li>flushdb：清空当前库；</li><li>flushall；通杀全部库；</li></ul><h4 id="1-2-Redis数据结构"><a href="#1-2-Redis数据结构" class="headerlink" title="1.2 Redis数据结构"></a>1.2 Redis数据结构</h4><p>redis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)</p><ol><li>String：set, get, del, append, strlen</li><li>Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall</li><li>List：lpush, rpush, lrange, lpop(删除), rpop, lindex</li><li>Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)</li><li>ZSet：zadd, zrange, zrem</li></ol><h4 id="1-3-Redis键-key-–常用命令介绍"><a href="#1-3-Redis键-key-–常用命令介绍" class="headerlink" title="1.3 Redis键(key)–常用命令介绍"></a>1.3 Redis键(key)–常用命令介绍</h4><ul><li>keys *：查看所有 key ；</li><li>exists key的名字：判断某个 key 是否存在；</li><li>move key dbID（0-15）： 当前库就没有了，被移除了；</li><li>expire key 秒钟： 为给定的 key 设置过期时间；</li><li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；</li><li>type key： 查看你的 key 是什么类型；</li></ul><h3 id="2-Redis持久化"><a href="#2-Redis持久化" class="headerlink" title="2. Redis持久化"></a>2. Redis持久化</h3><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。</p><h4 id="2-1-RDB（Redis-DataBase）"><a href="#2-1-RDB（Redis-DataBase）" class="headerlink" title="2.1 RDB（Redis DataBase）"></a>2.1 RDB（Redis DataBase）</h4><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p><ul><li>开启RDB持久化方式一：save命令，或bgsave(异步)</li><li>开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：<code>redis-server redis.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1     # 900s内至少达到一条写命令</span><br><span class="line">save 300 10    # 300s内至少达至10条写命令</span><br><span class="line">save 60 10000  # 60s内至少达到10000条写命令</span><br></pre></td></tr></table></figure><ul><li><p>RDB的几个优点</p><ul><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li></ul></li><li><p>RDB的几个缺点</p><ul><li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ul></li></ul><h4 id="2-2-AOF-Append-only-file"><a href="#2-2-AOF-Append-only-file" class="headerlink" title="2.2 AOF(Append-only file)"></a>2.2 AOF(Append-only file)</h4><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><ul><li>开启方式：在Redis配置文件redis.conf配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes                  # 开启aof机制</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # aof文件名</span><br><span class="line"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec(每秒写入一次)或no(操作系统处理)</span><br><span class="line">appendfsync always</span><br><span class="line">no-appendfsync-on-rewrite no    # 默认不重写aof文件</span><br><span class="line">dir ~/redis/                    # 保存目录</span><br></pre></td></tr></table></figure><ul><li>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令</li></ul><ul><li>AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li><li>AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。</li><li>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</li></ul><h5 id="2-2-1-AOF文件修复"><a href="#2-2-1-AOF文件修复" class="headerlink" title="2.2.1 AOF文件修复"></a>2.2.1 AOF文件修复</h5><ol><li>备份被写坏的AOF文件</li><li>运行redis-check-aof –fix进行修复</li><li>用diff -u来看下两个文件的差异，确认问题点</li><li>重启redis，加载修复后的AOF文件</li></ol><h3 id="3-Redis的高并发和快速原因"><a href="#3-Redis的高并发和快速原因" class="headerlink" title="3. Redis的高并发和快速原因"></a>3. Redis的高并发和快速原因</h3><ol><li>redis是基于内存的，内存的读写速度非常快；</li><li>redis是单线程的，省去了很多上下文切换线程的时间；</li><li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</li><li>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li><li>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li></ol><h3 id="4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用"><a href="#4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用" class="headerlink" title="4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用"></a>4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用</h3><ol><li>哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。<ol><li>集群监控：负责监控Redis master和slave进程是否正常工作</li><li>消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li><li>故障转移：如果master node挂掉了，会自动转移到slave node上</li><li>配置中心：如果故障转移发生了，通知client客户端新的master地址</li></ol></li><li>复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。<ol><li>从数据库向主数据库发送sync(数据同步)命令。</li><li>主数据库接收同步命令后，会保存快照，创建一个RDB文件。</li><li>当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。</li><li>主数据库将缓冲区的所有写命令发给从服务器执行。</li><li>以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。</li></ol></li></ol><h3 id="5-Redis-主从复制、哨兵和集群这三个有什么区别"><a href="#5-Redis-主从复制、哨兵和集群这三个有什么区别" class="headerlink" title="5. Redis 主从复制、哨兵和集群这三个有什么区别"></a>5. Redis 主从复制、哨兵和集群这三个有什么区别</h3><p>主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。</p><ol><li>主从模式：读写分离，备份，一个Master可以有多个Slaves。</li><li>哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li><li>集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li></ol><h3 id="6-Redis-Cluster集群"><a href="#6-Redis-Cluster集群" class="headerlink" title="6. Redis Cluster集群"></a>6. Redis Cluster集群</h3><p>Redis Cluster，是Redis 3.0开始引入的分布式存储方案。<br>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p><ul><li>集群的作用：<ol><li>数据分区：数据分区(或称数据分片)是集群最核心的功能。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</li></ol></li></ul><h4 id="6-1-Redis-Cluster集群的搭建可以分为四步："><a href="#6-1-Redis-Cluster集群的搭建可以分为四步：" class="headerlink" title="6.1 Redis Cluster集群的搭建可以分为四步："></a>6.1 Redis Cluster集群的搭建可以分为四步：</h4><ol><li><strong>启动节点</strong>：将节点以集群模式启动，此时节点是独立的，并没有建立联系；</li><li><strong>节点握手</strong>：让独立的节点连成一个网络；</li><li><strong>分配槽</strong>：将16384个槽分配给主节点；</li><li><strong>指定主从关系</strong>：为从节点指定主节点。</li></ol><h4 id="6-2-Redis-Cluster工作原理"><a href="#6-2-Redis-Cluster工作原理" class="headerlink" title="6.2 Redis Cluster工作原理"></a>6.2 Redis Cluster工作原理</h4><ul><li>客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点</li><li>根据公式<code>HASH_SLOT=CRC16(key) mod 16384</code>，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         CRC16(key)    |  0~5460   | &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">         mode 16384    |</span><br><span class="line">Client --------------&gt; | 5461~10922| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">                       |</span><br><span class="line">                       |10923~10383| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br></pre></td></tr></table></figure><h4 id="6-3-Redis-Cluster优点"><a href="#6-3-Redis-Cluster优点" class="headerlink" title="6.3 Redis Cluster优点:"></a>6.3 Redis Cluster优点:</h4><ol><li>无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master</li><li>可以进行水平扩容</li><li>支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。</li></ol><h4 id="6-4-Redis-Cluster缺点"><a href="#6-4-Redis-Cluster缺点" class="headerlink" title="6.4 Redis Cluster缺点:"></a>6.4 Redis Cluster缺点:</h4><ol><li>批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）</li><li>资源隔离性较差，容易出现相互影响的情况。</li></ol><h4 id="6-5-Redis-Cluster总结："><a href="#6-5-Redis-Cluster总结：" class="headerlink" title="6.5 Redis Cluster总结："></a>6.5 Redis Cluster总结：</h4><ol><li>Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。</li><li>单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。</li><li>不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。</li><li>如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。</li><li>Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。</li><li>Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis本质上是一个Key-Value类型的&lt;strong&gt;内存数据库&lt;/strong&gt;，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。
    
    </summary>
    
      <category term="并发" scheme="http://chaooo.github.io/categories/concurrent/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="并发" scheme="http://chaooo.github.io/tags/concurrent/"/>
    
      <category term="Redis" scheme="http://chaooo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】MySQL索引的使用及优化</title>
    <link href="http://chaooo.github.io/article/20190905.html"/>
    <id>http://chaooo.github.io/article/20190905.html</id>
    <published>2019-09-05T09:04:12.000Z</published>
    <updated>2019-10-20T13:25:05.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-索引的基本概念"><a href="#1-索引的基本概念" class="headerlink" title="1. 索引的基本概念"></a>1. 索引的基本概念</h3><p>索引是一种<strong>数据结构</strong>。对数据库表中一列或多列的值进行排序的数据结构。<br>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。<a id="more"></a><br>提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p><ol><li>索引的作用<ol><li>快速检索数据，降低数据库的IO成本；</li><li>保证数据记录的唯一性；</li><li>实现表与表之间的参照完整性；</li><li>在使用order by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间，降低CPU的消耗；</li></ol></li><li>索引的缺点<ol><li>索引的缺点是创建和维护索引需要耗费时间和空间</li><li>索引可以提高查询速度，会减慢写入速度</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li></ol></li></ol><h3 id="2-索引的适用场景"><a href="#2-索引的适用场景" class="headerlink" title="2. 索引的适用场景"></a>2. 索引的适用场景</h3><h4 id="2-1-适合建索引的场景"><a href="#2-1-适合建索引的场景" class="headerlink" title="2.1 适合建索引的场景"></a>2.1 适合建索引的场景</h4><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关联建立索引</li><li>频繁更新的字段不适合创建索引（更新字段不仅要更新数据本身，而且还要更新索引树）</li><li>where条件里用不到的字段不创建索引</li><li>单键/组合索引的选择问题（在高并发下倾向创建组合索引）</li><li>查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度（索引主要干两件事：检索、排序。）</li><li>查询中统计或者分组的字段</li></ol><h4 id="2-2-不适合建索引的场景"><a href="#2-2-不适合建索引的场景" class="headerlink" title="2.2 不适合建索引的场景"></a>2.2 不适合建索引的场景</h4><ol><li>表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）</li><li>经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。</li><li>数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）</li></ol><h3 id="3-MySQl中索引的结构（B-树）"><a href="#3-MySQl中索引的结构（B-树）" class="headerlink" title="3. MySQl中索引的结构（B+树）"></a>3. MySQl中索引的结构（B+树）</h3><h4 id="3-1-基本概念："><a href="#3-1-基本概念：" class="headerlink" title="3.1 基本概念："></a>3.1 基本概念：</h4><ol><li>二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；</li><li>B树：多路搜索树，每个节点存储M/2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；</li><li>B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；</li><li>B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1/2提高到2/3；</li></ol><h4 id="3-2-B-树的特性："><a href="#3-2-B-树的特性：" class="headerlink" title="3.2 B+树的特性："></a>3.2 B+树的特性：</h4><ol><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>不可能在非叶子结点命中；</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>更适合文件索引系统；</li></ol><h4 id="3-3-B-树的三个特点："><a href="#3-3-B-树的三个特点：" class="headerlink" title="3.3 B+树的三个特点："></a>3.3 B+树的三个特点：</h4><ol><li>关键字数和子树相同<ul><li>在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</li></ul></li><li>非叶子节点仅用作索引，它的关键字和子节点有重复元素<ul><li>除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</li><li>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</li></ul></li><li>叶子节点用指针连在一起<ul><li>叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</li></ul></li></ol><blockquote><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。<br>B+ 树的查找必会查到叶子节点，更加稳定。<br>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p></blockquote><h4 id="3-4-B-树的三个优点："><a href="#3-4-B-树的三个优点：" class="headerlink" title="3.4 B+ 树的三个优点："></a>3.4 B+ 树的三个优点：</h4><ul><li>层级更低，IO 次数更少</li><li>每次都需要查询到叶子节点，查询性能稳定</li><li>叶子节点形成有序链表，范围查询方便</li></ul><h3 id="4-索引的优化"><a href="#4-索引的优化" class="headerlink" title="4. 索引的优化"></a>4. 索引的优化</h3><h4 id="4-1-优化法则（口诀）："><a href="#4-1-优化法则（口诀）：" class="headerlink" title="4.1 优化法则（口诀）："></a>4.1 优化法则（口诀）：</h4><ul><li>全值匹配我最爱，最左前缀要遵守</li><li>带头大哥不能死，中间兄弟不能断</li><li>索引列上无计算，范围之后全失效</li><li>like百分写最右，覆盖索引不写星</li><li>不等控制还有or，索引失效要少用</li><li>var引号不能丢，SQL优化也不难</li></ul><h4 id="4-2-具体描述"><a href="#4-2-具体描述" class="headerlink" title="4.2 具体描述"></a>4.2 具体描述</h4><ol><li>全值匹配<ul><li>怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多</li></ul></li><li>最佳左前缀法则<ul><li>指的是查询从索引的最左前列开始并且不跳过索引中的列。</li><li>例如：复合索引<code>A-&gt;B-&gt;C</code>，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。</li></ul></li><li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右面的列<ul><li>例如：<code>select t from test where A=1 and B&gt;2 and C=3</code>，那么B&gt;2后的查询条件失效。</li></ul></li><li>尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 <code>SELECT *</code>。</li><li>MySQL在使用不等于(<code>!=</code> 或<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描</li><li><code>is null</code>，<code>is not null</code> 也无法使用索引</li><li>like以通配符开头<code>(&#39;%abc...&#39;)</code>mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面<code>(&#39;abc...%&#39;)</code>的才能避免索引失效。</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li></ol><h3 id="5-in-和-exists区别及应用场景"><a href="#5-in-和-exists区别及应用场景" class="headerlink" title="5. in 和 exists区别及应用场景"></a>5. in 和 exists区别及应用场景</h3><h4 id="5-1-in-和-exists的区别"><a href="#5-1-in-和-exists的区别" class="headerlink" title="5.1 in 和 exists的区别:"></a>5.1 in 和 exists的区别:</h4><ul><li>如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。</li><li>其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</li><li>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</li></ul><h4 id="5-2-not-in-和not-exists"><a href="#5-2-not-in-和not-exists" class="headerlink" title="5.2 not in 和not exists"></a>5.2 not in 和not exists</h4><ul><li>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；</li><li>而not extsts 的子查询依然能用到表上的索引。</li><li>所以无论那个表大，用not exists都比not in要快</li></ul><h3 id="6-order-by-和-group-by-优化"><a href="#6-order-by-和-group-by-优化" class="headerlink" title="6. order by 和 group by 优化"></a>6. order by 和 group by 优化</h3><p>索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。</p><h4 id="6-1-提高ORDER-BY速度的技巧"><a href="#6-1-提高ORDER-BY速度的技巧" class="headerlink" title="6.1 提高ORDER BY速度的技巧"></a>6.1 提高ORDER BY速度的技巧</h4><ol><li>ORDER BY时不要使用SELECT *，只查需要的字段。</li><li>增大<code>sort_buffer_size</code>参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）</li><li>增大<code>max_length_for_sort_data</code>参数大小</li></ol><h4 id="6-2-GROUP-BY的优化"><a href="#6-2-GROUP-BY的优化" class="headerlink" title="6.2 GROUP BY的优化"></a>6.2 GROUP BY的优化</h4><ol><li>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。</li><li>当无法使用索引列，考虑增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>的参数设置。</li><li>WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。</li></ol><blockquote><p>注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)</p></blockquote><p>一般性建议：</p><ul><li>对于单值索引，尽量选择针对query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。</li><li>在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li></ul><blockquote><p>参考链接：<a href="https://www.zhihu.com/people/hen-six-49/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/hen-six-49/activities</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-索引的基本概念&quot;&gt;&lt;a href=&quot;#1-索引的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 索引的基本概念&quot;&gt;&lt;/a&gt;1. 索引的基本概念&lt;/h3&gt;&lt;p&gt;索引是一种&lt;strong&gt;数据结构&lt;/strong&gt;。对数据库表中一列或多列的值进行排序的数据结构。&lt;br&gt;根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】MySQL慢日志查询分析</title>
    <link href="http://chaooo.github.io/article/20190829.html"/>
    <id>http://chaooo.github.io/article/20190829.html</id>
    <published>2019-08-28T16:26:43.000Z</published>
    <updated>2019-10-20T06:00:02.482Z</updated>
    
    <content type="html"><![CDATA[<p>同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。<a id="more"></a></p><ul><li>错误日志：记录启动、运行或停止mysqld时出现的问题。</li><li>通用日志：记录建立的客户端连接和执行的语句。</li><li>更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。</li><li>二进制日志：记录所有更改数据的语句。还用于复制。</li><li>慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询</li><li>Innodb日志：InnoDB redo log(记录了事务的行为，可以很好的通过其对页进行“重做”操作)</li></ul><h3 id="1-开启慢查询日志"><a href="#1-开启慢查询日志" class="headerlink" title="1. 开启慢查询日志"></a>1. 开启慢查询日志</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。<br>通过<code>show variables like &#39;slow_query%&#39;;</code>查询是否开了慢查询(默认禁用OFF)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%slow_query_log%';</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br><span class="line">| Variable_name       | Value                                                |</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br><span class="line">| slow_query_log      | OFF                                                  |</span><br><span class="line">| slow_query_log_file | D:\mysql-5.7.27-winx64\data\DESKTOP-E9F062A-slow.log |</span><br><span class="line">+<span class="comment">---------------------+------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><blockquote><p><code>slow_query_log</code> 慢查询开启状态  OFF 未开启 ON 为开启<br><code>slow_query_log_file</code> 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</p></blockquote><p>开启慢查询，需要设置<code>slow_query_log</code>参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log = 1; //设置开启或者关闭，0为关闭，1为开启</span><br><span class="line">mysql&gt; set global long_query_time = 3;  //设置慢的阙值时间，默认10秒</span><br></pre></td></tr></table></figure><blockquote><p>如果通过终端命令设定的话，需要重新连接或新开一个会话才能看到修改值</p></blockquote><p>使用set global slow_query_log 命令开启慢查询日志，只对当前数据库生效，如果Mysql重启后则会失效。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1 <span class="comment">#开启</span></span><br><span class="line">slow_query_log_file = /mysql-5.7.27-winx64/data/mysql-slow.log <span class="comment">#默认host_name_show.log</span></span><br><span class="line">long_query_time = 3 <span class="comment">#默认10秒（查询超过多少秒才记录）</span></span><br><span class="line">log-queries-not-using-indexes = on <span class="comment">#如果值设置为ON，则会记录所有没有利用索引的查询，一般在性能调优的时候会暂时开启。</span></span><br><span class="line">log_output = 'FILE,TABLE' <span class="comment">#输出的格式(FILE:文本, TABLE:表中, FILE,TABLE:同时输出到文本和表中)</span></span><br></pre></td></tr></table></figure><p>插入一条测试慢查询</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sleep(5);</span><br></pre></td></tr></table></figure><p>通过MySQL命令查看有多少慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like '%Slow_queries%';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Slow_queries  | 1     |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="2-慢查询日志分析工具"><a href="#2-慢查询日志分析工具" class="headerlink" title="2. 慢查询日志分析工具"></a>2. 慢查询日志分析工具</h3><table><thead><tr><th>工具</th><th>一般统计</th><th>高级统计</th><th>语言</th><th>优势</th><th>针对log</th></tr></thead><tbody><tr><td>mysqldumpslow</td><td><code>√</code></td><td><code>×</code></td><td>perl</td><td>mysql官方自带</td><td>slow</td></tr><tr><td>myprofi</td><td><code>√</code></td><td><code>×</code></td><td>php</td><td>简单</td><td>slow</td></tr><tr><td>mysql-log-filter</td><td><code>√</code></td><td>部分<code>√</code></td><td>python</td><td>简单</td><td>slow</td></tr><tr><td>mysql-explain-slow-log</td><td><code>√</code></td><td><code>×</code></td><td>perl</td><td>无</td><td>slow</td></tr><tr><td>mysqlbinlog</td><td><code>√</code></td><td><code>×</code></td><td>二进制</td><td>mysql官方自带</td><td>binary log</td></tr><tr><td>mysqlsla</td><td><code>√</code></td><td><code>√</code></td><td>perl</td><td>总能强大，使用简单，自定义能力强</td><td>所有日志，包括自定义日志</td></tr><tr><td>pt-query-digest</td><td><code>√</code></td><td><code>√</code></td><td>perl</td><td>总能强大，使用简单，自定义能力强</td><td>所有日志，包括自定义日志</td></tr></tbody></table><h4 id="2-1-mysqldumpslow"><a href="#2-1-mysqldumpslow" class="headerlink" title="2.1 mysqldumpslow"></a>2.1 mysqldumpslow</h4><ul><li>MySQL自带的慢查询日志分析工具mysqldumpslow主要功能是, 统计不同慢sql的:<ul><li>出现次数(Count),</li><li>执行最长时间(Time), </li><li>累计总耗费时间(Time),</li><li>等待锁的时间(Lock), </li><li>发送给客户端的行总数(Rows),</li><li>扫描的行总数(Rows), </li><li>用户以及sql语句本身(抽象了一下格式, 比如 limit 1, 20 用 limit N,N 表示).<br>安装后基本使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log  //得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /data/mysql/mysql-slow.log //得到访问次数最多的10个SQL </span><br><span class="line">mysqldumpslow -s t -t 10 -g "left join" /data/mysql/mysql-slow.log  //得到按照时间排序的前10条里面含有做了连接的查询SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /data/mysql/mysql-slow.log | more  //另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-2-mysqlsla"><a href="#2-2-mysqlsla" class="headerlink" title="2.2 mysqlsla"></a>2.2 mysqlsla</h4><p>hackmysql.com推出的一款日志分析工具(该网站还维护了 mysqlreport, mysqlidxchk 等比较实用的mysql工具)</p><ul><li>整体来说, 功能非常强大. 数据报表,非常有利于分析慢查询的原因, 包括执行频率, 数据量, 查询消耗等.</li></ul><p>安装后基本使用方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlsla -lt slow -sort t_sum -top 1000  /tmp/slow_query.log</span><br></pre></td></tr></table></figure><ul><li>结果选项说明：<ul><li>总查询次数 (queries total),</li><li>去重后的sql数量 (unique),</li><li>输出报表的内容排序(sorted by),</li><li>最重大的慢sql统计信息(包括 平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数)</li><li>Count, sql的执行次数及占总的slow log数量的百分比.</li><li>Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.</li><li>95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.</li><li>Lock Time, 等待锁的时间.</li><li>95% of Lock , 95%的慢sql等待锁时间.</li><li>Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.</li><li>Rows examined, 扫描的行数量.</li><li>Database, 属于哪个数据库</li><li>Users, 哪个用户,IP, 占到所有用户执行的sql百分比</li><li>Query abstract, 抽象后的sql语句</li><li>Query sample, sql语句</li></ul></li><li>mysqlsla常用参数说明：<ol><li><code>-log-type (-lt) type logs</code>:通过这个参数来制定log的类型，主要有slow, general, binary, msl, udl,分析slow log时通过制定为slow</li><li><code>-sort</code>:t_sum:按总时间排序(默认)，c_sum:按总次数排序c_sum_p: sql语句执行次数占总执行次数的百分比。</li><li><code>-top</code>:显示sql的数量，默认是10,表示按规则取排序的前多少条</li><li><code>–statement-filter (-sf) [+-][TYPE]</code>:过滤sql语句的类型，比如select、update、drop，[TYPE] 有SELECT, CREATE, DROP, UPDATE, INSERT，例如”+SELECT,INSERT”，不出现的默认是-，即不包括。</li><li><code>-db</code>：要处理哪个库的日志：</li></ol></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举个例子，只取funsion数据库的select语句，并按照总时间排序，取前1000条数据</span></span><br><span class="line"><span class="comment"># 保存到当前目录下的 slow_query.pretty.log文件中</span></span><br><span class="line">mysqlsla -lt slow  -sort t_sum  -sf "+<span class="keyword">select</span><span class="string">"  -db funsion  -top 1000  /tmp/slow_query.log &gt; ./slow_query.pretty.log</span></span><br></pre></td></tr></table></figure><blockquote><p>深度使用可参考： <a href="https://yq.aliyun.com/articles/59260" target="_blank" rel="noopener">MySQL日志分析神器之mysqlsla</a></p></blockquote><h4 id="2-3-pt-query-digest"><a href="#2-3-pt-query-digest" class="headerlink" title="2.3 pt-query-digest"></a>2.3 pt-query-digest</h4><p>pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分析最近12小时内的查询：</span></span><br><span class="line">pt-query-digest  <span class="comment">--since=12h  slow.log &gt; slow_report2.log</span></span><br></pre></td></tr></table></figure><ol><li>pt-query-digest语法及重要选项<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest [OPTIONS] [FILES] [DSN]</span><br><span class="line">    <span class="comment">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class="line">    <span class="comment">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class="line">    <span class="comment">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span></span><br><span class="line">    <span class="comment">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span></span><br><span class="line">    <span class="comment">--host  mysql服务器地址</span></span><br><span class="line">    <span class="comment">--user  mysql用户名</span></span><br><span class="line">    <span class="comment">--password  mysql用户密码</span></span><br><span class="line">    <span class="comment">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span></span><br><span class="line">    <span class="comment">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span></span><br><span class="line">    <span class="comment">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span></span><br><span class="line">    <span class="comment">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span></span><br><span class="line">    <span class="comment">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span></span><br></pre></td></tr></table></figure></li></ol><p>分析pt-query-digest输出结果</p><ol><li>总体统计结果<ul><li>Overall：总共有多少条查询</li><li>Time range：查询执行的时间范围</li><li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li><li>total：总计   min：最小   max：最大  avg：平均</li><li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li><li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li></ul></li><li>查询分组统计结果<ul><li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li><li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li><li>Response：总的响应时间</li><li>time：该查询在本次分析中总的时间占比</li><li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li><li>R/Call：平均每次执行的响应时间</li><li>V/M：响应时间Variance-to-mean的比率</li><li>Item：查询对象</li></ul></li><li>每一种查询的详细统计结果<ul><li>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</li><li>ID：查询的ID号，和上图的Query ID对应</li><li>Databases：数据库名</li><li>Users：各个用户执行的次数（占比）</li><li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li><li>Tables：查询中涉及到的表</li><li>Explain：SQL语句</li></ul></li></ol><h3 id="3-explain查看执行计划"><a href="#3-explain查看执行计划" class="headerlink" title="3. explain查看执行计划"></a>3. explain查看执行计划</h3><p>在上面的慢查询中，我们已经将查询时间超过阀值的sql语句过滤了出来，<code>explain+查询语句</code>具体分析是哪里出了问题。<br>MySQL 提供了一个 <code>Explain</code> 命令, 它可以对 select 语句进行分析, 并输出 select 执行的详细信息, 以供开发人员针对性优化.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure><ol><li><p>各列的含义如下:</p><ul><li><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li><code>select_type</code>: SELECT 查询的类型.<ul><li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY, 表示此查询是最外层的查询</li><li>UNION, 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>SUBQUERY, 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><code>table</code>: 查询的是哪个表</li><li><code>partitions</code>: 匹配的分区</li><li><code>type</code>: join 类型<ul><li>type字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过<code>type</code>字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</li><li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li><li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li><li>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. </li><li>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.</li><li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li><li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li><li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难.</li></ul></li><li><code>possible_keys</code>: 此次查询中可能选用的索引<ul><li>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</li></ul></li><li><code>key</code>: 此字段是 MySQL 在当前查询时所真正使用到的索引.</li><li><code>key_len</code>: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</li><li><code>ref</code>: 哪个字段或常数与 key 一起被使用</li><li><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.<ul><li>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数, 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</li></ul></li><li><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</li><li><code>extra</code>: EXplain 中的很多额外的信息会在 Extra 字段显示<ul><li>Using filesort: 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li><li>Using index: “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li>Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ul></li></ul></li><li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:</p></li></ol><ul><li><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><ul><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</li></ul></li></ul><h3 id="4-MySQL性能分析语句show-profile"><a href="#4-MySQL性能分析语句show-profile" class="headerlink" title="4. MySQL性能分析语句show profile"></a>4. MySQL性能分析语句show profile</h3><p>Query Profile是MySQL自带的一种Query诊断分析工具，可以完整的显示一条sql执行的各方面的详细信息，默认关闭;</p><ol><li><p>看看当前的MySQL版本是否支持: <code>show variables like &#39;profiling&#39;;</code>或<code>show variables like &#39;profiling%&#39;;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'profiling%';</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+<span class="comment">------------------------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>使用前需要开启: <code>set profiling = 1; (1:开 / 0:关)</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling = 1;</span><br></pre></td></tr></table></figure></li><li><p><strong>运行sql后</strong>，查询结果<code>show profiles;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILES\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Query_ID: 1</span><br><span class="line">Duration: 0.02949950</span><br><span class="line">   Query: <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">2</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.03405350</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">select</span> * <span class="keyword">from</span> housedemo</span><br><span class="line">*************************** <span class="number">3.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">3</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.07813800</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">select</span> * <span class="keyword">from</span> house</span><br><span class="line">*************************** <span class="number">4.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">Query_ID: <span class="number">4</span></span><br><span class="line"><span class="keyword">Duration</span>: <span class="number">0.00018150</span></span><br><span class="line">   <span class="keyword">Query</span>: <span class="keyword">show</span> prifiles</span><br></pre></td></tr></table></figure></li><li><p>诊断SQL, show profile <code>Type</code> io for query <code>Query_ID</code></p><ul><li>LIMIT部分的用法与SELECT中LIMIT子句一致，不赘述。</li><li>Type是可选的，取值范围可以如下：<ul><li><code>ALL</code> 显示所有性能信息</li><li><code>BLOCK IO</code> 显示块IO操作的次数</li><li><code>CONTEXT SWITCHES</code> 显示上下文切换次数，不管是主动还是被动</li><li><code>CPU</code> 显示用户CPU时间、系统CPU时间</li><li><code>IPC</code> 显示发送和接收的消息数量</li><li><code>MEMORY</code> [暂未实现]</li><li><code>PAGE FAULTS</code> 显示页错误数量</li><li><code>SOURCE</code> 显示源码中的函数名称与位置</li><li><code>SWAPS</code> 显示SWAP的次数</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 3;</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line">| starting             | 0.000077 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| checking permissions | 0.000013 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| Opening tables       | 0.031992 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| init                 | 0.000059 | 0.000000 |   0.000000 |         NULL |          NULL |</span><br><span class="line">| System <span class="keyword">lock</span>          | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| optimizing           | <span class="number">0.000007</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">statistics</span>           | <span class="number">0.000017</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| preparing            | <span class="number">0.008535</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| executing            | <span class="number">0.000016</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| Sending <span class="keyword">data</span>         | <span class="number">0.037234</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">end</span>                  | <span class="number">0.000011</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| <span class="keyword">query</span> <span class="keyword">end</span>            | <span class="number">0.000012</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| closing <span class="keyword">tables</span>       | <span class="number">0.000014</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000108</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000030</span> | <span class="number">0.000000</span> |   <span class="number">0.000000</span> |         <span class="literal">NULL</span> |          <span class="literal">NULL</span> |</span><br><span class="line">+<span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br></pre></td></tr></table></figure><p>从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理的你工作，在这完全可以看到一条SQL的完整生命周期。</p><ol start="5"><li>日常开发需要注意<ul><li>如果show profile … for query id；出现了如下四个，则必须优化这条sql。<ol><li><code>converting HEAP to MyISAM</code> 查询结果太大， 内存都不够用了网磁盘上搬了</li><li><code>Creating tmp table</code> 创建临时表</li><li>拷贝数据到临时表：假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这个时候就是导致SQL变慢的罪魁祸首</li><li>用完再删除</li><li><code>Copying to tmp table on disk</code> 把内存中临时表复制到磁盘，危险！！！</li><li><code>locked</code></li></ol></li></ul></li></ol><h3 id="5-全局查询日志"><a href="#5-全局查询日志" class="headerlink" title="5. 全局查询日志"></a>5. 全局查询日志</h3><p>切记：<strong>永远不要再生产环境开启这个功能</strong>。<br>全局查询日志有时也能帮助我们来调SQL。但是，切记，这家伙只能在测试环境使用，绝不可以在生产环境使用。</p><ol><li><p>命令启用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global general_log=1; #开启后会把所有的SQL偷偷的记录</span><br><span class="line">mysql&gt; set global log_output='TABLE';</span><br></pre></td></tr></table></figure></li><li><p>配置启用,  在MySQL的my.cnf中，设置如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启</span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment">#记录日志文件的路径</span></span><br><span class="line">general_log_file=/path/logfile</span><br><span class="line"><span class="comment">#输出格式</span></span><br><span class="line">log_output=file</span><br></pre></td></tr></table></figure></li><li><p>此后，你所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mysql.general_log;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>场景：如果需要做系统的定案分析(今天下午2点-3点出的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。那么用general_log这个表来收集什么时间段发生了什么样的SQL，帮助我们定位收集。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】深入JVM(三)-内存模型JMM 与 锁机制</title>
    <link href="http://chaooo.github.io/article/20190827.html"/>
    <id>http://chaooo.github.io/article/20190827.html</id>
    <published>2019-08-27T09:30:45.000Z</published>
    <updated>2019-10-30T12:43:40.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型-Java-Memory-Model"><a href="#Java内存模型-Java-Memory-Model" class="headerlink" title="Java内存模型(Java Memory Model)"></a>Java内存模型(Java Memory Model)</h3><p>Java Memory Model(JMM)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节(可见性,有序性,原子性)。</p><ul><li>所有的变量都存储在主内存中</li><li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li><li>JMM规定：<ul><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。<a id="more"></a></li></ul></li></ul><p><img src="http://cdn.chaooo.top/Java/JMM.png" alt></p><h3 id="1-JMM-同步八种操作"><a href="#1-JMM-同步八种操作" class="headerlink" title="1. JMM-同步八种操作"></a>1. JMM-同步八种操作</h3><p>JMM模型下,线程间通信必须要经过主内存。<br>JMM数据原子操作:<code>lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock</code></p><ol><li><strong>lock</strong>（锁定）：将<strong>主内存</strong>变量加锁，标识为线程独占状态</li><li><strong>read</strong>（读取）：从<strong>主内存</strong>读取数据到工作内存</li><li><strong>load</strong>（载入）：将读取的数据写入<strong>工作内存</strong></li><li><strong>use</strong>（使用）：将<strong>工作内存</strong>数据传递给执行引擎来计算</li><li><strong>assign</strong>（赋值）：将计算好的值赋值给<strong>工作内存</strong>的变量</li><li><strong>store</strong>（存储）：把<strong>工作内存</strong>数据存储到主内存</li><li><strong>write</strong>（写入）：把store过来的变量值赋值给<strong>主内存</strong>的变量</li><li><strong>unlock</strong>（解锁）：将<strong>主内存</strong>变量解锁，释放后的变量才可以被其他线程锁定。</li></ol><p>在执行上述八种基本操作时，必须满足如下规则：</p><ol><li>从主复制到工作,必须按顺序执行<code>read-&gt;load</code>操作; 从工作同步到主内存,必须按顺序执行<code>store-&gt;write</code>操作; 但不保证必须是连续执行</li><li>不允许<code>read-&gt;load</code>、<code>store-&gt;write</code>操作之一单独出现</li><li>assign操作改变数据后必须同步到主内存,不允许把没有发生过assign操作的数据同步到主内存</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作,lock和unlock必须成对出现</li><li>lock操作会清空工作内存中此变量的值，执行引擎使用前需要重新执行load或assign操作初始化变量的值</li><li>不允许去unlock一个未被锁定 或 被其他线程锁定的变量</li><li>unlock之前，必须先同步到主内存中（执行store和write操作）</li></ol><h3 id="2-JMM-原子性"><a href="#2-JMM-原子性" class="headerlink" title="2. JMM-原子性"></a>2. JMM-原子性</h3><p>和数据库事务中的原子性一样，满足原子性特性的操作是不可中断的，要么全部执行成功要么全部执行失败。<br>Synchronized能够实现：<strong>原子性</strong>(同步) 和 可见性</p><ul><li>JMM关于synchronized的两条规定：<ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li></ol></li><li>线程执行互斥代码的过程：<ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存</li><li>执行代码</li><li>将更改后的共享变量的值刷新到主内存</li><li>释放互斥锁</li></ol></li></ul><h3 id="2-JMM-可见性"><a href="#2-JMM-可见性" class="headerlink" title="2. JMM-可见性"></a>2. JMM-可见性</h3><p>多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值。<br>volatile能够实现<strong>可见性</strong>，但不保证原子性</p><ul><li><p>深入来说：通过加入内存屏障和禁止重排序优化来实现的。</p><ul><li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li><li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li></ul></li><li><p>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</p></li><li><p>线程写volatile变量的过程：</p><ol><li>改变线程工作内存中volatile变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ol></li><li><p>线程读volatile变量的过程：</p><ol><li>从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ol></li></ul><h4 id="2-1-happens-before规则"><a href="#2-1-happens-before规则" class="headerlink" title="2.1 happens-before规则"></a>2.1 happens-before规则</h4><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这2个操作之间必须要存在happens-before关系。</p><ul><li>定义: 如果一个操作在另一个操作之前发生(happens-before),那么第一个操作的执行结果将对第二个操作可见, 而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><ul><li>happens-before规则：<ol><li>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；论是单线程还是多线程，必须要先释放锁，然后其他线程才能进行lock操作</li><li>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见</li><li>线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断</li><li>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</li></ol></li></ul><h3 id="3-JMM-有序性"><a href="#3-JMM-有序性" class="headerlink" title="3. JMM-有序性"></a>3. JMM-有序性</h3><p>编译器和处理器为了优化程序性能而对指令序列进行重排序，也就是你编写的代码顺序和最终执行的指令顺序是不一致的，重排序可能会导致多线程程序出现内存可见性问题。</p><ul><li>我们编写的源代码到最终执行的指令，会经过三种重排序:<ul><li>源代码–&gt;<strong>编译器优化重排序</strong>–&gt;<strong>指令级并行重排序</strong>–&gt;<strong>内存系统重排序</strong>–&gt;最终执行的指令</li></ul></li></ul><h4 id="3-1-as-if-serial语义"><a href="#3-1-as-if-serial语义" class="headerlink" title="3.1 as-if-serial语义"></a>3.1 as-if-serial语义</h4><p>as-if-serial语义：不管怎么重排序(编译器和处理器为了提高并行度做的优化),(单线程)程序的执行结果不会改变。编译器、runtime和处理器都必须遵守as-if-serial语义。<br>多线程中程序交错执行时, 重排序可能造成内存可见性问题, 可能会改变程序的执行结果。</p><ul><li><p>有序性规则表现在以下两种场景: 线程内和线程间</p><ol><li>线程内: 指令会按照一种“串行”(as-if-serial)的方式执行，此种方式已经应用于顺序编程语言。</li><li>线程间: 一个线程“观察”到其他线程并发地执行非同步的代码时，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块以及volatile字段的操作仍维持相对有序。</li></ol></li><li><p>As-if-serial只是保障单线程不会出问题，所以有序性保障，可以理解为把As-if-serial扩展到多线程，那么在多线程中也不会出现问题</p><ul><li>从底层的角度来看，是借助于处理器提供的相关指令内存屏障来实现的</li><li>对于Java语言本身来说，Java已经帮我们与底层打交道，我们不会直接接触内存屏障指令，java提供的关键字synchronized和volatile，可以达到这个效果，保障有序性（借助于显式锁Lock也是一样的，Lock逻辑与synchronized一致）</li></ul></li></ul><h4 id="3-2-著名的双检锁-double-checked-locking-模式实现单例"><a href="#3-2-著名的双检锁-double-checked-locking-模式实现单例" class="headerlink" title="3.2 著名的双检锁(double-checked locking)模式实现单例"></a>3.2 著名的双检锁(double-checked locking)模式实现单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// volatile保证happens-before规则,重排序被禁止</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例没创建,才进入内部的synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 判断其他线程是否已经创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不用volatile修饰INSTANCE,可能造成访问的是一个初始化未完成的对象; 使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。</p></blockquote><h3 id="4-锁机制"><a href="#4-锁机制" class="headerlink" title="4. 锁机制"></a>4. 锁机制</h3><ul><li>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是<strong>锁的升级是单向的</strong>，也就是说只能从低到高升级，不会出现锁的降级）。</li><li>锁的状态是通过对象监视器在<strong>对象头</strong>中的字段来表明的。 四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。 这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(<strong>使用synchronized时</strong>)。</li></ul><h4 id="4-1-对象头Mark"><a href="#4-1-对象头Mark" class="headerlink" title="4.1 对象头Mark"></a>4.1 对象头Mark</h4><ul><li>Mark Word,对象头的标记,32位: 描述对象的hash,锁信息,垃圾回收标记,分代年龄<ul><li>指向锁记录的指针</li><li>指向monitor的指针</li><li>GC标记</li><li>偏向锁线程ID</li></ul></li></ul><h4 id="4-2-偏向锁"><a href="#4-2-偏向锁" class="headerlink" title="4.2 偏向锁"></a>4.2 偏向锁</h4><p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优</p><ul><li>大部分情况锁是没有竞争的,所以可以通过偏向锁来提高性能; </li><li>所谓偏向,就是偏心,即锁会偏向于当前已经占有锁的线程,总是由同一线程多次获得; </li><li>会在对象头和栈帧中的锁记录里存储锁偏向的线程ID</li><li>只要没有竞争,获得偏向锁的线程,在将来进入同步块,不需要做同步</li><li>当其他线程请求相同的锁时,偏向模式结束</li><li>-XX:+UseBiasedLocking(默认开启)</li><li>在竞争激烈的场合,偏向锁会增加系统负担</li></ul><h4 id="4-3-轻量级锁"><a href="#4-3-轻量级锁" class="headerlink" title="4.3 轻量级锁"></a>4.3 轻量级锁</h4><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><ul><li>普通的锁处理性能不够理想,轻量级锁是一种快速的锁定方法.</li><li>过程: 如果对象没有被锁定:<ol><li>将对象头的Mark指针保存到锁对象中</li><li>将对象头设置为指向锁的指针(在线程栈空间中)</li></ol></li><li>如果轻量级锁失败,表示存在竞争,升级为重量级锁(常规锁)</li><li>在没有锁竞争的情况下,减少传统锁使用OS互斥量产生的性能损耗</li><li>在竞争激烈的场合,轻量级锁会多做很多额外操作,导致性能下降</li></ul><h4 id="4-4-自旋锁"><a href="#4-4-自旋锁" class="headerlink" title="4.4 自旋锁"></a>4.4 自旋锁</h4><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><ul><li>当竞争存在时,如果线程可以很快获得锁,那么可以不在OS层挂起线程,让线程做几个空操作(自旋)</li><li>如果同步块很长,自旋失败,会降低系统性能</li><li>如果同步块很短,自旋成功,节省线程挂起切换时间,提升系统性能</li></ul><h4 id="4-5-重量级锁"><a href="#4-5-重量级锁" class="headerlink" title="4.5 重量级锁"></a>4.5 重量级锁</h4><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h4 id="4-6-synchronized的执行过程："><a href="#4-6-synchronized的执行过程：" class="headerlink" title="4.6 synchronized的执行过程："></a>4.6 synchronized的执行过程：</h4><ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li><li>如果自旋成功则依然处于轻量级状态。</li><li>如果自旋失败，则升级为重量级锁。</li></ol><blockquote><p>以上几种锁都是JVM自己内部实现，当我们执行synchronized同步块的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；</p></blockquote><h3 id="5-Java语言层面对锁的优化"><a href="#5-Java语言层面对锁的优化" class="headerlink" title="5. Java语言层面对锁的优化"></a>5. Java语言层面对锁的优化</h3><ol><li><strong>减少锁持有时间</strong><ul><li>不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</li></ul></li><li><strong>减少锁的粒度</strong><ul><li>它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；</li><li>java中很多数据结构都是采用这种方法提高并发操作的效率：<ul><li>ConcurrentHashMap: 使用Segment数组,Segment继承自ReenTrantLock，所以每个Segment就是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</li><li>LongAdder:实现思路也类似ConcurrentHashMap，LongAdder有一个根据当前并发状况动态改变的Cell数组，Cell对象里面有一个long类型的value用来存储值;开始没有并发争用的时候或者是cells数组正在初始化的时候，会使用cas来将值累加到成员变量的base上，在并发争用的情况下，LongAdder会初始化cells数组，在Cell数组中选定一个Cell加锁，数组有多少个cell，就允许同时有多少线程进行修改，最后将数组中每个Cell中的value相加，在加上base的值，就是最终的值；cell数组还能根据当前线程争用情况进行扩容，初始长度为2，每次扩容会增长一倍，直到扩容到大于等于cpu数量就不再扩容，这也就是为什么LongAdder比cas和AtomicInteger效率要高的原因，后面两者都是volatile+cas实现的，他们的竞争维度是1，LongAdder的竞争维度为“Cell个数+1”为什么要+1？因为它还有一个base，如果竞争不到锁还会尝试将数值加到base上；</li></ul></li><li>拆锁的粒度不能无限拆，最多可以将一个锁拆为当前CPU数量即可；</li></ul></li><li><strong>锁粗化</strong><ul><li>大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度(如:循环内的操作);</li></ul></li><li><strong>锁分离</strong><ul><li>使用读写锁: ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写；</li><li>读写分离: CopyOnWriteArrayList 、CopyOnWriteArraySet<ul><li>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</li><li>CopyOnWrite并发容器用于读多写少的并发场景，因为，读的时候没有锁，但是对其进行更改的时候是会加锁的，否则会导致多个线程同时复制出多个副本，各自修改各自的；</li></ul></li><li>LinkedBlockingQueue: LinkedBlockingQueue也体现了这样的思想，在队列头入队，在队列尾出队，入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高；</li></ul></li><li><strong>锁消除</strong><ul><li>在即时编译时,如果发现不可能被共享的对象,则可以消除对象的锁操作</li></ul></li><li><strong>无锁</strong>(如CAS)<ul><li>如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用CAS效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+CAS操作会是非常高效的选择；</li></ul></li><li>消除缓存行的伪共享<ul><li>除了我们在代码中使用的同步锁和jvm自己内置的同步锁外，还有一种隐藏的锁就是缓存行，它也被称为性能杀手。在多核cup的处理器中，每个cup都有自己独占的一级缓存、二级缓存，甚至还有一个共享的三级缓存，为了提高性能，cpu读写数据是以缓存行为最小单元读写的；32位的cpu缓存行为32字节，64位cup的缓存行为64字节，这就导致了一些问题。</li></ul></li></ol><h3 id="6-CAS与原子类"><a href="#6-CAS与原子类" class="headerlink" title="6. CAS与原子类"></a>6. CAS与原子类</h3><p>CAS即<code>Compare and Swap</code>翻译过来就是比较并替换, 它体现了一种乐观锁的思想 (synchronized为悲观锁思想); </p><ul><li>结合CAS和volatile可以实现<strong>无锁并发</strong>(非阻塞同步),适用于竞争不激烈,多核CPU的场景下(竞争激烈,重试频繁发生会影响效率);</li><li>CAS算法涉及到三个操作数: 内存值V, 旧值A, 新值B; 当且仅当V==A时，CAS用新值B来更新V，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</li><li>CAS底层依赖一个Unsafe类来直接调用操作系统底层的CAS指令;</li></ul><h4 id="6-1-Unsafe类"><a href="#6-1-Unsafe类" class="headerlink" title="6.1 Unsafe类"></a>6.1 Unsafe类</h4><p>java中CAS操作依赖于Unsafe类，Unsafe类所有方法都是native的，直接调用操作系统底层资源执行相应任务，它可以像C一样操作内存指针，是非线程安全的。</p><ul><li>Unsafe里的CAS 操作相关实现: compareAndSwapObject,compareAndSwapInt,compareAndSwapLong<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，</span></span><br><span class="line"><span class="comment">//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">long</span> expected,<span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-原子操作类"><a href="#6-2-原子操作类" class="headerlink" title="6.2 原子操作类"></a>6.2 原子操作类</h4><p>并发包JUC(java.util.concurrent)中的原子操作类(Atomic系列),底层是基于<code>CAS + volatile</code>实现的.</p><ul><li>AtomicBoolean：原子更新布尔类型</li><li>AtomicInteger：原子更新整型</li><li>AtomicLong：原子更新长整型</li></ul><p>下面看AtomicInteger类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取指针类Unsafe    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe(); </span><br><span class="line">    <span class="comment">//省略...获取内存偏移量等</span></span><br><span class="line">    <span class="comment">//如果当前值为expect，则设置为update(当前值指的是value变量)    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//当前值加1返回旧值，底层CAS操作    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger基本是基于Unsafe类中CAS相关操作实现的，是无锁操作。<br>再看Unsafe类中的getAndAddInt()方法，该方法执行一个CAS操作，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unsafe类中的getAndAddInt方法(JDK8)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> v;        </span><br><span class="line">    <span class="keyword">do</span> &#123;            </span><br><span class="line">        v = getIntVolatile(o, offset);        </span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));        </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出getAndAddInt通过一个while循环不断的重试更新要设置的值，直到成功为止，调用的是Unsafe类中的compareAndSwapInt方法，是一个CAS操作方法。</p><h4 id="6-3-CAS操作中可能会带来的ABA问题"><a href="#6-3-CAS操作中可能会带来的ABA问题" class="headerlink" title="6.3 CAS操作中可能会带来的ABA问题"></a>6.3 CAS操作中可能会带来的ABA问题</h4><p>ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。</p><ul><li><strong>无法正确判断这个变量是否已被修改过</strong>，一般称这种情况为ABA问题。</li><li>ABA问题一般不会有太大影响，产生几率也比较小。但是并不排除极特殊场景下会造成影响，因此需要解决方法：<ul><li>AtomicStampedReference类</li><li>AtomicMarkableReference类</li></ul></li><li><strong>AtomicStampedReference类</strong>: 一个带有时间戳的对象引用，每次修改时，不但会设置新的值，还会记录修改时间。在下一次更新时，不但会对比当前值和期望值，还会对比当前时间和期望值对应的修改时间，只有二者都相同，才会做出更新。解决了反复读写时，无法预知值是否已被修改的窘境。<ul><li>底层实现为：一个键值对Pair存储数据和时间戳，并构造volatile修饰的私有实例；两者都符合预期才会调用Unsafe的compareAndSwapObject方法执行数值和时间戳替换。</li></ul></li><li>AtomicMarkableReference类: 一个boolean值的标识，true和false两种切换状态表示是否被修改。不靠谱。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java内存模型-Java-Memory-Model&quot;&gt;&lt;a href=&quot;#Java内存模型-Java-Memory-Model&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型(Java Memory Model)&quot;&gt;&lt;/a&gt;Java内存模型(Java Memory Model)&lt;/h3&gt;&lt;p&gt;Java Memory Model(JMM)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节(可见性,有序性,原子性)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的变量都存储在主内存中&lt;/li&gt;
&lt;li&gt;每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)&lt;/li&gt;
&lt;li&gt;JMM规定：&lt;ul&gt;
&lt;li&gt;线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。&lt;/li&gt;
&lt;li&gt;不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】深入JVM(二)-类文件结构 与 类加载机制</title>
    <link href="http://chaooo.github.io/article/20190825.html"/>
    <id>http://chaooo.github.io/article/20190825.html</id>
    <published>2019-08-25T11:29:48.000Z</published>
    <updated>2019-10-29T08:11:29.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h3><p>Class文件是一组以 <strong>8 位字节</strong>为基础单位的二进制流，各个数据<strong>严格按照顺序紧凑的排列</strong>在 Class 文件中，中间无任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，会按照高位在前的方式分割成若干个 8 位字节进行存储。<br>Java 虚拟机规范规定 Class 文件格式采用一种类似与 C 语言结构体的伪结构体来存储数据，这种伪结构体中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。<a id="more"></a></p><ul><li><strong>无符号数</strong>：属于基本数据类型，以u1、u2、u4、u8来代表1个字节、2个字节、4个字节、8个字节的无符号数， 无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li><strong>表</strong>：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以「_info」结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件就是一张表。</li></ul><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                <span class="comment">//Class文件的标志(魔数)</span></span><br><span class="line">    u2             minor_version;        <span class="comment">//Class的小版本号</span></span><br><span class="line">    u2             major_version;        <span class="comment">//Class的大版本号</span></span><br><span class="line">    u2             constant_pool_count;  <span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;         <span class="comment">//Class的访问标记</span></span><br><span class="line">    u2             this_class;           <span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;          <span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;     <span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;          <span class="comment">//Class文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];  <span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;         <span class="comment">//Class文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;      <span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.chaooo.top/Java/JVM-class.png" alt></p><h4 id="1-1-魔数-Magic-Number"><a href="#1-1-魔数-Magic-Number" class="headerlink" title="1.1 魔数 (Magic Number)"></a>1.1 魔数 (Magic Number)</h4><ul><li>Class文件的<strong>0~3字节</strong>(前四个字节: ca fe ba be)</li><li>作用: 确定这个文件是否为一个能被虚拟机接收的Class文件</li></ul><h4 id="1-2-Class文件版本"><a href="#1-2-Class文件版本" class="headerlink" title="1.2 Class文件版本"></a>1.2 Class文件版本</h4><ul><li><strong>4~7字节</strong>, 其中4<del>5次版本号,6</del>7主版本号(如jdk8主版本号是: 00 34)</li></ul><h4 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h4><ul><li><strong>8~9字节</strong>表示16进制常量池数量,其后紧跟具体常量池, 常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）</li><li>常量池主要存放两大常量: <strong>字面量</strong>和<strong>符号引用</strong><ul><li>字面量: Java语言层面的常量概念(String,final等)</li><li>符号引用: 编译原理方面的概念(类和接口的全限定名\字段的名称和描述符\方法的名称和描述符)</li></ul></li><li>常量池中每一项常量都是一个表，这<strong>14种表</strong>有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型</strong></li><li>.class文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)</li></ul><h4 id="1-4-类的访问标志与继承信息"><a href="#1-4-类的访问标志与继承信息" class="headerlink" title="1.4 类的访问标志与继承信息"></a>1.4 类的访问标志与继承信息</h4><ul><li>在常量池结束之后，紧接着的<strong>两个字节</strong>代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等.</li><li>access_flags中一共有16个标志位可以使用，当前只定义了其中的8个，没有使用到的标志位要求一律为0。</li></ul><h4 id="1-5-当前类索引-this-父类索引-super-与接口索引集合-interfaces"><a href="#1-5-当前类索引-this-父类索引-super-与接口索引集合-interfaces" class="headerlink" title="1.5 当前类索引(this),父类索引(super)与接口索引集合(interfaces)"></a>1.5 当前类索引(<code>this</code>),父类索引(<code>super</code>)与接口索引集合(<code>interfaces</code>)</h4><ul><li>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</li><li>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</li></ul><h4 id="1-6-成员变量信息-Feild"><a href="#1-6-成员变量信息-Feild" class="headerlink" title="1.6 成员变量信息(Feild)"></a>1.6 成员变量信息(Feild)</h4><ul><li>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li><li>字段信息包括：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称，以上修饰符都是布尔类型。</li><li>方法和字段的描述符作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</li><li>根描述规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，对象类型使用字符L加对象的全限定名来表示。<ul><li>B: 基本类型byte</li><li>C: 基本类型char</li><li>D: 基本类型double</li><li>F: 基本类型float</li><li>I: 基本类型</li><li>J: 基本类型long</li><li>S: 基本类型short</li><li>Z: 基本类型boolean</li><li>V: 特殊类型void</li><li>L: 对象类型，如Ljava/lang/Object</li></ul></li></ul><h4 id="1-7-方法信息-Method"><a href="#1-7-方法信息-Method" class="headerlink" title="1.7 方法信息(Method)"></a>1.7 方法信息(Method)</h4><ul><li><code>methods_count</code> 表示方法的数量，而 <code>method_info</code> 表示的方法表。</li><li>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</li></ul><h4 id="1-8-附加属性信息"><a href="#1-8-附加属性信息" class="headerlink" title="1.8 附加属性信息"></a>1.8 附加属性信息</h4><ul><li><code>attributes_count</code>表示属性表中的属性个数, <code>attribute_info</code> 表示属性表</li><li>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</li></ul><h3 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h3><p>Java字节码指令就是Java虚拟机能够识别、可执行的指令，可以说是Jvm的最小执行单元。javac命令会将Java源文件编译成字节码文件，即.class文件，其中就包含了大量的字节码指令，javap命令可以解析字节码(.class文件)，将字节码内部逻辑以可读的方式呈现出来 (<code>javap -v -p HelloWorld</code>)。</p><ul><li>按指令的功能分为如下几类：<ol><li><strong>存储和加载类指令</strong>：主要包括load系列(将一个局部变量加载到操作数栈)、store系列(将一个数值从操作数栈存储到局部变量表)和ldc/push/const系列(将一个常量加载到操作数栈)，主要用于在<strong>局部变量表</strong>、<strong>操作数栈</strong>和<strong>常量池</strong>三者之间进行<strong>数据调度</strong>；<ul><li>例如: <code>iload_0</code>表示从当前栈帧局部变量表中0号位置取int类型的数值加载到操作数栈</li></ul></li><li><strong>对象操作指令</strong>（创建与读写访问）：比如我们刚刚的putfield和getfield就属于读写访问的指令，此外还有putstatic/getstatic，还有new系列指令，以及instanceof等指令。</li><li><strong>操作数栈管理指令</strong>：如pop和dup，他们只对操作数栈进行操作。</li><li>类型转换指令和运算指令：如add(加)/sub(减)/mul(乘)/div(除)/l2i/d2f等系列指令，实际上这类指令一般也只对操作数栈进行操作。</li><li>控制跳转指令：这类里包含常用的if系列指令以及goto类指令。</li><li><strong>方法调用和返回指令</strong>：主要包括invoke系列指令和return系列指令。这类指令也意味这一个方法空间的开辟和结束，即invoke会唤醒一个新的java方法小宇宙（新的栈和局部变量表），而return则意味着这个宇宙的结束回收。</li></ol></li><li>从指令操作的数据类型来讲：指令开头或尾部的一些字母，就往往表明了它所能操作的数据类型：<ul><li>a对应对象，表示指令操作对象性数据，比如aload和astore、areturn等等。</li><li>i对应整形。也就有iload，istore等i系列指令。</li><li>f对应浮点型，l对应long，b对应byte，d对应double，c对应char。</li><li>ia对应int array，aa对应object array，da对应double array。</li></ul></li></ul><h3 id="3-编译期处理-语法糖"><a href="#3-编译期处理-语法糖" class="headerlink" title="3. 编译期处理(语法糖)"></a>3. 编译期处理(语法糖)</h3><p><strong>语法糖</strong>: 指Java编译器把.java源码编译为.class字节码过程中,自动生成和转换的一些代码. 如:默认构造器,自动拆装箱等.</p><ol><li><strong>默认构造器</strong>: <code>public class Candy{}</code> 编译后为: <code>public class Candy{public Candy(){super();}}</code> </li><li><strong>自动拆装箱</strong>: <code>Integer x=1;int y=x;</code> 编译后为: <code>Integer x=Integer.valueOf(1);int y=x.intValue();</code></li><li><strong>泛型擦除</strong>: 擦除的是字节码上的泛型信息.</li><li><strong>泛型反射</strong>: 通过反射获得泛型信息</li><li><strong>可变参数</strong>: <code>String... args</code> 可以是一个<code>String[] args</code></li><li><strong>foreach</strong>: 集合相当于获取迭代器Iterator</li><li><strong>switch</strong>: Jdk7开始可以配合String和枚举<ul><li>switch-String: 执行了两遍switch,第一遍根据字符串的hashCode和equals将字符串转换为相应的byte类型,第二遍利用byte执行比较.</li><li>switch-枚举: 会为当前类生成一个静态内部类(合成类,仅JVM使用,对我们不可见),用来映射枚举类的枚举编号(从0开始)与数组元素的关系,数组大小即为枚举元素的个数,里面存储case用来对比的数字,根据这个数字执行switch</li></ul></li><li><strong>枚举类</strong>: 继承Enum并且用final修饰类,构造方法私有,枚举量被编译成本类的final类变量,定义私有静态枚举量数组$VALUES,静态方法values()用来返回定义的枚举量数组的clone(),静态方法valueOf()调用父类valueOf(本类.class,名称)根据类型和名称得到相应实例</li><li><strong>try-with-resources</strong>: 无论try块的异常还是关闭资源时的异常都不会丢。可以在 try-with-resources 语句中同时处理多个资源。<ul><li>在 Java 7/8 ，try-with-resources 语句中必须声明要关闭的资源。通过这种方式声明的资源属于隐式 final。</li><li>Java 9 中甚至能使用预先创建的资源，只要所引用的资源声明为 final 或者是 effective final。</li><li>在幕后施展魔法的是 AutoCloseable 或者 Closeable 接口，它们与 try-with-resources 语句协同工作。</li></ul></li><li><strong>重写桥接</strong>: 子类重写方法返回值可以是父类返回值的子类,JVM内部使用了桥接方法(synthetic bridge修饰)重写父类方法并返回子类重写的同名方法,并且没有命名冲突,仅对jvm可见.</li><li><strong>匿名内部类</strong>: 内部创建了final修饰的实现类, 匿名内部类引用局部变量时,局部变量必须是final的:因为内部创建实现类时,将值赋给其对象的valx属性,valx属性没有机会再跟着一起变化.</li></ol><h3 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4. 类加载阶段"></a>4. 类加载阶段</h3><ol><li>隐式加载：new</li><li>显式加载：loadClass、forName等(需要调用Class的newInstance方法获取实例)</li><li>类的装载阶段：<strong><code>加载 --&gt; 链接 --&gt; 初始化</code></strong><ul><li>加载：通过Classloader加载class文件字节码，生成class对象</li><li>链接：校验–&gt;准备–&gt;解析<ul><li>校验：检查加载的Class的正确性和安全性</li><li>准备：为变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池内的符号引用转换为直接引用</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ul></li></ol><h4 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h4><ul><li>将类的字节码载入方法区中,内部采用C++的instanceKlass描述java类, 它的重要field有:<ul><li><code>_java_mirror</code>:Java类的镜像, <code>_super</code>:父类, <code>_field</code>:成员变量, <code>_methods</code>:方法, <code>_constants</code>:常量池, <code>_class_loader</code>:类加载器, <code>_vtable</code>:虚方法表, <code>_itable</code>:接口方法表</li></ul></li><li>如果这个类还有父类没加载,先加载父类</li><li><strong>加载和链接可能是交替运行的</strong></li></ul><blockquote><p><code>instanceKlass</code>这样的元数据是存储在方法区(元空间),但<code>_java_mirror</code>存储在堆中; 可通过HSDB工具查看.</p></blockquote><h4 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h4><ol><li>验证: 验证类是否符合JVM规范,安全性检查</li><li>准备: 为static变量分配空间,设置默认值<ul><li>jdk7开始, static变量存储于<code>_java_mirror</code>末尾, jdk7之前是instanceKlass末尾.</li><li>static变量分配空间和赋值是两个步骤, 分配空间在准备阶段完成,赋值在初始化阶段完成</li><li>如果static变量是final的<strong>基本类型或字符串常量</strong>,那么编译阶段值就确定了,赋值在准备阶段完成</li><li>如果static变量是final的<strong>引用类型</strong>,那么赋值还是会在初始化阶段完成</li></ul></li><li>解析: 将常量池中的符号引用解析为直接引用(确切知道类,方法,属性在内存中的位置)</li></ol><h4 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h4><ul><li>初始化即调用<code>&lt;cinit&gt;()V</code>方法,虚拟机会<strong>保证</strong>这个类的[<strong>构造方法</strong>]<strong>线程安全</strong></li><li><strong>发生的时机</strong>: 概括的说,类初始化是[<strong>懒惰的</strong>]<ul><li>main方法所在的类的,总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化, 如果父类没有初始化,会引发</li><li>子类访问父类静态变量, 只会触发父类的初始化</li><li>Class.forName 和 new操作 导致初始化</li></ul></li><li><strong>不会</strong>导致类初始化的情况<ul><li>访问类的static final 静态常量(基本类型和字符串常量)<strong>不会</strong>触发初始化</li><li>类对象.class 不会</li><li>创建该类的数组 不会</li><li>类加载器的loadClass方法 不会</li><li>Class.forName的第二个参数为false时 不会</li></ul></li></ul><h4 id="4-4-应用实例-懒惰初始化单例模式-线程安全"><a href="#4-4-应用实例-懒惰初始化单例模式-线程安全" class="headerlink" title="4.4 应用实例-懒惰初始化单例模式(线程安全)"></a>4.4 应用实例-懒惰初始化单例模式(线程安全)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 内部类中保存单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次调用getInstance,才会导致内部类加载和初始化其静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5. 类加载器"></a>5. 类加载器</h3><p>以JDK8为例:</p><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>启动类加载器, 最顶层, 打印显示为null</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>扩展类加载器, 第二级, 打印显示为$ExtClassLoader</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>应用程序类加载器, 第三级, 打印显示为$AppClassLoader</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="5-1-类加载器-双亲委派机制"><a href="#5-1-类加载器-双亲委派机制" class="headerlink" title="5.1 类加载器-双亲委派机制"></a>5.1 类加载器-双亲委派机制</h4><ul><li>类加载器在接到加载类的请求时，首先将加载任务<strong>委托给上级加载器</strong>，依次递归，如果上级加载器可以完成类加载任务，就成功返回；只有上级加载器无法完成此加载任务时，才自己去加载。</li><li>这种双亲委派模式的好处，一个可以避免类的重复加载，另外也避免了java的核心API被篡改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * loadClass方法的实现方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//【1】 检查该类是否已经加载</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//【2】 有上级的话,委派上级 loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//【3】 如果没有上级了(ExtClassLoader),则委派BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//【4】 每一级都找不到,调用findClass(每个类加载器自己扩展)来加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-线程上下文类加载器"><a href="#5-2-线程上下文类加载器" class="headerlink" title="5.2 线程上下文类加载器"></a>5.2 线程上下文类加载器</h4><ul><li>Java 提供了很多服务提供者接口(Service Provider Interface，SPI),允许第三方为这些接口提供实现(常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等)。</li><li>SPI接口中的代码经常需要加载具体的实现类; SPI的接口由Java核心库来提供，实现类可能是作为Java应用所依赖的jar包被包含进来，可以通过类路径（CLASSPATH）来找到。</li><li>SPI的接口是Java核心库的一部分，是由引导类加载器来加载的；引导类加载器是无法找到SPI的实现类的,这时候需要抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类。</li><li>类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。</li><li>Java默认的 线程上下文类加载器 是 应用程序类加载器(AppClassLoader)。</li></ul><h4 id="5-3-何时使用Thread-getContextClassLoader"><a href="#5-3-何时使用Thread-getContextClassLoader" class="headerlink" title="5.3 何时使用Thread.getContextClassLoader()?"></a>5.3 何时使用Thread.getContextClassLoader()?</h4><ul><li>总的说来动态加载资源时，一般只有两种选择，当前类加载器和线程上下文类加载器。当前类加载器是指当前方法所在类的加载器。这个类加载器是运行时类解析使用的加载器，Class.forName(String)和Class.getResource(String)也使用该类加载器。代码中X.class的写法使用的类加载器也是这个类加载器。</li><li>该如何选择类加载器？<ul><li>如若代码是限于某些特定框架，这些框架有着特定加载规则，则不要做任何改动，让框架开发者来保证其工作（比如应用服务器提供商，尽管他们并不能总是做对）。如在Web应用和EJB中，要使用Class.gerResource来加载资源。</li><li>在其他情况下，我们可以自己来选择最合适的类加载器。可以使用策略模式来设计选择机制。其思想是将“总是使用上下文类加载器”或者“总是使用当前类加载器”的决策同具体实现逻辑分离开。往往设计之初是很难预测何种类加载策略是合适的，该设计能够让你可以后来修改类加载策略。</li><li>一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程。</li></ul></li></ul><h4 id="5-4-类加载器与Web容器"><a href="#5-4-类加载器与Web容器" class="headerlink" title="5.4 类加载器与Web容器"></a>5.4 类加载器与Web容器</h4><p>以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。<strong>该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类</strong>。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p><ul><li>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：<ol><li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li><li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li><li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li></ol></li></ul><h4 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h4><ol><li>什么时候需要自定义类加载器<ul><li>加载非classpath路径的任意路径类文件</li><li>都是通过接口来使用实现,希望解耦时,常用于框架设计</li><li>这些类希望予以隔离,不同应用的同名类都可以加载,不冲突,常见于tomcat容器</li></ul></li><li>如何自定义类加载器<ol><li>继承ClassLoader类</li><li>重写findClass(String className)方法</li><li>读取(加载)类文件的字节码。</li><li>调用ClassLoader超类的defineClass方法，向虚拟机提供字节码。</li><li>使用者调用该自定义类加载器的loadClass方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 类名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String cname = <span class="string">"E:\\myclasspath\\"</span> + name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] classBytes = Files.readAllBytes(Paths.get(cname));</span><br><span class="line">            Class&lt;?&gt; cl = defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">            <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.print(e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-运行期JVM自动优化"><a href="#6-运行期JVM自动优化" class="headerlink" title="6. 运行期JVM自动优化"></a>6. 运行期JVM自动优化</h3><p>Java程序最初是通过解释器进行解释执行的，当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。<strong>解释执行节约内存，编译执行提升效率</strong>。 同时，解释器可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，则通过逆优化退回到解释状态继续执行。<br>HotSpot虚拟机中内置了两个即时编译器，分别称为<strong>Client Compiler(C1编译器)</strong>和<strong>Server Compiler(C2编译器)</strong>，默认采用Interpreter(解释器)与其中一个编译器直接配合的方式工作，使用哪个编译器取决于虚拟机运行的模式，也可以自己去指定。</p><ul><li><p>分层编译策略, JVM将执行状态分成了5个层次:</p><ol><li>0层, 解释执行</li><li>1层, 使用C1即时编译器编译执行(不带profiling)</li><li>2层, 使用C1即时编译器编译执行(带基本的profiling)</li><li>3层, 使用C1即时编译器编译执行(带完全的profiling)</li><li>4层, 使用C2即时编译器编译执行<blockquote><p>profiling是指在运行过程中收集一些程序执行状态的数据,例如[方法的调用次数],[循环的回边次数]等</p></blockquote></li></ol></li><li><p>即时编译器(JIT)与解释器的区别</p><ul><li>解释器是将字节码解释为机器码,下次即便遇到相同的字节码,仍会执行重复的解释</li><li>JIT是将一些字节码编译为机器码并存入CodeCache,下次遇到相同的代码,直接执行,无需再编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT会根据平台类型,生成平台特定的机器码</li></ul></li><li><p>对于占据大部分的不常用的代码,我们无需耗费时间将其编译成机器码,而是采用解释执行的方式运行;另一方面,对于占据小部分的热点代码,我们则可以将其编译成机器码,以达到理想的运行速度;</p></li><li><p>执行效率: <code>Interpreter &lt; C1 &lt; C2</code>, 总的目标是发现热点代码(hotpot名称的由来)优化之.</p></li></ul><h4 id="6-1-公共子表达式消除"><a href="#6-1-公共子表达式消除" class="headerlink" title="6.1 公共子表达式消除"></a>6.1 公共子表达式消除</h4><p>如果一个表达式E已经计算过了，并且先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共表达式，可以直接用之前的结果替换。<br>例：int d = (c * b) * 12 + a + (a + b * c) =&gt; int d = E * 12 + a + (a + E)</p><h4 id="6-2-数组边界检查消除"><a href="#6-2-数组边界检查消除" class="headerlink" title="6.2 数组边界检查消除"></a>6.2 数组边界检查消除</h4><p>Java语言中访问数组元素都要进行上下界的范围检查，每次读写都有一次条件判定操作，这无疑是一种负担。编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组长度以内，那么整个循环中就可以把上下界检查消除，这样可以省很多次的条件判断操作。</p><h4 id="6-3-方法内联"><a href="#6-3-方法内联" class="headerlink" title="6.3 方法内联"></a>6.3 方法内联</h4><p>方法内联能去除方法调用的成本，同时也为其他优化建立了良好的基础，因此各种编译器一般会把内联优化放在优化序列的最靠前位置，然而由于Java对象的方法默认都是虚方法，在编译期无法确定方法版本，就无法内联。</p><ul><li>因此方法调用都需要在运行时进行多态选择，为了解决虚方法的内联问题，Java虚拟机团队引入了“类型继承关系分析(CHA)”的技术。<ol><li>在内联时，若是非虚方法，则可以直接内联  </li><li>遇到虚方法，首先根据CHA判断此方法是否有多个目标版本，若只有一个，可以直接内联，但是需要预留一个“逃生门”，称为守护内联，若在程序的后续执行过程中，加载了导致继承关系发生变化的新类，就需要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</li><li>若CHA判断此方法有多个目标版本，则编译器会使用“内联缓存”，第一次调用缓存记录下方法接收者的版本信息，并且每次调用都比较版本，若一致则可以一直使用，若不一致则取消内联，查找虚方法表进行方法分派。</li></ol></li></ul><h4 id="6-4-逃逸分析"><a href="#6-4-逃逸分析" class="headerlink" title="6.4 逃逸分析"></a>6.4 逃逸分析</h4><p>分析对象动态作用域，当一个方法被定以后，它可能被外部方法所引用，称为方法逃逸，甚至还有可能被外部线程访问到，称为线程逃逸。</p><ul><li>若能证明一个对象不会逃逸到方法或线程之外，这可以通过栈上分配、同步消除、标量替换来进行优化。<ol><li>栈上分配：如果确定一个对象不会逃逸，则可以让它分配在栈上，对象所占用的内存空间就可以随栈帧出栈而销毁。这样可以减小垃圾收集系统的压力。  </li><li>同步消除：线程同步相对耗时，如果确定一个变量不会逃逸出线程，那这个变量的读写不会有竞争，则对这个变量实施的同步措施也就可以消除掉。  </li><li>标量替换：如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那么程序真正执行的时候可以不创建这个对象，改为直接创建它的成员变量，这样就可以在栈上分配。</li></ol></li></ul><h3 id="7-反射机制"><a href="#7-反射机制" class="headerlink" title="7. 反射机制"></a>7. 反射机制</h3><p>简单说，反射机制是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。<br>Class反射对象描述的是类的语义结构，通过class对象，可以获取构造器，成员变量，方法等类元素的反射对象，并且可以用编程的方法通过这些反射对象对目标对象进行操作。<br>这些反射类在java.lang.reflect包中定义，下面是最主要的三个类：</p><ol><li>Constructor：类的构造函数反射类：<ul><li>通过Class#getConstructors()方法可以获得类的所有构造函数的反射对象数组。</li><li>其中最主要的方法是newInstance(Object[] args),通过该方法可以创建一个对象类的实例，功能和new一样。在jdk5.0之后，提供了newInstance(Object…args)更为灵活。</li></ul></li><li>Method：类方法的反射类。<ul><li>通过Class#getDeclaredMethods()方法可以获取所有方法的反射类对象数组Method[].其中最主要的方法是:</li><li>invoke(String name,class parameterTypes),和invoke(Object obj,Object…args)。同时也还有很多其他方法</li><li>Class getReturnType（）：获取方法的返回值类型</li><li>Class[] getParameterTypes（）：获取方法的参数数组</li></ul></li><li>Field：类成员变量的反射类，<ul><li>通过Class#getDeclareFields（）可以获取类成员变量反射的数组。</li><li>Class#getDeclareField（String  name）获取某特定名称的反射对象。</li><li>最主要的方法是：set(Object obj,Object value),为目标对象的成员变量赋值。如果是基础类型还可以这样赋值setInt(),setString()…</li></ul></li></ol><ul><li>java还提供了包的反射类和注解的反射类。</li><li>总结:java反射体系保证了通过程序化的方式访问目标对象的所有元素，对于private 和protected成员变量或者方法，也是可以访问的。</li></ul><h4 id="7-1-反射中，Class-forName和classloader的区别"><a href="#7-1-反射中，Class-forName和classloader的区别" class="headerlink" title="7.1 反射中，Class.forName和classloader的区别"></a>7.1 反射中，Class.forName和classloader的区别</h4><ul><li>Class.forName()得到的Class是完成初始化的</li><li>而ClassLoader.loadClass()得到的Class是还没有链接的。</li><li>Spring IoC为了加快初始化速度，因此大量使用了延时加载技术。而使用classloader不需要执行类中的初始化代码，可以加快加载速度，把类的初始化工作留到实际使用到这个类的时候。</li></ul><h4 id="7-2-哪里用到反射机制？"><a href="#7-2-哪里用到反射机制？" class="headerlink" title="7.2 哪里用到反射机制？"></a>7.2 哪里用到反射机制？</h4><ul><li>JDBC中，利用反射动态加载了数据库驱动程序。</li><li>Web服务器中利用反射调用了Sevlet的服务方法。</li><li>Eclispe等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。</li><li>很多框架都用到反射机制，注入属性，调用方法，如Spring。</li></ul><h4 id="7-3-反射机制的优缺点？"><a href="#7-3-反射机制的优缺点？" class="headerlink" title="7.3 反射机制的优缺点？"></a>7.3 反射机制的优缺点？</h4><p>优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。<br>缺点：对性能有影响，这类操作总是慢于直接执行java代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-类文件结构&quot;&gt;&lt;a href=&quot;#1-类文件结构&quot; class=&quot;headerlink&quot; title=&quot;1. 类文件结构&quot;&gt;&lt;/a&gt;1. 类文件结构&lt;/h3&gt;&lt;p&gt;Class文件是一组以 &lt;strong&gt;8 位字节&lt;/strong&gt;为基础单位的二进制流，各个数据&lt;strong&gt;严格按照顺序紧凑的排列&lt;/strong&gt;在 Class 文件中，中间无任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，会按照高位在前的方式分割成若干个 8 位字节进行存储。&lt;br&gt;Java 虚拟机规范规定 Class 文件格式采用一种类似与 C 语言结构体的伪结构体来存储数据，这种伪结构体中只有两种数据类型：&lt;strong&gt;无符号数&lt;/strong&gt;和&lt;strong&gt;表&lt;/strong&gt;。
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】深入JVM(一)-运行时数据区 与 垃圾回收机制</title>
    <link href="http://chaooo.github.io/article/20190823.html"/>
    <id>http://chaooo.github.io/article/20190823.html</id>
    <published>2019-08-23T15:15:19.000Z</published>
    <updated>2019-10-27T15:59:59.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java虚拟机运行时数据区"><a href="#Java虚拟机运行时数据区" class="headerlink" title="Java虚拟机运行时数据区"></a>Java虚拟机运行时数据区</h3><ol><li>程序计数器（Program Counter Register）</li><li>本地方法栈（Native Method Stack）</li><li>Java虚拟机栈（VM Stack）</li><li>Java堆（Heap）（线程共享）</li><li>方法区（Method Area）（线程共享）<a id="more"></a></li></ol><p><img src="http://cdn.chaooo.top/Java/JVM.png" alt></p><h4 id="Java运行过程"><a href="#Java运行过程" class="headerlink" title="Java运行过程"></a>Java运行过程</h4><ol><li><code>Java源代码</code> 经过<strong>Javac</strong>编译成 字节码（bytecode)<code>.class文件</code>;</li><li>在运行时，通过 <strong>虚拟机(JVM)内嵌的解释器</strong> 将<code>字节码</code>转换成为最终的<code>机器码</code>。</li></ol><blockquote><p>常见的JVM，都提供了 JIT(Just-In-Time)编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成机器码，所以准确的说Java代码会<code>解释执行或编译执行</code>。</p></blockquote><h3 id="1-程序计数器（Program-Counter-Register）"><a href="#1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.程序计数器（Program Counter Register）"></a>1.程序计数器（Program Counter Register）</h3><ul><li>线程私有</li><li>不会内存溢出</li><li>作用：记住下一条JVM指令的执行地址。</li></ul><h3 id="2-Java虚拟机栈（VM-Stack）"><a href="#2-Java虚拟机栈（VM-Stack）" class="headerlink" title="2.Java虚拟机栈（VM Stack）"></a>2.Java虚拟机栈（VM Stack）</h3><ul><li>线程私有</li><li>LIFO（后进先出）</li><li>存储栈帧，支撑Java方法的调用、执行和退出</li><li>可能出现OutOfMemoryError异常（如果被设计成动态扩展，而扩展又未申请到足够的内存抛出）和StackOverflowError异常（如线程请求的栈深度大于最大深度抛出）</li></ul><p><img src="http://cdn.chaooo.top/Java/JVM-stack.png" alt></p><h4 id="2-1-栈帧（Frame）"><a href="#2-1-栈帧（Frame）" class="headerlink" title="2.1 栈帧（Frame）"></a>2.1 栈帧（Frame）</h4><ul><li>Java虚拟机栈中存储的内容，它被用于存储数据和部分过程结构的数据结构，同时也被用来处理动态链接、方法返回值 和 异常分派</li><li>一个完整的栈帧包含：<strong>局部变量表</strong>、<strong>操作数栈</strong>、动态连接信息、方法正常完成和异常完成的信息</li><li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="2-2-局部变量表"><a href="#2-2-局部变量表" class="headerlink" title="2.2 局部变量表"></a>2.2 局部变量表</h4><ul><li>由若干个Slot组成，长度由编译期决定</li><li>单个Slot可以储存一个类型为boolean、byte、char、short、float、reference、returnAddress 的数据，两个Slot可以存储一个类型为long或double的数据</li><li>局部变量表用于方法间参数的传递，以及方法执行过程中存储基础数据类型的值和对象的引用</li></ul><h4 id="2-3-操作数栈"><a href="#2-3-操作数栈" class="headerlink" title="2.3 操作数栈"></a>2.3 操作数栈</h4><ul><li>一个后进先出栈，由若干个Entry组成，长度由编译期决定</li><li>单个Entry即可以存储一个Java虚拟机中定义的任意数据类型的值，包括long和double类型，但是存储long和double类型的Entry深度为2，其他类型深度为1</li><li>在方法执行过程中，栈帧用于存储计算参数和计算结果；在方法调用时，操作数栈也用来准备调用方法的参数以及接收方法返回结果</li></ul><h4 id="2-4-栈的内存溢出（StackOverflowError）"><a href="#2-4-栈的内存溢出（StackOverflowError）" class="headerlink" title="2.4 栈的内存溢出（StackOverflowError）"></a>2.4 栈的内存溢出（StackOverflowError）</h4><ol><li>栈帧过多导致内存溢出（方法的递归调用）</li><li>栈帧过大导致内存溢出</li><li>JSON数据转换可能导致内存溢出（可用@JsonIgnore忽略不能转换的属性）</li></ol><h4 id="2-5-线程诊断"><a href="#2-5-线程诊断" class="headerlink" title="2.5 线程诊断"></a>2.5 线程诊断</h4><ol><li>案例1：cpu占用过高<ul><li>Linux下，<code>top</code>打印所有进程，筛选cpu占用高的进程号，如：32655</li><li>用<code>ps H -eo pid,tid,%cpu | grep 32655</code>打印32655的所有线程，定位到具体cpu占用过高的线程</li><li><code>jstack 进程id</code>打印该线程的所有线程详情</li><li>将线程id换算成16进制，对比打印出的线程详情，定位到具体线程，进一步定位到源代码具体代码行号。</li></ul></li><li>案例2：程序运行很长时间没有结果<ul><li>前面步骤同上，<code>jstack 进程id</code>打印该线程的所有线程详情</li><li>在最后一段找到了 Found one Java-level <strong>deadlock</strong>，定位死锁的具体行号。</li></ul></li></ol><h3 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.本地方法栈（Native Method Stack）"></a>3.本地方法栈（Native Method Stack）</h3><ul><li>线程私有</li><li>LIFO（后进先出）</li><li>支撑Native方法的调用、执行和退出</li><li>可能出现OutOfMemoryError异常 和 StackOverflowError异常</li><li>有一些虚拟机（如HotSpot）将Java虚拟机栈和本地方法栈合并实现</li></ul><h4 id="3-1-Java虚拟机栈和本地方法栈可能发生的异常情况："><a href="#3-1-Java虚拟机栈和本地方法栈可能发生的异常情况：" class="headerlink" title="3.1 Java虚拟机栈和本地方法栈可能发生的异常情况："></a>3.1 Java虚拟机栈和本地方法栈可能发生的异常情况：</h4><ul><li>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量时，Java虚拟机将会抛出一个StackOverflowError异常</li><li>如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</li></ul><h3 id="4-Java堆（Heap）"><a href="#4-Java堆（Heap）" class="headerlink" title="4.Java堆（Heap）"></a>4.Java堆（Heap）</h3><ul><li>全局共享</li><li>通常是Java虚拟机中最大的一块内存区域</li><li>作用是作为Java对象的主要存储区域（通过new创建的对象都会使用堆内存）</li><li>有垃圾回收机制</li></ul><p><img src="http://cdn.chaooo.top/Java/JVM-heap.png" alt></p><h4 id="4-1-Java堆可能发生的异常"><a href="#4-1-Java堆可能发生的异常" class="headerlink" title="4.1 Java堆可能发生的异常"></a>4.1 Java堆可能发生的异常</h4><ul><li>如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那Java虚拟机将会抛出一个OutOfMemoryError异常。</li></ul><h4 id="4-2-堆内存诊断"><a href="#4-2-堆内存诊断" class="headerlink" title="4.2 堆内存诊断"></a>4.2 堆内存诊断</h4><ol><li><strong>jps工具</strong>：查看当前系统中有哪些Java进程</li><li><strong>jmap工具</strong>：查看堆内存占用情况<code>jmap -head 进程id</code></li><li><strong>jconsole工具</strong>：图形界面，多功能的监测工具，可以连续监测</li></ol><ul><li>案例：垃圾回收后，内存占用仍然很高<ul><li>jps工具定位进程，<code>jmap -head 进程id</code>查看堆使用情况，</li><li>可以用jconsole工具手动执行GC</li><li>用jvirsualvm抓取堆dump(快照，抓取堆里面有哪些类型的对象及个数等信息)</li></ul></li></ul><h4 id="4-3-字符串常量池-StringTable"><a href="#4-3-字符串常量池-StringTable" class="headerlink" title="4.3 字符串常量池 (StringTable)"></a>4.3 字符串常量池 (StringTable)</h4><ul><li>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；</li><li>在JDK7.0版本，字符串常量池被移到了堆中</li><li>字符串手动入池:  调用<code>String.intern()</code></li></ul><h3 id="5-方法区（Method-Area）"><a href="#5-方法区（Method-Area）" class="headerlink" title="5.方法区（Method Area）"></a>5.方法区（Method Area）</h3><ul><li>全局共享</li><li>作用是存储Java类的结构信息</li><li>JVMS不要求该区域实现自动内存管理，但是商用Java虚拟机都能够自动管理该区域内存</li><li>在JDK1.8后，方法区由元空间实现</li></ul><blockquote><p>方法区内存溢出场景：spring、mabatis等动态加载类的场景使用不当会导致方法区内存溢出</p></blockquote><h4 id="5-1-运行时常量池"><a href="#5-1-运行时常量池" class="headerlink" title="5.1 运行时常量池"></a>5.1 运行时常量池</h4><ul><li>全局共享</li><li>是方法区的一部分</li><li>作用是存储Java类文件常量池中的符号信息</li><li>可能出现OutOfMemoryError异常</li></ul><h4 id="5-2-永久代与方法区"><a href="#5-2-永久代与方法区" class="headerlink" title="5.2 永久代与方法区"></a>5.2 永久代与方法区</h4><ul><li>在JDK1.2~6，HotSpot使用永久代实现方法区</li><li>在JDK1.7，开始移除（符号表被到Native Heap，字符串常量和类的静态引用被移到Java Head中）</li><li>在JDK1.8，永久代被元空间（Metaspace）所替代</li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h3><ul><li>全局共享</li><li>并非JVMS定义的标准Java运行时内存区域, 属于操作系统内存</li><li>JDK1.4引入NIO，目的是避免Java堆 和 Native堆 中来回 复制数据 带来的性能损耗。</li><li>能被自动管理，但是在检测手段上可能会由一些简陋</li><li>可能出现OutOfMemoryError异常</li><li>常用于NIO操作时，用于数据缓冲区</li><li>分配回收成本高，但读写性能高，不受JVM内存回收管理</li></ul><h3 id="7-可回收对象的判定"><a href="#7-可回收对象的判定" class="headerlink" title="7.可回收对象的判定"></a>7.可回收对象的判定</h3><ol><li>引用计数法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就+1，当引用失效就-1，任何时候计数器为0时就是可回收对象。</li><li>可达性分析：通过一系列名为GC Roots的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则称该对象是不可达的。</li></ol><blockquote><p>目前主流Java虚拟机中<strong>并没有</strong>选用引用计数法，其中最重要的原因是它很难解决<strong>循环引用问题</strong></p></blockquote><h4 id="7-1-Java语言中的GC-Roots"><a href="#7-1-Java语言中的GC-Roots" class="headerlink" title="7.1 Java语言中的GC Roots"></a>7.1 Java语言中的GC Roots</h4><ul><li>在虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>在方法区中的类静态属性引用的对象。</li><li>在方法区中的常量引用的对象。</li><li>在本地方法栈中JNI（即一般说的Native方法）的引用对象。</li></ul><h4 id="7-2-Java引用类型"><a href="#7-2-Java引用类型" class="headerlink" title="7.2 Java引用类型"></a>7.2 Java引用类型</h4><ol><li>强引用：Java中默认声明的就是强引用<ul><li>垃圾回收器将永远<strong>不会</strong>回收被【强引用】对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。可以赋值为null中断强引用。</li></ul></li><li>软引用（SoftReference）：用来描述一些非必需但仍有用的对象，用java.lang.ref.SoftReference类来表示软引用<ul><li>垃圾回收后，在内存<strong>不足时会</strong>再次触发垃圾回收，回收【软引用】对象，仍不足，才会抛出内存溢出异常。可以配合引用队列来释放软引用自身。</li></ul></li><li>弱引用（WeakReference）：用 java.lang.ref.WeakReference 来表示弱引用<ul><li>垃圾回收器将永远<strong>都会</strong>回收被【弱引用】对象，无论内存是否足够。可以配合引用队列来释放弱引用自身。</li></ul></li><li>虚引用（PhantomReference）：最弱的一种引用关系，用 PhantomReference 类来表示<ul><li><strong>必须配合引用队列</strong>使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存。</li></ul></li></ol><h3 id="8-垃圾回收算法"><a href="#8-垃圾回收算法" class="headerlink" title="8.垃圾回收算法"></a>8.垃圾回收算法</h3><ol><li>标记清除算法（Mark-Sweep）</li><li>标记整理算法(Mark-Compact)</li><li>复制算法（copying）</li></ol><h4 id="8-1-分代垃圾回收（Java堆分为新生代和老年代）"><a href="#8-1-分代垃圾回收（Java堆分为新生代和老年代）" class="headerlink" title="8.1 分代垃圾回收（Java堆分为新生代和老年代）"></a>8.1 分代垃圾回收（Java堆分为新生代和老年代）</h4><ol><li>对象首先分配在新生代的<code>Eden区</code></li><li>新生代空间不足时，触发 <code>Minor GC</code>，Eden区和From幸存区(Survivor)存活的对象使用coping复制到To幸存区中，存活的年龄+1 并且交换From和To。</li><li>Minor GC会引发 <code>STW(Stop the world)</code>，暂停其他用户的线程，等垃圾回收结束后，用户线程才恢复运行</li><li>当对象<code>寿命超过阈值</code>时，会晋升至老年代，最大寿命15(4bit)</li><li>当老年代空间不足，会先尝试触发 Minor GC，如果之后空间仍不足，那么触发 <code>Full GC</code>，STW的时间更长</li></ol><h4 id="8-2-相关JVM参数"><a href="#8-2-相关JVM参数" class="headerlink" title="8.2 相关JVM参数"></a>8.2 相关JVM参数</h4><ol><li>堆初始大小：         <code>-Xms</code></li><li>堆最大大小：         <code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></li><li>新生代大小：         <code>-Xmn</code> 或 <code>(-XX:NewSize=size + -XX:MaxNewSize=size)</code></li><li>幸存区比例（动态）：  <code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></li><li>幸存区比例：         <code>-XX:SurvivorRatio=ratio</code></li><li>晋升阈值：           <code>-XX:MaxTenuringThreshold=threshold</code></li><li>晋升详情：           <code>-XX:+PrintTenuringDistribution</code></li><li>GC详情：            <code>-XX:+PrintGCDetils -verbose:gc</code></li><li>FullGC 前 MinorGC： <code>-XX:+ScavengeBeforeFullGC</code></li></ol><h3 id="9-垃圾回收器"><a href="#9-垃圾回收器" class="headerlink" title="9.垃圾回收器"></a>9.垃圾回收器</h3><ol><li>串行（开启：<code>-XX:+UseSerialGC=Serial + SerialOld</code>）<ul><li>单线程</li><li>适合堆内存较小，适合个人电脑</li></ul></li><li>吞吐量优先<ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>让单位时间内，总STW的时间最短</li></ul></li><li>响应时间优先<ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽量让单次STW的时间最短</li></ul></li></ol><h4 id="9-1-吞吐量优先（并行）回收器"><a href="#9-1-吞吐量优先（并行）回收器" class="headerlink" title="9.1 吞吐量优先（并行）回收器"></a>9.1 吞吐量优先（并行）回收器</h4><ol><li>开启(默认开启)： <code>-XX:+UseParallelGC</code> ~ <code>-XX:+UseParallelOldGC</code></li><li>动态调整堆大小：<code>-XX:+UseAdaptiveSizePolicy</code></li><li>目标吞吐量：<code>-XX:GCTimeRatio=ratio</code> </li><li>最大暂停时间的目标值：<code>-XX:MaxGCPauseMillis=ms</code></li><li>线程数：<code>-XX:ParallelGCThreads=n</code></li></ol><h4 id="9-2-响应时间优先（并发）回收器"><a href="#9-2-响应时间优先（并发）回收器" class="headerlink" title="9.2 响应时间优先（并发）回收器"></a>9.2 响应时间优先（并发）回收器</h4><p>可以和用户线程<strong>并发</strong>执行，工作在老年代</p><ol><li>开启：<code>-XX:+UseConcMarkSweepGC</code> 配合 <code>-XX:UseParNewGC</code> ~ <code>SerialOld</code></li><li>并行和并发线程数：<code>-XX:ParallelGCThreads=n</code> ~ <code>-XX:ConsGCThreads=threads</code></li><li>回收时机（内存占比）:<code>-XX:CMSInitiatingOccupancyFraction=percent</code></li><li>重新标记前对新生代先做垃圾回收：<code>-XX:+CMSScavengeBeforeRemark</code></li></ol><h4 id="9-3-G1（Garbage-First）（并发）"><a href="#9-3-G1（Garbage-First）（并发）" class="headerlink" title="9.3 G1（Garbage First）（并发）"></a>9.3 G1（Garbage First）（并发）</h4><ol><li>G1回收器 适用场景<ul><li>同时注重 吞吐量(Throughput)和低延迟(Low latency)，默认暂停目标是200ms</li><li>超大堆内存，会将堆划分为多个大小相等的区域(Region)</li><li>整体上是标记+整理算法，两个区域之间是复制算法</li></ul></li><li>相关JVM参数<ul><li>开启（JDK9默认）：<code>-XX:+UseG1GC</code></li><li>区域大小：<code>-XX:G1HeapRegionSize=size</code></li><li>最大暂停时间：<code>-XX:MaxGCPauseMillis=time</code></li></ul></li><li>G1垃圾回收阶段（三个阶段循环）<ol><li><strong><code>Young Collection</code></strong>：新生代GC（会STW）</li><li><strong><code>Young Collection + Concurrent Mark</code></strong>：<ul><li>在YoungGC时会进行<code>GC Root</code>的初始标记</li><li>老年代占用堆空间比例达到阈值值，进行并发标记(不会STW)，由下面的JVM参数决定</li><li><code>-XX:InitiatingHeadOccupancyPercent=percent</code>(默认45%)</li></ul></li><li><strong><code>Mixed Collection</code></strong>：会对Eden、Survivor、Old进行全面垃圾回收<ul><li>最终标记(Remark)会STW</li><li>拷贝存活(Evacuation)会STW</li><li>为达到最大暂停时间短的目标，Old区是优先回收垃圾最多的区域</li></ul></li></ol></li></ol><h4 id="9-4-Minor-GC-和-Full-GC"><a href="#9-4-Minor-GC-和-Full-GC" class="headerlink" title="9.4 Minor GC 和 Full GC"></a>9.4 Minor GC 和 Full GC</h4><ol><li>SerialGC<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：Full GC</li></ul></li><li>ParallelGC<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：Full GC</li></ul></li><li>CMS<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：分两种情况（回收速度高于内存产生速度不会触发Full GC）</li></ul></li><li>G1<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：分两种情况（回收速度高于内存产生速度不会触发Full GC）</li></ul></li></ol><blockquote><ul><li><code>Minor GC</code>：当Eden区满时，触发Minor GC</li><li><code>Full GC</code>：<ul><li>System.gc()方法的调用</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、From幸存区 向 To幸存区 复制时，对象大小大于To区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li></ul></blockquote><h3 id="10-垃圾回收调优"><a href="#10-垃圾回收调优" class="headerlink" title="10.垃圾回收调优"></a>10.垃圾回收调优</h3><ol><li>调优领域：内存、锁竞争、CPU占用、IO</li><li>调优目标：【低延迟】还是【高吞吐量】（高吞吐量:ParallelGC，低延迟:CMS,G1,ZGC）</li><li>最快的GC是不发生GC：查看Full GC前后的内存占用（内存数据太多？数据表示太臃肿？内存泄漏？）</li><li>新生代调优：new操作内存分配廉价、死亡对象回收代价是零、大部分对象用过即死、MinorGC时间远低于FullGC</li></ol><h4 id="10-1-新生代调优"><a href="#10-1-新生代调优" class="headerlink" title="10.1 新生代调优"></a>10.1 新生代调优</h4><ol><li>理想情况：新生代能容纳所有【并发量*(请求-响应)】的数据</li><li>幸存区大到能够保留【当前活跃对象+需要晋升对象】</li><li>【晋升阈值配置】得当，让长时间存活的对象尽快晋升<ul><li>调整最大晋升阈值：<code>-XX:MaxTenuringThreshold=threshold</code></li><li>打印晋升详情：<code>-XX:+PrintTenuringDistribution</code></li></ul></li></ol><h4 id="10-2-老年代调优"><a href="#10-2-老年代调优" class="headerlink" title="10.2 老年代调优"></a>10.2 老年代调优</h4><p>以CMS为例：</p><ol><li>CMS的老年代内存越大越好（避免浮动垃圾引起的并发失败）</li><li>先尝试不做调优，如果没有FullGC那么已经OK，否则先尝试调优新生代</li><li>观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3<ul><li><code>-XX:CMSInitiatingOccupancyPercent=percent</code></li></ul></li></ol><h4 id="10-3-调优案例"><a href="#10-3-调优案例" class="headerlink" title="10.3 调优案例"></a>10.3 调优案例</h4><ol><li>案例1：FullGC 和 MinorGC频繁<ul><li>可能原因：空间紧张，若业务高峰期时，新生代空间紧张，幸存区的晋升阈值会降低，大量本来生存短对象晋升老年区，进一步触发老年代FullGC的频繁发生</li><li>解决方法：经过分析，观察堆空间大小，先试着增大新生代内存，同时增大幸存区的空间以及晋升阈值。</li></ul></li><li>案例2：请求高峰期发生了FullGC，单次暂停时间特别长（CMS）<ul><li>查看日志，看CMS哪个阶段暂停时间长（重新标记阶段），解决：打开开关参数CMSScavengeBeforeRemark</li><li>重新标记前对新生代先做垃圾回收：<code>-XX:+CMSScavengeBeforeRemark</code></li></ul></li></ol><h4 id="10-4-G1调优最佳实践"><a href="#10-4-G1调优最佳实践" class="headerlink" title="10.4 G1调优最佳实践"></a>10.4 G1调优最佳实践</h4><ol><li>不要设置新生代和老年代的大小<ul><li>G1收集器在运行的时候会调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间目标。设置了新生代大小相当于放弃了G1为我们做的自动调优。我们需要做的只是设置整个堆内存的大小，剩下的交给G1自己去分配各个代的大小。</li></ul></li><li>不断调优暂停时间指标<ul><li>通过XX:MaxGCPauseMillis=x可以设置启动应用程序暂停的时间，G1在运行的时候会根据这个参数选择CSet来满足响应时间的设置。一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。</li></ul></li><li>关注Evacuation Failure<ul><li>Evacuation Failure类似于CMS里面的晋升失败，堆空间的垃圾太多导致无法完成Region之间的拷贝，于是不得不退化成Full GC来做一次全局范围内的垃圾收集。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java虚拟机运行时数据区&quot;&gt;&lt;a href=&quot;#Java虚拟机运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机运行时数据区&quot;&gt;&lt;/a&gt;Java虚拟机运行时数据区&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;程序计数器（Program Counter Register）&lt;/li&gt;
&lt;li&gt;本地方法栈（Native Method Stack）&lt;/li&gt;
&lt;li&gt;Java虚拟机栈（VM Stack）&lt;/li&gt;
&lt;li&gt;Java堆（Heap）（线程共享）&lt;/li&gt;
&lt;li&gt;方法区（Method Area）（线程共享）
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Java知识梳理】网络协议</title>
    <link href="http://chaooo.github.io/article/20190815.html"/>
    <id>http://chaooo.github.io/article/20190815.html</id>
    <published>2019-08-15T13:04:33.000Z</published>
    <updated>2019-10-20T05:59:00.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分层网络协议"><a href="#1-分层网络协议" class="headerlink" title="1. 分层网络协议"></a>1. 分层网络协议</h3><ol><li>OSI七层网络协议：物理层，数据链路层，网络层，传输层(TCP/UDP)，会话层，表示层，应用层</li><li>TCP/IP协议分层(可以理解为OSI的一种实现)：网络接口层，网络层，传输层(TCP/UDP)，应用层<a id="more"></a></li></ol><h3 id="2-TCP通信协议简介："><a href="#2-TCP通信协议简介：" class="headerlink" title="2. TCP通信协议简介："></a>2. TCP通信协议简介：</h3><ul><li>面向连接的、可靠的、基于字节流的 传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来校验数据在传输过程中是否有误</li><li>报文头中的ACK(确认序号标志)，SYN(同步序号，用于建立连接过程)</li></ul><h3 id="3-TCP建立连接的三次握手"><a href="#3-TCP建立连接的三次握手" class="headerlink" title="3. TCP建立连接的三次握手"></a>3. TCP建立连接的三次握手</h3><ol><li>第一次：建立连接时，客户端发送<code>SYN包(syn=j)</code>到服务器，并进入<code>SYS_SEND</code>状态，等待服务器确认；</li><li>第二次：服务器收到<code>SYN包</code>，必须确认客户的<code>SYN(ack=j+1)</code>，同时自己也发送一个<code>SYN包(syn=k)</code>，即 <code>SYN+ACK包</code>，此时服务器进入<code>SYN_RECV</code>状态；</li><li>第三次：客户端收到<code>SYN+ACK包</code>，向服务器发送确认包<code>ACK(ack=k+1)</code>，此包发送完毕，客户端和服务端进入<code>ESTABLISHED</code>状态，完成三次握手。</li></ol><h3 id="4-为什么需要三次握手"><a href="#4-为什么需要三次握手" class="headerlink" title="4. 为什么需要三次握手"></a>4. 为什么需要三次握手</h3><ul><li>为了初始化Sequence Number的初始值（通信双方要互相通知对方自己的Sequence Number，要作为以后数据通信的序号，以保证接收到的数据不会因为网络传输问题而乱序，TCP会用这个序号拼接数据）</li></ul><h3 id="5-首次握手的隐患—SYN超时"><a href="#5-首次握手的隐患—SYN超时" class="headerlink" title="5. 首次握手的隐患—SYN超时"></a>5. 首次握手的隐患—SYN超时</h3><ul><li>服务端收到客户端的SYN，回复SYN-ACK的时候未收到ACK确认</li><li>服务端不断尝试(重发SYN-ACK)直至超时，Linux默认等待63秒才断开连接(默认重试5次，重试间隔1s开始，每次翻倍，即1+2+4+8+16+32=63)</li><li>可能遭受SYN Flood的风险(syn攻击，又称为ddos攻击)</li></ul><h3 id="6-什么是SYN-Flood攻击"><a href="#6-什么是SYN-Flood攻击" class="headerlink" title="6. 什么是SYN Flood攻击"></a>6. 什么是SYN Flood攻击</h3><ul><li>客户端恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB，从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。而攻击发起方的资源消耗相比较可忽略不计。</li><li>SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一。</li></ul><h3 id="7-Linux针对SYN-Flood的防护措施"><a href="#7-Linux针对SYN-Flood的防护措施" class="headerlink" title="7. Linux针对SYN Flood的防护措施"></a>7. Linux针对SYN Flood的防护措施</h3><ul><li>SYN队列满后，通过tcp_syncookies参数回发SYN Cookies</li><li>若为正常连接则客户端会回发SYN Cookies，直接建立连接</li></ul><h3 id="8-建立连接后，客户端出现故障怎么办（保活机制）"><a href="#8-建立连接后，客户端出现故障怎么办（保活机制）" class="headerlink" title="8. 建立连接后，客户端出现故障怎么办（保活机制）"></a>8. 建立连接后，客户端出现故障怎么办（保活机制）</h3><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测树仍未收到响应则中断连接</li></ul><h3 id="9-TCP终止连接的四次挥手（以客户端主动为例）"><a href="#9-TCP终止连接的四次挥手（以客户端主动为例）" class="headerlink" title="9. TCP终止连接的四次挥手（以客户端主动为例）"></a>9. TCP终止连接的四次挥手（以客户端主动为例）</h3><ol><li>第一次：客户端发送一个<code>FIN(seq=u)</code>，用来关闭客户端到服务器的数据传送，客户端进入<code>FIN_WAIT_1</code>状态；</li><li>第二次：服务器收到<code>FIN</code>，发回一个<code>ACK(ack=u+1)</code>，确认序号为收到的序号+1(和SYN一样，一个FIN将占用一个序号)，服务端进入<code>CLOSE_WAIT</code>状态；</li><li>第三次：服务端发送一个<code>FIN(seq=w)</code>，用来关闭服务端到客户端的数据传送，服务端进入<code>LAST_ACK</code>状态；</li><li>第四次：客户端收到<code>FIN</code>，发回一个<code>ACK(ack=w+1)</code>，将确认序号设置为收到序号+1，客户端进入<code>TIME_WAIT</code>状态，服务端进入<code>CLOSED</code>状态，完成四次挥手。</li></ol><h3 id="10-存在TIME-WAIT状态的原因"><a href="#10-存在TIME-WAIT状态的原因" class="headerlink" title="10. 存在TIME_WAIT状态的原因"></a>10. 存在TIME_WAIT状态的原因</h3><ul><li>保证TCP全双工连接的可靠释放，确保有足够时间让对方收到ACK包</li><li>避免新旧来凝结混淆，使旧数据包在网络中因过期而失效</li></ul><h3 id="11-为什么需要四次挥手"><a href="#11-为什么需要四次挥手" class="headerlink" title="11. 为什么需要四次挥手"></a>11. 为什么需要四次挥手</h3><ul><li>因为全双工，发送方和接收方都需要FIN报文和ACK报文</li></ul><h3 id="12-服务器出现大量CLOSE-WAIT状态的原因"><a href="#12-服务器出现大量CLOSE-WAIT状态的原因" class="headerlink" title="12. 服务器出现大量CLOSE_WAIT状态的原因"></a>12. 服务器出现大量CLOSE_WAIT状态的原因</h3><ul><li>对方关闭socket连接，我方忙于读或写，没有及时关闭连接<ul><li>检查代码，特别是释放资源的代码</li><li>检查配置，特别是处理请求的线程配置</li></ul></li></ul><h3 id="13-UDP简介"><a href="#13-UDP简介" class="headerlink" title="13. UDP简介"></a>13. UDP简介</h3><ul><li>面向非连接</li><li>不维护连接状态，支持同时向多个客户端传输相同消息</li><li>数据包报头只有8个字节，额外开销小</li><li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠性，不需要维持复杂的链接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或者合并</li></ul><h3 id="14-TCP和UDP的区别"><a href="#14-TCP和UDP的区别" class="headerlink" title="14. TCP和UDP的区别"></a>14. TCP和UDP的区别</h3><ul><li>面向连接 vs 无连接</li><li>可靠性和有序性 vs 不保证</li><li>全双工的字节流 vs 全双工的数据报</li><li>效率低 vs 速度快</li><li>重量级 vs 轻量级</li></ul><h3 id="15-Http协议简介"><a href="#15-Http协议简介" class="headerlink" title="15. Http协议简介"></a>15. Http协议简介</h3><ul><li>基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），Hyper Text Transfer Protocol（超文本传输协议）的缩写。</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法(GET、HEAD、POST等)和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li><strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</li><li><strong>支持B/S及C/S模式</strong>。</li></ul><h3 id="16-HTTP-请求-响应的步骤"><a href="#16-HTTP-请求-响应的步骤" class="headerlink" title="16. HTTP 请求/响应的步骤"></a>16. HTTP 请求/响应的步骤</h3><ol><li>客户端连接到Web服务器<ul><li>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="https://chaooo.github.io">https://chaooo.github.io</a>。</li></ul></li><li>发送HTTP请求<ul><li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li></ul></li><li>服务器接受请求并返回HTTP响应<ul><li>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li></ul></li><li>释放连接TCP连接<ul><li>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li></ul></li><li>客户端浏览器解析HTML内容<ul><li>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li></ul></li></ol><h3 id="17-在浏览器地址栏键入URL，按下回车之后会经历以下流程："><a href="#17-在浏览器地址栏键入URL，按下回车之后会经历以下流程：" class="headerlink" title="17. 在浏览器地址栏键入URL，按下回车之后会经历以下流程："></a>17. 在浏览器地址栏键入URL，按下回车之后会经历以下流程：</h3><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li><li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li><li>释放 TCP连接;</li><li>浏览器将该 html 文本并显示内容; 　</li></ol><h3 id="18-HTTP之状态码"><a href="#18-HTTP之状态码" class="headerlink" title="18. HTTP之状态码"></a>18. HTTP之状态码</h3><ol><li>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<ul><li>1xx：指示信息–表示请求已接收，继续处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li>5xx：服务器端错误–服务器未能实现合法的请求</li></ul></li><li>常见状态码：<ul><li>200 OK                    //客户端请求成功</li><li>400 Bad Request           //客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized          //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li><li>403 Forbidden             //服务器收到请求，但是拒绝提供服务</li><li>404 Not Found             //请求资源不存在，eg：输入了错误的URL</li><li>500 Internal Server Error //服务器发生不可预期的错误</li><li>503 Server Unavailable    //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul></li></ol><h3 id="19-HTTPS和HTTP的区别："><a href="#19-HTTPS和HTTP的区别：" class="headerlink" title="19. HTTPS和HTTP的区别："></a>19. HTTPS和HTTP的区别：</h3><ol><li>https协议需要到CA申请证书(收费)，http不需要。</li><li>https密文传输，http明文传输。</li><li>http使用80端口，https默认使用443端口。</li><li>https = http + 加密 + 认证 + 完整性保护</li></ol><h3 id="20-Socket简介"><a href="#20-Socket简介" class="headerlink" title="20. Socket简介"></a>20. Socket简介</h3><ul><li><p>Socket是对TCP/IP协议的抽象，是操作系统对外开发的接口</p></li><li><p>基于tcp协议的编程模型</p><ul><li>服务器：<ol><li>创建ServerSocket类型的对象并提供端口号；</li><li>等待客户端的连接请求，调用accept方法；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li><li>客户端：<ol><li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li></ul></li><li><p>基于udp协议的编程模型</p><ul><li>主机A(接收方):<ol><li>创建DatagramSocket类型的对象，并提供端口号；</li><li>创建DatagramPacket类型的对象，用于接收发来的数据；</li><li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li><li>主机B(发送方)<ol><li>创建DatagramSocket类型的对象；</li><li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li><li>通过Socket发送数据，调用<strong>send()</strong>方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-分层网络协议&quot;&gt;&lt;a href=&quot;#1-分层网络协议&quot; class=&quot;headerlink&quot; title=&quot;1. 分层网络协议&quot;&gt;&lt;/a&gt;1. 分层网络协议&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;OSI七层网络协议：物理层，数据链路层，网络层，传输层(TCP/UDP)，会话层，表示层，应用层&lt;/li&gt;
&lt;li&gt;TCP/IP协议分层(可以理解为OSI的一种实现)：网络接口层，网络层，传输层(TCP/UDP)，应用层
    
    </summary>
    
      <category term="Java知识梳理" scheme="http://chaooo.github.io/categories/java/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="java" scheme="http://chaooo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】JSON Web Token 入门</title>
    <link href="http://chaooo.github.io/article/20190806.html"/>
    <id>http://chaooo.github.io/article/20190806.html</id>
    <published>2019-08-06T07:50:53.000Z</published>
    <updated>2019-10-20T05:56:22.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON-Web-Token"><a href="#JSON-Web-Token" class="headerlink" title="JSON Web Token"></a>JSON Web Token</h2><p>JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。</p><a id="more"></a><ul><li>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</li><li>此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</li><li>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</li></ul><h3 id="1-JWT数据结构"><a href="#1-JWT数据结构" class="headerlink" title="1. JWT数据结构"></a>1. JWT数据结构</h3><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。</p><ul><li>例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<code>.</code>eyJhdWQiOiJjaGFvIiwidWlkIjoyOSwiZXhwIjoxNTY3OTM2NzgwfQ<code>.</code>6zvimBNs_MCiov4MOkkUodgKmRFBS2dVhmhIb1MV6m4。</li></ul><p>JWT 的三个部分(<code>Header.Payload.Signature</code>)依次如下:</p><ol><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ol><h4 id="1-1-Header（头部）"><a href="#1-1-Header（头部）" class="headerlink" title="1.1 Header（头部）"></a>1.1 Header（头部）</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>alg</code>：签名的算法（algorithm），默认是 HMAC SHA256（写成<code>HS256</code>）</li><li><code>typ</code>：表示这个令牌（token）的类型（type），JWT令牌统一写为<code>JWT</code>。</li></ul><p>最后，将上面的 JSON 对象使用 <code>Base64URL算法</code>转成字符串。</p><h4 id="1-2-Payload（负载）"><a href="#1-2-Payload（负载）" class="headerlink" title="1.2 Payload（负载）"></a>1.2 Payload（负载）</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段(Reserved claims)，供选用。标准中建议使用这些字段，但不强制。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号，JWT唯一标识，能用于防止JWT重复使用</li></ul><p>除了官方字段，还有公共声明的字段（见：<a href="http://www.iana.org/assignments/jwt/jwt.xhtml" target="_blank" rel="noopener">http://www.iana.org/assignments/jwt/jwt.xhtml</a>）也可以定义私有字段，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p></blockquote><p>这个 JSON 对象也要使用 <code>Base64URL算法</code>转成字符串。</p><h4 id="1-3-Signature（签名）"><a href="#1-3-Signature（签名）" class="headerlink" title="1.3 Signature（签名）"></a>1.3 Signature（签名）</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。该签名信息是通过header和payload，加上secret，通过算法加密生成。</p><ul><li>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<ul><li><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></li></ul></li><li>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</li></ul><h3 id="2-Base64URL算法"><a href="#2-Base64URL算法" class="headerlink" title="2. Base64URL算法"></a>2. Base64URL算法</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h3 id="3-JWT-的使用方式及特点"><a href="#3-JWT-的使用方式及特点" class="headerlink" title="3. JWT 的使用方式及特点"></a>3. JWT 的使用方式及特点</h3><ol><li><p>认证原理：</p><ul><li>客户端向服务器申请授权，服务器认证以后，生成一个token字符串并返回给客户端，此后客户端在请求受保护的资源时携带这个token，服务端进行验证再从这个token中解析出用户的身份信息。</li></ul></li><li><p>JWT的使用方式：</p><ul><li>客户端收到服务器返回的JWT，存储在浏览器（Cookie或localStorage）</li><li>此后，客户端每次与服务器通信，都要带上这个JWT。<ol><li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul><li><code>Authorization: &lt;token&gt;</code></li><li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li></ul></li><li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li></ol></li></ul></li><li><p>对JWT实现token续签的做法：</p><ol><li>额外生成一个refreshToken用于获取新token，refreshToken需存储于服务端，其过期时间比JWT的过期时间要稍长。</li><li>用户携带refreshToken参数请求token刷新接口，服务端在判断refreshToken未过期后，取出关联的用户信息和当前token。</li><li>使用当前用户信息重新生成token，并将旧的token置于黑名单中，返回新的token。</li></ol></li><li><p>JWT 的几个特点</p><ol><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ol></li></ol><h3 id="4-Java中JWT的使用"><a href="#4-Java中JWT的使用" class="headerlink" title="4. Java中JWT的使用"></a>4. Java中JWT的使用</h3><p>java-jwt工具包提供了<strong>JWT算法的封装</strong></p><ol><li>导入java-jwt，选择一种算法（HMAC256为例）<ul><li><strong><code>Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);</code></strong></li><li>算法定义了一个令牌是如何被签名和验证的。</li></ul></li><li>创建一个签名的<code>JWT token</code>（通过调用jwt.create()创建一个JWTCreator实例）<ul><li><strong><code>String token = JWT.create().withIssuer(&quot;auth0&quot;).sign(algorithm);</code></strong></li><li><em>如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出<strong>JWTCreationException</strong>异常</em></li></ul></li><li>验证令牌（调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。方法build()返回的实例是可重用的，因此可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token）<ul><li><strong><code>JWTVerifier verifier = JWT.require(algorithm).withIssuer(&quot;auth0&quot;).build();</code></strong></li><li><strong><code>verifier.verify(token);</code></strong></li><li><em>如果令牌有一个无效的签名，或者没有满足Claim要求，那么将会抛出<strong>JWTVerificationException</strong>异常</em></li></ul></li><li>jwt时间的验证（当验证一个令牌时，时间验证会自动发生；JWT令牌可能包括可用于验证的DateNumber字段）<ul><li><code>&quot;iat&quot; &lt; TODAY</code>：这个令牌发布了一个过期的时间</li><li><code>&quot;exp&quot; &gt; TODAY</code>：这个令牌还没过期</li><li><code>&quot;nbf&quot; &gt; TODAY</code>：这个令牌已经被使用了</li></ul></li><li>解码一个jwt令牌<ul><li><code>DecodedJWT jwt = JWT.decode(token);</code></li><li><code>jwt.getAlgorithm();</code>:返回jwt的算法值,如果没有定义则返回null</li><li><code>jwt.getType();</code>:返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）</li><li><em>如果令牌有无效的语法，或者消息头或有效负载不是JSONs，那么将会抛出<strong>JWTDecodeException</strong>异常</em></li></ul></li></ol><h3 id="5-Java中JWT的使用实例"><a href="#5-Java中JWT的使用实例" class="headerlink" title="5. Java中JWT的使用实例"></a>5. Java中JWT的使用实例</h3><p>封装一个JWT工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT; <span class="comment">//导入java-jwt</span></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.JWTVerifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.entity.User; <span class="comment">//引入User实体类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置过期时间，这里设置15分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">15</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//服务端的私钥secret,在任何场景都不应该流露出去</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_SECRET = <span class="string">"zhengchao"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **User**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **password**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createToken</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">            <span class="comment">// 私钥和加密算法</span></span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">// 设置头部信息</span></span><br><span class="line">            Map&lt;String, Object&gt; header = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            header.put(<span class="string">"typ"</span>, <span class="string">"JWT"</span>);</span><br><span class="line">            header.put(<span class="string">"alg"</span>, <span class="string">"HS256"</span>);</span><br><span class="line">            <span class="comment">// 返回token字符串</span></span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">"aud"</span>, user.getName())</span><br><span class="line">                    .withClaim(<span class="string">"uid"</span>, user.getId())</span><br><span class="line">                    .withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验token是否正确</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **token**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVerify</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出uid信息,用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseTokenUid</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"uid"</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出aud信息,用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseTokenAud</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">"aud"</span>).asString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录成功后，生成token给浏览器，存储在浏览器（Cookie或localStorage）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String token = JwtUtil.createToken(user);</span><br></pre></td></tr></table></figure><p>此后，客户端每次与服务器通信（需权限的资源），都要带上这个JWT。</p><ol><li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul><li><code>Authorization: &lt;token&gt;</code></li><li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li></ul></li><li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li></ol><blockquote><p>jwt 适合做简单的 restful api 认证，颁发一个固定有效期的 jwt，降低 jwt 暴露的风险，尽量不要对 jwt 做服务端的状态管理，这样才能体现出 jwt 无状态的优势。</p></blockquote><h3 id="附：java-jwt已经实现的算法"><a href="#附：java-jwt已经实现的算法" class="headerlink" title="附：java-jwt已经实现的算法"></a>附：java-jwt已经实现的算法</h3><table><thead><tr><th>JWS</th><th>算法</th><th>介绍</th></tr></thead><tbody><tr><td>HS256</td><td>HMAC256</td><td>HMAC with SHA-256</td></tr><tr><td>HS384</td><td>HMAC384</td><td>HMAC with SHA-384</td></tr><tr><td>HS512</td><td>HMAC512</td><td>HMAC with SHA-512</td></tr><tr><td>RS256</td><td>RSA256</td><td>RSASSA-PKCS1-v1_5 with SHA-256</td></tr><tr><td>RS384</td><td>RSA384</td><td>RSASSA-PKCS1-v1_5 with SHA-384</td></tr><tr><td>RS512</td><td>RSA512</td><td>RSASSA-PKCS1-v1_5 with SHA-512</td></tr><tr><td>ES256</td><td>ECDSA256</td><td>ECDSA with curve P-256 and SHA-256</td></tr><tr><td>ES384</td><td>ECDSA384</td><td>ECDSA with curve P-384 and SHA-384</td></tr><tr><td>ES512</td><td>ECDSA512</td><td>ECDSA with curve P-521 and SHA-512</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JSON-Web-Token&quot;&gt;&lt;a href=&quot;#JSON-Web-Token&quot; class=&quot;headerlink&quot; title=&quot;JSON Web Token&quot;&gt;&lt;/a&gt;JSON Web Token&lt;/h2&gt;&lt;p&gt;JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【安全认证】MD5算法加盐实现用户密码加密</title>
    <link href="http://chaooo.github.io/article/20190728.html"/>
    <id>http://chaooo.github.io/article/20190728.html</id>
    <published>2019-07-28T13:49:28.000Z</published>
    <updated>2019-10-20T05:56:04.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MD5加密算法介绍"><a href="#1-MD5加密算法介绍" class="headerlink" title="1. MD5加密算法介绍"></a>1. MD5加密算法介绍</h3><p>MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。</p><a id="more"></a> <h3 id="2-MD5加密算法特点："><a href="#2-MD5加密算法特点：" class="headerlink" title="2. MD5加密算法特点："></a>2. MD5加密算法特点：</h3><ol><li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li><li>容易计算：从原数据计算出MD5值很容易。</li><li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ol><h3 id="3-盐（Salt）"><a href="#3-盐（Salt）" class="headerlink" title="3. 盐（Salt）"></a>3. 盐（Salt）</h3><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p><h3 id="4-java-security-MessageDigest类"><a href="#4-java-security-MessageDigest类" class="headerlink" title="4. java.security.MessageDigest类"></a>4. java.security.MessageDigest类</h3><p>JDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。</p><ul><li>MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。</li><li>MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。</li><li>对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。</li></ul><h3 id="5-封装一个MD5加密工具类"><a href="#5-封装一个MD5加密工具类" class="headerlink" title="5. 封装一个MD5加密工具类"></a>5. 封装一个MD5加密工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s：待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化MessageDigest的MD5算法对象</span></span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="comment">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = md.digest(s.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="comment">//将字节数组转换为16进制字符串并返回</span></span><br><span class="line">            <span class="keyword">return</span> toHex(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随即盐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">salt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用UUID生成随机盐</span></span><br><span class="line">        UUID uuid = UUID.randomUUID();</span><br><span class="line">        <span class="comment">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class="line">        String[] arr = uuid.toString().split(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转换为16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] HEX_DIGITS = <span class="string">"0123456789ABCDEF"</span>.toCharArray();</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class="line">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]);</span><br><span class="line">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class="number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-使用封装的MD5工具类完成用户注册-主要代码"><a href="#6-使用封装的MD5工具类完成用户注册-主要代码" class="headerlink" title="6. 使用封装的MD5工具类完成用户注册(主要代码)"></a>6. 使用封装的MD5工具类完成用户注册(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">register</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">//设置用户名</span></span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="comment">//密码加密后再保存</span></span><br><span class="line">    String salt = MD5Util.salt();</span><br><span class="line">    String md5Password = MD5Util.md5(password+salt);</span><br><span class="line">    <span class="comment">//存入MD5加密后的密码</span></span><br><span class="line">    user.setPassword(md5Password);</span><br><span class="line">    <span class="comment">//随机盐存入数据库，用于登录校验</span></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line">    <span class="comment">//最后将用户数据数据存入数据库</span></span><br><span class="line">    <span class="keyword">int</span> row = userDao.insert(user);</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-使用封装的MD5工具类完成用户登录-主要代码"><a href="#7-使用封装的MD5工具类完成用户登录-主要代码" class="headerlink" title="7. 使用封装的MD5工具类完成用户登录(主要代码)"></a>7. 使用封装的MD5工具类完成用户登录(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据用户名在数据库查找用户</span></span><br><span class="line">    User user = userDao.selectByName(name);</span><br><span class="line">    <span class="comment">//取出用户信息比对</span></span><br><span class="line">    String dbPassword = user.getPassword();</span><br><span class="line">    String  salt = user.getSalt();</span><br><span class="line">    <span class="comment">//通过密码+盐 重新生成 MD5密码</span></span><br><span class="line">    String md5Password = MD5Util.md5(password+salt);</span><br><span class="line">    <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">        <span class="comment">//登录成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-扩展：MessageDigest类常用方法"><a href="#8-扩展：MessageDigest类常用方法" class="headerlink" title="8. 扩展：MessageDigest类常用方法"></a>8. 扩展：MessageDigest类常用方法</h3><h4 id="8-1-构造方法摘要"><a href="#8-1-构造方法摘要" class="headerlink" title="8.1 构造方法摘要"></a>8.1 构造方法摘要</h4><p><code>MessageDigest(String algorithm)</code> –创建具有指定算法名称的MessageDigest 实例对象。</p><ul><li>MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有”MD5”，”SHA”等。</li></ul><h4 id="8-2-成员方法摘要："><a href="#8-2-成员方法摘要：" class="headerlink" title="8.2 成员方法摘要："></a>8.2 成员方法摘要：</h4><table><thead><tr><th>返回值</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Object</td><td><code>clone()</code></td><td>如果实现是可复制的，则返回一个副本。</td></tr><tr><td>byte[]</td><td><code>digest()</code></td><td>通过执行诸如填充之类的最终操作完成哈希计算。</td></tr><tr><td>byte[]</td><td><code>digest(byte[] input)</code></td><td>使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。</td></tr><tr><td>int</td><td><code>digest(byte[] buf, int offset, int len)</code></td><td>通过执行诸如填充之类的最终操作完成哈希计算。</td></tr><tr><td>String</td><td><code>getAlgorithm()</code></td><td>返回标识算法的独立于实现细节的字符串。</td></tr><tr><td>int</td><td><code>getDigestLength()</code></td><td>返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm)</code></td><td>生成实现指定摘要算法的 MessageDigest 对象。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm, Provider provider)</code></td><td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm, String provider)</code></td><td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td></tr><tr><td>Provider</td><td><code>getProvider()</code></td><td>返回此信息摘要对象的提供程序。</td></tr><tr><td>static boolean</td><td><code>isEqual(byte[] digesta, byte[] digestb)</code></td><td>比较两个摘要的相等性。</td></tr><tr><td>void</td><td><code>reset()</code></td><td>重置摘要以供再次使用。</td></tr><tr><td>String</td><td><code>toString()</code></td><td>返回此信息摘要对象的字符串表示形式。</td></tr><tr><td>void</td><td><code>update(byte input)</code></td><td>使用指定的字节更新摘要。</td></tr><tr><td>void</td><td><code>update(byte[] input)</code></td><td>使用指定的字节数组更新摘要。</td></tr><tr><td>void</td><td><code>update(byte[] input, int offset, int len)</code></td><td>使用指定的字节数组，从指定的偏移量开始更新摘要。</td></tr><tr><td>void</td><td><code>update(ByteBuffer input)</code></td><td>使用指定的 ByteBuffer 更新摘要。</td></tr></tbody></table><blockquote><p>★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-MD5加密算法介绍&quot;&gt;&lt;a href=&quot;#1-MD5加密算法介绍&quot; class=&quot;headerlink&quot; title=&quot;1. MD5加密算法介绍&quot;&gt;&lt;/a&gt;1. MD5加密算法介绍&lt;/h3&gt;&lt;p&gt;MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。&lt;/p&gt;
    
    </summary>
    
      <category term="安全认证" scheme="http://chaooo.github.io/categories/safe/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="安全认证" scheme="http://chaooo.github.io/tags/ssafe/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】嵌入式SQL语言</title>
    <link href="http://chaooo.github.io/article/20190716.html"/>
    <id>http://chaooo.github.io/article/20190716.html</id>
    <published>2019-07-16T06:32:28.000Z</published>
    <updated>2019-10-20T05:35:37.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，</li><li>然而，交互式SQL本身也有很多局限：<a id="more"></a><ul><li>从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以</li><li>从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</li></ul></li><li>因此，高级语言+SQL语言：<ul><li>既继承高级语言的过程控制性</li><li>又结合SQL语言的复杂结果集操作的非过程性</li><li>同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作</li></ul></li><li>嵌入式SQL语言<ul><li>将SQL语言嵌入到某一种高级语言中使用</li><li>这种高级语言，如C/C++, Java, PowerBuilder等，又称宿主语言(Host Language)</li><li>嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式</li></ul></li></ul><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol><li><a href="#id1">变量声明与数据库连接</a></li><li><a href="#id2">事务Transaction</a></li><li><a href="#id3">数据集与游标</a></li><li><a href="#id4">状态捕获及错误处理机制</a></li><li><a href="#id5">动态SQL</a></li><li><a href="#id6">数据字典与SQLDA</a></li><li><a href="#id7">ODBC简介</a></li><li><a href="#id8">JDBC简介</a></li><li><a href="#id9">嵌入式SQL-ODBC-JDBC三者比较</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-变量声明与数据库连接"><a href="#1-变量声明与数据库连接" class="headerlink" title="1. 变量声明与数据库连接"></a>1. 变量声明与数据库连接</h3><ol><li>以宿主语言<strong>C语言</strong>为例，对比交互式SQL语言与嵌入式SQL语言<ul><li>交互式SQL:<code>select Sname, Sage from Student where Sname=&#39;张三&#39;;</code></li><li>嵌入式SQL:<code>exec sql select Sname, Sage into :vSname, :vSage from Student where Sname=&#39;张三&#39;;</code></li></ul></li><li>典型特点<ul><li><strong>exec sql</strong>引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句</li><li>增加一 <strong>into子句</strong>: 该子句用于指出接收SQL语句检索结果的程序变量</li><li>由冒号引导的<strong>程序变量</strong>,如: ‘:vSname’, ‘:vSage’</li></ul></li></ol><h4 id="1-1-变量的声明与使用"><a href="#1-1-变量的声明与使用" class="headerlink" title="1.1 变量的声明与使用"></a>1.1 变量的声明与使用</h4><ul><li><p>在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">    char vSname[10], specName[10]="张三";</span><br><span class="line">    int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br></pre></td></tr></table></figure></li><li><p>变量声明和赋值中，要注意：</p><ul><li>宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为’\0’，而程序中用双引号来描述。</li><li>宿主程序变量类型与数据库字段类型之间有些是有差异的,有些DBMS可支持自动转换，有些不能。</li></ul></li><li><p>声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。</p></li><li><p>嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">    char vSname[10], specName[10]="张三";</span><br><span class="line">    int vSage;</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">//用户可在此处基于键盘输入给specName赋值</span><br><span class="line">exec sql <span class="keyword">select</span> Sname, Sage <span class="keyword">into</span> :vSname, :vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname = :specName;</span><br><span class="line">//比较相应的交互式SQL语句：</span><br><span class="line"><span class="keyword">select</span> Sname, Sage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-程序与数据库的连接和断开"><a href="#1-2-程序与数据库的连接和断开" class="headerlink" title="1.2 程序与数据库的连接和断开"></a>1.2 程序与数据库的连接和断开</h4><h5 id="1-2-1-数据库的连接connect"><a href="#1-2-1-数据库的连接connect" class="headerlink" title="1.2.1 数据库的连接connect"></a>1.2.1 数据库的连接connect</h5><p>在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异</p><ol><li>SQL标准中建议的连接语法为：<ul><li><code>execsql connecttotarget-server asconnect-name useruser-name;</code></li><li>或 <code>execsql connecttodefault;</code></li></ul></li><li>Oracle中数据库连接:<ul><li><code>execsql connect:user_name identified by :user_pwd;</code></li></ul></li><li>DB2 UDB中数据库连接:<ul><li><code>execsql connecttomydb user:user_name using:user_pwd;</code></li></ul></li></ol><h5 id="1-2-1-数据库的断开disconnect"><a href="#1-2-1-数据库的断开disconnect" class="headerlink" title="1.2.1 数据库的断开disconnect"></a>1.2.1 数据库的断开disconnect</h5><p>在嵌入式SQL程序执行之后，需要与数据库断开连接</p><ol><li>SQL标准中建议的断开连接的语法为：<ul><li><code>exec sql disconnect connect-name;</code></li><li>或 <code>exec sql disconnect current;</code></li></ul></li><li>Oracle中断开连接:<ul><li><code>exec sql commit release;</code></li><li>或 <code>exec sql rollback release;</code></li></ul></li><li>DB2 UDB中断开连接:<ul><li><code>exec sql connect reset;</code></li><li><code>exec sql disconnect current;</code></li></ul></li></ol><h4 id="1-3-SQL执行的提交与撤消"><a href="#1-3-SQL执行的提交与撤消" class="headerlink" title="1.3 SQL执行的提交与撤消"></a>1.3 SQL执行的提交与撤消</h4><p>SQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果</p><ol><li>SQL执行的提交：<ul><li><code>execsql commitwork;</code></li></ul></li><li>SQL执行的撤消：<ul><li><code>execsql rollbackwork;</code></li></ul></li><li>为此，很多DBMS都设计了捆绑提交/撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：<ul><li><code>execsql commitrelease;</code></li><li>或 <code>execsql rollbackrelease;</code></li></ul></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-事务Transaction"><a href="#2-事务Transaction" class="headerlink" title="2. 事务Transaction"></a>2. 事务Transaction</h3><ol><li>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务</li><li>从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li><li>简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；<strong>事务是一个不可分割的工作逻辑单元</strong>。</li></ol><h4 id="2-1-事务的特性-ACID"><a href="#2-1-事务的特性-ACID" class="headerlink" title="2.1 事务的特性: ACID"></a>2.1 事务的特性: ACID</h4><ol><li><strong>原子性</strong>Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行</li><li><strong>一致性</strong>Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的</li><li><strong>隔离性</strong>Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。</li><li><strong>持久性</strong>Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。</li></ol><blockquote><p>换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。</p></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-数据集与游标"><a href="#3-数据集与游标" class="headerlink" title="3. 数据集与游标"></a>3. 数据集与游标</h3><p>读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)</p><ol><li>检索单行结果，可将结果直接传送到宿主程序的变量中(Into)<ul><li>示例：<code>exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;</code></li></ul></li><li>检索多行结果，则需使用游标(Cursor)<ul><li>游标是指向某检索记录集的指针</li><li>通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕</li><li>读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取</li><li>记录集有结束标识EOF, 用来标记后面已没有记录了</li></ul></li></ol><ul><li>游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭</li><li>游标可以定义一次，多次打开(多次执行)，多次关闭</li></ul><h4 id="3-1-游标的使用方法"><a href="#3-1-游标的使用方法" class="headerlink" title="3.1 游标的使用方法"></a>3.1 游标的使用方法</h4><ol><li><p>Cursor的定义：declare cursor</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    Subquery</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">    [<span class="keyword">FOR</span> [ <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> columnname [, columnname…]]]];</span><br><span class="line">//示例:</span><br><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass= :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br></pre></td></tr></table></figure></li><li><p>Cursor的打开和关闭：open cursor //close cursor</p><ul><li>EXEC SQL OPEN cursor_name;</li><li>EXEC SQL CLOSE cursor_name;</li></ul></li><li><p>Cursor的数据读取：Fetch</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH cursor_name</span><br><span class="line">    INTO host-variable , [host-variable, …];</span><br><span class="line">//示例:</span><br><span class="line">exec sql <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass= :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno <span class="keyword">for</span> <span class="keyword">read</span> <span class="keyword">only</span> ;</span><br><span class="line">exec sql open cur_student;</span><br><span class="line">…</span><br><span class="line">exec sql fetch cur_student into :vSno, :vSname, :vSage</span><br><span class="line">…</span><br><span class="line">exec sql close cur_student;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-可滚动游标"><a href="#3-2-可滚动游标" class="headerlink" title="3.2 可滚动游标"></a>3.2 可滚动游标</h4><ol><li>ODBC支持的可滚动Cursor<ul><li>标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开</li><li>ODBC(OpenDataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口</li><li>许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能</li></ul></li><li>可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标<ul><li>可滚动游标移动时需判断是否到结束位置，或到起始位置<ul><li>可通过判断是否到EOF位置(最后一条记录的后面),或BOF位置(起始记录的前面)</li><li>如果不需区分，可通过whenevernotfound语句设置来检测</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> cursor_name [INSENSITIVE] [<span class="keyword">SCROLL</span>] <span class="keyword">CURSOR</span></span><br><span class="line">[<span class="keyword">WITH</span> HOLD] <span class="keyword">FOR</span> Subquery</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span> | <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> columnname [,</span><br><span class="line">columnname ]…];</span><br><span class="line">EXEC SQL FETCH</span><br><span class="line">[ NEXT | PRIOR | FIRST | LAST</span><br><span class="line">| [ABSOLUTE | RELATIVE] value_spec ]</span><br><span class="line">FROM cursor_name INTO host-variable [, host-variable …];</span><br></pre></td></tr></table></figure><ul><li><code>NEXT</code>向结束方向移动一条；</li><li><code>PRIOR</code>向开始方向移动一条；</li><li><code>FIRST</code>回到第一条；</li><li><code>LAST</code>移动到最后一条；</li><li><code>ABSOLUTvalue_spec</code>定向检索指定位置的行,value_spec由1至当前记录集最大值；</li><li><code>RELATIVEvalue_spec</code>相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动</li></ul><h4 id="3-3-数据库记录的增删改"><a href="#3-3-数据库记录的增删改" class="headerlink" title="3.3 数据库记录的增删改"></a>3.3 数据库记录的增删改</h4><ol><li>数据库记录的删除<ul><li>一种是查找删除(与交互式DELETE语句相同)，一种是定位删除</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">WHERE</span> search_condition | <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line">//示例：查找删除</span><br><span class="line">exec sql <span class="keyword">delete</span> <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city = ‘Harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid);</span><br><span class="line">//示例：定位删除</span><br><span class="line">exec sql <span class="keyword">declare</span> delcust <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> cid <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city =‘harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid = c.cid)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> cid;</span><br><span class="line">exec sql open delcust</span><br><span class="line">While (TRUE) &#123;</span><br><span class="line">    exec sql fetch delcust into :cust_id;</span><br><span class="line">    exec sql delete from customers where current of delcust ; &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>数据库记录的更新<ul><li>一种是查找更新(与交互式Update语句相同)，一种是定位更新</li></ul></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">UPDATE</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">SET</span> columnname = expr [, columnname = expr …]</span><br><span class="line">    [ <span class="keyword">WHERE</span> search_condition ] | <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line">//示例：查找更新</span><br><span class="line">exec sql <span class="keyword">update</span> student s <span class="keyword">set</span> sclass = ‘<span class="number">035102</span>’</span><br><span class="line">    <span class="keyword">where</span> s.sclass = ‘<span class="number">034101</span>’</span><br><span class="line">// 示例：定位更新</span><br><span class="line">exec <span class="keyword">sql</span> <span class="keyword">declare</span> stud <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.sclass =‘<span class="number">034101</span>’</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> sclass;</span><br><span class="line">exec sql open stud</span><br><span class="line">While (TRUE) &#123;</span><br><span class="line">    exec sql fetch stud into :vSno, :vSname, :vSclass;</span><br><span class="line">    exec sql update student set sclass = ‘035102’ where current of stud ; &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>数据库记录的插入<ul><li>只有一种类型的插入语句</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename [ (columnname [,columnname, …] )]</span><br><span class="line">    [ <span class="keyword">VALUES</span> (expr [ , expr , …] ) | subqurey ] ;</span><br><span class="line">//示例：插入语句</span><br><span class="line">exec sql <span class="keyword">insert</span> <span class="keyword">into</span> student ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">values</span> (‘<span class="number">03510128</span>’, ‘张三’, ‘<span class="number">035101</span>’) ;</span><br><span class="line">//示例：插入语句</span><br><span class="line">exec sql <span class="keyword">insert</span> <span class="keyword">into</span> masterstudent ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">select</span> sno, sname, sclass <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-状态捕获及错误处理机制"><a href="#4-状态捕获及错误处理机制" class="headerlink" title="4. 状态捕获及错误处理机制"></a>4. 状态捕获及错误处理机制</h3><h4 id="4-1-基本机制"><a href="#4-1-基本机制" class="headerlink" title="4.1 基本机制"></a>4.1 基本机制</h4><ul><li><p>状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理</p></li><li><p>嵌入式 SQL程序中，状态捕获及处理有三部分构成</p><ol><li>设置SQL通信区:一般在嵌入式SQL程序的开始处便设置<ul><li><code>exec sql include sqlca;</code></li></ul></li><li>设置状态捕获语句:在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域<ul><li><code>exec sql whenever sqlerror goto report_error;</code></li></ul></li><li>状态处理语句:某一段程序以应对SQL操作的某种状态<ul><li><code>report_error: exec sql rollback;</code></li></ul></li></ol></li><li><p>SQL通信区: SQLCA</p><ol><li>SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理</li><li>SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一</li></ol></li><li><p>状态捕获语句: <code>exec sql whenever condition action;</code></p><ul><li>Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).<ul><li>SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS</li><li>NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现</li><li>SQLWARNING: 不是错误，但应引起注意的条件</li></ul></li><li>如果满足condition, 则要采取一些动作(由action指出)<ul><li>CONTINUE: 忽略条件或错误，继续执行</li><li>GOTO 标号: 转移到标号所指示的语句，去进行相应的处理</li><li>STOP: 终止程序运行、撤消当前的工作、断开数据库的连接</li><li>DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行</li></ul></li></ul></li><li><p>状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    exec sql whenever sqlerror <span class="keyword">stop</span>;</span><br><span class="line">    … …</span><br><span class="line">    goto s1</span><br><span class="line">    … …</span><br><span class="line">    exec sql whenever sqlerror continue;</span><br><span class="line">    s1: exec sql <span class="keyword">update</span> agents <span class="keyword">set</span> <span class="keyword">percent</span> = <span class="keyword">percent</span> + <span class="number">1</span>;</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br><span class="line">//S1标号指示的语句受第二个Whenever语句约束。</span><br><span class="line">//注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)</span><br></pre></td></tr></table></figure></li><li><p>状态捕获语句Whenever的使用容易引发无限循环</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    exec sql whenever sqlerror goto handle_error;</span><br><span class="line">    exec sql <span class="keyword">create</span> <span class="keyword">table</span> customers(cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cname <span class="built_in">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">    … …</span><br><span class="line">    handle_error:</span><br><span class="line">        exec sql whenever sqlerror continue;// 控制是否无限循环：无，则可能；有，则不会</span><br><span class="line">        exec sql <span class="keyword">drop</span> customers;</span><br><span class="line">        exec sql disconnect;</span><br><span class="line">        fprintf(stderr,”could not <span class="keyword">create</span> customers <span class="keyword">table</span>\n”);</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-状态信息"><a href="#4-2-状态信息" class="headerlink" title="4.2 状态信息"></a>4.2 状态信息</h4><p>典型DBMS系统记录状态信息的三种方法</p><ul><li>状态记录:<ol><li><code>sqlcode</code>: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。<ul><li>sqlcode== 0, successful call;</li><li>sqlcode &lt; 0, error, e.g., from connect, database does not exist , –16;</li><li>sqlcode &gt; 0, warning, e.g., no rows retrieved from fetch</li></ul></li><li><code>sqlca.sqlcode</code>: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录</li><li><code>sqlstate</code>: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate</li></ol></li><li>当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)</li><li>但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)</li></ul><h4 id="4-3-程序自身进行错误信息的处理"><a href="#4-3-程序自身进行错误信息的处理" class="headerlink" title="4.3 程序自身进行错误信息的处理"></a>4.3 程序自身进行错误信息的处理</h4><p>正确的显式状态处理示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exec sql <span class="keyword">begin</span> declar <span class="keyword">section</span>;</span><br><span class="line">    char SQLSTATE[6];</span><br><span class="line">exec sql <span class="keyword">end</span> <span class="keyword">declare</span> <span class="keyword">section</span>;</span><br><span class="line">exec sql whenever sqlerror goto handle_error;</span><br><span class="line">… …</span><br><span class="line">exec sql whenever sqlerror continue;</span><br><span class="line">exec sql <span class="keyword">create</span> <span class="keyword">table</span> custs</span><br><span class="line">    (cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>, cname <span class="built_in">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">if (strcmp(SQLSTATE, “82100”)==0)</span><br><span class="line">    &lt;处理82100错误的程序&gt;</span><br><span class="line">    … …</span><br></pre></td></tr></table></figure><p>上述的if语句是能被执行的，因为createtable发生错误时是继续向下执行的。</p><p><span id="id5"><span></span></span></p><h3 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h3><h4 id="5-1-动态SQL的概念"><a href="#5-1-动态SQL的概念" class="headerlink" title="5.1 动态SQL的概念"></a>5.1 动态SQL的概念</h4><p>动态SQL是相对于静态SQL而言的</p><ul><li>静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)</li><li>动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量</li></ul><h4 id="5-2-动态SQL的两种执行方式"><a href="#5-2-动态SQL的两种执行方式" class="headerlink" title="5.2 动态SQL的两种执行方式"></a>5.2 动态SQL的两种执行方式</h4><p>如SQL语句已经被构造在host-variable字符串变量中,则：</p><ol><li><strong>立即执行语句</strong>: 运行时编译并执行<ul><li><code>EXEC SQL EXECUTE IMMEDIATE :host-variable;</code></li></ul></li><li><strong>Prepare-Execute-Using语句</strong>:PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句<ul><li><code>EXEC SQL PREPARE sql_temp FROM :host-variable;</code></li><li><code>EXEC SQL EXECUTE sql_temp USING :cond-variable</code></li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-数据字典与SQLDA"><a href="#6-数据字典与SQLDA" class="headerlink" title="6. 数据字典与SQLDA"></a>6. 数据字典与SQLDA</h3><h4 id="6-1-数据字典的概念"><a href="#6-1-数据字典的概念" class="headerlink" title="6.1 数据字典的概念"></a>6.1 数据字典的概念</h4><p>数据字典(Data dictionary)，又称为系统目录(System Catalogs)</p><ul><li>是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等,这些信息又称数据库的元数据–关于数据的数据。</li><li>不同DBMS术语不一样：数据字典(DataDictionary(Oracle))、目录表(DB2UDB)、系统目录(INFORMIX)、系统视图(X/Open)</li><li>不同DBMS中系统目录存储方式可能是不同的,但会有一些信息对DBA公开。这些公开的信息,DBA可以使用一些特殊的SQL命令来检索。</li></ul><h4 id="6-2-数据字典的内容构成"><a href="#6-2-数据字典的内容构成" class="headerlink" title="6.2 数据字典的内容构成"></a>6.2 数据字典的内容构成</h4><p>数据字典通常存储的是数据库和表的元数据，即模式本身的信息：</p><ol><li>与关系相关的信息<ul><li>关系名字</li><li>每一个关系的属性名及其类型</li><li>视图的名字及其定义</li><li>完整性约束</li></ul></li><li>用户与账户信息，包括密码</li><li>统计与描述性数据：如每个关系中元组的数目</li><li>物理文件组织信息：<ul><li>关系是如何存储的(顺序/无序/散列等)</li><li>关系的物理位置</li></ul></li><li>索引相关的信息</li></ol><h4 id="6-3-数据字典的结构"><a href="#6-3-数据字典的结构" class="headerlink" title="6.3 数据字典的结构"></a>6.3 数据字典的结构</h4><ol><li>也是存储在磁盘上的关系</li><li>专为内存高效访问设计的特定的数据结构</li></ol><ul><li>可能的字典数据结构<ul><li><code>Relation_metadata</code> = <code>(relation_name, number_of_attributes, storage_organization, location)</code></li><li><code>Attribute_metadata</code> = <code>(attribute_name, relation_name, domain_type, position, length)</code></li><li><code>User_metadata</code> = <code>(user_name, encrypted_password, group)</code></li><li><code>Index_metadata</code> = <code>(index_name, relation_name, index_type, index_attributes)</code></li><li><code>View_metadata</code> = <code>(view_name, definition)</code></li></ul></li></ul><h4 id="6-4-X-Open标准的系统目录"><a href="#6-4-X-Open标准的系统目录" class="headerlink" title="6.4 X/Open标准的系统目录"></a>6.4 X/Open标准的系统目录</h4><ol><li>X/Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息<ul><li><code>Table_Schem</code>：表的模式名(通常是表所有者的用户名)</li><li><code>Table_Name</code>：表名</li><li><code>Table_Type</code>：<code>&#39;Base_Table&#39;</code>或<code>&#39;View&#39;</code></li></ul></li><li>可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：<ul><li><code>Select Table_Name From Tables;</code></li></ul></li><li>模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。</li><li>一般而言，一个用户有一个模式。可以使用CreateSchema语句来创建模式(用法参见相关文献)，在CreateTable等语句可以使用所定义的模式名称。</li></ol><h4 id="6-5-Oracle的数据字典"><a href="#6-5-Oracle的数据字典" class="headerlink" title="6.5 Oracle的数据字典"></a>6.5 Oracle的数据字典</h4><ol><li>Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识<ul><li><code>USER_</code> :用户视图，用户所拥有的对象，在用户模式中</li><li><code>ALL_</code>  :扩展的用户视图，用户可访问的对象</li><li><code>DBA_</code>  :DBA视图(所有用户都可访问的DBA对象的子集)</li></ul></li><li>Oracle数据字典中定义了三个视图<code>USER_Tables</code>,<code>ALL_Tables</code>,和<code>DBA_Tables</code>供DBA和用户使用数据字典中关于<strong>表的信息</strong></li><li>同样,Oracle数据字典中也定义了三个视图<code>USER_TAB_Columns</code>,<code>ALL_TAB_Columns</code>(<code>Accessible_Columns</code>),和<code>DBA_TAB_Columns</code>供DBA和用户使用数据字典中关于表的<strong>列的信息</strong></li><li>可以使用SQL语句来访问这些表中的信息：<ul><li><code>Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;</code></li></ul></li><li>Oracle数据字典中还定义了其他视图<ul><li><code>TABLE_PRIVILEDGE</code>(或<code>ALL_TAB_GRANTS</code>)</li><li><code>COLUMN_PRIVILEDGE</code>(或<code>ALL_COL_GRANTS</code>)可访问表的权限，列的权限</li><li><code>CONSTRAINT_DEFS</code>(或<code>ALL_CONSTRAINTS</code>)可访问表的各种约束</li></ul></li><li>可以使用下述命令获取Oracle定义的所有视图信息<ul><li><code>Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;</code></li></ul></li><li>如果用户使用Oracle,可使用其提供的<code>SQL*PLUS</code>进行交互式访问</li><li>动态SQL: 表和列都已知，动态构造检索条件。</li><li>动态SQL:检索条件可动态构造，表和列也可动态构造。</li></ol><h4 id="6-6-SQLDA"><a href="#6-6-SQLDA" class="headerlink" title="6.6 SQLDA"></a>6.6 SQLDA</h4><p>构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息</p><ol><li>SQLDA: SQLDescriptorArea,SQL描述符区域。<ul><li>SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等</li><li>通过读取SQLDA信息可以进行更为复杂的动态SQL的处理</li><li>不同DBMS提供的SQLDA格式并不是一致的。</li></ul></li></ol><p><span id="id7"><span></span></span></p><h3 id="7-ODBC简介"><a href="#7-ODBC简介" class="headerlink" title="7. ODBC简介"></a>7. ODBC简介</h3><h4 id="7-1-ODBC定义"><a href="#7-1-ODBC定义" class="headerlink" title="7.1 ODBC定义"></a>7.1 ODBC定义</h4><p>ODBC：Open DataBase Connection，ODBC是一种标准—不同语言的应用程序与不同数据库服务器之间通讯的标准。</p><ul><li>一组API(应用程序接口)，支持应用程序与数据库服务器的交互</li><li>应用程序通过调用ODBC API, 实现<ol><li>与数据服务器的连接</li><li>向数据库服务器发送SQL命令</li><li>一条一条的提取数据库检索结果中的元组传递给应用程序的变量</li></ol></li><li>具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。</li><li>ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；</li></ul><h4 id="7-2-通过ODBC连接数据库"><a href="#7-2-通过ODBC连接数据库" class="headerlink" title="7.2 通过ODBC连接数据库"></a>7.2 通过ODBC连接数据库</h4><ol><li>ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中</li><li>当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果</li><li>ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄</li><li>应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:<ul><li><code>connection handle</code>, 连接句柄</li><li><code>the server</code>，要连接的数据库服务器</li><li><code>the user identifier</code>，用户</li><li><code>password</code> ，密码</li><li><code>SQL_NTS</code> 类型说明前面的参数是空终止的字符串</li></ul></li><li>示例<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int ODBCexample()&#123;</span><br><span class="line">    RETCODE error; <span class="comment">/* 返回状态吗 */</span></span><br><span class="line">    HENV env; <span class="comment">/* 环境变量 */</span></span><br><span class="line">    HDBC conn; <span class="comment">/* 连接句柄 */</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line">    //分配数据库连接环境</span><br><span class="line">    SQLConnect(conn, "aura.bell-labs.com", SQL_NTS, "avi", SQL_NTS, avipasswd", SQL_NTS);</span><br><span class="line">    //打开一个数据库连接</span><br><span class="line">    &#123; …. Do actual work … &#125;</span><br><span class="line">    //与数据库通讯</span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">    //断开连接与释放环境</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-3-通过ODBC与数据库服务器进行通讯"><a href="#7-3-通过ODBC与数据库服务器进行通讯" class="headerlink" title="7.3 通过ODBC与数据库服务器进行通讯"></a>7.3 通过ODBC与数据库服务器进行通讯</h4><ol><li>应用程序使用SQLExecDirect()向数据库发送SQL命令；</li><li>使用SQLFetch()获取产生的结果元组；</li><li>使用SQLBindCol()绑定C语言变量与结果中的属性<ul><li>当获取一个元组时，属性值会自动地传送到相应的C语言变量中</li></ul></li><li>SQLBindCol()的参数：<ul><li>ODBC定义的stmt变量,查询结果中的属性位置</li><li>SQL到C的类型变换,变量的地址.</li><li>对于类似字符数组一样的可变长度类型，应给出<ul><li>•变量的最大长度</li><li>•当获取到一个元组后，实际长度的存储位置.</li><li>•注:当返回实际长度为负数，说明是一个空值。</li></ul></li></ul></li><li>示例<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">char branchname[80]; float balance;</span><br><span class="line">int lenOut1, lenOut2;</span><br><span class="line">HSTMT stmt;</span><br><span class="line">SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line">//分配一个与指定数据库连接的新的语句句柄</span><br><span class="line">char * sqlquery = "select branch_name, sum (balance)</span><br><span class="line">    from account</span><br><span class="line">    group by branch_name";</span><br><span class="line">error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line">//执行查询，stmt句柄指向结果集合</span><br><span class="line">if (error == SQL_SUCCESS) &#123;</span><br><span class="line">SQLBindCol(stmt, 1, SQL_C_CHAR, branchname , 80, &amp;lenOut1);</span><br><span class="line">SQLBindCol(stmt, 2, SQL_C_FLOAT, &amp;balance, 0 , &amp;lenOut2);</span><br><span class="line">//绑定高级语言变量与stmt句柄中的属性</span><br><span class="line">while (SQLFetch(stmt) &gt;= SQL_SUCCESS) &#123;</span><br><span class="line">//提取一条记录，结果数据被存入高级语言变量中</span><br><span class="line">    printf (" %s %g\n", branchname, balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SQLFreeStmt(stmt, SQL_DROP);</span><br><span class="line">//释放语句句柄</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-4-ODBC的其他功能"><a href="#7-4-ODBC的其他功能" class="headerlink" title="7.4 ODBC的其他功能"></a>7.4 ODBC的其他功能</h4><ol><li>动态SQL语句的预编译-动态参数传递功能</li><li>获取元数据特性<ul><li>发现数据库中的所有关系的特性 以及</li><li>发现每一个查询结果的列的名字和类型等；</li></ul></li><li>默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。<ul><li>应用程序可以关闭一个连接的自动提交特性<ul><li><code>SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)}</code></li></ul></li><li>此时事务要显式地给出提交和撤销的命令<ul><li><code>SQLTransact(conn, SQL_COMMIT)</code> or <code>SQLTransact(conn, SQL_ROLLBACK)</code></li></ul></li></ul></li></ol><p><span id="id8"><span></span></span></p><h3 id="8-JDBC简介"><a href="#8-JDBC简介" class="headerlink" title="8. JDBC简介"></a>8. JDBC简介</h3><h4 id="8-1-JDBC定义"><a href="#8-1-JDBC定义" class="headerlink" title="8.1 JDBC定义"></a>8.1 JDBC定义</h4><p>JDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。</p><ul><li>JDBCAPI分成两个程序包：<ul><li>Java.sql 核心API –J2SE(Java2标准版)的一部分。使用<code>java.sql.DriverManager</code>类、<code>java.sql.Driver</code>和<code>java.sql.Connection</code>接口连接到数据库</li><li>Javax.sql 可选扩展API–J2EE(Java2企业版)的一部分。包含了基于<code>JNDI(JavaNamingandDirectoryInterface,Java命名和目录接口)</code>的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。</li></ul></li></ul><h4 id="8-2-JDBC的功能"><a href="#8-2-JDBC的功能" class="headerlink" title="8.2 JDBC的功能"></a>8.2 JDBC的功能</h4><ol><li><code>java.sql.DriverManager</code>——处理驱动的调入并且对产生新数据库连接提供支持</li><li><code>Java.sql.Driver</code>——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。</li><li><code>java.sql.Connection</code>——代表对特定数据库的连接。</li><li><code>Try {…} Catch {…}</code> ——异常捕获及其处理</li><li><code>java.sql.Statement</code>——对特定的数据库执行SQL语句</li><li><code>java.sql.PreparedStatement</code> —— 用于执行预编译的SQL语句</li><li><code>java.sql.CallableStatement</code> ——用于执行对数据库内嵌过程的调用。</li><li><code>java.sql.ResultSet</code>——从当前执行的SQL语句中返回结果数据。</li></ol><h4 id="8-3-使用JDBC-API访问数据库的过程"><a href="#8-3-使用JDBC-API访问数据库的过程" class="headerlink" title="8.3 使用JDBC API访问数据库的过程"></a>8.3 使用JDBC API访问数据库的过程</h4><ol><li><p>概念性的基本过程</p><ul><li>打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制</li></ul></li><li><p>具体实施过程</p><ol><li>•传递一个Driver给DriverManager，加载数据库驱动。<ul><li><code>Class.forName()</code></li></ul></li><li>•通过URL得到一个Connection对象, 建立数据库连接<ul><li><code>DriverManager.getConnection(sDBUrl)</code></li><li><code>DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)</code></li></ul></li><li>•接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<ul><li><code>Statement stmt=con.createStatement()</code></li></ul></li><li>•查询返回一个ResultSet。<ul><li><code>ResultSet rs=stmt.executeQuery(sSQL)</code></li></ul></li></ol></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">try</span> &#123; <span class="comment">//错误捕获</span></span><br><span class="line">    Class.forName (<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    Connection conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span>, userid, passwd);</span><br><span class="line">    <span class="comment">//加载数据库驱动，建立数据库连接</span></span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    <span class="comment">//创建一个语句对象</span></span><br><span class="line">    … Do Actual Work ….</span><br><span class="line">    <span class="comment">//进行SQL语句的执行与处理工作</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    <span class="comment">//关闭语句对象，关闭连接</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">    System.out.println(<span class="string">"SQLException : "</span> + sqle); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完整的示例程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName (<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    Connection conn = DriverManager.getConnection(</span><br><span class="line">        <span class="string">"jdbc:oracle:thin:@db.yale.edu:1521:univdb"</span>, userid, passwd);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt.executeUpdate( <span class="string">"insert into instructor values</span></span><br><span class="line"><span class="string">        (‘77987', ‘Kim', ‘Physics’,98000)"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">"插入错误:"</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">    ResultSet rset = stmt.executeQuery(</span><br><span class="line">        <span class="string">"select dept_name, avg(salary) from instructor group by dept_name"</span>);</span><br><span class="line">    <span class="keyword">while</span> ( rset.next() ) &#123;</span><br><span class="line">        System.out.println(rset.getString(“dept_name<span class="string">") + "</span> <span class="string">" + rset.getFloat(2));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    stmt.close();</span></span><br><span class="line"><span class="string">    conn.close();</span></span><br><span class="line"><span class="string">&#125; catch (SQLException sqle) &#123;</span></span><br><span class="line"><span class="string">    System.out.println("</span>SQLException:<span class="string">" + sqle);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id9"><span></span></span></p><h3 id="9-嵌入式SQL-ODBC-JDBC三者比较"><a href="#9-嵌入式SQL-ODBC-JDBC三者比较" class="headerlink" title="9. 嵌入式SQL-ODBC-JDBC三者比较"></a>9. 嵌入式SQL-ODBC-JDBC三者比较</h3><p>执行一条SQL语句，读取执行的结果集合</p><ol><li>嵌入式SQL的思维模式<ol><li>建立数据库连接</li><li>声明一个游标</li><li>打开游标</li><li>读取一条记录(循环)</li><li>关闭游标</li><li>断开数据库连接</li></ol></li><li>ODBC的思维模式<ol><li>建立数据库连接</li><li>分配语句句柄</li><li>用句柄执行SQL</li><li>建立高级语言变量与句柄属性的对应</li><li>读取一条记录(循环)</li><li>释放语句句柄</li><li>断开数据库连接</li></ol></li><li>JDBC的思维模式<ol><li>建立数据库连接</li><li>创建语句对象</li><li>用语句对象执行SQL，并返回结果对象</li><li>从结果对象获取一条记录</li><li>提取对象的属性值传给高级语言变量(返回上一步)</li><li>释放语句对象</li><li>断开数据库连接</li></ol></li></ol><ul><li>相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致</li><li>不同点, 操作方式的不同:<ul><li>嵌入式SQL按照语句进行操作</li><li>ODBC按照函数来进行操作</li><li>JDBC按照对象来进行操作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，&lt;/li&gt;
&lt;li&gt;然而，交互式SQL本身也有很多局限：
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】数据库语言SQL</title>
    <link href="http://chaooo.github.io/article/20190701.html"/>
    <id>http://chaooo.github.io/article/20190701.html</id>
    <published>2019-07-01T11:36:31.000Z</published>
    <updated>2019-10-20T05:35:08.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h3><p><strong>结构化查询语言</strong>(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p><ul><li>SQL语言是集DDL、DML和DCL于一体的数据库语言<a id="more"></a><ol><li><strong>DDL语句</strong>引导词：Create(建立),Alter(修改),Drop(撤消)<ul><li>模式的定义和删除，包括定义Database,Table,View,Index,完整性约束条件等，也包括定义对象(RowType行对象,Type列对象)</li></ul></li><li><strong>DML语句</strong>引导词：Insert ,Delete, Update, Select<ul><li>各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入</li><li>各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等</li><li>各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等</li></ul></li><li><strong>DCL语句</strong>引导词：Grant,Revoke<ul><li>安全性控制：授权和撤消授权</li></ul></li></ol></li></ul><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol><li><a href="#id1">利用SQL建立数据库</a></li><li><a href="#id2">利用SQL简单查询</a></li><li><a href="#id3">利用SQL多表联合查询</a></li><li><a href="#id4">利用SQL进行增-删-改</a></li><li><a href="#id5">利用SQL语言修正与撤销数据库</a></li><li><a href="#id6">SQL Server介绍</a></li><li><a href="#id7">SQL语言-子查询</a></li><li><a href="#id8">SQL语言-结果计算与聚集计算</a></li><li><a href="#id9">SQL语言-分组查询与分组过滤</a></li><li><a href="#id10">SQL语言实现关系代数操作</a></li><li><a href="#id11">SQL语言之视图及其应用</a></li><li><a href="#id12">数据库完整性</a></li><li><a href="#id13">数据库的静态完整性(约束)</a></li><li><a href="#id14">数据库的动态完整性(触发器)</a></li><li><a href="#id15">数据库索引</a></li><li><a href="#id16">数据库序列</a></li><li><a href="#id17">数据库安全性</a></li><li><a href="#id18">数据库自主安全性机制</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-利用SQL建立数据库"><a href="#1-利用SQL建立数据库" class="headerlink" title="1. 利用SQL建立数据库"></a>1. 利用SQL建立数据库</h3><p>DDL：数据定义语言（Data Definition Language)，<br>DDL通常由<strong>DBA(数据库管理员)</strong>来使用，也有经DBA授权后由应用程序员来使用</p><ol><li>创建数据库(DB)：<strong>Create Database</strong><ul><li>数据库(Database)是若干具有相互关联关系的Table/Relation的集合</li><li>简单语法形式：<code>create database database 数据库名;</code></li></ul></li><li>创建DB中的Table(定义关系模式)：<strong>Create Table</strong><ul><li><code>Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);</code><ul><li><code>[]</code>表示其括起的内容可以省略，<code>|</code>表示其隔开的两项可取其一</li><li><code>Primary key</code>: 主键约束。每个表只能创建一个主键约束</li><li><code>Unique</code>: 唯一性约束(即候选键)。可以有多个唯一性约束</li><li><code>Not null</code>: 非空约束。</li></ul></li></ul></li><li><strong>数据类型</strong>（SQL-92标准）<ul><li><code>char(n)</code>:固定长度的字符串</li><li><code>varchar(n)</code>:可变长字符串</li><li><code>int</code>:整数 //有时不同系统也写作integer</li><li><code>numeric(p，q)</code>:固定精度数字，小数点左边p位，右边(p-q)位</li><li><code>real</code>:浮点精度数字 //有时不同系统也写作<code>float(n)</code>，小数点后保留n位</li><li><code>date</code>:日期 (如 2003-09-12)</li><li><code>time</code>:时间 (如 23:15:003)<blockquote><p>注意: 现行商用DBMS的数据类型有时有些差异</p></blockquote></li></ul></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-利用SQL简单查询"><a href="#2-利用SQL简单查询" class="headerlink" title="2. 利用SQL简单查询"></a>2. 利用SQL简单查询</h3><p>DML：数据操纵语言（Data Manipulation Language)，<br>DML通常由<strong>用户或应用程序员</strong>使用，访问经授权的数据库</p><ol><li><p>向Table中添加数据(追加元组)：<strong>Insert into</strong></p><ul><li><strong><code>insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);</code></strong><ul><li>values值的排列，须与列名排列一致</li><li>若所有列名省略，则values值的排列须与该表存储中的列名排列一致</li></ul></li></ul></li><li><p>单表查询<strong>Select</strong></p><ul><li><strong><code>Select Select 列名[[,列名] …] From 表名[Where 检索条件];</code></strong><ul><li>语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。</li><li>相当于：<code>Π[列名,...,列名](σ检索条件(表名))</code></li></ul></li><li>Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。</li></ul></li><li><p>检索条件的书写<strong>Where</strong></p><ul><li>与选择运算<code>σF(R)</code>的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。</li><li><code>Select Tname From Teacher Where Salary &gt; 2000 and D# = ’03’;</code>//检索教师表中所有工资大于2000元 并且是03系的教师姓名</li></ul></li><li><p>排重(<code>DISTINCT</code>)</p><ul><li>关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。</li><li>在Table中要求无重复元组是通过定义Primary key或Unique来保证的;</li><li>而在检索结果中要求无重复元组, 是通过<strong>DISTINCT保留字</strong>的使用来实现的。</li><li><code>Select DISTINCT S# From SC Where Score &gt; 80;</code></li></ul></li><li><p>排序(<code>ORDER BY</code>)</p><ul><li>Select语句中结果排序是通过增加<strong>order by</strong>子句实现的</li><li><code>order by 列名 [asc|desc]</code></li><li>意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。</li></ul></li><li><p>模糊查询(<code>*LIKE*</code>)</p><ul><li><code>_</code>：一个字符，<code>%</code>：任意长度字符。</li><li><code>Select Sname From Student Where Sname Like &#39;张_ _&#39;;</code>//检索名字为张某某的所有同学姓名</li><li><code>Select Sname From Student Where Sname Not Like &#39;张%&#39;;</code>//检索名字不姓张的所有同学姓名</li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-利用SQL多表联合查询"><a href="#3-利用SQL多表联合查询" class="headerlink" title="3. 利用SQL多表联合查询"></a>3. 利用SQL多表联合查询</h3><p>多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。</p><ul><li>检索语句: <strong><code>Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;</code></strong></li><li>相当于<code>Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))</code></li><li>检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接</li></ul><ol><li><p>θ-连接之<strong>等值连接</strong></p><ul><li>多表连接时，如两个表的属性名相同，则需采用<strong><code>表名.属性名</code></strong>方式来限定该属性是属于哪一个表</li><li><code>Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#=&#39;001&#39; Order By Score DESC;</code>//按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)</li></ul></li><li><p>属性重名重名处理(表别名)</p><ul><li>连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用<strong><code>别名</code></strong>以便区分</li><li><code>Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;</code></li><li>当定义了别名后，在检索条件中可以使用别名来限定属性</li><li>as 可以省略</li></ul></li><li><p>θ-连接之<strong>不等值连接</strong></p><ul><li><code>Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary&gt;T2.Salary;</code>//求有薪水差额的任意两位教师</li></ul></li><li><p>实例：</p><ul><li><code>Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#=&#39;001&#39; and S2.C#=&#39;002&#39; and S1.Score &gt; S2.Score;</code>//求“001”号课成绩比“002”号课成绩高的所有学生的学号</li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-利用SQL进行增-删-改"><a href="#4-利用SQL进行增-删-改" class="headerlink" title="4. 利用SQL进行增-删-改"></a>4. 利用SQL进行增-删-改</h3><ol><li>SQL-之<strong>更新操作</strong><ul><li>元组新增Insert：新增一个或一些元组到数据库的Table中</li><li>元组更新Update:对某些元组中的某些属性值进行重新设定</li><li>元组删除Delete：删除某些元组</li></ul></li></ol><blockquote><ul><li>SQL-DML既能单一记录操作，也能对记录集合进行批更新操作</li><li>SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等</li></ul></blockquote><ol start="2"><li>SQL-之<strong>INSERT</strong><ul><li>单一元组新增命令形式：插入一条指定元组值的元组<ul><li><strong><code>insert into 表名 [(列名[,列名]…)] values (值 [,值]…);</code></strong></li></ul></li><li>批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。<ul><li><strong><code>insert into 表名 [(列名[，列名]…)] 子查询;</code></strong></li><li>示例：<code>Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like &#39;%伟&#39;;</code>//将检索到的满足条件的同学新增到该表中</li></ul></li></ul></li></ol><blockquote><p>注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。</p></blockquote><ol start="3"><li><p>SQL-之<strong>DELETE</strong></p><ul><li>元组删除Delete命令: 删除满足指定条件的元组</li><li><strong><code>Delete From 表名 [ Where 条件表达式];</code></strong></li><li>如果Where条件省略，则删除所有的元组(清空表)。</li><li>示例：<code>Delete From Student Where S# in ( Select S# From SC Where Score &lt; 60 Group by S# Having Count(*)&gt;= 4);</code>//删除有四门不及格课程的所有同学</li></ul></li><li><p>SQL-之<strong>UPDATE</strong></p><ul><li>元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值</li><li><strong><code>Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];</code></strong></li><li>如果Where条件省略，则更新所有的元组。</li><li>示例：<code>Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname=&#39;计算机&#39;);</code>//将所有计算机系的教师工资上调10%</li></ul></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-利用SQL语言修正与撤销数据库"><a href="#5-利用SQL语言修正与撤销数据库" class="headerlink" title="5. 利用SQL语言修正与撤销数据库"></a>5. 利用SQL语言修正与撤销数据库</h3><ol><li><p>修正基本表的定义</p><ul><li><strong><code>alter table tablename</code></strong></li><li><strong><code>[add {colname datatype, …}]</code></strong> //增加新列</li><li><strong><code>[drop {完整性约束名}]</code></strong> //删除完整性约束</li><li><strong><code>[modify {colname datatype, …}]</code></strong> //修改列定义</li><li>示例：<code>Alter Table Student Drop Unique(Sname);</code>删除学生姓名必须取唯一值的约束</li><li>示例：<code>Alter Table Student Add Saddr char[40],PID char[18];</code>在学生表Student上增加二列Saddr, PID</li></ul></li><li><p>SQL-DDL之撤销与修改</p><ul><li><code>drop table 表名;</code> //撤消基本表</li><li><code>drop database 数据库名;</code> //撤消数据库</li></ul></li><li><p>SQL-DDL之数据库指定与关闭命令</p><ul><li>有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。</li><li><code>use 数据库名;</code> //指定当前数据库</li><li><code>close 数据库名;</code> //关闭当前数据库</li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-SQL-Server介绍"><a href="#6-SQL-Server介绍" class="headerlink" title="6. SQL Server介绍"></a>6. SQL Server介绍</h3><p>SQL Server 是 Microsoft提供的一款关系数据库管理系统</p><ol><li>SQL Server 的系统数据库<ul><li>Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。</li><li>Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。</li><li>Msdb：代理服务数据库，提供一个存储空间。</li><li>Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。</li></ul></li><li>SQL Server的数据库<ul><li>文件：有三种文件扩展名：.mdf、.ndf、.ldf<ul><li>主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。</li><li>辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。</li><li>日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。</li></ul></li><li>页面：是SQL Server存储的最小单位。一页为8K或8192字节。</li><li>空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位</li></ul></li></ol><h4 id="6-1-SQL-Server数据库的创建-删除与维护"><a href="#6-1-SQL-Server数据库的创建-删除与维护" class="headerlink" title="6.1 SQL Server数据库的创建-删除与维护"></a>6.1 SQL Server数据库的创建-删除与维护</h4><ol><li>创建数据库<ul><li>语法形式：Create Database 库名</li><li>可视化操作(查询分析器)：Database(鼠标右键) -&gt; new Database… -&gt; 填写数据库名及配置</li><li>创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。</li><li>创建数据库的用户自动成为数据库的拥有者。</li></ul></li><li>删除数据库<ul><li>语法形式：Drop Database 库名</li><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Delete</li><li>对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。</li><li>当数据库处于正在使用或正在恢复状态时，不能删除。</li></ul></li><li>备份数据库<ul><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Back Up…</li><li>备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。<ul><li>完全数据库备份：完全备份数据文件和日志文件。</li><li>差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。</li><li>事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。</li><li>数据库文件和文件组备份：用在数据库相当大的情况下。</li></ul></li></ul></li><li>恢复数据库<ul><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Restore</li><li>数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。</li><li>数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。</li><li>可以通过企业管理器来完成数据库恢复。</li></ul></li><li>数据库授权: <ul><li>语法形式：grant 权限 on 表名 to 用户名</li><li>权限有：select,update,insert,delete,exec,dri。</li><li>对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.</li></ul></li></ol><h4 id="6-2-SQL-Server数据表的创建-与增-删-改-查"><a href="#6-2-SQL-Server数据表的创建-与增-删-改-查" class="headerlink" title="6.2 SQL Server数据表的创建-与增/删/改/查"></a>6.2 SQL Server数据表的创建-与增/删/改/查</h4><ol><li>创建表<ul><li>同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。</li><li>用T-SQL语句创建表，语法形式：<code>CREATE TABLE [数据库名.所有者名.]表名 ({&lt;列名 数据类型&gt;} [缺省值][约束][是否为空] …)</code><blockquote><p>注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持</p></blockquote></li><li>可视化操作(查询分析器)：数据库名 -&gt; Tables -&gt; New Table…</li></ul></li><li>增加、修改表字段<ul><li>语法形式：<code>ALTER TABLE ADD | ALTER 字段名 &lt;类型&gt;</code></li></ul></li><li>创建、删除与修改约束<ul><li>约束是SQL提供自动保持数据库完整性的一种方法，共5种。</li><li>用T-SQL语句建立约束，语法形式：<code>CONSTRAINT 约束名 约束类型 (列名)</code><ul><li>约束名：在库中应该唯一，如不指定，系统会给出</li><li>约束类型 (5种)：<ul><li>primary key constraint (主键值)</li><li>unique constraint (唯一性)</li><li>check constraint (检查性)</li><li>default constraint (默认)</li><li>foreign key constraint (外部键)</li></ul></li><li>列名：要约束的字段名</li></ul></li><li>示例:<code>Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));</code></li></ul></li></ol><p><span id="id7"><span></span></span></p><h3 id="7-SQL语言-子查询"><a href="#7-SQL语言-子查询" class="headerlink" title="7. SQL语言-子查询"></a>7. SQL语言-子查询</h3><ul><li>子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。</li><li>三种类型的子查询：(NOT) IN-子查询；θ-Some/θ-All子查询；(NOT) EXISTS子查询</li></ul><h4 id="7-1-NOT-IN子查询"><a href="#7-1-NOT-IN子查询" class="headerlink" title="7.1 (NOT) IN子查询"></a>7.1 (NOT) IN子查询</h4><ol><li>基本语法：<code>表达式 [not] in (子查询)</code><ul><li>语法中，表达式的最简单形式就是列名或常数。</li><li>语义：判断某一表达式的值是否在子查询的结果中。</li><li>示例：<ul><li><code>Select * From Student Where Sname in (&#39;张三&#39;, &#39;王三&#39;);</code>//列出张三、王三同学的所有信息</li><li><code>Select S#, Sname From Student Where S# in (Select S# From SC Where C#=&#39;001&#39;);</code>//列出选修了001号课程的学生的学号和姓名</li></ul></li></ul></li><li>非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询</li><li>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询</li><li>外层向内层传递的参量需要使用外层的表名或表别名来限定<ul><li>示例：<code>Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#=&#39;001&#39;);</code>//求学过001号课程的同学的姓名</li></ul></li></ol><blockquote><p>注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。</p></blockquote><h4 id="7-2-θ-Some-θ-All子查询"><a href="#7-2-θ-Some-θ-All子查询" class="headerlink" title="7.2 θ-Some/θ-All子查询"></a>7.2 θ-Some/θ-All子查询</h4><ol><li>基本语法：<code>表达式 θ some (子查询)</code> / <code>表达式 θ all (子查询)</code><ul><li>语法中，θ是比较运算符：<code>&lt;, &gt;, &gt;=, &lt;=, =, &lt;&gt;</code>。</li><li>语义：将表达式的值与子查询的结果进行比较：<ul><li>如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则<code>表达式 θ some (子查询)</code>的结果便为真</li><li>如果表达式的值与子查询结果的所有值相比较都满足 关系，则<code>表达式 θ all (子查询)</code>的结果便为真</li></ul></li><li>示例：<ul><li><code>Select Tname From Teacher Where Salary &lt;= all ( Select Salary From Teacher);</code>//找出工资最低的教师姓名</li><li><code>Select S# From SC Where C# = “001” and Score &lt; some ( Select Score From SC Where C#=&#39;001&#39;);</code>//找出001号课成绩不是最高的所有学生的学号</li></ul></li></ul></li></ol><blockquote><p>在SQL标准中，也有θ-Any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。</p></blockquote><ol start="2"><li>等价性变换需要注意<ul><li><code>表达式 = some (子查询)</code>和<code>表达式 in (子查询)</code>含义<strong>相同</strong></li><li><code>表达式 &lt;&gt; some (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>不同</strong></li><li><code>表达式 &lt;&gt; all (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>相同</strong></li></ul></li></ol><h4 id="7-3-NOT-EXISTS子查询"><a href="#7-3-NOT-EXISTS子查询" class="headerlink" title="7.3 (NOT) EXISTS子查询"></a>7.3 (NOT) EXISTS子查询</h4><ol><li>基本语法：<code>[not] Exists [not] Exists (子查询)</code><ul><li>语义：子查询结果中有无元组存在</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：检索选修了赵三老师主讲课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC, Course, Teacher</span><br><span class="line">        <span class="keyword">Where</span> SC.C<span class="comment">#=Course.C# and SC. S#=Student.S#</span></span><br><span class="line">        <span class="keyword">and</span> Course.T<span class="comment"># = Teacher.T# and Tname='赵三');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--示例：检索学过001号教师主讲的所有课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> //不存在</span><br><span class="line">        ( <span class="keyword">Select</span> * <span class="keyword">From</span> Course //有一门<span class="number">001</span>教师主讲课程</span><br><span class="line">        <span class="keyword">Where</span> Course.T<span class="comment"># = ‘001’ and not exists //该同学没学过</span></span><br><span class="line">            ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC</span><br><span class="line">            <span class="keyword">Where</span> S<span class="comment"># = Student.S# and C# = Course.C#));</span></span><br><span class="line"><span class="comment">--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过</span></span><br></pre></td></tr></table></figure><p><span id="id8"><span></span></span></p><h3 id="8-SQL语言-结果计算与聚集计算"><a href="#8-SQL语言-结果计算与聚集计算" class="headerlink" title="8. SQL语言-结果计算与聚集计算"></a>8. SQL语言-结果计算与聚集计算</h3><h4 id="8-1-结果计算"><a href="#8-1-结果计算" class="headerlink" title="8.1 结果计算"></a>8.1 结果计算</h4><p>Select-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算</p><ul><li><code>Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];</code><ul><li>expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书</li><li>agfunc()是一些聚集函数</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求有差额(差额&gt;0)的任意两位教师的薪水差额</span></span><br><span class="line"><span class="keyword">Select</span> T1.Tname <span class="keyword">as</span> TR1, T2.Tname <span class="keyword">as</span> TR2, T1.Salary – T2.Salary</span><br><span class="line">    <span class="keyword">From</span> Teacher T1, Teacher T2</span><br><span class="line">    <span class="keyword">Where</span> T1.Salary &gt; T2.Salary;</span><br></pre></td></tr></table></figure><h4 id="8-2-聚集函数"><a href="#8-2-聚集函数" class="headerlink" title="8.2 聚集函数"></a>8.2 聚集函数</h4><p>SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc,分别是：COUNT、SUM、AVG、MAX、MIN</p><table><thead><tr><th>聚合函数</th><th>支持的数据类型</th><th>描述</th></tr></thead><tbody><tr><td>count()</td><td>任何类型/*</td><td>计算结果集中的总行数</td></tr><tr><td>sum()</td><td>Numeric</td><td>计算指定列中所有非空值的总和</td></tr><tr><td>avg()</td><td>numeric</td><td>计算指定列中所有非空值的平均值</td></tr><tr><td>max()</td><td>char/numeric</td><td>返回指定列中最大值</td></tr><tr><td>min()</td><td>char/numeric</td><td>返回指定列中最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Sum</span>(Salary) <span class="keyword">From</span> Teacher;</span><br><span class="line"><span class="comment">--示例：求计算机系教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Sum</span>(Salary) <span class="keyword">From</span> Teacher T, Dept</span><br><span class="line">    <span class="keyword">Where</span> Dept.Dname = ‘计算机’ <span class="keyword">and</span> Dept.D<span class="comment"># = T.D#;</span></span><br><span class="line"><span class="comment">--示例：求数据库课程的平均成绩</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">AVG</span>(Score) <span class="keyword">From</span> Course C, SC</span><br><span class="line">    <span class="keyword">Where</span> C.Cname = ‘数据库’ <span class="keyword">and</span> C.C<span class="comment"># = SC.C#;</span></span><br></pre></td></tr></table></figure><p><span id="id9"><span></span></span></p><h3 id="9-SQL语言-分组查询与分组过滤"><a href="#9-SQL语言-分组查询与分组过滤" class="headerlink" title="9. SQL语言-分组查询与分组过滤"></a>9. SQL语言-分组查询与分组过滤</h3><h4 id="9-1-分组查询"><a href="#9-1-分组查询" class="headerlink" title="9.1 分组查询"></a>9.1 分组查询</h4><p>分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。</p><ol><li><p>分组的基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 ] ;</span><br></pre></td></tr></table></figure></li><li><p>分组条件可以是：<code>列名1, 列名2, …</code></p></li><li><p>示例： 求每一个学生的平均成绩</p><ul><li><code>Select S#, AVG(Score) From SC Group by S#;</code></li></ul></li></ol><h4 id="9-2-分组过滤"><a href="#9-2-分组过滤" class="headerlink" title="9.2 分组过滤"></a>9.2 分组过滤</h4><p>聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤</p><ul><li>分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。</li><li>Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。</li></ul><ol><li><p>基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 [ <span class="keyword">Having</span> <span class="keyword">Having</span> 分组过滤条件] ] ;</span><br></pre></td></tr></table></figure></li><li><p>示例：求不及格课程超过两门的同学的学号</p><ul><li><code>Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2;</code> </li></ul></li></ol><h4 id="9-3-where子句与having子句的区别"><a href="#9-3-where子句与having子句的区别" class="headerlink" title="9.3 where子句与having子句的区别"></a>9.3 where子句与having子句的区别</h4><ol><li>聚合函数是比较where、having 的关键。在from后面的执行顺序：<ul><li><code>where -&gt; 聚合函数(sum,min,max,avg,count) -&gt;having</code></li></ul></li><li>列出group by来比较二者:<ul><li>where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。</li><li>having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。</li></ul></li></ol><blockquote><p>注意事项 ： </p><ol><li>where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 </li><li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 </li><li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</li></ol></blockquote><p><span id="id10"><span></span></span></p><h3 id="10-SQL语言实现关系代数操作"><a href="#10-SQL语言实现关系代数操作" class="headerlink" title="10. SQL语言实现关系代数操作"></a>10. SQL语言实现关系代数操作</h3><p>SQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。</p><ul><li>基本语法形式：<ul><li><code>子查询 {Union [ALL] | Intersect [ALL] | Except [ALL] 子查询}</code></li></ul></li><li>通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。<ul><li>假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：<ul><li>子查询1 Union ALL 子查询2 ，出现m + n次</li><li>子查询1 Intersect ALL 子查询2 ，出现min(m,n)次</li><li>子查询1 Except ALL 子查询2 ，出现max(0, m – n)次</li></ul></li></ul></li></ul><blockquote><p>UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但<strong>有些DBMS并不支持</strong>这些运算，使用时要注意。</p></blockquote><h4 id="10-1-SQL并运算-UNION"><a href="#10-1-SQL并运算-UNION" class="headerlink" title="10.1 SQL并运算(UNION)"></a>10.1 SQL并运算(UNION)</h4><ol><li>示例：已知两个表<ul><li>Customers(Cid, Cname, City, Discnt)</li><li>Agents(Aid, Aname, City, Percent)</li></ul></li><li>求客户所在的或者代理商所在的城市<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Customers</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Agents;</span><br></pre></td></tr></table></figure></li></ol><h4 id="10-2-SQL交运算-INTERSECT"><a href="#10-2-SQL交运算-INTERSECT" class="headerlink" title="10.2 SQL交运算(INTERSECT)"></a>10.2 SQL交运算(INTERSECT)</h4><ol><li><p>示例：求既学过002号课，又学过003号课的同学学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘002’</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘003’;</span></span><br></pre></td></tr></table></figure></li><li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p><ul><li><code>Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);</code></li></ul></li><li><p>交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。</p></li></ol><h4 id="10-3-SQL差运算-EXCEPT"><a href="#10-3-SQL差运算-EXCEPT" class="headerlink" title="10.3 SQL差运算(EXCEPT)"></a>10.3 SQL差运算(EXCEPT)</h4><ol><li><p>示例： 假定所有学生都有选课，求没学过002号课程的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S<span class="comment"># From SC</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">Select</span> S<span class="comment"># From SC Where C# = ‘002’;</span></span><br></pre></td></tr></table></figure></li><li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S<span class="comment"># From SC SC1</span></span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> * <span class="keyword">From</span> SC</span><br><span class="line">        <span class="keyword">Where</span> C<span class="comment"># = ‘002’ and S# = SC1.S#);</span></span><br></pre></td></tr></table></figure></li><li><p>差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。</p></li></ol><h4 id="10-4-空值的处理"><a href="#10-4-空值的处理" class="headerlink" title="10.4 空值的处理"></a>10.4 空值的处理</h4><p>空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p><ol><li>在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。</li><li>空值检测：<ul><li><code>is [not ] null</code> //测试指定列的值是否为空值</li></ul></li><li>示例：找出年龄值为空的学生姓名<ul><li><code>Select Sname From Student Where Sage is null;</code></li></ul></li><li>现行DBMS的空值处理小结<ul><li>除is[not]null之外，空值不满足任何查找条件</li><li>如果null参与算术运算，则该算术表达式的值为null</li><li>如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown</li><li>如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li></ul></li></ol><h4 id="10-5-内连接、外连接"><a href="#10-5-内连接、外连接" class="headerlink" title="10.5 内连接、外连接"></a>10.5 内连接、外连接</h4><ol><li><p>标准SQL语言中连接运算通常为：</p><ul><li><code>Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;</code></li><li>即相当于采用<code>Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))</code>。</li></ul></li><li><p>SQL的高级语法中引入了内连接与外连接运算，具体形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 [ [, 列名] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [<span class="keyword">NATURAL</span>]</span><br><span class="line">    [ <span class="keyword">INNER</span> | &#123; <span class="keyword">LEFT</span> | <span class="keyword">RIGHT</span> | <span class="keyword">FULL</span>&#125; [<span class="keyword">OUTER</span>]] <span class="keyword">JOIN</span> 表名<span class="number">2</span></span><br><span class="line">    &#123; <span class="keyword">ON</span> 连接条件 | <span class="keyword">Using</span> (Colname &#123;, Colname …&#125;) &#125;</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ] … ;</span><br></pre></td></tr></table></figure></li><li><p>由 <strong>连接类型</strong> 和 <strong>连接条件</strong> 构成连接运算。</p><ul><li><strong><code>Natural</code></strong>：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次</li><li><strong><code>Inner Join</code></strong>: 即关系代数中的θ-连接运算</li><li><strong><code>Left Outer Join, Right Outer Join, Full Outer Join</code></strong>: 即关系代数中的外连接运算</li><li><strong><code>on &lt;连接条件&gt;</code></strong>：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li><li><strong><code>using (Col1, Col2, …, Coln)</code></strong>：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次</li></ul></li><li><p>示例:</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher.T<span class="comment">#, Tname, Cname</span></span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Inner</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T<span class="comment"># = Course.T#</span></span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T<span class="comment"># ASC;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher. T<span class="comment">#, Tname, Cname</span></span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Left</span> <span class="keyword">Outer</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T<span class="comment"># = Course.T#</span></span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T<span class="comment"># ASC ;</span></span><br></pre></td></tr></table></figure><p><span id="id11"><span></span></span></p><h3 id="11-SQL语言之视图及其应用"><a href="#11-SQL语言之视图及其应用" class="headerlink" title="11. SQL语言之视图及其应用"></a>11. SQL语言之视图及其应用</h3><ol><li>数据库的三级模式两层映像<ul><li>三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成</li><li>应用–&gt; <strong>外模式</strong>(多个) –&gt; <strong>概念模式</strong>(一个) –&gt; <strong>内模式</strong>(一个) –&gt; 数据库</li><li>两层映像：<code>E-C</code>映像(外模式-&gt;概念模式)、<code>C-I</code>映像(概念模式-&gt;内模式)。</li></ul></li><li>对应概念模式的数据在SQL中被称为<strong>基本表(Table)</strong>,而对应外模式的数据称为<strong>视图(View)</strong>。<strong>视图不仅包含外模式，而且包含其E-C映像</strong>。</li><li><strong>基本表</strong>是实际存储于存储文件中的表，基本表中的<strong>数据是需要存储的</strong></li><li><strong>视图</strong>在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其<strong>数据并不存储</strong>，而是在运行过程中动态产生与维护的</li><li>对视图数据的更改最终要反映在对基本表的更改上。</li></ol><h4 id="11-1-视图的定义"><a href="#11-1-视图的定义" class="headerlink" title="11.1 视图的定义"></a>11.1 视图的定义</h4><p>视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。</p><ol><li>定义视图: <code>create view view_name [(列名[列名] …)] as 子查询 [with check option]</code><ul><li>如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。</li><li>with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式</li></ul></li><li>示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> CompStud <span class="keyword">AS</span></span><br><span class="line">    (<span class="keyword">Select</span> * <span class="keyword">From</span> Student</span><br><span class="line">        <span class="keyword">Where</span> D<span class="comment"># in (Select D# From Dept</span></span><br><span class="line">            <span class="keyword">Where</span> Dname = ‘计算机’));</span><br></pre></td></tr></table></figure></li></ol><h4 id="11-2-视图的使用"><a href="#11-2-视图的使用" class="headerlink" title="11.2 视图的使用"></a>11.2 视图的使用</h4><p>使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用</p><ul><li>示例：检索计算机系的所有学生，我们可使用CompStud<ul><li><code>Select * From CompStud;</code></li></ul></li><li>示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud<ul><li><code>Select * From CompStud Where Sage&lt;20;</code></li></ul></li></ul><h4 id="11-3-视图的更新"><a href="#11-3-视图的更新" class="headerlink" title="11.3 视图的更新"></a>11.3 视图的更新</h4><p>SQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。</p><ol><li>SQL视图更新的可执行性<ul><li>如果视图的select目标列包含聚集函数，则不能更新</li><li>如果视图的select子句使用了unique或distinct，则不能更新</li><li>如果视图中包括了groupby子句，则不能更新</li><li>如果视图中包括经算术表达式计算出来的列，则不能更新</li><li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li></ul></li><li>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新</li><li>可更新SQL视图示例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CStud(S<span class="comment">#, Sname, Sclass)</span></span><br><span class="line"><span class="keyword">as</span> ( <span class="keyword">select</span> S<span class="comment">#, Sname, Sclass from Student where D# ='03');</span></span><br><span class="line"><span class="comment">-- 更新视图</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> CStud <span class="keyword">Values</span> (<span class="string">'98030104'</span>, <span class="string">'张三丰'</span>, <span class="string">'980301'</span>);</span><br><span class="line"><span class="comment">-- 更新视图 将转换为 更新基本表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span> (<span class="string">'98030104'</span>, <span class="string">'张三丰'</span>, <span class="literal">Null</span>, <span class="literal">Null</span>, <span class="string">'03'</span>, <span class="string">'980301'</span>)</span><br></pre></td></tr></table></figure><h4 id="11-4-视图的撤销"><a href="#11-4-视图的撤销" class="headerlink" title="11.4 视图的撤销"></a>11.4 视图的撤销</h4><p>已经定义的视图也可以撤消</p><ul><li>撤消视图：<code>Drop View view_name</code></li></ul><p>不仅视图可以撤消，基本表、数据库等都可以撤消</p><ul><li>撤消基本表：<code>Drop Table 表名</code></li></ul><p><span id="id12"><span></span></span></p><h3 id="12-数据库完整性"><a href="#12-数据库完整性" class="headerlink" title="12. 数据库完整性"></a>12. 数据库完整性</h3><p>数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性–在任何情况下的正确性、有效性和一致性</p><ul><li>广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等</li><li>狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。</li></ul><h4 id="12-1-基本概念"><a href="#12-1-基本概念" class="headerlink" title="12.1 基本概念"></a>12.1 基本概念</h4><p>关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性</p><ol><li>数据库完整性管理的作用<ul><li>防止和避免数据库中不合理数据的出现</li><li>DBMS应尽可能地自动防止DB中语义不合理现象</li><li>如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担</li></ul></li><li>DBMS怎样自动保证完整性：<ul><li>DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)</li><li>当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性</li></ul></li><li><strong>完整性约束条件</strong>(或称完整性约束规则)的一般形式：Integrity Constraint::=(O,P,A,R)<ul><li>O：数据集合：约束的对象(列、多列(元组)、元组集合)</li><li>P：谓词条件：需要定义什么样的约束</li><li>A：触发条件：默认更新时检查</li><li>R：响应动作：默认拒绝</li></ul></li></ol><h4 id="12-2-数据库完整性的分类"><a href="#12-2-数据库完整性的分类" class="headerlink" title="12.2 数据库完整性的分类"></a>12.2 数据库完整性的分类</h4><ol><li><p>按约束对象分类:</p><ul><li>域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的</li><li>关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断</li></ul></li><li><p>按约束来源分类:</p><ul><li>结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；</li><li>内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。</li></ul></li><li><p>按约束状态分类:</p><ul><li>静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。</li><li>动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。</li></ul></li></ol><p><span id="id13"><span></span></span></p><h3 id="13-数据库的静态完整性-约束"><a href="#13-数据库的静态完整性-约束" class="headerlink" title="13. 数据库的静态完整性(约束)"></a>13. 数据库的静态完整性(约束)</h3><ol><li><p>SQL语言支持的约束类别：</p><ul><li>静态约束<ul><li>列完整性—域完整性约束</li><li>表完整性–关系完整性约束</li></ul></li><li>动态约束<ul><li>触发器</li></ul></li></ul></li><li><p>CreateTable有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性</p><ul><li>定义完整性约束条件：列完整性、表完整性</li></ul></li><li><p>列约束：一种<strong>域约束类型</strong>，对单一列的值进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; NOT NULL |                  //列值非空</span><br><span class="line">[ CONSTRAINT constraintname ] //为约束命名，便于以后撤消</span><br><span class="line">&#123; UNIQUE                      //列值是唯一</span><br><span class="line">| PRIMARY KEY                 //列为主键</span><br><span class="line">| <span class="keyword">CHECK</span> (search_cond)         //列值满足条件,条件只能使用列当前值</span><br><span class="line">| <span class="keyword">REFERENCES</span> tablename [(colname) ]</span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">DELETE</span> &#123; <span class="keyword">CASCADE</span> | <span class="keyword">SET</span> <span class="literal">NULL</span> &#125; ] &#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>表约束：一种<strong>关系约束类型</strong>，对多列或元组的值进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ CONSTRAINT constraintname ]       //为约束命名，便于以后撤消</span><br><span class="line">&#123; UNIQUE (colname &#123;,colname…&#125;)      //几列值组合在一起是唯一</span><br><span class="line">| PRIMARY KEY (colname &#123;,colname…&#125;) //几列联合为主键</span><br><span class="line">| <span class="keyword">CHECK</span> (search_condition)          //元组多列值共同满足条件</span><br><span class="line">                                    //条件中只能使用同一元组的不同列当前值</span><br><span class="line">| <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (colname &#123;,colname…&#125;)</span><br><span class="line"><span class="keyword">REFERENCES</span> tablename [(colname &#123;,colname…&#125;)]//引用另一表tablename的若干列的值作为外键</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。</p></blockquote><ol start="5"><li><p>Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)</p><ul><li>示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)<ul><li><code>Alter Table SC DROP CONSTRAINT ctscore;</code></li></ul></li><li>有些DBMS支持独立的追加约束,注意书写格式可能有些差异<ul><li>示例：<code>Alter Table SC Add Constraint nctscore check (Score&gt;=0.0 and Score&lt;=150.0));</code></li></ul></li></ul></li><li><p>现约束的方法-断言ASSERTION</p><ul><li>一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件</li><li>表约束和列约束就是一些特殊的断言</li><li>SQL还提供了复杂条件表达的断言。其语法形式为：<ul><li><code>CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt;</code></li></ul></li><li>当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">assertion</span> sum_constraint <span class="keyword">check</span></span><br><span class="line">    (<span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> branch</span><br><span class="line">    <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">sum</span>(amount ) <span class="keyword">from</span> loan</span><br><span class="line">        <span class="keyword">where</span> loan.branch_name = branch.branch_name )</span><br><span class="line">    &gt;= (<span class="keyword">select</span> <span class="keyword">sum</span> (balance ) <span class="keyword">from</span> <span class="keyword">account</span></span><br><span class="line">        <span class="keyword">where</span> account.branch_name = branch.branch_name )))</span><br><span class="line"><span class="comment">-- 数据表：</span></span><br><span class="line"><span class="keyword">account</span>(branch_name, account_number,…, balance) //分行，账户及其余额</span><br><span class="line">loan(branch_name , loan_number, amount,) //分行的每一笔贷款</span><br><span class="line">branch(branch_name, … ) //分行</span><br></pre></td></tr></table></figure><blockquote><p>断言测试增加了数据库维护的负担，要小心使用复杂的断言。</p></blockquote><p><span id="id14"><span></span></span></p><h3 id="14-数据库的动态完整性-触发器"><a href="#14-数据库的动态完整性-触发器" class="headerlink" title="14. 数据库的动态完整性(触发器)"></a>14. 数据库的动态完整性(触发器)</h3><p>实现数据库动态完整的方法—触发器Trigger</p><ol><li><p>触发器Trigger</p><ul><li>Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger</li><li>Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。</li></ul></li><li><p>基本语法</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span></span><br><span class="line">    &#123; <span class="keyword">INSERT</span> | <span class="keyword">DELETE</span> | <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> colname &#123;, colname...&#125;] &#125;</span><br><span class="line">    <span class="keyword">ON</span> tablename [<span class="keyword">REFERENCING</span> corr_name_def &#123;, corr_name_def...&#125; ]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> | <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span>]</span><br><span class="line">                //对更新操作的每一条结果(前者)，或整个更新操作完成(后者)</span><br><span class="line">    [<span class="keyword">WHEN</span> (search_condition)]           //检查条件，如满足执行下述程序</span><br><span class="line">    &#123; <span class="keyword">statement</span>         //单行程序直接书写，多行程序要用下行方式</span><br><span class="line">    | BEGIN ATOMIC statement; &#123; statement;...&#125; END &#125;</span><br></pre></td></tr></table></figure></li><li><p>触发器Trigger意义：</p><ul><li>当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件<code>search_condition</code>,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用<code>corr_name_def</code>来限定。</li></ul></li><li><p>事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}</p><ul><li>当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发</li><li>操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由<code>corr_name_def</code>的使用来区分</li></ul></li><li><p><code>corr_name_def</code>的定义</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; OLD [ROW] [AS] old_row_corr_name //更新前的旧元组命别名为</span><br><span class="line">| NEW [ROW] [AS] new_row_corr_name //更新后的新元组命别名为</span><br><span class="line">| OLD TABLE [AS] old_table_corr_name //更新前的旧Table命别名为</span><br><span class="line">| NEW TABLE [AS] new_table_corr_name //更新后的新Table命别名为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>corr_name_def</code>将在检测条件或后面的动作程序段中被引用处理</p></blockquote><ol start="6"><li><p>示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> teacher_chgsal <span class="keyword">before</span> <span class="keyword">update</span> <span class="keyword">of</span> salary</span><br><span class="line">    <span class="keyword">on</span> teacher</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> x, <span class="keyword">old</span> y</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">when</span> (x.salary &lt; y.salary)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    raise_application_error(<span class="number">-20003</span>, <span class="string">'invalid salary on update'</span>);</span><br><span class="line">    //此条语句为Oracle的错误处理函数</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> sumc <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> sc</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> <span class="keyword">row</span> newi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> SumCourse = SumCourse + <span class="number">1</span></span><br><span class="line">    <span class="keyword">where</span> S<span class="comment"># = :newi.S# ;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> delS<span class="comment"># after delete on Student</span></span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">old</span> oldi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> sc <span class="keyword">where</span> S<span class="comment"># = :oldi.S# ;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li></ol><p><span id="id15"><span></span></span></p><h3 id="15-数据库索引"><a href="#15-数据库索引" class="headerlink" title="15. 数据库索引"></a>15. 数据库索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种<strong>数据结构</strong>（最常见的是B-Tree）</p><ol><li>索引的作用<ol><li>快速取数据；</li><li>保证数据记录的唯一性；</li><li>实现表与表之间的参照完整性；</li><li>在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。</li></ol></li><li>创建索引：<code>CREATE INDEX  索引名称  on 表名(字段名);</code></li><li>删除索引：<code>DROP INDEX 索引名称</code></li><li>索引注意事项：<ol><li>查询时减少使用<code>*</code>返回全部列，不要返回不需要的列</li><li>where表达式子句包含索引的表达式置前</li><li>避免在Order by中使用表达式</li><li>索引技术是数据库自动使用，一个表格只存在一个索引就够了</li></ol></li><li>缺点<ol><li>索引的缺点是创建和维护索引需要耗费时间和空间</li><li>索引可以提高查询速度，会减慢写入速度</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li></ol></li></ol><h4 id="15-1-索引主要种类"><a href="#15-1-索引主要种类" class="headerlink" title="15.1 索引主要种类"></a>15.1 索引主要种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p><ol><li>唯一索引<ul><li>唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</li></ul></li><li>主键索引<ul><li>数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</li></ul></li><li>聚集索引<ul><li>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</li></ul></li><li>索引列<ul><li>可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</li></ul></li></ol><p><span id="id16"><span></span></span></p><h3 id="16-数据库序列"><a href="#16-数据库序列" class="headerlink" title="16. 数据库序列"></a>16. 数据库序列</h3><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要<code>CREATE SEQUENCE</code>系统权限。</p><h4 id="16-1-Oracle中的序列（Sequence）"><a href="#16-1-Oracle中的序列（Sequence）" class="headerlink" title="16.1 Oracle中的序列（Sequence）"></a>16.1 Oracle中的序列（Sequence）</h4><ol><li><p>创建序列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> 序列名 </span><br><span class="line">    [<span class="keyword">increment</span> <span class="keyword">by</span> n]   <span class="comment">--每次增加n个，默认为1</span></span><br><span class="line">    [<span class="keyword">start</span> <span class="keyword">with</span> n]     <span class="comment">--起始值n，默认为1</span></span><br><span class="line">    [&#123;maxvalue n | <span class="keyword">nomaxvalue</span>&#125;]  <span class="comment">--最大值设置，递增默认10的27次方，递减默认-1</span></span><br><span class="line">    [&#123;<span class="keyword">minvalue</span> n | <span class="keyword">nominvalue</span>&#125;]  <span class="comment">--最小值设置，递增默认1，递减默认-10的26次方</span></span><br><span class="line">    [&#123;<span class="keyword">cycle</span> | <span class="keyword">nocycle</span>&#125;]   <span class="comment">--是否循环</span></span><br><span class="line">    [&#123;<span class="keyword">cache</span> n | nocache&#125;] <span class="comment">--是否对序列进行内存缓冲，默认为20</span></span><br></pre></td></tr></table></figure></li><li><p>查询序列</p><ul><li><code>NEXTVAL</code>:返回序列中下一个有效的值，任何用户都可以引用。</li><li><code>CURRVAL</code>:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询下一个将要使用的序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.nextval <span class="keyword">from</span> dual</span><br><span class="line"><span class="comment">--查询当前序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.currval <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure><blockquote><ul><li>Oracle将sequence的定义存储在数据字典之中。</li><li>Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。</li></ul></blockquote><ol start="3"><li>删除序列：<code>Drop sequence 序列名</code></li><li>更改序列：<code>Alter sequence 序列名 [其余参数同创建序列]</code></li><li>使用序列示例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.直接使用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person (<span class="keyword">id</span>, <span class="keyword">name</span>, <span class="keyword">password</span>) <span class="keyword">values</span> (序列名.nextval, <span class="string">'张三'</span>, <span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值</span></span><br><span class="line"><span class="comment">-- 2.1创建触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> 触发器名 <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> person</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> 序列名.nextval <span class="keyword">into</span> :new.id <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 2.2插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person ( username, age, <span class="keyword">password</span>) <span class="keyword">values</span> (<span class="string">'张三'</span>, <span class="number">20</span>, <span class="string">'zhang123'</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>注意点：<ul><li>一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。</li><li>当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。</li><li>大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。</li></ul></li></ol><h4 id="16-2-Mysql中的序列（AUTO-INCREMENT）"><a href="#16-2-Mysql中的序列（AUTO-INCREMENT）" class="headerlink" title="16.2 Mysql中的序列（AUTO_INCREMENT）"></a>16.2 Mysql中的序列（AUTO_INCREMENT）</h4><p>MySQL中最简单使用序列的方法就是使用<code>AUTO_INCREMENT</code>来定义列。</p><ol><li>orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。</li><li>首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。</li><li>mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.</li><li>mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。</li></ol><p><span id="id17"><span></span></span></p><h3 id="17-数据库安全性"><a href="#17-数据库安全性" class="headerlink" title="17. 数据库安全性"></a>17. 数据库安全性</h3><p>数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏</p><ol><li>数据库安全性管理涉及许多方面<ol><li>社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法</li><li>公共政策/制度方面：例如，政府或组织的信息公开或非公开制度</li><li>安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)</li><li>数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)</li><li>数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制</li></ol></li><li>DBMS的安全机制<ol><li><strong>自主安全性机制</strong>：存取控制(AccessControl)<ul><li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li></ul></li><li><strong>强制安全性机制</strong>：<ul><li>通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据</li></ul></li><li>推断控制机制：<ul><li>防止通过历史信息，推断出不该被其知道的信息；</li><li>防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li></ul></li><li>数据加密存储机制：<ul><li>通过加密、解密保护数据，密钥、加密/解密方法与传输</li></ul></li></ol></li><li>DBA的责任和义务<ul><li>熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略</li><li>规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，</li><li><strong>划分好数据的安全级别以及用户的安全级别</strong></li><li>实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等</li></ul></li></ol><p><span id="id18"><span></span></span></p><h3 id="18-数据库自主安全性机制"><a href="#18-数据库自主安全性机制" class="headerlink" title="18. 数据库自主安全性机制"></a>18. 数据库自主安全性机制</h3><ul><li>通常情况下，自主安全性是通过授权机制来实现的。</li><li>用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。<ul><li>授权者：决定用户权利的人</li><li>授权：授予用户访问的权利</li></ul></li></ul><ol><li>DBMS自动实现自主安全性：<ul><li>DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)</li><li>当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问</li></ul></li><li>DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制<ul><li><code>AccessRule ::=(S, O, t, P)</code><ul><li>S: 请求主体(用户)</li><li>O: 访问对象</li><li>t: 访问权利</li><li>P: 谓词</li></ul></li><li>{AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;</li><li>用户多时，可以按用户组建立访问规则</li><li>访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库</li><li>权利：包括创建、增、删、改、查等</li><li>谓词：拥有权利需满足的条件</li></ul></li><li><strong>示例</strong>：员工管理数据库的安全性控制示例<code>Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)</code><ul><li>示例要求：<ul><li>员工管理人员：能访问该数据库的所有内容，便于维护员工信息</li><li>收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问</li><li>每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改</li><li>部门领导：能够查询其所领导部门人员的所有情况</li><li>高层领导：能访问该数据库的所有内容，但只能读</li></ul></li><li>两种控制示例<ul><li>按名控制安全性：存储矩阵</li><li>按内容控制安全性：视图</li></ul></li><li>视图是安全性控制的重要手段</li><li>通过视图可以限制用户对关系中某些数据项的存取,例如：<ul><li>视图1：CreateEmpV1as select*fromEmployee</li><li>视图2：CreateEmpV2as selectPname,D#fromEmployee</li></ul></li><li>通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：<ul><li>视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId</li><li>视图2： CreateEmpV4asselect*fromEmployeewhereHead=:UserId</li></ul></li><li>用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述</li></ul></li></ol><h4 id="18-1-SQL语言的用户与权利"><a href="#18-1-SQL语言的用户与权利" class="headerlink" title="18.1 SQL语言的用户与权利"></a>18.1 SQL语言的用户与权利</h4><ol><li><p>SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴</p></li><li><p>授权机制—自主安全性；视图的运用</p></li><li><p>关系级别(普通用户) &lt;– 账户级别(程序员用户) &lt;– 超级用户(DBA) </p><ul><li>(级别1)Select : 读(读DB, Table, Record, Attribute, … )</li><li>(级别2)Modify : 更新<ul><li>Insert : 插入(插入新元组, … )</li><li>Update : 更新(更新元组中的某些值, …)</li><li>Delete : 删除(删除元组, …)</li></ul></li><li>(级别3)Create : 创建(创建表空间、模式、表、索引、视图等)<ul><li>Create : 创建</li><li>Alter : 更新</li><li>Drop : 删除</li></ul></li></ul></li><li><p>级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。</p></li><li><p>授权命令<code>GRANT</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &#123;<span class="keyword">all</span> <span class="keyword">PRIVILEGES</span> | privilege &#123;,privilege…&#125;&#125;</span><br><span class="line">    <span class="keyword">ON</span> [<span class="keyword">TABLE</span>] tablename | viewname</span><br><span class="line">    <span class="keyword">TO</span> &#123;<span class="keyword">public</span> | <span class="keyword">user</span>-<span class="keyword">id</span> &#123;, <span class="keyword">user</span>-<span class="keyword">id</span>…&#125;&#125;</span><br><span class="line">    [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure><ul><li>user-id ，某一个用户账户，由DBA创建的合法账户</li><li>public, 允许所有有效用户使用授予的权利</li><li>privilege是下面的权利<ul><li>SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES</li></ul></li><li>WITH GRANT OPTION选项是允许被授权者传播这些权利</li></ul></li><li><p>SQL-DCL的控制安全性-授权示例:</p><ul><li>假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)<ul><li>Grant All Priviledges ON Employee TO Emp2001;</li><li>Grant SELECT ON EmpV2 TO Emp5001;</li><li>Grant SELECT ON EmpV3 TO public;</li><li>Grant SELECT ON EmpV4 TO Emp0021;</li></ul></li><li>授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)</li><li>授权者授予的权利必须是授权者已经拥有的权利</li></ul></li><li><p>收回授权命令<code>REVOKE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &#123;<span class="keyword">all</span> <span class="keyword">privilEges</span> | priv &#123;, priv…&#125; &#125; </span><br><span class="line">    <span class="keyword">ON</span> tablename | viewname</span><br><span class="line">    <span class="keyword">FROM</span> &#123;<span class="keyword">public</span> | <span class="keyword">user</span> &#123;, <span class="keyword">user</span>…&#125; &#125;;</span><br></pre></td></tr></table></figure><ul><li>示例: <code>revoke select on employee from UserB;</code></li></ul></li></ol><h4 id="18-2-自主安全性的授权过程及其问题"><a href="#18-2-自主安全性的授权过程及其问题" class="headerlink" title="18.2 自主安全性的授权过程及其问题"></a>18.2 自主安全性的授权过程及其问题</h4><h5 id="18-2-1-授权过程"><a href="#18-2-1-授权过程" class="headerlink" title="18.2.1 授权过程:"></a>18.2.1 授权过程:</h5><ol><li>第一步：DBA创建DB, 并为每一个用户创建一个账户<ul><li>假定建立了五个用户：UserA, UserB, UserC, UserD, UserE</li></ul></li><li>第二步：DBA授予某用户账户级别的权利<ul><li>假定授予UserA</li></ul></li><li>第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利<ul><li>假定UserA创建了Employee, 则UserA就是Employee表的属主账户</li></ul></li><li>第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…<ul><li>假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。</li></ul></li></ol><ul><li>注意授权的传播范围<ul><li>传播范围包括两个方面：水平传播数量和垂直传播数量<ul><li>水平传播数量是授权者的再授权用户数目(树的广度)</li><li>垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)</li></ul></li><li>有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。</li><li>当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回</li><li>如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。</li></ul></li></ul><h5 id="18-2-2-强制安全性机制"><a href="#18-2-2-强制安全性机制" class="headerlink" title="18.2.2 强制安全性机制"></a>18.2.2 强制安全性机制</h5><ol><li>强制安全性机制<ul><li>强制安全性通过对数据对象进行安全性分级<ul><li>绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)</li></ul></li><li>同时对用户也进行上述的安全性分级</li><li>从而强制实现不同级别用户访问不同级别数据的一种机制</li></ul></li><li>强制安全性机制的实现<ul><li>DBMS引入强制安全性机制, 可以通过扩展关系模式来实现<ul><li>关系模式: R(A1: D1, A2: D2, …, An:Dn)</li><li>对属性和元组引入安全性分级特性或称分类特性<ul><li>R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性</li></ul></li></ul></li><li>这样, 关系中的每个元组, 都将扩展为带有安全分级的元组</li><li>强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL语言概述&quot;&gt;&lt;a href=&quot;#SQL语言概述&quot; class=&quot;headerlink&quot; title=&quot;SQL语言概述&quot;&gt;&lt;/a&gt;SQL语言概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;结构化查询语言&lt;/strong&gt;(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL语言是集DDL、DML和DCL于一体的数据库语言
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】数据库系统基础</title>
    <link href="http://chaooo.github.io/article/20190622.html"/>
    <id>http://chaooo.github.io/article/20190622.html</id>
    <published>2019-06-22T12:20:19.000Z</published>
    <updated>2019-10-20T05:34:26.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>数据库 是 电子化信息的集合<ul><li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li></ul></li><li>表(Table)：以按行按列形式组织及展现的数据<a id="more"></a><ul><li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li></ul></li><li>数据库系统的构成（概念层次）:<ol><li>数据库(DB):Database：相互之间有关联关系的数据的集合</li><li>数据库管理系统(DBMS):Database Management System</li><li>数据库应用(DBAP):Database Application</li><li>数据库管理员(DBA):Database Asministrator</li><li>计算机基本系统</li></ol></li></ol><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ol><li><a href="#id1">数据库管理系统(DBMS)</a></li><li><a href="#id2">数据库系统的标准结构</a></li><li><a href="#id3">三级模式两层映像</a></li><li><a href="#id4">数据模型</a></li><li><a href="#id5">关系模型</a></li><li><a href="#id6">关系模型中的完整性</a></li><li><a href="#id7">关系代数</a></li><li><a href="#id8">关系演算</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-数据库管理系统-DBMS"><a href="#1-数据库管理系统-DBMS" class="headerlink" title="1. 数据库管理系统(DBMS)"></a>1. 数据库管理系统(DBMS)</h3><h4 id="1-1-从用户角度看DBMS-数据库管理系统"><a href="#1-1-从用户角度看DBMS-数据库管理系统" class="headerlink" title="1.1 从用户角度看DBMS(数据库管理系统)"></a>1.1 从用户角度看DBMS(数据库管理系统)</h4><ol><li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等<ul><li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li><li>用户使用DDL描述其所要建立的表的格式</li><li>DBMS依照用户的定义，创建数据库及其中的表</li></ul></li><li>数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等<ul><li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li><li>用户使用DML描述其所要进行的增、删、改、查等操作</li><li>DBMS依照用户的操作描述，实际执行这些操作</li></ul></li><li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)<ul><li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li><li>用户使用DCL描述其对数据库所要实施的控制</li><li>DBMS依照用户描述，实际ijnx控制</li></ul></li><li>数据库维护：转储/恢复/重组/性能监测/分析…<ul><li>DBMS提供了一系列程序(实用程序/例行程序)给用户</li><li>在这些程序中提供了对数据库维护的各种功能</li><li>用户使用这些程序进行各种数据库维护操作</li><li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li></ul></li></ol><h4 id="1-2-数据库语言"><a href="#1-2-数据库语言" class="headerlink" title="1.2 数据库语言"></a>1.2 数据库语言</h4><ul><li>使用者使用数据库语言，利用DBMS操纵数据库</li><li>SQL语言：结构化的数据库语言</li><li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li></ul><h4 id="1-3-从系统实现角度看DBMS的功能"><a href="#1-3-从系统实现角度看DBMS的功能" class="headerlink" title="1.3 从系统实现角度看DBMS的功能"></a>1.3 从系统实现角度看DBMS的功能</h4><ol><li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li><li>DBMS为完成DB管理，在后台运行着一系列程序…<ul><li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li><li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li><li><strong>数据存取与索引</strong>：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等</li><li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li><li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li><li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li><li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li><li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li><li><strong>数据字典管理</strong>：管理用户已经定义的信息</li><li><strong>应用程序接口(API)</strong>：提供应用程序使用DBMS特定功能的二首段</li><li><strong>数据库数据装载、重组等实用程序</strong></li><li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li></ul></li></ol><blockquote><p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p></blockquote><p><span id="id2"><span></span></span></p><h3 id="2-数据库系统的标准结构"><a href="#2-数据库系统的标准结构" class="headerlink" title="2. 数据库系统的标准结构"></a>2. 数据库系统的标准结构</h3><p>DBMS管理数据的三个层次：</p><ol><li>External Level = User Level（外部级别 = 用户级别）<ul><li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li></ul></li><li>Conceptual Level = Logic level（概念级别 = 逻辑级别）<ul><li>从全局角度理解/管理的数据, 含相应的关联约束</li></ul></li><li>Internal Level = Physical level（内部级别 = 物理级别）<ul><li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-三级模式两层映像"><a href="#3-三级模式两层映像" class="headerlink" title="3. 三级模式两层映像"></a>3. 三级模式两层映像</h3><p>数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成</p><ul><li>应用–&gt; 外模式(多个) –&gt; 模式(一个) –&gt; 内模式(一个) –&gt; 数据库</li></ul><h4 id="3-1-数据-视图-与模式-数据的结构"><a href="#3-1-数据-视图-与模式-数据的结构" class="headerlink" title="3.1 数据(视图)与模式(数据的结构)"></a>3.1 数据(视图)与模式(数据的结构)</h4><ul><li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li><li>视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据</li></ul><h4 id="3-2-三级模式-三级视图"><a href="#3-2-三级模式-三级视图" class="headerlink" title="3.2 三级模式(三级视图)"></a>3.2 三级模式(三级视图)</h4><ol><li>External Schema —-(External) View<ul><li>外模式：某一用户能够看到与处理的数据的结构描述</li></ul></li><li>(Conceptual) Schema —- Conceptual View<ul><li>模式(概念模式)：从全局角度理解/管理的数据的结构描述, 含相应的关联约束</li><li>体现在数据之间的内在本质联系</li></ul></li><li>Internal Schema —- Internal  View<ul><li>内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li></ul></li></ol><h4 id="3-3-两层映像"><a href="#3-3-两层映像" class="headerlink" title="3.3 两层映像"></a>3.3 两层映像</h4><ol><li>E-C Mapping：External Schema-Conceptual Schema Mapping <ul><li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li><li>便于用户观察和使用</li></ul></li><li>C-I Mapping：Conceptual Schema-Internal Schema Mapping <ul><li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li><li>便于计算机进行存储和处理</li></ul></li></ol><h4 id="3-4-标准结构的两个独立性"><a href="#3-4-标准结构的两个独立性" class="headerlink" title="3.4 标准结构的两个独立性"></a>3.4 标准结构的两个独立性</h4><ol><li>逻辑数据独立性<ul><li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li></ul></li><li>物理数据独立性<ul><li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-数据模型"><a href="#4-数据模型" class="headerlink" title="4. 数据模型"></a>4. 数据模型</h3><ol><li>数据模型：模式 与 模式的结构<ul><li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li><li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li><li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li></ul></li><li>三大经典数据模型<ul><li>关系模型：<strong>表</strong>的形式组织数据</li><li>层次模型：<strong>树</strong>的形式组织数据</li><li>网状模型：<strong>图</strong>的形式组织数据</li></ul></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-关系模型"><a href="#5-关系模型" class="headerlink" title="5. 关系模型"></a>5. 关系模型</h3><ol><li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：<ul><li>描述DB各种数据的基本结构形式(Table/Relation)</li><li>描述Table与Table之间所可能发生的各种操作(关系运算)</li><li>描述这些操作所应遵循的约束条件(完整性约束)</li></ul></li><li>关系模型的三个要素：<ul><li>基本结构：Relation/Table</li><li>基本操作：Relation Operator<ul><li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li><li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li></ul></li><li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li></ul></li><li>表(Table)的基本构成要素<ul><li>列/字段/属性/数据项：列名，列值</li><li>行/元组/记录</li><li>标题/模式</li></ul></li></ol><h4 id="5-1-“表”的严格定义"><a href="#5-1-“表”的严格定义" class="headerlink" title="5.1 “表”的严格定义"></a>5.1 “表”的严格定义</h4><ul><li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li><li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li><li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li></ul><h4 id="5-2-关系模式与关系"><a href="#5-2-关系模式与关系" class="headerlink" title="5.2 关系模式与关系"></a>5.2 关系模式与关系</h4><ul><li>同一关系模式下，可有很多的关系</li><li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li><li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li></ul><h4 id="5-3-关系的特性"><a href="#5-3-关系的特性" class="headerlink" title="5.3 关系的特性"></a>5.3 关系的特性</h4><ul><li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li><li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li><li>列位置互换性：区分哪一列是靠列名</li><li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)</li><li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li><li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li><li>属性不可再分特性:又被称为关系第一范式</li></ul><h4 id="5-4-关系的一些重要概念"><a href="#5-4-关系的一些重要概念" class="headerlink" title="5.4 关系的一些重要概念"></a>5.4 关系的一些重要概念</h4><ol><li>候选码(Candidate Key)/候选键<ul><li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li></ul></li><li>主码(Primary Key)/主键<ul><li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li></ul></li><li>主属性与非主属性<ul><li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li><li>最简单的，候选码只包含一个属性；</li><li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li></ul></li><li>外码(Foreign Key)/外键<ul><li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li><li>两个关系通常是靠外码连接起来的。</li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-关系模型中的完整性"><a href="#6-关系模型中的完整性" class="headerlink" title="6. 关系模型中的完整性"></a>6. 关系模型中的完整性</h3><h4 id="6-1-实体完整性"><a href="#6-1-实体完整性" class="headerlink" title="6.1 实体完整性"></a>6.1 实体完整性</h4><ul><li>关系的主码中的属性值不能为空值；</li><li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li></ul><h4 id="6-2-参照完整性"><a href="#6-2-参照完整性" class="headerlink" title="6.2 参照完整性"></a>6.2 参照完整性</h4><ul><li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li><li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li></ul><h4 id="6-3-用户自定义完整性"><a href="#6-3-用户自定义完整性" class="headerlink" title="6.3 用户自定义完整性"></a>6.3 用户自定义完整性</h4><ul><li>用户针对具体的应用环境定义的完整性约束条件</li></ul><h4 id="6-4-DBMS对关系完整性的支持"><a href="#6-4-DBMS对关系完整性的支持" class="headerlink" title="6.4 DBMS对关系完整性的支持"></a>6.4 DBMS对关系完整性的支持</h4><ul><li>实体完整性和参照完整性由DBMS系统自动支持</li><li>DBMS系统通常提供了如下机制：<ol><li>它使用户可以自行定义有关的完整性约束条件</li><li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li></ol></li></ul><p><span id="id7"><span></span></span></p><h3 id="7-关系代数"><a href="#7-关系代数" class="headerlink" title="7. 关系代数"></a>7. 关系代数</h3><h4 id="7-1-关系代数的特点"><a href="#7-1-关系代数的特点" class="headerlink" title="7.1 关系代数的特点"></a>7.1 关系代数的特点</h4><ul><li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li><li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li><li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li><li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li><li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li></ul><h4 id="7-2-关系代数的约束"><a href="#7-2-关系代数的约束" class="headerlink" title="7.2 关系代数的约束"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p><ul><li>并相容性：<ol><li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li><li>定义：关系R与关系S存在相容性，当且仅当：<ul><li>(1) 关系R和关系S的属性数目必须相同；</li><li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li></ul></li></ol><ul><li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li><li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li></ul></li></ul><h4 id="7-3-关系代数的基本操作"><a href="#7-3-关系代数的基本操作" class="headerlink" title="7.3 关系代数的基本操作"></a>7.3 关系代数的基本操作</h4><ol><li>集合操作<ul><li>并（UNIO）：R∪S</li><li>交（INTERSECTION）：R∩S</li><li>差（DIFFERENCE）：R-S</li><li>笛卡儿积（Cartesian PRODUCT）：R×S</li></ul></li><li>纯关系操作<ul><li>选择（SELECT）：σF(R)</li><li>投影（PROJECT）：ΠA(R)</li><li>连接（JOIN）：R⋈S</li><li>除（DIVISION）：R÷S</li></ul></li></ol><h5 id="7-3-1-并-Union-操作"><a href="#7-3-1-并-Union-操作" class="headerlink" title="7.3.1 并(Union) 操作"></a>7.3.1 并(Union) 操作</h5><ul><li>定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：<strong><code>R∪S</code></strong>, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li><li>数学描述：<code>R∪S={t|t∈R∨t∈S}</code>，其中t是元组</li><li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li><li>汉语中的“或者…或者…”通常意义是并运算的要求。</li><li><code>R∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li></ul><h5 id="7-3-2-差-Difference-操作"><a href="#7-3-2-差-Difference-操作" class="headerlink" title="7.3.2 差(Difference) 操作"></a>7.3.2 差(Difference) 操作</h5><ul><li>定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：<strong><code>R-S</code></strong>, 它由出现在关系R中但不出现在关系S中的元组构成。</li><li>数学描述：<code>R－S={t|t∈R∧t∉S}</code>，其中t是元组</li><li>汉语中的“是…但不含…”通常意义是差运算的要求。</li><li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li></ul><h5 id="7-3-3-交（Intersection-Referential-integrity）-操作"><a href="#7-3-3-交（Intersection-Referential-integrity）-操作" class="headerlink" title="7.3.3  交（Intersection Referential integrity） 操作"></a>7.3.3  交（Intersection Referential integrity） 操作</h5><ul><li>定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。</li><li>数学描述：<code>R∩S={t|t∈R∧t∈S}</code>，其中t是元组</li></ul><h5 id="7-3-4-广义笛卡尔积-Extended-cartesian-product-操作"><a href="#7-3-4-广义笛卡尔积-Extended-cartesian-product-操作" class="headerlink" title="7.3.4 广义笛卡尔积(Extended cartesian product) 操作"></a>7.3.4 广义笛卡尔积(Extended cartesian product) 操作</h5><ul><li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：<strong><code>RxS</code></strong>；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。</li><li>数学描述：<code>RxS = {&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S}</code></li><li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li><li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li><li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).</li></ul><h5 id="7-3-5-选择-Select"><a href="#7-3-5-选择-Select" class="headerlink" title="7.3.5 选择(Select)"></a>7.3.5 选择(Select)</h5><ul><li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作<strong><code>σF(R)</code></strong>, 它从关系R中选择出满足给定条件condition的元组构成。</li><li>数学描述：<code>σF(R) = {t|t∈R ∧ F(t)=&#39;真&#39;}</code>,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。</li><li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；¬；∧；∨</code> }</li></ul><h5 id="7-3-6-投影-Project"><a href="#7-3-6-投影-Project" class="headerlink" title="7.3.6 投影(Project)"></a>7.3.6 投影(Project)</h5><ul><li>定义：给定一个关系R, 投影运算结果也是一个关系，记作<strong><code>A(R)</code></strong>, 它从关系R中选出属性包含在A中的列构成。</li><li>数学描述：<code>ΠA(R) = {t[A] | t∈R}</code>,其中A为R中的属性列</li><li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li></ul><h4 id="7-4-关系代数的扩展操作"><a href="#7-4-关系代数的扩展操作" class="headerlink" title="7.4 关系代数的扩展操作"></a>7.4 关系代数的扩展操作</h4><h5 id="7-4-1-交-Intersection"><a href="#7-4-1-交-Intersection" class="headerlink" title="7.4.1 交(Intersection)"></a>7.4.1 交(Intersection)</h5><ul><li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：<strong><code>R∩S</code></strong>, 它由同时出现在关系R和关系S中的元组构成。</li><li>数学描述：<code>R∩S = {t|t∈R ∧ t∈S}</code>，其中t是元组</li><li>R∩S 和 S∩R 运算的结果是同一个关系</li><li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li><li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li></ul><h5 id="7-4-2-θ-连接-θ-Join-theta-Join"><a href="#7-4-2-θ-连接-θ-Join-theta-Join" class="headerlink" title="7.4.2 θ-连接(θ-Join, theta-Join)"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul><li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li><li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 <strong><code>R⋈S[AθB]</code></strong>：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li><li>数学描述：<code>R⋈S[AθB] = σ t[A]θs[B] (R×S)</code>，σF(RxS)其中t是R中的元组，s是S中的元组</li><li>在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用</li><li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li></ul><h5 id="7-4-3-等值连接-Equi-Join"><a href="#7-4-3-等值连接-Equi-Join" class="headerlink" title="7.4.3 等值连接(Equi-Join)"></a>7.4.3 等值连接(Equi-Join)</h5><ul><li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作<strong><code>R⋈S[A=B]</code></strong>：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li><li>数学描述：<code>R⋈S[A=B] = σ t[A]=s[B] (R×S)</code></li><li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li><li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接/等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li></ul><h5 id="7-4-4-自然连接-Natural-Join"><a href="#7-4-4-自然连接-Natural-Join" class="headerlink" title="7.4.4 自然连接(Natural-Join)"></a>7.4.4 自然连接(Natural-Join)</h5><ul><li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li><li>数学描述：<code>R⋈S = σ t[B]=s[B] (R×S)</code></li><li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li></ul><h4 id="7-5-关系代数的基本书写思路"><a href="#7-5-关系代数的基本书写思路" class="headerlink" title="7.5 关系代数的基本书写思路"></a>7.5 关系代数的基本书写思路</h4><ol><li>选出将用到的关系/表</li><li>做”积”运算（可用连接运算替换）</li><li>做选择运算保留所需的行/元组</li><li>做投影运算保留所需的列/属性</li></ol><ul><li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li><li>如涉及多个表，则检查：<ul><li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li><li>如不能，能否使用等值或不等值连接(θ-连接)</li><li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li></ul></li><li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li></ul><h4 id="7-6-关系代数之复杂扩展操作"><a href="#7-6-关系代数之复杂扩展操作" class="headerlink" title="7.6 关系代数之复杂扩展操作"></a>7.6 关系代数之复杂扩展操作</h4><h5 id="7-6-1-除-Division"><a href="#7-6-1-除-Division" class="headerlink" title="7.6.1 除(Division)"></a>7.6.1 除(Division)</h5><ul><li>除法运算经常用于求解“查询… 全部的/所有的…”问题</li><li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li><li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li><li>数学描述：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R÷S = &#123;t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) &#125;</span><br><span class="line">    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>其中[R-S]为投影Π的下标(属性)</p></blockquote><h5 id="7-6-2-外连接-Outer-Join"><a href="#7-6-2-外连接-Outer-Join" class="headerlink" title="7.6.2 外连接(Outer-Join)"></a>7.6.2 外连接(Outer-Join)</h5><ul><li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li><li>外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li><li>外连接的形式：左外连接、右外连接、全外连接<ul><li>左外连接 = 自然连接(或连接) + 左侧表中失配的元组</li><li>右外连接 = 自然连接(或连接) + 右侧表中失配的元组</li><li>全外连接 = 自然连接(或连接) + 两侧表中失配的元组</li><li>左外连接(Left Outer Join)记为：⋊</li><li>右外连接(Right Outer Join)记为：⋉</li><li>全外连接(Full Outer Join)记为：⋊⋉</li></ul></li></ul><p><span id="id8"><span></span></span></p><h3 id="8-关系演算"><a href="#8-关系演算" class="headerlink" title="8. 关系演算"></a>8. 关系演算</h3><p>关系演算是<strong>描述关系运算</strong>的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</p><ul><li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ol><li>关系元组演算是以<strong>元组变量</strong>作为谓词变量的基本对象</li><li>关系域演算是以<strong>域变量</strong>作为谓词变量的基本对象</li></ol></li></ul><h4 id="8-1-关系元组演算"><a href="#8-1-关系元组演算" class="headerlink" title="8.1 关系元组演算"></a>8.1 关系元组演算</h4><ol><li>关系元组演算公式：{ t | P(t) }<ul><li>表示：所有使谓词 P 为真的元组 t 的集合</li><li>t 是元组变量</li><li>t ∈ r 表示元组 t 在关系 r 中</li><li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li><li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li></ul></li><li>关系元组演算公式的基本形式：{ t | P(t) }</li><li>P(t)可以是如下三种形式之一的原子公式：<ul><li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li><li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=</li><li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li></ul></li><li>P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造<ul><li>如果F是一个公式，则 ¬F 也是公式</li><li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li></ul></li><li>P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例</li><li>构造P(t)还有两个运算符：∃(存在)、∀(任意)<ul><li>如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式</li><li>如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式</li><li>运算符∃和∀，又称为量词，前者称“<strong>存在量词</strong>”，后者称“<strong>全称量词</strong>”</li><li>而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“<strong>约束变量</strong>”，否则被称为“<strong>自由变量</strong>”。</li></ul></li><li>元组演算的等价性变换<ul><li>符号<code>&lt;=&gt;</code>表示表示等价于,如：<code>¬(A&gt;B) &lt;=&gt; A&lt;=B  &lt;=&gt; A&lt;B∨A=B</code></li></ul></li></ol><h4 id="8-2-关系域演算"><a href="#8-2-关系域演算" class="headerlink" title="8.2 关系域演算"></a>8.2 关系域演算</h4><ol><li>关系域演算公式的基本形式：<code>{&lt;x1,x2, …,xn&gt; | P(x1,x2, …,xn)}</code>,其中 xi 代表域变量或常量, P为以xi为变量的公式。</li><li>元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；</li><li>域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。</li><li>公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。</li><li>元组演算和域演算可以等价互换。</li></ol><h5 id="8-2-1-基于关系域演算的QBE语言"><a href="#8-2-1-基于关系域演算的QBE语言" class="headerlink" title="8.2.1 基于关系域演算的QBE语言"></a>8.2.1 基于关系域演算的QBE语言</h5><p>QBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。</p><ol><li>特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可</li><li>QBE操作框架由四个部分构成<ul><li>关系名区：用于书写欲待查询的关系名</li><li>属性名区：用于显示对应关系名区关系的所有属性名</li><li>操作命令区：用于书写查询操作的命令</li><li>查询条件区：用于书写查询条件</li></ul></li><li>QBE的操作命令<ul><li>Print 或 P.   —- 显示输出操作</li><li>Delete或D.   —- 删除操作</li><li>Insert或I.     —- 插入操作</li><li>Update或U. —- 更新操作</li></ul></li><li>构造查询的几个要素 <ul><li>示例元素: 即域变量， 一定要加下划线 </li><li>示例元素是这个域中可能的一个值， 它不必是查询结果中的元素</li><li>打印操作符P.: 指定查询结果所含属性列 </li><li>查询条件: 不用加下划线</li><li>可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略</li><li>排序要求 <ul><li>升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高</li></ul></li></ul></li></ol><h4 id="8-3-安全性"><a href="#8-3-安全性" class="headerlink" title="8.3 安全性"></a>8.3 安全性</h4><p>关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的</p><ol><li>关系代数是一种集合运算，是安全的<ul><li>集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。</li></ul></li><li>关系演算不一定是安全的<ul><li>如：{t|¬(R(t))}, {t R(t)∨t[2]&gt;3}可能表示无限关系</li></ul></li><li>需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。</li></ol><h5 id="8-3-1-安全约束有限集合DOM"><a href="#8-3-1-安全约束有限集合DOM" class="headerlink" title="8.3.1 安全约束有限集合DOM"></a>8.3.1 安全约束有限集合DOM</h5><ol><li>DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。</li><li>DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。</li><li>安全元组演算表达式，满足三个条件：<ul><li>只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。<ul><li>{ t|ψ(t) }中t的取值只能是DOM中的值，有限的。</li></ul></li><li>对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。<ul><li>{ t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。</li></ul></li><li>对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。<ul><li>{ t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。</li></ul></li></ul></li></ol><h4 id="8-4-关于三种关系运算的一些观点"><a href="#8-4-关于三种关系运算的一些观点" class="headerlink" title="8.4 关于三种关系运算的一些观点"></a>8.4 关于三种关系运算的一些观点</h4><ol><li>关系运算有三种：关系代数、关系元组演算和关系域演算</li><li>三种关系运算都是抽象的数学运算，体现了三种不同的思维<ul><li>关系代数—以集合为对象的操作思维，由集合到集合的变换</li><li>元组演算—以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环</li><li>域演算—以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件</li></ul></li><li>三种运算之间是等价的<ul><li>关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等<br>价的。即一种形式的表达式可以被等价地转换为另一种形式</li></ul></li><li>三种关系运算都可说是非过程性的<ul><li>相比之下：域演算的非过程性最好，元组演算次之，关系代数最差</li></ul></li><li>三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础<ul><li>一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的</li><li>目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等</li></ul></li><li>数据库语言可以基于这三种抽象运算来设计<ul><li>用“键盘符号”来替换抽象的数学符号</li><li>用易于理解的符号组合来表达抽象的数学符号</li><li>例如：ISBL语言—基于关系代数的数据库语言</li><li>再例如：Ingres系统的QUEL语言</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据库 是 电子化信息的集合&lt;ul&gt;
&lt;li&gt;将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;表(Table)：以按行按列形式组织及展现的数据
    
    </summary>
    
      <category term="数据库" scheme="http://chaooo.github.io/categories/db/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/db/"/>
    
  </entry>
  
  <entry>
    <title>【杂谈】对开源的理解</title>
    <link href="http://chaooo.github.io/article/20190411.html"/>
    <id>http://chaooo.github.io/article/20190411.html</id>
    <published>2019-04-11T12:13:15.000Z</published>
    <updated>2019-10-20T05:33:42.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是开源"><a href="#什么是开源" class="headerlink" title="什么是开源"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p><p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p><a id="more"></a><p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p><h3 id="开源是否等于免费"><a href="#开源是否等于免费" class="headerlink" title="开源是否等于免费"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p><p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p><p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p><p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p><p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p><h3 id="为什么要选择开源软件"><a href="#为什么要选择开源软件" class="headerlink" title="为什么要选择开源软件"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p><p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p><p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p><p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p><p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p><blockquote><p>参考连接：</p><ul><li><a href="https://blog.csdn.net/happmaoo/article/details/83201544" target="_blank" rel="noopener">https://blog.csdn.net/happmaoo/article/details/83201544</a></li><li><a href="https://www.oschina.net/news/58921/what-is-open-source" target="_blank" rel="noopener">https://www.oschina.net/news/58921/what-is-open-source</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是开源&quot;&gt;&lt;a href=&quot;#什么是开源&quot; class=&quot;headerlink&quot; title=&quot;什么是开源&quot;&gt;&lt;/a&gt;什么是开源&lt;/h3&gt;&lt;p&gt;所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。&lt;/p&gt;
&lt;p&gt;在IT领域来说的话，字面意思就是&lt;strong&gt;开放源代码&lt;/strong&gt;，开源软件的源代码任何人都可以审查、修改和增强。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://chaooo.github.io/categories/other/"/>
    
    
      <category term="杂谈" scheme="http://chaooo.github.io/tags/other/"/>
    
      <category term="开源" scheme="http://chaooo.github.io/tags/open-source/"/>
    
  </entry>
  
  <entry>
    <title>【环境配置】Win10下配置Nginx+PHP-7+MySQL-5.6</title>
    <link href="http://chaooo.github.io/article/20181022.html"/>
    <id>http://chaooo.github.io/article/20181022.html</id>
    <published>2018-10-22T03:39:12.000Z</published>
    <updated>2019-10-20T05:32:13.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件下载"><a href="#1-软件下载" class="headerlink" title="1. 软件下载"></a>1. 软件下载</h3><ul><li>Windows操作系统。</li><li>Nginx，下载地址：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>。</li><li>PHP，下载地址：<a href="http://php.net/downloads.php" target="_blank" rel="noopener">http://php.net/downloads.php</a>（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。</li><li>MySQL，下载地址：<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">https://www.mysql.com/downloads/</a>。（选择社区版<code>Community</code>-&gt;<code>MySQL Community Server</code>-&gt;<code>MySQL Community Server 5.6</code>，根据Windows系统选择对应zip包）。<a id="more"></a><h3 id="2-软件安装"><a href="#2-软件安装" class="headerlink" title="2. 软件安装"></a>2. 软件安装</h3>在C盘新建安装目录<code>C:\PHP</code>。<h4 id="2-1-Nginx安装"><a href="#2-1-Nginx安装" class="headerlink" title="2.1 Nginx安装"></a>2.1 Nginx安装</h4>Nginx本身就是绿色软件，下载zip安装包解压到<code>C:\PHP</code>，打开目录<code>C:\PHP\nginx-1.15.8</code>双击nginx.exe就可以运行，然后在浏览器打开<a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>，出现欢迎界面表示NGINX正常工作。<br>确认NGINX正常工作后在任务管理器中结束nginx.exe任务。<h4 id="2-2-PHP安装"><a href="#2-2-PHP安装" class="headerlink" title="2.2 PHP安装"></a>2.2 PHP安装</h4>把PHP的zip安装包解压到<code>C:\PHP</code>，解压后PHP安装目录为：<code>C:\PHP\php-7.3.2</code>。<br>cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。<br>将<code>C:\PHP\php-7.3.2</code>加入系统环境变量。<h4 id="2-3-准备网站根目录"><a href="#2-3-准备网站根目录" class="headerlink" title="2.3 准备网站根目录"></a>2.3 准备网站根目录</h4>准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把<code>C:\PHP\web</code>作为我的网站根目录。<br>在根目录<code>C:\PHP\web</code>下新建一个info.php文件，输入如下内容：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-让nginx识别PHP"><a href="#2-4-让nginx识别PHP" class="headerlink" title="2.4 让nginx识别PHP"></a>2.4 让nginx识别PHP</h4><p>  配置PHP (<code>C:\PHP\php-7.3.2</code>)<br>  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:<br>  在PHP根目录下修改配置文件<code>C:\PHP\php-7.3.2\php.ini-development</code>并另存为<code>php.ini</code>,在其中修改或添加配置：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgi.fix_pathinfo=1</span><br></pre></td></tr></table></figure></p><p>  配置nginx conf(<code>C:\PHP\nginx-1.15.8\conf</code>)<br>  在Nginx根目录下找到conf目录，编辑器打开<code>C:\PHP\nginx-1.15.8\confnginx.conf</code>:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">error_log  logs/error.log; #打开error_log</span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        # ...</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root     C:\PHP\web; #配置根目录</span><br><span class="line">            index   index.html index.htm index.php;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # ...</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        # 打开下面几行注释</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            root             C:\PHP\web; #配置根目录</span><br><span class="line">            fastcgi_pass     127.0.0.1:9000;</span><br><span class="line">            fastcgi_index    index.php;</span><br><span class="line">            #重要: 把下面 /scripts 修改成 $document_root</span><br><span class="line">            fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; </span><br><span class="line">            include          fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-5-运行与测试"><a href="#2-5-运行与测试" class="headerlink" title="2.5 运行与测试"></a>2.5 运行与测试</h4><p>nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么<code>nginx.conf</code>中有这样一句<code>fastcgi_pass 127.0.0.1:9000;</code>。</p><ol><li><p>在任务管理器中结束nginx.exe任务，然后到<code>C:\PHP\nginx-1.15.8</code>目录双击nginx.exe开启服务。</p></li><li><p>在命令行中，cd到php的home目录<code>C:\PHP\php-7.3.2</code>，然后执行如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php-cgi.exe -b <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9000</span> -c php.ini</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器，输入 <a href="http://127.0.0.1/info.php" target="_blank" rel="noopener">http://127.0.0.1/info.php</a>，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</p></li></ol><h4 id="2-6-MySQL安装"><a href="#2-6-MySQL安装" class="headerlink" title="2.6 MySQL安装"></a>2.6 MySQL安装</h4><p>  把MySQL的zip安装包解压到<code>C:\PHP</code>，解压后PHP安装目录为：<code>C:\PHP\mysql-5.6.43-winx64</code>。<br>  将<code>C:\PHP\mysql-5.6.43-winx64\bin</code>加入系统环境变量。<br>  修改配置文件<code>C:\PHP\mysql-5.6.43-winx64\my-default.ini</code>并另存为<code>my.ini</code>,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basedir=C:\PHP\mysql-5.6.43-winx64       #mysql所在目录</span><br><span class="line">datadir=C:\PHP\mysql-5.6.43-winx64\data  #mysql所在目录\data</span><br></pre></td></tr></table></figure></p><p>  以管理员身份运行cmd,到安装目录的bin下，输入<code>mysqld -install</code>：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\PHP\mysql-5.6.43-winx64\bin&gt; mysqld -install</span><br><span class="line">Service successfully installed.</span><br></pre></td></tr></table></figure></p><p>  输入命令:<code>mysql --version</code>,正常会显示版本信息。<br>  输入命令:<code>net start mysql</code>启动服务(停止命令：net stop mysql):<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\PHP\mysql-5.6.43-winx64\bin&gt;net start mysql</span><br><span class="line">MySQL 服务正在启动 ..</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure></p><p>  服务启动成功之后，输入命令：<code>mysql -u root -p</code>（第一次登录没有密码，直接按回车过）:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\PHP\mysql-5.6.43-winx64\bin&gt;mysql -u root -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 1</span><br><span class="line">Server version: 5.6.43 MySQL Community Server (GPL)</span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></p><p>  如出现<code>mysql&gt;</code>,即登录成功。<br>  输入命令<code>exit</code>,退出登录。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; exit</span><br><span class="line">Bye</span><br><span class="line">C:\PHP\mysql-5.6.43-winx64\bin&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-制作自动启动脚本"><a href="#3-制作自动启动脚本" class="headerlink" title="3. 制作自动启动脚本"></a>3. 制作自动启动脚本</h3><p>控制台就一直开着，很不方便。这个时候可以使用 <a href="https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip" target="_blank" rel="noopener">RunHiddenConsole.zip</a> 来得管理服务的启动与关闭。</p><h4 id="3-1-启动脚本"><a href="#3-1-启动脚本" class="headerlink" title="3.1 启动脚本"></a>3.1 启动脚本</h4><p>在目录<code>C:\PHP</code>下新建一个<code>start.bat</code>作为启动脚本文件：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">:启动脚本</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> php_home=./php-<span class="number">7</span>.<span class="number">3</span>.<span class="number">2</span></span><br><span class="line"><span class="built_in">set</span> nginx_home=./nginx-<span class="number">1</span>.<span class="number">15</span>.<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">REM Windows 下无效</span></span><br><span class="line"><span class="comment">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class="line"><span class="built_in">set</span> PHP_FCGI_MAX_REQUESTS=<span class="number">1000</span></span><br><span class="line"><span class="built_in">echo</span> Starting PHP FastCGI...</span><br><span class="line">RunHiddenConsole <span class="variable">%php_home%</span>/php-cgi.exe -b <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9000</span> -c <span class="variable">%php_home%</span>/php.ini</span><br><span class="line"><span class="built_in">echo</span> FastCGI 启动成功</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Starting nginx...</span><br><span class="line">RunHiddenConsole <span class="variable">%nginx_home%</span>/nginx.exe -p <span class="variable">%nginx_home%</span></span><br><span class="line"><span class="built_in">echo</span> nginx 启动成功</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">:<span class="built_in">echo</span> <span class="number">15</span>秒后自动退出</span><br><span class="line">:<span class="built_in">ping</span> <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>  -n <span class="number">15</span> &gt; null</span><br><span class="line">:请按任意键继续. . .</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><h4 id="3-2-停止脚本"><a href="#3-2-停止脚本" class="headerlink" title="3.2 停止脚本"></a>3.2 停止脚本</h4><p>在目录<code>C:\PHP</code>下新建一个<code>stop.bat</code>作为停止脚本文件：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">:停止脚本</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> Stopping nginx...  </span><br><span class="line"><span class="built_in">taskkill</span> /F /IM nginx.exe &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span> nginx 已停止</span><br><span class="line">:换行</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Stopping PHP FastCGI...</span><br><span class="line"><span class="built_in">taskkill</span> /F /IM php-cgi.exe &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span> FastCGI 已停止</span><br><span class="line">:请按任意键继续. . .</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><h4 id="3-3-重启脚本"><a href="#3-3-重启脚本" class="headerlink" title="3.3 重启脚本"></a>3.3 重启脚本</h4><p>在目录<code>C:\PHP</code>下新建一个<code>restart.bat</code>作为重启脚本文件：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">:停止脚本</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> Stopping nginx...  </span><br><span class="line"><span class="built_in">taskkill</span> /F /IM nginx.exe &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span> nginx 已停止</span><br><span class="line">:换行</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Stopping PHP FastCGI...</span><br><span class="line"><span class="built_in">taskkill</span> /F /IM php-cgi.exe &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span> FastCGI 已停止</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line">:启动脚本</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> php_home=./php-<span class="number">7</span>.<span class="number">3</span>.<span class="number">2</span></span><br><span class="line"><span class="built_in">set</span> nginx_home=./nginx-<span class="number">1</span>.<span class="number">15</span>.<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">REM Windows 下无效</span></span><br><span class="line"><span class="comment">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class="line"><span class="built_in">set</span> PHP_FCGI_MAX_REQUESTS=<span class="number">1000</span></span><br><span class="line"><span class="built_in">echo</span> Starting PHP FastCGI...</span><br><span class="line">RunHiddenConsole <span class="variable">%php_home%</span>/php-cgi.exe -b <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9000</span> -c <span class="variable">%php_home%</span>/php.ini</span><br><span class="line"><span class="built_in">echo</span> FastCGI 启动成功</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Starting nginx...</span><br><span class="line">RunHiddenConsole <span class="variable">%nginx_home%</span>/nginx.exe -p <span class="variable">%nginx_home%</span></span><br><span class="line"><span class="built_in">echo</span> nginx 启动成功</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">:<span class="built_in">echo</span> <span class="number">15</span>秒后自动退出</span><br><span class="line">:<span class="built_in">ping</span> <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>  -n <span class="number">15</span> &gt; null</span><br><span class="line">:请按任意键继续. . .</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><h3 id="4-最后"><a href="#4-最后" class="headerlink" title="4.最后"></a>4.最后</h3><p>我的根目录结构</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">PHP</span>&gt;<span class="title">dir</span></span></span><br><span class="line"><span class="function"> 驱动器 <span class="title">C</span> 中的卷是 系统</span></span><br><span class="line"><span class="function"> 卷的序列号是 09<span class="title">C1</span>-<span class="title">B27D</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="title">C</span>:\<span class="title">PHP</span> 的目录</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2019/02/22  15:46    &lt;<span class="title">DIR</span>&gt;          .</span></span><br><span class="line"><span class="function">2019/02/22  15:46    &lt;<span class="title">DIR</span>&gt;          ..</span></span><br><span class="line"><span class="function">2019/02/22  11:23    &lt;<span class="title">DIR</span>&gt;          <span class="title">mysql</span>-5.6.43-<span class="title">winx64</span></span></span><br><span class="line"><span class="function">2018/12/25  17:54    &lt;<span class="title">DIR</span>&gt;          <span class="title">nginx</span>-1.15.8</span></span><br><span class="line"><span class="function">2019/02/21  15:59    &lt;<span class="title">DIR</span>&gt;          <span class="title">php</span>-7.3.2</span></span><br><span class="line"><span class="function">2019/02/22  15:41               758 <span class="title">restart.bat</span></span></span><br><span class="line"><span class="function">2010/10/26  11:43             1,536 <span class="title">RunHiddenConsole.exe</span></span></span><br><span class="line"><span class="function">2019/02/22  15:41               549 <span class="title">start.bat</span></span></span><br><span class="line"><span class="function">2019/02/22  15:41               227 <span class="title">stop.bat</span></span></span><br><span class="line"><span class="function">2019/02/21  16:56    &lt;<span class="title">DIR</span>&gt;          <span class="title">web</span></span></span><br><span class="line"><span class="function">               4 个文件          3,070 字节</span></span><br><span class="line"><span class="function">               6 个目录 100,959,772,672 可用字节</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-软件下载&quot;&gt;&lt;a href=&quot;#1-软件下载&quot; class=&quot;headerlink&quot; title=&quot;1. 软件下载&quot;&gt;&lt;/a&gt;1. 软件下载&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Windows操作系统。&lt;/li&gt;
&lt;li&gt;Nginx，下载地址：&lt;a href=&quot;http://nginx.org/en/download.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;PHP，下载地址：&lt;a href=&quot;http://php.net/downloads.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://php.net/downloads.php&lt;/a&gt;（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。&lt;/li&gt;
&lt;li&gt;MySQL，下载地址：&lt;a href=&quot;https://www.mysql.com/downloads/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mysql.com/downloads/&lt;/a&gt;。（选择社区版&lt;code&gt;Community&lt;/code&gt;-&amp;gt;&lt;code&gt;MySQL Community Server&lt;/code&gt;-&amp;gt;&lt;code&gt;MySQL Community Server 5.6&lt;/code&gt;，根据Windows系统选择对应zip包）。
    
    </summary>
    
      <category term="环境配置" scheme="http://chaooo.github.io/categories/env/"/>
    
    
      <category term="环境配置" scheme="http://chaooo.github.io/tags/env/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot】MVC应用</title>
    <link href="http://chaooo.github.io/article/20180620.html"/>
    <id>http://chaooo.github.io/article/20180620.html</id>
    <published>2018-06-20T09:31:30.000Z</published>
    <updated>2019-10-20T05:24:16.096Z</updated>
    
    <content type="html"><![CDATA[<p>对Spring Web MVC封装，简化MVC结构web应用开发。</p><a id="more"></a><h3 id="1-SpringBoot-MVC开发Restful服务（前后分离）"><a href="#1-SpringBoot-MVC开发Restful服务（前后分离）" class="headerlink" title="1. SpringBoot MVC开发Restful服务（前后分离）*"></a>1. SpringBoot MVC开发Restful服务（前后分离）*</h3><p>按rest规则发送HTTP请求–&gt;Spring MVC–&gt;返回JSON结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web（springmvc、rest、jackson、tomcat）</li><li>在application.properties修改tomcat端口</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller、Service、Dao组件</li></ol><h3 id="2-SpringBoot-MVC开发JSP应用（PC浏览器）"><a href="#2-SpringBoot-MVC开发JSP应用（PC浏览器）" class="headerlink" title="2. SpringBoot MVC开发JSP应用（PC浏览器）"></a>2. SpringBoot MVC开发JSP应用（PC浏览器）</h3><p>HTTP请求–&gt;Spring MVC–&gt;JSP–&gt;HTML响应输出结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web、jasper解析器、jstl</li><li>在application.properties修改tomcat端口、viewResolver</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller组件，返回ModelAndView</li><li>在src/main/webapp下定义JSP组件</li></ol><h3 id="3-SpringBoot-MVC开发Thymeleaf应用（PC浏览器）"><a href="#3-SpringBoot-MVC开发Thymeleaf应用（PC浏览器）" class="headerlink" title="3. SpringBoot MVC开发Thymeleaf应用（PC浏览器）*"></a>3. SpringBoot MVC开发Thymeleaf应用（PC浏览器）*</h3><p>HTTP请求–&gt;Spring MVC–&gt;Thymeleaf模板–&gt;HTML响应输出结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web、spring-boot-starter-thymeleaf</li><li>在application.properties修改tomcat端口</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller组件，返回ModelAndView</li><li>在src/main/resources/templates下定义模板文件<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"https://www.thymeleaf.org/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">th:text</span>=<span class="string">"$&#123;data&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li>th:text表达式作用：将模型中的数据以只读文本显示到元素中</li><li>th:text表达式作用：将模型中的数据以只读文本显示到元素中。</li><li>th:if 表达式作用：if判断逻辑</li><li>th:each 表达式作用：循环逻辑</li><li>th:href 表达式作用：动态生成href链接</li></ul></blockquote><p>Thymeleaf模板和JSP区别</p><ol><li>运行机制不同<ul><li>JSP–&gt;Servlet–&gt;HTML</li><li>模板+数据–&gt;HTML输出</li></ul></li><li>模板简单易用;JSP相对复杂些<ul><li>JSP:9大内置对象、EL、JSTL、嵌入Java代码、框架标签</li><li>模板：模板表达式</li></ul></li><li>模板效率高,比JSP性能好<ul><li>模板：缓存</li></ul></li></ol><h3 id="4-SpringBoot-MVC静态资源处理"><a href="#4-SpringBoot-MVC静态资源处理" class="headerlink" title="4. SpringBoot MVC静态资源处理"></a>4. SpringBoot MVC静态资源处理</h3><p>静态资源包含图片、js、css等，动态资源servlet、jsp等。</p><p>SpringBoot中src/main/resources目录下有几个约定的静态资源存放位置</p><ul><li>META-INF/resources（优先级最高）</li><li>resources</li><li>static</li><li>public（优先级最低）</li></ul><p>自定义静态资源访问路径，编写一个配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStaticConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/**"</span>)</span><br><span class="line">            .addResourceLocations(</span><br><span class="line">                <span class="string">"classpath:/images/"</span>,</span><br><span class="line">                <span class="string">"classpath:/resources/"</span>,</span><br><span class="line">                <span class="string">"classpath:/static/"</span>,</span><br><span class="line">                <span class="string">"classpath:/public/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-SpringBoot-MVC异常处理"><a href="#5-SpringBoot-MVC异常处理" class="headerlink" title="5. SpringBoot MVC异常处理"></a>5. SpringBoot MVC异常处理</h3><ol><li><p>异常处理机制</p><ul><li>SpringBoot底层提供了异常处理机制。SpringBoot提供了一个ErrorMvcAutoConfiguration自动配置组件，创建了一个BasicErrorController对象，提供两个/error请求处理，一个返回html，另一个返回json。当MVC底层遇到异常会用转发方式发出/error请求。</li></ul></li><li><p>可以自定义ErrorController替代底层BasicErrorController，将错误提示转发到自定义提示界面(全局)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//@RequestMapping("/error")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorController</span> <span class="keyword">implements</span> <span class="title">ErrorController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/error"</span>,produces= MediaType.TEXT_HTML_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.setViewName(<span class="string">"myerror"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/error"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"程序发生了异常"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ExceptionHandler异常处理（局部）</p><ul><li>ErrorController管理全局异常，@ExceptionHandler管理所在Controller组件的异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">"msg"</span>, <span class="string">"发生异常"</span>);</span><br><span class="line">    map.put(<span class="string">"type"</span>, ex.getClass());</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>可以将上述方法封装成一个BasicController，通过@ControllerAdvice作用到所有Controller组件上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//等价于所有Controller都继承它</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">error</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"msg"</span>, <span class="string">"发生异常"</span>);</span><br><span class="line">        map.put(<span class="string">"type"</span>, ex.getClass());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-SpringBoot-AOP"><a href="#6-SpringBoot-AOP" class="headerlink" title="6. SpringBoot AOP"></a>6. SpringBoot AOP</h3><ol><li><p>引入spring-boot-starter-aop</p></li><li><p>定义一个切面组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//将Bean组件纳入Spring容器</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//将Bean组件定义为Aspect切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)<span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----开始处理----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)<span class="comment">//最终通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----处理完毕----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"within(cn.xdl.controller.*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        Object obj = pjp.proceed();<span class="comment">//调用目标组件方法</span></span><br><span class="line">        watch.stop();</span><br><span class="line">        System.out.println(<span class="string">"处理时间:"</span>+watch.getTotalTimeMillis()+<span class="string">" 毫秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置切面组件</p><ul><li>@Aspect、@Before、@After、@Around、@AfterReturning、@AfterThrowing等</li></ul></li></ol><h3 id="7-SpringBoot-MVC拦截器"><a href="#7-SpringBoot-MVC拦截器" class="headerlink" title="7. SpringBoot MVC拦截器"></a>7. SpringBoot MVC拦截器</h3><ol><li><p>编写一个拦截器组件,实现HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了MyInterceptor拦截器"</span>);</span><br><span class="line">        String user = (String)request.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.sendRedirect(<span class="string">"/tologin"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//阻止后续流程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续执行后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyInterceptor my;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(my).addPathPatterns(<span class="string">"/direction/list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-SpringBoot整合Servlet-Filter"><a href="#8-SpringBoot整合Servlet-Filter" class="headerlink" title="8. SpringBoot整合Servlet/Filter"></a>8. SpringBoot整合Servlet/Filter</h3><h4 id="8-1-整合Servlet"><a href="#8-1-整合Servlet" class="headerlink" title="8.1 整合Servlet"></a>8.1 整合Servlet</h4><p>首先导入spring-boot-starter-web</p><h5 id="8-1-1-整合Servlet方式一："><a href="#8-1-1-整合Servlet方式一：" class="headerlink" title="8.1.1 整合Servlet方式一："></a>8.1.1 整合Servlet方式一：</h5><ol><li><p>编写一个Servlet组件，继承HttpServlet</p></li><li><p>在Servlet类定义前使用@WebServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"helloservlet"</span>,urlPatterns= &#123;<span class="string">"/hello.do"</span>&#125;,loadOnStartup=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.getWriter().println(<span class="string">"Hello SpringBoot Servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类前需要使用@ServletComponentScan扫描@WebServlet配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//扫描@WebServlet、@WebFilter、@WebListener组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="8-1-2-整合Servlet方式二："><a href="#8-1-2-整合Servlet方式二：" class="headerlink" title="8.1.2 整合Servlet方式二："></a>8.1.2 整合Servlet方式二：</h5><ol><li><p>编写一个Servlet组件，继承HttpServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.getWriter().println(<span class="string">"Hello Spring Some Servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ServletRegistrationBean+@Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="title">someservlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean&lt;Servlet&gt; bean = <span class="keyword">new</span> ServletRegistrationBean&lt;Servlet&gt;();</span><br><span class="line">        bean.setServlet(<span class="keyword">new</span> SomeServlet());</span><br><span class="line">        bean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        urls.add(<span class="string">"/some.do"</span>);</span><br><span class="line">        bean.setUrlMappings(urls);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-2-整合Filter"><a href="#8-2-整合Filter" class="headerlink" title="8.2 整合Filter"></a>8.2 整合Filter</h4><p>在SpringBoot整合Servlet的基础上整合Filter</p><h5 id="8-2-1-整合Filter方式一："><a href="#8-2-1-整合Filter方式一：" class="headerlink" title="8.2.1 整合Filter方式一："></a>8.2.1 整合Filter方式一：</h5><ol><li><p>编写一个Filter组件，继承Filter</p></li><li><p>在Filter类定义前使用@WebFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns=<span class="string">"/hello.do"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletRequest request, ServletResponse response, FilterChain chain</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----hello filter------servlet执行之前"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">"-----hello filter------servlet执行之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类前需要使用@ServletComponentScan扫描@WebServlet配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//扫描@WebServlet、@WebFilter、@WebListener组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="8-2-2-整合Filter方式二："><a href="#8-2-2-整合Filter方式二：" class="headerlink" title="8.2.2 整合Filter方式二："></a>8.2.2 整合Filter方式二：</h5><ol><li><p>编写一个Filter组件，继承Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletRequest request, ServletResponse response, FilterChain chain</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----som filter------servlet执行之前"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">"-----som filter------servlet执行之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用FilterRegistrationBean+@Bean 注册过滤器并设置拦截的请求地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="title">somefilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; bean = <span class="keyword">new</span> FilterRegistrationBean&lt;Filter&gt;();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> SomeFilter());</span><br><span class="line">        <span class="comment">// 配置要拦截的请求</span></span><br><span class="line">        bean.addUrlPatterns(<span class="string">"/some.do"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="9-SpringBoot-任务调度"><a href="#9-SpringBoot-任务调度" class="headerlink" title="9. SpringBoot 任务调度"></a>9. SpringBoot 任务调度</h3><h4 id="9-1-服务器启动后自动调用"><a href="#9-1-服务器启动后自动调用" class="headerlink" title="9.1 服务器启动后自动调用"></a>9.1 服务器启动后自动调用</h4><p>tomcat服务器启动后自动调用任务，可以使用ApplicationRunner或CommandLineRunner接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask1</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务器启动后自动执行SomeTask1任务---"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask2</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务器启动后自动执行SomeTask2任务-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多个Task任务，可以通过@Order指定先后顺序，多个任务是线程同步调用。</p></blockquote><h4 id="9-2-程序运行后定时调用任务"><a href="#9-2-程序运行后定时调用任务" class="headerlink" title="9.2 程序运行后定时调用任务"></a>9.2 程序运行后定时调用任务</h4><p>Spring提供了一个Spring Schedule模块，封装了任务调用，之前都是采用Quartz组件调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span><span class="comment">//开启Schedule模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeTask3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在服务器启动1秒后调用任务，每隔3秒调用一次</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(initialDelay=<span class="number">1000</span>,fixedRate=<span class="number">3000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----周期性调用SomeTask3-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在服务器启动0秒后调用任务，每隔5秒调用一次</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0/5 * * * * ?"</span>)<span class="comment">//秒 分 时 日 月 星期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----周期性调用SomeTask4-----"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Spring Schedule还需要指定cron表达式，表达式具体规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">秒   分    时    日   月   星期   年（可省略）</span><br><span class="line">0    0     10    1   10    ？</span><br><span class="line">秒： 0-59</span><br><span class="line">分： 0-59</span><br><span class="line">时： 0-23</span><br><span class="line">日： 1-31</span><br><span class="line">月： 1-12</span><br><span class="line">星期：1-7，1表示星期日，7表示星期六</span><br><span class="line">* ： 表示每一分、每一秒、每一天，任何一个可能值</span><br><span class="line">? ： 只用在日和星期部分，如果指定日，星期用？;如果指定星期，日用?，避免日和星期冲突 </span><br><span class="line">/ ： 表示增量，0/1表示0\1\2\3\4递增加1；0/5表示0\5\10\15；1/5表示1\6\11\16\21</span><br><span class="line">L ： 只用在日和星期部分，表示最后一天、周六</span><br></pre></td></tr></table></figure><p>cron表达式案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;30 * * * * ?&quot; 每半分钟触发任务</span><br><span class="line">&quot;30 10 * * * ?&quot; 每小时的10分30秒触发任务</span><br><span class="line">&quot;30 10 1 * * ?&quot; 每天1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 * ?&quot; 每月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 10 ? *&quot; 每年10月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 10 ? 2011&quot; 2011年10月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 ? 10 * 2011&quot; 2011年10月每天1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 ? 10 SUN 2011&quot; 2011年10月每周日1点10分30秒触发任务</span><br><span class="line">&quot;15,30,45 * * * * ?&quot; 每15秒，30秒，45秒时触发任务</span><br><span class="line">&quot;15-45 * * * * ?&quot; 15到45秒内，每秒都触发任务</span><br><span class="line">&quot;15/5 * * * * ?&quot; 每分钟的每15秒开始触发，每隔5秒触发一次</span><br><span class="line">&quot;15-30/5 * * * * ?&quot; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次</span><br><span class="line">&quot;0 0/3 * * * ?&quot; 每小时的第0分0秒开始，每三分钟触发一次</span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 星期一到星期五的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 L * ?&quot; 每个月最后一天的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 LW * ?&quot; 每个月最后一个工作日的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 ? * 5L&quot; 每个月最后一个星期四的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 ? * 5#3&quot; 每个月第三周的星期四的10点15分0秒触发任务</span><br></pre></td></tr></table></figure><h4 id="9-3-SpringBoot-Quartz"><a href="#9-3-SpringBoot-Quartz" class="headerlink" title="9.3 SpringBoot+Quartz"></a>9.3 SpringBoot+Quartz</h4><p>导入spring-boot-starter-quartz, 编写Job任务组件，继承QuartzJobBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask5</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过Quartz工具调用定时任务"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置Job组件（JobDetail、Tigger）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将MyTask5任务组件封装成JobDetail</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">task5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(MyTask5.class)</span><br><span class="line">            .withIdentity(<span class="string">"task5"</span>).storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//为JobDetail指定触发时间cron表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">task5Trigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CronScheduleBuilder cronScheduleBuilder = </span><br><span class="line">            CronScheduleBuilder.cronSchedule(<span class="string">"0/5 46 10 * * ?"</span>);</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(task5())</span><br><span class="line">                .withIdentity(<span class="string">"task5"</span>)</span><br><span class="line">                .withSchedule(cronScheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Spring Web MVC封装，简化MVC结构web应用开发。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/categories/SpringBoot/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot】数据库访问</title>
    <link href="http://chaooo.github.io/article/20180614.html"/>
    <id>http://chaooo.github.io/article/20180614.html</id>
    <published>2018-06-14T09:29:31.000Z</published>
    <updated>2019-10-20T05:25:23.046Z</updated>
    
    <content type="html"><![CDATA[<p>Springboot对于数据访问层，无论是SQL还是NOSQL，都默认采用整合Spring Data的方式进行统一处理，Springboot添加大量自动配置，屏蔽了很多设置。并引入各种<em>Template，</em>Repository来简化我们对数据访问层的操作。</p><a id="more"></a><h3 id="1-SpringBoot数据库访问"><a href="#1-SpringBoot数据库访问" class="headerlink" title="1.SpringBoot数据库访问"></a>1.SpringBoot数据库访问</h3><h4 id="1-1-Spring-DAO-JdbcTemplate"><a href="#1-1-Spring-DAO-JdbcTemplate" class="headerlink" title="1.1 Spring DAO JdbcTemplate"></a>1.1 Spring DAO JdbcTemplate</h4><p>引入spring-boot-starter-jdbc后（hikari、spring-jdbc包），就可以借助DataSourceAutoConfiguration、JdbcTemplateAutoConfiguration自动配置组件创建出HikariDataSource、JdbcTemplate对象。</p><ol><li>引入jdbc启动器、驱动包，创建连接池</li><li>根据要操作表定义entity（pojo，属性名与字段名一致）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义Dao接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>定义Dao实现类，扫描并注入JdbcTemplate使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span><span class="comment">//通过组件扫描加载到Spring容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDirectionDao</span> <span class="keyword">implements</span> <span class="title">DirectionDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;<span class="comment">//通过自动配置加载到Spring容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from direction"</span>;</span><br><span class="line">        RowMapper&lt;Direction&gt; rowMapper = </span><br><span class="line">            <span class="keyword">new</span> BeanPropertyRowMapper&lt;Direction&gt;(Direction.class);</span><br><span class="line">        <span class="keyword">return</span> template.query(sql, rowMapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Spring-MyBatis（XML-SQL版本）"><a href="#1-2-Spring-MyBatis（XML-SQL版本）" class="headerlink" title="1.2 Spring MyBatis（XML SQL版本）"></a>1.2 Spring MyBatis（XML SQL版本）</h4><ul><li>引入spring-boot-starter-jdbc、驱动包、mybatis-spring-boot-starter</li><li>引入application.properties（连接池参数）</li><li>实体类(同上)</li><li>SQL定义</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.xdl.dao.DirectionMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.xdl.entity.Direction"</span>&gt;</span></span><br><span class="line">        select * from direction</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"cn.xdl.entity.Direction"</span>&gt;</span></span><br><span class="line">        select * from direction where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direction <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@MapperScan和mybatis.mapperLocations=classpath:sql/*.xml</p></li><li><p>在启动类前追加@MapperScan</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages=<span class="string">"cn.xdl.dao"</span>)<span class="comment">//扫描Mapper接口创建对象加载到Spring容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在application.properties追加mybatis.mapperLocations</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.mapperLocations=classpath:sql/*.xml</span><br></pre></td></tr></table></figure><h4 id="1-3-Spring-MyBatis（注解-SQL版本）"><a href="#1-3-Spring-MyBatis（注解-SQL版本）" class="headerlink" title="1.3 Spring MyBatis（注解 SQL版本）"></a>1.3 Spring MyBatis（注解 SQL版本）</h4><ul><li>引入spring-boot-starter-jdbc、驱动包、mybatis-spring-boot-starter</li><li>引入application.properties（连接池参数）</li><li>实体类(同上)</li><li>定义Mapper接口，使用@Select、@Update、@Insert、@Delete注解定义SQL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from direction"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from direction where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Direction <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update direction set name=#&#123;name&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateName</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id,@<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span>String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用@MapperScan（同上）</li></ul><h3 id="2-Spring-Data-JPA"><a href="#2-Spring-Data-JPA" class="headerlink" title="2. Spring Data JPA"></a>2. Spring Data JPA</h3><h4 id="2-1-Jpa"><a href="#2-1-Jpa" class="headerlink" title="2.1 Jpa"></a>2.1 Jpa</h4><p>Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p><p>Sun引入新的JPA ORM规范主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。</p><blockquote><p>注意:Jpa 是一套规范，不是一套产品，那么像 Hibernate,TopLink,JDO 他们是一套产品，如果说这些产品实现了这个 Jpa 规范，那么我们就可以叫他们为 Jpa 的实现产品。</p></blockquote><h4 id="2-2-Spring-Boot-Jpa"><a href="#2-2-Spring-Boot-Jpa" class="headerlink" title="2.2 Spring Boot Jpa"></a>2.2 Spring Boot Jpa</h4><p>Spring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。</p><blockquote><p>Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现</p></blockquote><p>在Spring中使用JPA访问数据库，需要使用Spring Data模块支持。<br>    - SpringData是对Spring框架一个扩展模块，包含对JPA、Redis、MongoDB等技术的访问支持。</p><p>Spring Boot Jpa的使用 </p><ol><li><p>引入spring-boot-starter-jdbc、spring-boot-starter-data-jpa、驱动包</p></li><li><p>在application.properties定义db连接池参数（同上）</p></li><li><p>定义RunBoot启动类，使用@SpringBootApplication标记（同上）</p></li><li><p>根据要操作的表定义实体类，使用@Entity、@Table、@Id、@Column定义该对象和表结构之间的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"direction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义Dao接口，可以选择继承JpaRepository、PagingAndSortingRepository、CrudRepository等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DirectionDao</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Direction</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3-Dao扩展操作"><a href="#2-3-Dao扩展操作" class="headerlink" title="2.3 Dao扩展操作"></a>2.3 Dao扩展操作</h4><p>分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pageable pageable = PageRequest.of(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//of(页数从0开始,记录条数)</span></span><br><span class="line">Page&lt;Direction&gt; page = dao.findAll(pageable);</span><br><span class="line">List&lt;Direction&gt; list = page.getContent();</span><br><span class="line">list.forEach(d-&gt;&#123;System.out.println(d.getId()+<span class="string">" "</span>+d.getName());&#125;);</span><br><span class="line">System.out.println(<span class="string">"总记录数:"</span>+page.getTotalElements()</span><br><span class="line">+<span class="string">" 页数:"</span>+(page.getNumber()+<span class="number">1</span>)+<span class="string">"/"</span>+page.getTotalPages());</span><br><span class="line">List&lt;Direction&gt; list1 = dao.findByIdGreaterThan2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>按方法名规则扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//where id&gt;?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure><p>定义SQL语句扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(nativeQuery=<span class="keyword">true</span>,value=<span class="string">"select * from direction where id&gt;:id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan1</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p>定义JPQL面向查询语句扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"from Direction where id&gt;:id"</span>) <span class="comment">//使用类型名和属性名替代表名和字段名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title">findByIdGreaterThan2</span><span class="params">(@Param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p>按名称模糊查询，带分页支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(nativeQuery=<span class="keyword">true</span>,value=<span class="string">"select * from direction where name like :name"</span></span><br><span class="line">    ,countQuery=<span class="string">"select count(*) from direction where name like :name"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Direction&gt; <span class="title">findByNameLike1</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String name,Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Springboot对于数据访问层，无论是SQL还是NOSQL，都默认采用整合Spring Data的方式进行统一处理，Springboot添加大量自动配置，屏蔽了很多设置。并引入各种&lt;em&gt;Template，&lt;/em&gt;Repository来简化我们对数据访问层的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/categories/SpringBoot/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot】Boot 入门</title>
    <link href="http://chaooo.github.io/article/20180606.html"/>
    <id>http://chaooo.github.io/article/20180606.html</id>
    <published>2018-06-06T15:06:01.000Z</published>
    <updated>2019-10-20T05:23:23.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-项目管理工具Maven的基本使用"><a href="#1-项目管理工具Maven的基本使用" class="headerlink" title="1. 项目管理工具Maven的基本使用"></a>1. 项目管理工具Maven的基本使用</h3><p>Maven是一个使用java编写的开源的项目管理工具，可以方便灵活的控制项目，不必浪费时间去在不同的环境中配置依赖的jar包，而专心于业务逻辑。</p><h4 id="1-1-配置Maven的系统环境变量"><a href="#1-1-配置Maven的系统环境变量" class="headerlink" title="1.1 配置Maven的系统环境变量"></a>1.1 配置Maven的系统环境变量</h4><ol><li>下载并解压到目录，如<code>D:\apache-maven-3.6.1</code></li><li>添加新的系统环境变量MAVEN_HOME=安装的目录：<code>MAVEN_HOME=D:\apache-maven-3.6.1</code></li><li>添加<code>%MAVEN_HOME%\bin</code>到系统PATH变量.</li><li>测试Maven配置是否成功，打开命令行窗口，输入<code>mvn -v</code>，如果有maven 版本信息输出则证明配置成功，否则请查看自己配置路径等是否正确。</li></ol><blockquote><p>注意：安装Maven前请确保已安装JDK并成功配置其环境变量。</p></blockquote><h4 id="1-2-maven中的术语"><a href="#1-2-maven中的术语" class="headerlink" title="1.2 maven中的术语"></a>1.2 maven中的术语</h4><ul><li><strong>maven插件</strong>：maven主要定义了项目对象模型的生命周期。实际上每个任务都是交由插件完成的。maven的生命周期与插件目标相互绑定，来完成每个具体的任务。</li><li><strong>maven坐标</strong>：就是对项目的定位。groupId：组id，机构名。artifactId：构建id ，产品名或者产品的id。version ：版本号。</li><li><strong>坐标形式</strong>：groupId + artifactId+ version</li><li><strong>maven仓库</strong>：存放maven共享构建的位置。<ol><li>本地仓库：localRepository（使用<code>conf/settings.xml</code>设置）</li><li>私服仓库：部署在局域网中的仓库，方便整个团队的开发使用。</li><li>中央仓库：远程仓库下载地址：<a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a></li></ol></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- conf/settings.xml设置本地仓库路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">...</span></span></span><br><span class="line">    &lt;localRepository&gt;D:/apache-maven-3.6.1/.m2/repository&lt;/localRepository&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="1-3-maven构建的生命周期"><a href="#1-3-maven构建的生命周期" class="headerlink" title="1.3 maven构建的生命周期"></a>1.3 maven构建的生命周期</h4><p>清除–&gt; 编译–&gt; 测试–&gt; 报告–&gt; 打包(jar\war)–&gt; 安装–&gt; 部署</p><ol><li>清除：<code>mvn clean</code></li><li>编译：<code>mvn compile</code></li><li>测试：<code>mvn test</code></li><li>打包：<code>mvn package</code></li><li>安装：<code>mvn install</code></li><li>部署：<code>mvn deploy</code></li></ol><h4 id="1-4-MAVEN优点"><a href="#1-4-MAVEN优点" class="headerlink" title="1.4 MAVEN优点"></a>1.4 MAVEN优点</h4><ol><li>模块化项目<ul><li>项目非常大时，可借助Maven将一个项目拆分成多个工程，最好是一个模块对应一个工程，利于分工协作。而且模块可以通信。</li></ul></li><li>实现Jar包共享<ul><li>借助Maven，可将jar包仅仅保存在“仓库”中，有需要该文件时，就引用该文件接口，不需要复制文件过来占用空间。</li></ul></li><li>jar包的依赖<ul><li>借助Maven可以以规范的方式下载jar包，因为所有的知名框架或第三方工具的jar包已经按照统一的规范存放到了Maven的中央仓库中。</li></ul></li><li>jar包的自动导入<ul><li>通过xml定义引入jar包，Maven会自动导入jar包及其依赖jar包进来。</li></ul></li></ol><h4 id="1-5-MAVEN工具"><a href="#1-5-MAVEN工具" class="headerlink" title="1.5 MAVEN工具"></a>1.5 MAVEN工具</h4><ul><li>可以命令行使用，也可以结合Eclipse和Idea使用</li><li>简化项目搭建、编译、打包、发布等工作</li></ul><h3 id="2-SpringBoot基础"><a href="#2-SpringBoot基础" class="headerlink" title="2. SpringBoot基础"></a>2. SpringBoot基础</h3><ul><li>SpringBoot是对<strong>Spring框架的封装</strong>，用于<strong>简化</strong>Spring应用搭建和开发过程。</li><li>SpringBoot是pivotal公司产品、SpringCloud也是。</li></ul><h4 id="2-1-SpringBoot典型特点："><a href="#2-1-SpringBoot典型特点：" class="headerlink" title="2.1 SpringBoot典型特点："></a>2.1 SpringBoot典型特点：</h4><ul><li>去除XML配置，完全采用Java配置方式</li><li>内置tomcat服务器</li><li>利用自动配置创建很多对象（DataSource、JdbcTemplate、DispatcherServlet等）</li><li>提供一系列启动器（jar包集合）</li><li>采用properties或yml做配置文件</li><li>应用采用jar包发布</li></ul><h4 id="2-2-SpringBoot程序构成"><a href="#2-2-SpringBoot程序构成" class="headerlink" title="2.2 SpringBoot程序构成"></a>2.2 SpringBoot程序构成</h4><ul><li>创建工程，导入boot启动器（jar包）</li><li><code>spring-boot-starter</code> (核心、包含ioc、yml、自动配置、Log日志)</li><li><code>spring-boot-starter-parent</code>（包含参数设置、文件编码、jdk版本等）</li><li><code>spring-boot-starter-jdbc</code>（包含连接池、jdbcTemplate等）</li><li><code>spring-boot-starter-web</code>（包含mvc、restful、tomcat等）</li><li><code>spring-boot-starter-test</code>（包含junit、spring-test等）</li><li>添加配置文件<code>application.properties</code>或<code>application.yml</code></li></ul><h4 id="2-3-SpringBoot配置文件"><a href="#2-3-SpringBoot配置文件" class="headerlink" title="2.3 SpringBoot配置文件"></a>2.3 SpringBoot配置文件</h4><p>application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">server.port=8888</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr"> datasource:</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr"> port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><h4 id="2-4-SpringBoot启动类"><a href="#2-4-SpringBoot启动类" class="headerlink" title="2.4 SpringBoot启动类"></a>2.4 SpringBoot启动类</h4><p>定义启动类，通过main方法启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xxxx</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(Xxxx.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-SpringBoot数据库访问"><a href="#2-5-SpringBoot数据库访问" class="headerlink" title="2.5 SpringBoot数据库访问"></a>2.5 SpringBoot数据库访问</h4><p>在pom.xml定义spring-boot-starter-jdbc、mysql驱动包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在application.properties定义数据库连接参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/ydma</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>定义启动类，内部会根据自动配置机制生成DataSource和JdbcTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");</span></span><br><span class="line">        ApplicationContext ctx = </span><br><span class="line">                SpringApplication.run(RunBoot.class, args);</span><br><span class="line">        DataSource ds = ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(ds.getConnection());</span><br><span class="line">        JdbcTemplate template = ctx.getBean(JdbcTemplate.class);</span><br><span class="line">        System.out.println(template);</span><br><span class="line">        String sql = <span class="string">"insert into paper_score (total_score,my_score,user_id) values (?,?,?)"</span>;</span><br><span class="line">        Object[] params = &#123;<span class="number">100</span>,<span class="number">90</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        template.update(sql,params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提示：DataSource和JdbcTemplate都是基于自动配置机制产生，直接注入使用即可。</span></span><br></pre></td></tr></table></figure><h4 id="2-6-打包发布SpringBoot程序："><a href="#2-6-打包发布SpringBoot程序：" class="headerlink" title="2.6 打包发布SpringBoot程序："></a>2.6 打包发布SpringBoot程序：</h4><ol><li><p>在pom.xml定义spring-boot-maven-plugin插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击工程右键选择run as- maven build …</p></li><li><p>执行完毕后会在项目target目录下生成一个jar包，该包就是发布包</p><ul><li>可以采用java -jar xxxx.jar命令启动</li></ul></li></ol><blockquote><p>提示：eclipse设置jdk必须指向到JDK路径，不要JRE路径。</p></blockquote><h3 id="3-SpringBoot启动过程"><a href="#3-SpringBoot启动过程" class="headerlink" title="3. SpringBoot启动过程"></a>3. SpringBoot启动过程</h3><ol><li>调用SpringApplication的静态的run方法启动</li><li>静态的run方法调用SpringApplication对象的run方法<ul><li>(SpringApplication对象创建时加载spring.factories文件中Initializer和Application Listeners组件，判断程序类型servlet、reactive、default)</li></ul></li><li>对象的run方法会创建Spring的ApplicationContext容器对象<ul><li>获取启动Listener组件</li><li>获取environment环境参数</li><li>获取启动Logo信息Banner</li><li>根据程序类型不同创建不同类型的ApplicationContext对象</li><li>将Listener、environment、banner设置到ApplicationContext容器对象中</li><li>为ApplicationContext容器对象加载程序中各种Bean组件</li><li>开始执行启动任务ApplicationRunner、CommandLineRunner等</li><li>返回ApplicationContext容器对象</li></ul></li></ol><h3 id="4-SpringBootApplication作用"><a href="#4-SpringBootApplication作用" class="headerlink" title="4. @SpringBootApplication作用"></a>4. @SpringBootApplication作用</h3><p>SpringApplication.run方法在启动中，加载一个带有@SpringBootApplication标记的参数，该标记具有以下几种功能。</p><h4 id="4-1-SpringBootConfiguration（SpringBoot-Bean定义）"><a href="#4-1-SpringBootConfiguration（SpringBoot-Bean定义）" class="headerlink" title="4.1 @SpringBootConfiguration（SpringBoot Bean定义）"></a>4.1 @SpringBootConfiguration（SpringBoot Bean定义）</h4><ul><li>spring中bean定义<code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</code></li><li>SpringBoot通过<code>@Bean、@Primary</code>标记定义。</li></ul><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span><span class="comment">//开启Bean定义功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将返回的UserDao对象放入Spring容器，默认方法名为id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userdao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dao2"</span>)<span class="comment">//将返回的UserDao对象放入Spring容器，指定id为dao2</span></span><br><span class="line">    <span class="meta">@Primary</span><span class="comment">//默认注入该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userdao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"userService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@SpringBootConfiguration标记是对Spring的@Configuration封装，所以直接用@Configuration也可以。</p></blockquote><h4 id="4-2-ComponentScan（SpringBoot组件扫描）"><a href="#4-2-ComponentScan（SpringBoot组件扫描）" class="headerlink" title="4.2 @ComponentScan（SpringBoot组件扫描）"></a>4.2 @ComponentScan（SpringBoot组件扫描）</h4><ul><li>spring中组件扫描<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></li><li>SpringBoot通过@ComponentScan<ol><li>扫描指定包路径组件，带@Controller、@Service、@Repository、@Component注解标记组件<ul><li><code>@ComponentScan(basePackages= {&quot;cn.xdl.dao&quot;,&quot;cn.xdl.service&quot;})</code></li></ul></li><li>扫描cn.xdl包及子包下的组件<ul><li><code>@ComponentScan(basePackages=&quot;cn.xdl&quot;)</code></li></ul></li><li>扫描当前包及子包下的组件<ul><li><code>@ComponentScan</code></li></ul></li><li>扫描当前包及子包组件，并且将DeptService组件纳入<ul><li><code>@ComponentScan(includeFilters= {@Filter(type=FilterType.ASSIGNABLE_TYPE,classes=DeptService.class)})</code></li></ul></li><li>扫描当前包及子包组件，带有@Controller、@Service…、@MyComponent注解有效<ul><li><code>@ComponentScan(includeFilters= {@Filter(type=FilterType.ANNOTATION,classes=MyComponent.class)})</code></li></ul></li></ol></li></ul><h4 id="4-3-EnableAutoConfiguration（SpringBoot自动配置）"><a href="#4-3-EnableAutoConfiguration（SpringBoot自动配置）" class="headerlink" title="4.3 @EnableAutoConfiguration（SpringBoot自动配置）"></a>4.3 @EnableAutoConfiguration（SpringBoot自动配置）</h4><p>自动配置机制是SpringBoot框架特有功能，能在启动后自动创建一些常用对象，例如DataSource、JdbcTemplate等。</p><ul><li>自动配置原理：<ol><li>在xxx-autoconfigure.jar包中META-INF目录下有一个spring.factories文件，其中定义了大量的XxxAutoConfiguration配置组件。当开启@EnableAutoConfiguration标记时，标记内部会触发AutoConfigurationImportSelector组件调用SpringFactoriesLoader加载spring.factories文件。</li><li>自动配置组件就是采用@Configuration+@Bean+@Primary标记事先定义好的配置组件，通过Boot启动自动去spring.factories文件加载，然后在Spring容器中创建出约定对象。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataSourceAutoConfiguration<span class="comment">//创建dataSource对象</span></span><br><span class="line">JdbcTemplateAutoConfiguration<span class="comment">//创建jdbcTemplate</span></span><br><span class="line">DispatcherServletAutoConfiguration<span class="comment">//创建DispatcherServlet对象</span></span><br><span class="line">RedisAutoConfiguration<span class="comment">//创建RedisTemplate对象</span></span><br></pre></td></tr></table></figure><ul><li>通过自动配置机制创建DataSource对象<ol><li>引入spring-boot-starter-jdbc（hikari）、驱动包</li><li>在application.properties文件追加db参数</li><li>在启动类使用@EnableAutoConfiguration标记<ul><li>DataSourceAutoConfiguration默认会创建Hikari、tomcat、dbcp2连接池对象，优先级hikari最高，依次tomcat、dbcp2.</li><li>如果通过spring.datasource.type属性指定其他类型连接池组件，SpringBoot可以按指定类型创建连接池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h4 id="4-4-MAVEN如何排除某个jar包（扩展）"><a href="#4-4-MAVEN如何排除某个jar包（扩展）" class="headerlink" title="4.4 MAVEN如何排除某个jar包（扩展）"></a>4.4 MAVEN如何排除某个jar包（扩展）</h4><p>在引入spring-boot-starter-jdbc启动器时，由于jar包依赖会自动引入HikariCP，可以通过&lt; exclusion&gt;标记排除依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-项目管理工具Maven的基本使用&quot;&gt;&lt;a href=&quot;#1-项目管理工具Maven的基本使用&quot; class=&quot;headerlink&quot; title=&quot;1. 项目管理工具Maven的基本使用&quot;&gt;&lt;/a&gt;1. 项目管理工具Maven的基本使用&lt;/h3&gt;&lt;p&gt;Mave
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/categories/SpringBoot/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】SSM框架整合(Spring+SpringMVC+MyBatis)</title>
    <link href="http://chaooo.github.io/article/20180511.html"/>
    <id>http://chaooo.github.io/article/20180511.html</id>
    <published>2018-05-11T14:52:55.000Z</published>
    <updated>2019-10-20T05:14:35.263Z</updated>
    
    <content type="html"><![CDATA[<p>SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。<a id="more"></a></p><ul><li>使用spring MVC负责请求的转发和视图管理</li><li>spring实现业务对象管理</li><li>mybatis作为数据对象的持久化引擎</li></ul><h3 id="1-搭建SSM架构步骤："><a href="#1-搭建SSM架构步骤：" class="headerlink" title="1.搭建SSM架构步骤："></a>1.搭建SSM架构步骤：</h3><ol><li>设计数据库</li><li>先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。</li><li>编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li><li>编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。</li><li>配置spring和mybatis框架的整合(applicationContext.xml)</li><li>编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li><li>配置SpringMVC(web.xml)</li><li>编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li><li>编写JSP页面调用，请求哪些参数，需要获取什么数据。</li></ol><blockquote><p>DataBase –&gt; Entity –&gt; Mapper.xml –&gt; Mapper.Java(DAO) –&gt; Service.java –&gt; Controller.java –&gt; Jsp</p></blockquote><h3 id="2-搭建SSM架构实例（管理员登录）"><a href="#2-搭建SSM架构实例（管理员登录）" class="headerlink" title="2.搭建SSM架构实例（管理员登录）"></a>2.搭建SSM架构实例（管理员登录）</h3><h4 id="1-设计数据库-以MySql为例"><a href="#1-设计数据库-以MySql为例" class="headerlink" title="1. 设计数据库(以MySql为例)"></a>1. 设计数据库(以MySql为例)</h4><p>建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> exam_sys;</span><br><span class="line"><span class="comment">/** 管理员表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">admin</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'管理员ID'</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'管理员账号'</span>,</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">COMMENT</span> <span class="string">'管理员密码'</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_id_pk PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_name_uk <span class="keyword">UNIQUE</span>(<span class="keyword">NAME</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/** 插入数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span> (<span class="keyword">name</span>, <span class="keyword">password</span>) <span class="keyword">VALUES</span>(<span class="string">'admin'</span>, <span class="string">'123456'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h4 id="2-先写实体类entity，定义对象的属性"><a href="#2-先写实体类entity，定义对象的属性" class="headerlink" title="2. 先写实体类entity，定义对象的属性"></a>2. 先写实体类entity，定义对象的属性</h4><p>参照数据库中表的字段来设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.entity;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    private <span class="built_in">String</span> password;</span><br><span class="line">    <span class="comment">/** 添加 getter/setter方法</span></span><br><span class="line"><span class="comment">     *  添加 无参，有参构造</span></span><br><span class="line"><span class="comment">     *  重写toString()以便于测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-编写AdminMapper-xml（Mybatis），定义功能"><a href="#3-编写AdminMapper-xml（Mybatis），定义功能" class="headerlink" title="3. 编写AdminMapper.xml（Mybatis），定义功能"></a>3. 编写AdminMapper.xml（Mybatis），定义功能</h4><p>对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace指定和哪个Mapper映射器接口对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.exam.mapper.AdminDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByNameAndPassword"</span> <span class="attr">resultType</span>=<span class="string">"com.exam.entity.Admin"</span>&gt;</span></span><br><span class="line">        select * from admin where name=#&#123;name, jdbcType=VARCHAR&#125; and password=#&#123;password, jdbcType=VARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。"><a href="#4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。" class="headerlink" title="4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。"></a>4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。</h4><p>导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> com.exam.entity.Admin;</span><br><span class="line"></span><br><span class="line">public interface AdminDao &#123;</span><br><span class="line">    public Admin findByNameAndPassword(@Param(<span class="string">"name"</span>) <span class="built_in">String</span> name, @Param(<span class="string">"password"</span>) <span class="built_in">String</span> password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-配置spring和mybatis框架的整合"><a href="#5-配置spring和mybatis框架的整合" class="headerlink" title="5. 配置spring和mybatis框架的整合"></a>5. 配置spring和mybatis框架的整合</h4><p>导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/exam_sys"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory</span></span><br><span class="line"><span class="comment">        属性dataSource：注入连接池对象</span></span><br><span class="line"><span class="comment">        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置</span></span><br><span class="line"><span class="comment">        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/exam/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="typeAliasesPackage" value="com.exam.entity"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.exam.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="annotationClass" value="com.annotation.MyAnnotation"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启服务层组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.exam.service"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-编写Service-java，为控制层提供服务"><a href="#6-编写Service-java，为控制层提供服务" class="headerlink" title="6. 编写Service.java，为控制层提供服务"></a>6. 编写Service.java，为控制层提供服务</h4><p>接受控制层的参数，完成相应的功能，并返回给控制层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> com.exam.mapper.AdminDao;</span><br><span class="line"></span><br><span class="line">@Service(<span class="string">"adminService"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdminService</span> </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminDao dao;</span><br><span class="line">    </span><br><span class="line">    public boolean Login(<span class="built_in">String</span> name, <span class="built_in">String</span> password) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dao.findByNameAndPassword(name, password)!=<span class="literal">null</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-配置SpringMVC"><a href="#7-配置SpringMVC" class="headerlink" title="7. 配置SpringMVC"></a>7. 配置SpringMVC</h4><p>导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet分发请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler--&gt;</span></span><br></pre></td></tr></table></figure><p>在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启控制器组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.exam.controller"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启标注形式mvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-编写Controller-java，连接页面请求和服务层"><a href="#8-编写Controller-java，连接页面请求和服务层" class="headerlink" title="8. 编写Controller.java，连接页面请求和服务层"></a>8. 编写Controller.java，连接页面请求和服务层</h4><p>获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> com.exam.entity.Admin;</span><br><span class="line"><span class="keyword">import</span> com.exam.service.AdminService;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/admin"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdminController</span> </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminService <span class="keyword">as</span>;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(<span class="string">"/tologin"</span>)</span><br><span class="line">    public <span class="built_in">String</span> toLogin() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"admin/login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(value=<span class="string">"/login"</span>,method=RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public boolean addUser(Admin admin, HttpServletRequest request) &#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+admin);</span><br><span class="line">        System.out.println(admin.getName()+<span class="string">"---"</span>+admin.getPassword());</span><br><span class="line">        boolean bl = <span class="keyword">as</span>.Login(admin.getName(), admin.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(bl) &#123;</span><br><span class="line">            <span class="comment">//登录成功的逻辑</span></span><br><span class="line">            request.getSession().setAttribute(<span class="string">"admin"</span>, admin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//登录失败的逻辑</span></span><br><span class="line">        request.setAttribute(<span class="string">"msg"</span>, <span class="string">"登录失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-编写JSP页面调用"><a href="#9-编写JSP页面调用" class="headerlink" title="9. 编写JSP页面调用"></a>9. 编写JSP页面调用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    管理员: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aName"</span>  <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aPassword"</span>  <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"loginBtn"</span>  <span class="attr">type</span>=<span class="string">"button"</span>  <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="string">"#loginBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"admin/login"</span>,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"post"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: $(<span class="string">"#aName"</span>).val(),</span></span><br><span class="line"><span class="javascript">            password: $(<span class="string">"#aPassword"</span>).val()</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。
    
    </summary>
    
      <category term="Spring" scheme="http://chaooo.github.io/categories/Spring/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/back-end/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
