<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋过冬漫长</title>
  
  <subtitle>没有比脚更长的路，走过去，前面是个天！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chaooo.github.io/"/>
  <updated>2019-08-27T15:07:05.281Z</updated>
  <id>http://chaooo.github.io/</id>
  
  <author>
    <name>郑超(Charles·Zheng)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二十一、SpringBoot入门</title>
    <link href="http://chaooo.github.io/2019/08/27/21-SpringBoot%E5%85%A5%E9%97%A8.html"/>
    <id>http://chaooo.github.io/2019/08/27/21-SpringBoot入门.html</id>
    <published>2019-08-27T15:06:01.000Z</published>
    <updated>2019-08-27T15:07:05.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-项目管理工具Maven的基本使用"><a href="#1-项目管理工具Maven的基本使用" class="headerlink" title="1. 项目管理工具Maven的基本使用"></a>1. 项目管理工具Maven的基本使用</h3><p>Maven是一个使用java编写的开源的项目管理工具，可以方便灵活的控制项目，不必浪费时间去在不同的环境中配置依赖的jar包，而专心于业务逻辑。</p><h4 id="1-1-配置Maven的系统环境变量"><a href="#1-1-配置Maven的系统环境变量" class="headerlink" title="1.1 配置Maven的系统环境变量"></a>1.1 配置Maven的系统环境变量</h4><ol><li>下载并解压到目录，如<code>D:\apache-maven-3.6.1</code></li><li>添加新的系统环境变量MAVEN_HOME=安装的目录：<code>MAVEN_HOME=D:\apache-maven-3.6.1</code></li><li>添加<code>%MAVEN_HOME%\bin</code>到系统PATH变量.</li><li>测试Maven配置是否成功，打开命令行窗口，输入<code>mvn -v</code>，如果有maven 版本信息输出则证明配置成功，否则请查看自己配置路径等是否正确。</li></ol><blockquote><p>注意：安装Maven前请确保已安装JDK并成功配置其环境变量。</p></blockquote><h4 id="1-2-maven中的术语"><a href="#1-2-maven中的术语" class="headerlink" title="1.2 maven中的术语"></a>1.2 maven中的术语</h4><ul><li><strong>maven插件</strong>：maven主要定义了项目对象模型的生命周期。实际上每个任务都是交由插件完成的。maven的生命周期与插件目标相互绑定，来完成每个具体的任务。</li><li><strong>maven坐标</strong>：就是对项目的定位。groupId：组id，机构名。artifactId：构建id ，产品名或者产品的id。version ：版本号。</li><li><strong>坐标形式</strong>：groupId + artifactId+ version</li><li><strong>maven仓库</strong>：存放maven共享构建的位置。<ol><li>本地仓库：localRepository（使用<code>conf/settings.xml</code>设置）</li><li>私服仓库：部署在局域网中的仓库，方便整个团队的开发使用。</li><li>中央仓库：远程仓库下载地址：<a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a></li></ol></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- conf/settings.xml设置本地仓库路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">...</span></span></span><br><span class="line">    &lt;localRepository&gt;D:/apache-maven-3.6.1/.m2/repository&lt;/localRepository&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="1-3-maven构建的生命周期"><a href="#1-3-maven构建的生命周期" class="headerlink" title="1.3 maven构建的生命周期"></a>1.3 maven构建的生命周期</h4><p>清除–&gt; 编译–&gt; 测试–&gt; 报告–&gt; 打包(jar\war)–&gt; 安装–&gt; 部署</p><ol><li>清除：<code>mvn clean</code></li><li>编译：<code>mvn compile</code></li><li>测试：<code>mvn test</code></li><li>打包：<code>mvn package</code></li><li>安装：<code>mvn install</code></li><li>部署：<code>mvn deploy</code></li></ol><h4 id="1-4-MAVEN优点"><a href="#1-4-MAVEN优点" class="headerlink" title="1.4 MAVEN优点"></a>1.4 MAVEN优点</h4><ol><li>模块化项目<ul><li>项目非常大时，可借助Maven将一个项目拆分成多个工程，最好是一个模块对应一个工程，利于分工协作。而且模块可以通信。</li></ul></li><li>实现Jar包共享<ul><li>借助Maven，可将jar包仅仅保存在“仓库”中，有需要该文件时，就引用该文件接口，不需要复制文件过来占用空间。</li></ul></li><li>jar包的依赖<ul><li>借助Maven可以以规范的方式下载jar包，因为所有的知名框架或第三方工具的jar包已经按照统一的规范存放到了Maven的中央仓库中。</li></ul></li><li>jar包的自动导入<ul><li>通过xml定义引入jar包，Maven会自动导入jar包及其依赖jar包进来。</li></ul></li></ol><h4 id="1-5-MAVEN工具"><a href="#1-5-MAVEN工具" class="headerlink" title="1.5 MAVEN工具"></a>1.5 MAVEN工具</h4><ul><li>可以命令行使用，也可以结合Eclipse和Idea使用</li><li>简化项目搭建、编译、打包、发布等工作</li></ul><h3 id="2-SpringBoot基础"><a href="#2-SpringBoot基础" class="headerlink" title="2. SpringBoot基础"></a>2. SpringBoot基础</h3><ul><li>SpringBoot是对<strong>Spring框架的封装</strong>，用于<strong>简化</strong>Spring应用搭建和开发过程。</li><li>SpringBoot是pivotal公司产品、SpringCloud也是。</li></ul><h4 id="2-1-SpringBoot典型特点："><a href="#2-1-SpringBoot典型特点：" class="headerlink" title="2.1 SpringBoot典型特点："></a>2.1 SpringBoot典型特点：</h4><ul><li>去除XML配置，完全采用Java配置方式</li><li>内置tomcat服务器</li><li>利用自动配置创建很多对象（DataSource、JdbcTemplate、DispatcherServlet等）</li><li>提供一系列启动器（jar包集合）</li><li>采用properties或yml做配置文件</li><li>应用采用jar包发布</li></ul><h4 id="2-2-SpringBoot程序构成"><a href="#2-2-SpringBoot程序构成" class="headerlink" title="2.2 SpringBoot程序构成"></a>2.2 SpringBoot程序构成</h4><ul><li>创建工程，导入boot启动器（jar包）</li><li><code>spring-boot-starter</code> (核心、包含ioc、yml、自动配置、Log日志)</li><li><code>spring-boot-starter-parent</code>（包含参数设置、文件编码、jdk版本等）</li><li><code>spring-boot-starter-jdbc</code>（包含连接池、jdbcTemplate等）</li><li><code>spring-boot-starter-web</code>（包含mvc、restful、tomcat等）</li><li><code>spring-boot-starter-test</code>（包含junit、spring-test等）</li><li>添加配置文件<code>application.properties</code>或<code>application.yml</code></li></ul><h4 id="2-3-SpringBoot配置文件"><a href="#2-3-SpringBoot配置文件" class="headerlink" title="2.3 SpringBoot配置文件"></a>2.3 SpringBoot配置文件</h4><p>application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">server.port=8888</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr"> datasource:</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr"> port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><h4 id="2-4-SpringBoot启动类"><a href="#2-4-SpringBoot启动类" class="headerlink" title="2.4 SpringBoot启动类"></a>2.4 SpringBoot启动类</h4><p>定义启动类，通过main方法启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xxxx</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(Xxxx.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-SpringBoot数据库访问"><a href="#2-5-SpringBoot数据库访问" class="headerlink" title="2.5 SpringBoot数据库访问"></a>2.5 SpringBoot数据库访问</h4><p>在pom.xml定义spring-boot-starter-jdbc、mysql驱动包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在application.properties定义数据库连接参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/ydma</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>定义启动类，内部会根据自动配置机制生成DataSource和JdbcTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunBoot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");</span></span><br><span class="line">        ApplicationContext ctx = </span><br><span class="line">                SpringApplication.run(RunBoot.class, args);</span><br><span class="line">        DataSource ds = ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(ds.getConnection());</span><br><span class="line">        JdbcTemplate template = ctx.getBean(JdbcTemplate.class);</span><br><span class="line">        System.out.println(template);</span><br><span class="line">        String sql = <span class="string">"insert into paper_score (total_score,my_score,user_id) values (?,?,?)"</span>;</span><br><span class="line">        Object[] params = &#123;<span class="number">100</span>,<span class="number">90</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        template.update(sql,params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提示：DataSource和JdbcTemplate都是基于自动配置机制产生，直接注入使用即可。</span></span><br></pre></td></tr></table></figure><h4 id="2-6-打包发布SpringBoot程序："><a href="#2-6-打包发布SpringBoot程序：" class="headerlink" title="2.6 打包发布SpringBoot程序："></a>2.6 打包发布SpringBoot程序：</h4><ol><li><p>在pom.xml定义spring-boot-maven-plugin插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击工程右键选择run as- maven build …</p></li><li><p>执行完毕后会在项目target目录下生成一个jar包，该包就是发布包</p><ul><li>可以采用java -jar xxxx.jar命令启动</li></ul></li></ol><blockquote><p>提示：eclipse设置jdk必须指向到JDK路径，不要JRE路径。</p></blockquote><h3 id="3-SpringBoot启动过程"><a href="#3-SpringBoot启动过程" class="headerlink" title="3. SpringBoot启动过程"></a>3. SpringBoot启动过程</h3><ol><li>调用SpringApplication的静态的run方法启动</li><li>静态的run方法调用SpringApplication对象的run方法<ul><li>(SpringApplication对象创建时加载spring.factories文件中Initializer和Application Listeners组件，判断程序类型servlet、reactive、default)</li></ul></li><li>对象的run方法会创建Spring的ApplicationContext容器对象<ul><li>获取启动Listener组件</li><li>获取environment环境参数</li><li>获取启动Logo信息Banner</li><li>根据程序类型不同创建不同类型的ApplicationContext对象</li><li>将Listener、environment、banner设置到ApplicationContext容器对象中</li><li>为ApplicationContext容器对象加载程序中各种Bean组件</li><li>开始执行启动任务ApplicationRunner、CommandLineRunner等</li><li>返回ApplicationContext容器对象</li></ul></li></ol><h3 id="4-SpringBootApplication作用"><a href="#4-SpringBootApplication作用" class="headerlink" title="4. @SpringBootApplication作用"></a>4. @SpringBootApplication作用</h3><p>SpringApplication.run方法在启动中，加载一个带有@SpringBootApplication标记的参数，该标记具有以下几种功能。</p><h4 id="4-1-SpringBootConfiguration（SpringBoot-Bean定义）"><a href="#4-1-SpringBootConfiguration（SpringBoot-Bean定义）" class="headerlink" title="4.1 @SpringBootConfiguration（SpringBoot Bean定义）"></a>4.1 @SpringBootConfiguration（SpringBoot Bean定义）</h4><ul><li>spring中bean定义<code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</code></li><li>SpringBoot通过<code>@Bean、@Primary</code>标记定义。</li></ul><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span><span class="comment">//开启Bean定义功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将返回的UserDao对象放入Spring容器，默认方法名为id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userdao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dao2"</span>)<span class="comment">//将返回的UserDao对象放入Spring容器，指定id为dao2</span></span><br><span class="line">    <span class="meta">@Primary</span><span class="comment">//默认注入该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userdao1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"userService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@SpringBootConfiguration标记是对Spring的@Configuration封装，所以直接用@Configuration也可以。</p></blockquote><h4 id="4-2-ComponentScan（SpringBoot组件扫描）"><a href="#4-2-ComponentScan（SpringBoot组件扫描）" class="headerlink" title="4.2 @ComponentScan（SpringBoot组件扫描）"></a>4.2 @ComponentScan（SpringBoot组件扫描）</h4><ul><li>spring中组件扫描<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></li><li>SpringBoot通过@ComponentScan<ol><li>扫描指定包路径组件，带@Controller、@Service、@Repository、@Component注解标记组件<ul><li><code>@ComponentScan(basePackages= {&quot;cn.xdl.dao&quot;,&quot;cn.xdl.service&quot;})</code></li></ul></li><li>扫描cn.xdl包及子包下的组件<ul><li><code>@ComponentScan(basePackages=&quot;cn.xdl&quot;)</code></li></ul></li><li>扫描当前包及子包下的组件<ul><li><code>@ComponentScan</code></li></ul></li><li>扫描当前包及子包组件，并且将DeptService组件纳入<ul><li><code>@ComponentScan(includeFilters= {@Filter(type=FilterType.ASSIGNABLE_TYPE,classes=DeptService.class)})</code></li></ul></li><li>扫描当前包及子包组件，带有@Controller、@Service…、@MyComponent注解有效<ul><li><code>@ComponentScan(includeFilters= {@Filter(type=FilterType.ANNOTATION,classes=MyComponent.class)})</code></li></ul></li></ol></li></ul><h4 id="4-3-EnableAutoConfiguration（SpringBoot自动配置）"><a href="#4-3-EnableAutoConfiguration（SpringBoot自动配置）" class="headerlink" title="4.3 @EnableAutoConfiguration（SpringBoot自动配置）"></a>4.3 @EnableAutoConfiguration（SpringBoot自动配置）</h4><p>自动配置机制是SpringBoot框架特有功能，能在启动后自动创建一些常用对象，例如DataSource、JdbcTemplate等。</p><ul><li>自动配置原理：<ol><li>在xxx-autoconfigure.jar包中META-INF目录下有一个spring.factories文件，其中定义了大量的XxxAutoConfiguration配置组件。当开启@EnableAutoConfiguration标记时，标记内部会触发AutoConfigurationImportSelector组件调用SpringFactoriesLoader加载spring.factories文件。</li><li>自动配置组件就是采用@Configuration+@Bean+@Primary标记事先定义好的配置组件，通过Boot启动自动去spring.factories文件加载，然后在Spring容器中创建出约定对象。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataSourceAutoConfiguration<span class="comment">//创建dataSource对象</span></span><br><span class="line">JdbcTemplateAutoConfiguration<span class="comment">//创建jdbcTemplate</span></span><br><span class="line">DispatcherServletAutoConfiguration<span class="comment">//创建DispatcherServlet对象</span></span><br><span class="line">RedisAutoConfiguration<span class="comment">//创建RedisTemplate对象</span></span><br></pre></td></tr></table></figure><ul><li>通过自动配置机制创建DataSource对象<ol><li>引入spring-boot-starter-jdbc（hikari）、驱动包</li><li>在application.properties文件追加db参数</li><li>在启动类使用@EnableAutoConfiguration标记<ul><li>DataSourceAutoConfiguration默认会创建Hikari、tomcat、dbcp2连接池对象，优先级hikari最高，依次tomcat、dbcp2.</li><li>如果通过spring.datasource.type属性指定其他类型连接池组件，SpringBoot可以按指定类型创建连接池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h4 id="4-4-MAVEN如何排除某个jar包（扩展）"><a href="#4-4-MAVEN如何排除某个jar包（扩展）" class="headerlink" title="4.4 MAVEN如何排除某个jar包（扩展）"></a>4.4 MAVEN如何排除某个jar包（扩展）</h4><p>在引入spring-boot-starter-jdbc启动器时，由于jar包依赖会自动引入HikariCP，可以通过&lt; exclusion&gt;标记排除依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-项目管理工具Maven的基本使用&quot;&gt;&lt;a href=&quot;#1-项目管理工具Maven的基本使用&quot; class=&quot;headerlink&quot; title=&quot;1. 项目管理工具Maven的基本使用&quot;&gt;&lt;/a&gt;1. 项目管理工具Maven的基本使用&lt;/h3&gt;&lt;p&gt;Mave
      
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://chaooo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>二十、SSM框架整合(Spring+SpringMVC+MyBatis)</title>
    <link href="http://chaooo.github.io/2019/08/27/20-SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html"/>
    <id>http://chaooo.github.io/2019/08/27/20-SSM框架整合.html</id>
    <published>2019-08-27T14:52:55.000Z</published>
    <updated>2019-08-27T14:56:39.909Z</updated>
    
    <content type="html"><![CDATA[<p>SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。<a id="more"></a></p><ul><li>使用spring MVC负责请求的转发和视图管理</li><li>spring实现业务对象管理</li><li>mybatis作为数据对象的持久化引擎</li></ul><h3 id="1-搭建SSM架构步骤："><a href="#1-搭建SSM架构步骤：" class="headerlink" title="1.搭建SSM架构步骤："></a>1.搭建SSM架构步骤：</h3><ol><li>设计数据库</li><li>先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。</li><li>编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li><li>编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。</li><li>配置spring和mybatis框架的整合(applicationContext.xml)</li><li>编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li><li>配置SpringMVC(web.xml)</li><li>编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li><li>编写JSP页面调用，请求哪些参数，需要获取什么数据。</li></ol><blockquote><p>DataBase –&gt; Entity –&gt; Mapper.xml –&gt; Mapper.Java(DAO) –&gt; Service.java –&gt; Controller.java –&gt; Jsp</p></blockquote><h3 id="2-搭建SSM架构实例（管理员登录）"><a href="#2-搭建SSM架构实例（管理员登录）" class="headerlink" title="2.搭建SSM架构实例（管理员登录）"></a>2.搭建SSM架构实例（管理员登录）</h3><h4 id="1-设计数据库-以MySql为例"><a href="#1-设计数据库-以MySql为例" class="headerlink" title="1. 设计数据库(以MySql为例)"></a>1. 设计数据库(以MySql为例)</h4><p>建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> exam_sys;</span><br><span class="line"><span class="comment">/** 管理员表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">admin</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'管理员ID'</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'管理员账号'</span>,</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">COMMENT</span> <span class="string">'管理员密码'</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_id_pk PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_name_uk <span class="keyword">UNIQUE</span>(<span class="keyword">NAME</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/** 插入数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span> (<span class="keyword">name</span>, <span class="keyword">password</span>) <span class="keyword">VALUES</span>(<span class="string">'admin'</span>, <span class="string">'123456'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">admin</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h4 id="2-先写实体类entity，定义对象的属性"><a href="#2-先写实体类entity，定义对象的属性" class="headerlink" title="2. 先写实体类entity，定义对象的属性"></a>2. 先写实体类entity，定义对象的属性</h4><p>参照数据库中表的字段来设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.entity;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    private <span class="built_in">String</span> password;</span><br><span class="line">    <span class="comment">/** 添加 getter/setter方法</span></span><br><span class="line"><span class="comment">     *  添加 无参，有参构造</span></span><br><span class="line"><span class="comment">     *  重写toString()以便于测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-编写AdminMapper-xml（Mybatis），定义功能"><a href="#3-编写AdminMapper-xml（Mybatis），定义功能" class="headerlink" title="3. 编写AdminMapper.xml（Mybatis），定义功能"></a>3. 编写AdminMapper.xml（Mybatis），定义功能</h4><p>对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//ibatis.apache.org//DTD Mapper 3.0//EN" "http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace指定和哪个Mapper映射器接口对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.exam.mapper.AdminDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByNameAndPassword"</span> <span class="attr">resultType</span>=<span class="string">"com.exam.entity.Admin"</span>&gt;</span></span><br><span class="line">        select * from admin where name=#&#123;name, jdbcType=VARCHAR&#125; and password=#&#123;password, jdbcType=VARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。"><a href="#4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。" class="headerlink" title="4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。"></a>4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。</h4><p>导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> com.exam.entity.Admin;</span><br><span class="line"></span><br><span class="line">public interface AdminDao &#123;</span><br><span class="line">    public Admin findByNameAndPassword(@Param(<span class="string">"name"</span>) <span class="built_in">String</span> name, @Param(<span class="string">"password"</span>) <span class="built_in">String</span> password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-配置spring和mybatis框架的整合"><a href="#5-配置spring和mybatis框架的整合" class="headerlink" title="5. 配置spring和mybatis框架的整合"></a>5. 配置spring和mybatis框架的整合</h4><p>导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/exam_sys"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory</span></span><br><span class="line"><span class="comment">        属性dataSource：注入连接池对象</span></span><br><span class="line"><span class="comment">        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置</span></span><br><span class="line"><span class="comment">        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/exam/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="typeAliasesPackage" value="com.exam.entity"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.exam.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="annotationClass" value="com.annotation.MyAnnotation"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启服务层组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.exam.service"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-编写Service-java，为控制层提供服务"><a href="#6-编写Service-java，为控制层提供服务" class="headerlink" title="6. 编写Service.java，为控制层提供服务"></a>6. 编写Service.java，为控制层提供服务</h4><p>接受控制层的参数，完成相应的功能，并返回给控制层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> com.exam.mapper.AdminDao;</span><br><span class="line"></span><br><span class="line">@Service(<span class="string">"adminService"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdminService</span> </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminDao dao;</span><br><span class="line">    </span><br><span class="line">    public boolean Login(<span class="built_in">String</span> name, <span class="built_in">String</span> password) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dao.findByNameAndPassword(name, password)!=<span class="literal">null</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-配置SpringMVC"><a href="#7-配置SpringMVC" class="headerlink" title="7. 配置SpringMVC"></a>7. 配置SpringMVC</h4><p>导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet分发请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler--&gt;</span></span><br></pre></td></tr></table></figure><p>在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启控制器组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.exam.controller"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启标注形式mvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-编写Controller-java，连接页面请求和服务层"><a href="#8-编写Controller-java，连接页面请求和服务层" class="headerlink" title="8. 编写Controller.java，连接页面请求和服务层"></a>8. 编写Controller.java，连接页面请求和服务层</h4><p>获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.exam.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> com.exam.entity.Admin;</span><br><span class="line"><span class="keyword">import</span> com.exam.service.AdminService;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/admin"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdminController</span> </span>&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AdminService <span class="keyword">as</span>;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(<span class="string">"/tologin"</span>)</span><br><span class="line">    public <span class="built_in">String</span> toLogin() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"admin/login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(value=<span class="string">"/login"</span>,method=RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public boolean addUser(Admin admin, HttpServletRequest request) &#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+admin);</span><br><span class="line">        System.out.println(admin.getName()+<span class="string">"---"</span>+admin.getPassword());</span><br><span class="line">        boolean bl = <span class="keyword">as</span>.Login(admin.getName(), admin.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(bl) &#123;</span><br><span class="line">            <span class="comment">//登录成功的逻辑</span></span><br><span class="line">            request.getSession().setAttribute(<span class="string">"admin"</span>, admin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//登录失败的逻辑</span></span><br><span class="line">        request.setAttribute(<span class="string">"msg"</span>, <span class="string">"登录失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-编写JSP页面调用"><a href="#9-编写JSP页面调用" class="headerlink" title="9. 编写JSP页面调用"></a>9. 编写JSP页面调用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    管理员: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aName"</span>  <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aPassword"</span>  <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"loginBtn"</span>  <span class="attr">type</span>=<span class="string">"button"</span>  <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="string">"#loginBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"admin/login"</span>,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"post"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: $(<span class="string">"#aName"</span>).val(),</span></span><br><span class="line"><span class="javascript">            password: $(<span class="string">"#aPassword"</span>).val()</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十九、Java持久层框架Mybatis</title>
    <link href="http://chaooo.github.io/2019/08/27/19-Java%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6Mybatis.html"/>
    <id>http://chaooo.github.io/2019/08/27/19-Java持久层框架Mybatis.html</id>
    <published>2019-08-27T14:51:34.000Z</published>
    <updated>2019-08-27T14:55:08.273Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。</p><a id="more"></a><p>MyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。</p><ol><li><a href="#id1">Mybatis框架的构成</a></li><li><a href="#id2">使用Mybatis访问数据库</a></li><li><a href="#id3">Mybatis的CRUD操作</a></li><li><a href="#id4">Mapper映射器</a></li><li><a href="#id5">向mapper传多个参数</a></li><li><a href="#id6">结果集列名和属性名不一致的解决方法</a></li><li><a href="#id7">类型的别名和日志输出</a></li><li><a href="#id8">JdbcType</a></li></ol><p><span id="id1"><span> </span></span></p><h3 id="1-Mybatis框架的构成"><a href="#1-Mybatis框架的构成" class="headerlink" title="1. Mybatis框架的构成"></a>1. Mybatis框架的构成</h3><ul><li>实体类 ： 封装记录信息（JavaBean）</li><li>SQL定义文件 ：定义sql语句（编写SQL语句的XML）</li><li>主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML</li><li>框架API ：用于实现数据库增删改查操作（主要通过SqlSession）</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-使用Mybatis访问数据库"><a href="#2-使用Mybatis访问数据库" class="headerlink" title="2. 使用Mybatis访问数据库"></a>2. 使用Mybatis访问数据库</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p><ol><li><p>准备数据库及创建项目（需要mybatis的jar包和数据库驱动包）</p></li><li><p>根据表建立对应的实体类：<code>Emp(id,name,salary)</code></p></li><li><p>在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"environment"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"environment"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/mapper/EmpMapper.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在【src】包路径下创建配置文件（com/mapper/EmpMapper.xml）,然后根据需求定义sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mapper.EmpMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">         select * from emp32 where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">         select * from emp32 where name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li>parameterType：要求输入参数的类型</li><li>resultType：输出的类型</li></ul></blockquote><ol start="5"><li><p>封装工具类获取SQLSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory ssf;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 先构建SQLSession工厂构建器</span></span><br><span class="line">        SqlSessionFactoryBuilder ssfb = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        <span class="comment">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class="line">        InputStream inputStream = SqlSessionUtil.class.getClassLoader().getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        ssf = ssfb.build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 获取SQLSession</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class="line">        <span class="keyword">return</span> ssf.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SqlSession ss =SqlSessionUtil.getSqlSession();</span><br><span class="line">        Emp emp = ss.selectOne(<span class="string">"findById"</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>基本原理</p><ul><li>应用程序找 MyBatis 要数据</li><li>MyBatis 从数据库中找来数据</li><li>通过 mybatis-config.xml 定位哪个数据库</li><li>通过 EmpMapper.xml 执行对应的 sql 语句</li><li>基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中</li><li>返回一个 Emp 对象</li></ul></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-Mybatis的CRUD操作"><a href="#3-Mybatis的CRUD操作" class="headerlink" title="3. Mybatis的CRUD操作"></a>3. Mybatis的CRUD操作</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p><ol><li>第一步：配置EmpMapper.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertEmp"</span> <span class="attr">parameterType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    insert into emp32(name, salary) values(#&#123;name&#125;, #&#123;salary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    delete from emp32 where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    update emp32 set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">     select * from emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.mapper.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>parameterType：要求输入参数的类型</li><li>resultType：输出的类型</li></ul></blockquote><ol start="2"><li>第二步：SQLSession实现增删改查</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先构建SQLSession工厂构建器</span></span><br><span class="line">SqlSessionFactoryBuilder ssfb = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line"><span class="comment">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class="line">InputStream inputStream = EmpTest.class.getClassLoader().getResourceAsStream(<span class="string">"sqlmap-config.xml"</span>);</span><br><span class="line">SqlSessionFactory ssf = ssfb.build(inputStream);</span><br><span class="line"><span class="comment">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class="line">SqlSession ss = ssf.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">Emp emp = <span class="keyword">new</span> Emp(<span class="number">0</span>,<span class="string">"ef2"</span>,<span class="number">50000</span>);</span><br><span class="line"><span class="keyword">int</span> addRows = ss.insert(<span class="string">"insertEmp"</span>, emp);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">int</span> delRows = ss.delete(<span class="string">"deleteEmpById"</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">Emp emp2 = <span class="keyword">new</span> Emp(<span class="number">1</span>,<span class="string">"hello"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> updateRows = ss.update(<span class="string">"updateEmpById"</span>, emp2);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">Emp emp3 = ss.selectOne(<span class="string">"findById"</span>, <span class="number">6</span>);</span><br><span class="line">List&lt;Emp&gt; empList = ss.selectList(<span class="string">"findAll"</span>);</span><br><span class="line"></span><br><span class="line">ss.commit();</span><br></pre></td></tr></table></figure><blockquote><p>SqlSession对象的操作方法如下：</p><ul><li>insert(..) 插入操作</li><li>update(..) 更新操作</li><li>delete(..) 删除操作</li><li>selectOne(..) 单行查询操作</li><li>selectList(..) 多行查询操作</li><li>通过 session.commit() 来提交事务，也可以简单理解为更新到数据库</li></ul></blockquote><p><span id="id4"><span></span></span></p><h3 id="4-Mapper映射器"><a href="#4-Mapper映射器" class="headerlink" title="4. Mapper映射器"></a>4. Mapper映射器</h3><p>使用规则：</p><ol><li>接口的方法名和SQL定义文件中的id保持一致</li><li>接口方法的返回值类型 要和resultType 保持一致<ul><li>单行：<code>resultType</code></li><li>多行：<code>List&lt;resultType&gt;</code></li><li>增删改返回值，推荐int，也可以是void</li></ul></li><li>接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意</li><li>SQL定义文件中的namespace必须包名.接口名</li></ol><p><span id="id5"><span></span></span></p><h3 id="5-向mapper传多个参数"><a href="#5-向mapper传多个参数" class="headerlink" title="5. 向mapper传多个参数"></a>5. 向mapper传多个参数</h3><h4 id="5-1-第一种方案：-0-，-1-param1-和-param2"><a href="#5-1-第一种方案：-0-，-1-param1-和-param2" class="headerlink" title="5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}"></a>5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}</h4><p>DAO层的函数方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;0&#125; and name = #&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。<br>也可以用#{param1} 和 #{param2}实现同意效果。</p><h4 id="5-2-第二种方案-param"><a href="#5-2-第二种方案-param" class="headerlink" title="5.2 第二种方案@param"></a>5.2 第二种方案@param</h4><p>Dao层的函数方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(@param(<span class="string">"id"</span>)</span><span class="keyword">int</span> id, @<span class="title">param</span><span class="params">(<span class="string">"name"</span>)</span>String name)</span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-第三种方案：采用对象或Map传多参数"><a href="#5-3-第三种方案：采用对象或Map传多参数" class="headerlink" title="5.3 第三种方案：采用对象或Map传多参数"></a>5.3 第三种方案：采用对象或Map传多参数</h4><p>Dao层的函数方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName</span><span class="params">(Emp emp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Emp <span class="title">findByIdAndName2</span><span class="params">(Map&lt;String, Object&gt; params)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName"</span> <span class="attr">parameterType</span>=<span class="string">"com.bean.Emp"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByIdAndName2"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id6"><span></span></span></p><h3 id="6-结果集列名和属性名不一致的解决方法"><a href="#6-结果集列名和属性名不一致的解决方法" class="headerlink" title="6. 结果集列名和属性名不一致的解决方法"></a>6. 结果集列名和属性名不一致的解决方法</h3><p>在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。<br>解决方法：</p><ol><li>使用别名，select语句使用与属性一致的别名</li><li>使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系</span></span><br><span class="line"><span class="comment">    type:resultMap最终所映射的Java对象类型，可以使用别名</span></span><br><span class="line"><span class="comment">    id:对resultMap的唯一标识 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.bean.Emp"</span> <span class="attr">id</span>=<span class="string">"empMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id表示查询结果集中唯一标识 </span></span><br><span class="line"><span class="comment">        column:查询出的列名</span></span><br><span class="line"><span class="comment">        property:type所指定的类中的属性名 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"e_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对普通列的映射定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>  <span class="attr">column</span>=<span class="string">"salary"</span>  <span class="attr">property</span>=<span class="string">"sal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findEmpById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"empMap"</span>&gt;</span></span><br><span class="line">         select * from  emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id7"><span></span></span></p><h3 id="7-类型的别名和日志输出"><a href="#7-类型的别名和日志输出" class="headerlink" title="7. 类型的别名和日志输出"></a>7. 类型的别名和日志输出</h3><p>在mybatis-config.xml中自定义类型的别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"emp"</span> <span class="attr">type</span>=<span class="string">"com.bean.Emp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在EmpMapper.xml中使用别名 resultType=”emp”</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"emp"</span>&gt;</span></span><br><span class="line">    select id,name,salary sal from emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置MyBatis的日志输出到控制台</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置是否允许缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置日志输出的目标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id8"><span></span></span></p><h3 id="8-JdbcType"><a href="#8-JdbcType" class="headerlink" title="8. JdbcType"></a>8. JdbcType</h3><p>在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。</p><ul><li>所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。</li><li>一般情况下，我们没有必要按个字段去识别/判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。</li><li>MyBatis包含的JdbcType类型，主要有下面这些：<ul><li>BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.Emp"</span>&gt;</span></span><br><span class="line">    select * from emp32 where name = #&#123;name, jdbcType=VARCHAR&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id9"><span></span></span></p><h3 id="9-Mabatis中-和-的区别"><a href="#9-Mabatis中-和-的区别" class="headerlink" title="9. Mabatis中#{}和${}的区别"></a>9. Mabatis中#{}和${}的区别</h3><ol><li><code>${}</code>是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂）<ul><li>支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号</li></ul></li><li><code>#{}</code>是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入）<ul><li>不支持表名、排序方式等的占位，默认会将其当成字符串</li></ul></li></ol><h3 id="10-分页"><a href="#10-分页" class="headerlink" title="10. 分页"></a>10. 分页</h3><ol><li>在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置分页拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageHelper"</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>查询前使用分页API</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(2, 2);</span><br><span class="line">List<span class="tag">&lt;<span class="name">Emp</span>&gt;</span> emps = dao.orderBySalary();</span><br><span class="line">for(Emp emp: emps) &#123;</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Spring-MyBatis整合"><a href="#11-Spring-MyBatis整合" class="headerlink" title="11. Spring+MyBatis整合"></a>11. Spring+MyBatis整合</h3><p>Spring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API:</p><ol><li>SqlSessionFactoryBean<ul><li>创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源</li><li>依赖于dataSource 和加载SQL定义文件</li></ul></li><li>MapperFactoryBean<ul><li>根据指定的某一个Mapper接口生成Bean实例</li><li>依赖于SqlSessionFactory 和 MApper接口</li></ul></li><li>MapperScannerConfigurer<ul><li>根据指定包批量扫描Mapper接口并生成实例</li></ul></li><li>SqlSessionTemplate<ul><li>类似于JdbcTemplate，便于程序员自己编写Mapper实现类</li></ul></li></ol><h3 id="12-Spring-MyBatis完成sql操作"><a href="#12-Spring-MyBatis完成sql操作" class="headerlink" title="12. Spring+MyBatis完成sql操作"></a>12. Spring+MyBatis完成sql操作</h3><p><strong>第一步</strong>：使用Mybatis（同上）</p><ul><li>导jar包(mybatis包/数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口</li></ul><p><strong>第二步</strong>：配置SqlSessionFactoryBean</p><ul><li>导入jar包（mabatis-spring/ioc/aop/dao/连接池）</li><li>配置SqlSessionFactoryBean注入dataSource和指定sql定义文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：</p><ol><li>方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory<ul><li>最终产生Mapper接口的 实现类，注意这是实现类</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置SqlSessionFactoryBean 产生Mapper接口的 实现类  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"empDao"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"com.dao.EmpDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"empDao2"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"com.dao.EmpDao2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>方式二： MapperScannerConfigurer<ul><li>MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"annotationClass"</span> <span class="attr">value</span>=<span class="string">"com.annotation.MyAnnotation"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13-使用SqlSessionTemplate模板来完成DAO接口的实现类"><a href="#13-使用SqlSessionTemplate模板来完成DAO接口的实现类" class="headerlink" title="13. 使用SqlSessionTemplate模板来完成DAO接口的实现类"></a>13. 使用SqlSessionTemplate模板来完成DAO接口的实现类</h3><ol><li>使用Mybatis（同上）</li><li>配置SqlSessionFactoryBean（同上）</li><li>编写DAO接口的实现类<ul><li>开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory</li><li>使用SqlSessionTemplate对应API完成增删改查</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建SqlSessionTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionTemplate.selectOne(<span class="string">"findById"</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十八、Spring MVC框架</title>
    <link href="http://chaooo.github.io/2019/08/27/18-SpringMVC%E6%A1%86%E6%9E%B6.html"/>
    <id>http://chaooo.github.io/2019/08/27/18-SpringMVC框架.html</id>
    <published>2019-08-27T14:50:22.000Z</published>
    <updated>2019-08-27T14:55:17.931Z</updated>
    
    <content type="html"><![CDATA[<p>Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</p><a id="more"></a><ol><li><a href="#id1">Spring MVC基本概念</a></li><li><a href="#id2">Spring MVC的编写步骤</a></li><li><a href="#id3">标注(注解)形式的MVC</a></li><li><a href="#id4">mvc控制器接收页面参数</a></li><li><a href="#id5">mvc控制器把数据传递给页面</a></li><li><a href="#id6">Spring MVC实现重定向</a></li><li><a href="#id7">Spring MVC 中文参数的乱码问题</a></li><li><a href="#id8">Spring MVC 拦截器</a></li><li><a href="#id9">Spring MVC 拦截器的使用步骤</a></li><li><a href="#id10">Spring MVC异常处理</a></li><li><a href="#id11">Spring MVC文件上传</a></li><li><a href="#id12">文件上传与异常处理的结合</a></li><li><a href="#id13">Spring MVC响应JSON</a></li><li><a href="#id14">REST</a></li><li><a href="#id15">REST实例</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-Spring-MVC基本概念"><a href="#1-Spring-MVC基本概念" class="headerlink" title="1. Spring MVC基本概念"></a>1. Spring MVC基本概念</h3><h4 id="1-1-Spring-MVC-五大核心组件"><a href="#1-1-Spring-MVC-五大核心组件" class="headerlink" title="1.1 Spring MVC 五大核心组件"></a>1.1 Spring MVC 五大核心组件</h4><p>Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</p><ol><li>DispatcherServlet：控制器，请求入口</li><li>HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系</li><li>Controller：控制器，处理请求</li><li>ModelAndView：封装了 数据信息和视图信息</li><li>ViewResolver：视图处理器</li></ol><p>他的两个核心是两个核心：</p><ul><li>处理器映射：选择使用哪个控制器来处理请求 </li><li>视图解析器：选择结果应该如何渲染<blockquote><p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。</p></blockquote></li></ul><h4 id="1-2-SpringMVC运行原理"><a href="#1-2-SpringMVC运行原理" class="headerlink" title="1.2 SpringMVC运行原理"></a>1.2 SpringMVC运行原理</h4><ol><li>Http请求：客户端请求提交到DispatcherServlet。 </li><li>寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 </li><li>调用处理器：DispatcherServlet将请求提交到Controller。 </li><li>调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 </li><li>处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 </li><li>Http响应：视图负责将结果显示到客户端。</li></ol><h4 id="1-3-SpringMVC接口解释"><a href="#1-3-SpringMVC接口解释" class="headerlink" title="1.3 SpringMVC接口解释"></a>1.3 SpringMVC接口解释</h4><ol><li><strong>DispatcherServlet接口</strong>：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： <ol><li>截获符合特定格式的URL请求。 </li><li>初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 </li><li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li></ol></li><li><strong>HandlerMapping接口</strong>：能够完成客户请求到Controller映射。 </li><li><strong>Controller接口</strong>： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 <ul><li>Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 </li><li>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 </li></ul></li><li><strong>ViewResolver接口</strong>：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</li></ol><h4 id="1-4-SpringMVC配置"><a href="#1-4-SpringMVC配置" class="headerlink" title="1.4 SpringMVC配置"></a>1.4 SpringMVC配置</h4><ol><li><p>在web.xml文件中进行配置applicationContext.xml路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置applicationContext.xml，开启注解功能、配置试图解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/toHello.do"</span>&gt;</span>helloController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloController"</span> <span class="attr">class</span>=<span class="string">"com.controller.MyHelleController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-Spring-MVC的编写步骤"><a href="#2-Spring-MVC的编写步骤" class="headerlink" title="2. Spring MVC的编写步骤"></a>2. Spring MVC的编写步骤</h3><ol><li>建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</li><li>在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。</li><li>在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。</li><li>编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象</li><li>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</li></ol><p><span id="id3"><span></span></span></p><h3 id="3-标注-注解-形式的MVC"><a href="#3-标注-注解-形式的MVC" class="headerlink" title="3. 标注(注解)形式的MVC"></a>3. 标注(注解)形式的MVC</h3><ol><li><p>建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</p></li><li><p>在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。</p></li><li><p>开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"包名"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了）</p><ul><li>使用<code>@Controller</code> 可以把普通Java类转换成控制器，同时在容器中创建对象</li><li>使用<code>@RequestMapping(&quot;/路径&quot;)</code> 设置方法上</li></ul></li><li><p>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</p></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-mvc控制器接收页面参数"><a href="#4-mvc控制器接收页面参数" class="headerlink" title="4. mvc控制器接收页面参数"></a>4. mvc控制器接收页面参数</h3><ol><li><p>使用HttpServletRequest类型的参数来接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String acc_no = request.getParameter(<span class="string">"acc_no"</span>);</span><br><span class="line">    String acc_pwd = request.getParameter(<span class="string">"acc_password"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接定义和页面请求参数同名的控制器参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login2.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login2</span><span class="params">(String acc_no,String acc_password, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当页面参数和控制器参数名字不一致，@RequestParam(“acc_no”) 让请求参数和控制器参数对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login3.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login3</span><span class="params">(@RequestParam(<span class="string">"acc_no"</span>)</span> String a,String acc_password, ModelAndView mav) </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制器中 直接定义对象类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login4.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login4</span><span class="params">(Account acc, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-mvc控制器把数据传递给页面"><a href="#5-mvc控制器把数据传递给页面" class="headerlink" title="5. mvc控制器把数据传递给页面"></a>5. mvc控制器把数据传递给页面</h3><p>使用EL表达式在jsp页面接收数据<code>&lt;h1&gt;欢迎 ${acc_no} &lt;/h1&gt;</code></p><ol><li><p>使用域对象 进行传输 (request session ServletContext )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login6.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login6</span><span class="params">(String acc_no, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    req.setAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ModelAndView进行数据传输 </p><ul><li><code>mav.getModel().put(&quot;acc_no&quot;, acc_no);</code></li><li><code>mav.getModelMap().put(key, value);</code></li><li><code>mav.getModelMap().addAttribute(&quot;acc_no&quot;, acc_no);</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login7.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login7</span><span class="params">(String acc_no, ModelAndView mav)</span> </span>&#123;</span><br><span class="line">    mav.setViewName(<span class="string">"main"</span>);</span><br><span class="line">    <span class="comment">//mav.getModel().put("acc_no", acc_no);</span></span><br><span class="line">    <span class="comment">//mav.getModelMap().put(key, value)</span></span><br><span class="line">    mav.getModelMap().addAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用Model进行数据传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login8.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login8</span><span class="params">(String acc_no, Model m)</span> </span>&#123;</span><br><span class="line">    m.addAttribute(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ModelMap进行数据传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login9.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login9</span><span class="params">(String acc_no, ModelMap m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//m.addAttribute("acc_no", acc_no);</span></span><br><span class="line">    m.put(<span class="string">"acc_no"</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(“新名”)修改）</p><ul><li>默认名：<code>&lt;h1&gt;欢迎 ${ account.acc_no } &lt;/h1&gt;</code></li><li>@ModelAttribute(“acc”)：<code>&lt;h1&gt;欢迎 ${ acc.acc_no } &lt;/h1&gt;</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login10.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login10</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id6"><span></span></span></p><h3 id="6-Spring-MVC实现重定向"><a href="#6-Spring-MVC实现重定向" class="headerlink" title="6. Spring MVC实现重定向"></a>6. Spring MVC实现重定向</h3><ol><li>控制器方法返回String <ul><li>redirect:请求路径</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login11.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login11</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    <span class="comment">//return "forward:toMain.do";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:toMain.do"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/toMain.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 干其它的事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"main"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>控制器方法返回ModelAndView <ul><li>使用RedirectView  完成</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login12.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login12</span><span class="params">(@ModelAttribute(<span class="string">"acc"</span>)</span> Account acc) </span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    RedirectView rv = <span class="keyword">new</span> RedirectView(<span class="string">"toMain.do"</span>);</span><br><span class="line">    mav.setView(rv);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id7"><span></span></span></p><h3 id="7-Spring-MVC-中文参数的乱码问题"><a href="#7-Spring-MVC-中文参数的乱码问题" class="headerlink" title="7. Spring MVC 中文参数的乱码问题"></a>7. Spring MVC 中文参数的乱码问题</h3><p>tomcat8中 get 没有乱码问题，post 请求有乱码问题 </p><ol><li><p>参数为页面(HttpServletRequest request)与(HttpServletResponse response)时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>传入参数为<code>@RequestParam</code>时，可以通过字符串重新编码来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> String(string.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>方法名前出现<code>@RequestMapping(value=&quot;XXX&quot;)</code>时可以在value属性后再加一个属性<code>produces=&quot;text/html;charset=UTF-8&quot;</code>来解决</p></li><li><p>在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">utf</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">encodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id8"><span></span></span></p><h3 id="8-Spring-MVC-拦截器"><a href="#8-Spring-MVC-拦截器" class="headerlink" title="8. Spring MVC 拦截器"></a>8. Spring MVC 拦截器</h3><ol><li>拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置）</li><li>HandlerMapping接口<ul><li>preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。</li><li>postHandle：处理器执行后、视图处理前调用。</li><li>afterCompletion：整个请求处理完毕后调用。</li></ul></li></ol><p><span id="id9"><span></span></span></p><h3 id="9-Spring-MVC-拦截器的使用步骤"><a href="#9-Spring-MVC-拦截器的使用步骤" class="headerlink" title="9. Spring MVC 拦截器的使用步骤"></a>9. Spring MVC 拦截器的使用步骤</h3><ol><li>搭建一个基于标注的mvc</li><li>编写一个类实现HandlerInterceptor接口</li><li>在Spring配置文件中配置拦截器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/login.do"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xdl.interceptor.SomeInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id10"><span></span></span></p><h3 id="10-Spring-MVC异常处理"><a href="#10-Spring-MVC异常处理" class="headerlink" title="10. Spring MVC异常处理"></a>10. Spring MVC异常处理</h3><ol><li><p>配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleExceptionResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"exceptionMappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.RuntimeException"</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.Exception"</span>&gt;</span>error2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e)</span> </span>&#123;</span><br><span class="line">ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">mav.setViewName(<span class="string">"error"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">mav.setViewName(<span class="string">"error2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Controller</span></span><br><span class="line"><span class="comment">//public class MyController &#123;</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"error3"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><span id="id11"><span></span></span></p><h3 id="11-Spring-MVC文件上传"><a href="#11-Spring-MVC文件上传" class="headerlink" title="11. Spring MVC文件上传"></a>11. Spring MVC文件上传</h3><ol><li><p>jsp页面（method=”POST” enctype=”multipart/form-data type=”file”）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload.do"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"head_img"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><span id="id12"><span></span></span></p><h3 id="12-文件上传与异常处理的结合"><a href="#12-文件上传与异常处理的结合" class="headerlink" title="12. 文件上传与异常处理的结合"></a>12. 文件上传与异常处理的结合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/toFile.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">tofile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"file"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(String acc_no, MultipartFile head_img)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"acc_no:"</span> + acc_no );</span><br><span class="line"><span class="keyword">if</span>(head_img.getSize()&gt;<span class="number">1024</span>*<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件过大！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把文件写入磁盘</span></span><br><span class="line">String uniqueStr = UUID.randomUUID().toString();</span><br><span class="line">String oriFilename = head_img.getOriginalFilename();</span><br><span class="line">String suffix = oriFilename.substring(oriFilename.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"F:/Eclipse/datas/"</span>+uniqueStr+suffix);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">head_img.transferTo(file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(oriFilename);</span><br><span class="line">System.out.println(file);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"file"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 局部异常 */</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processError</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"error4"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id13"><span></span></span></p><h3 id="13-Spring-MVC响应JSON"><a href="#13-Spring-MVC响应JSON" class="headerlink" title="13. Spring MVC响应JSON"></a>13. Spring MVC响应JSON</h3><ol><li>搭建基于标注的mvc</li><li>在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON</li><li>给方法加@RequestMapping(“/请求路径”)、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包</li></ol><p><span id="id14"><span></span></span></p><h3 id="14-REST"><a href="#14-REST" class="headerlink" title="14. REST"></a>14. REST</h3><p>REST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。</p><ol><li>REST两个核心规范<ul><li>url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:<a href="http://test/source/1234）" target="_blank" rel="noopener">http://test/source/1234）</a></li><li>对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新</li></ul></li><li>restful<ul><li>符合REST设计规范和风格的应用程序或设计 就是RESTful</li></ul></li><li>Spring MVC对REST的支持<ul><li>@RequestMapping支持URI的模板，以及http请求方式设定的支持<ul><li><code>@RequestMapping(value=&quot;/account/{id}&quot;,method=RequestMethod.POST)</code></li></ul></li><li>对URI上路径变量的处理的支持，@PathVariable<ul><li><code>@PathVariable(&quot;id&quot;) int id</code></li></ul></li><li>rest请求路径是没有后缀的，需要把url-parttern修改成<code>/</code></li><li><code>&lt;servlet-mapping&gt;&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></li><li>需要对静态资源进行放行<code>&lt;mvc:default-servlet-handler/&gt;</code></li></ul></li></ol><p><span id="id15"><span></span></span></p><h3 id="15-REST实例"><a href="#15-REST实例" class="headerlink" title="15. REST实例"></a>15. REST实例</h3><ol><li>配置web.xml与applicationContext.xml(部分配置)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改rest请求路径 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- web.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写控制类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/toLogin.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id查询账户 GET */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccountById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        Random rm = <span class="keyword">new</span> Random();</span><br><span class="line">        Account acc = <span class="keyword">new</span> Account(id, <span class="string">"test"</span>+rm.nextInt(<span class="number">100</span>),<span class="string">"123"</span>, rm.nextInt(<span class="number">999</span>)+<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 新增账户 POST */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAccount</span><span class="params">(Account acc)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+acc);</span><br><span class="line">        <span class="keyword">if</span>(acc.getId()&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id删除帐户对象 DELETE */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.DELETE)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteAccountById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delete:"</span>+id);</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id更新帐户 PUT */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/account/&#123;id&#125;"</span>,method=RequestMethod.PUT)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putAccount</span><span class="params">(@RequestBody Account acc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//@RequestBody将接收的ajax请求的json字符串写入Account对象中</span></span><br><span class="line">        System.out.println(<span class="string">"update:"</span>+acc);</span><br><span class="line">        <span class="keyword">if</span>(acc.getId()&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写jsp页面</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountId"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountNo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountPassword"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>金额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"accountMoney"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"findBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"addBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"updateBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"delBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="string">"#findBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    findAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#addBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    addAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#updateBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    updateAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript">$(<span class="string">"#delBtn"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    delAccount();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getDatas</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> accountId = $(<span class="string">"#accountId"</span>).val();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> accountNo = $(<span class="string">"#accountNo"</span>).val();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> accountPassword = $(<span class="string">"#accountPassword"</span>).val();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> accountMoney = $(<span class="string">"#accountMoney"</span>).val();</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line">    id: accountId,</span><br><span class="line">    acc_no: accountNo,</span><br><span class="line">    acc_password: accountPassword,</span><br><span class="line">    acc_money: accountMoney</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">findAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"get"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountNo"</span>).val(res.acc_no);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountPassword"</span>).val(res.acc_password);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#accountMoney"</span>).val(res.acc_money);</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">addAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"post"</span>,</span></span><br><span class="line">        data: datas,</span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">delAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url: <span class="string">"account/"</span> + datas.id,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">"delete"</span>,</span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updateAccount</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> datas = getDatas();</span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        url:<span class="string">"account/"</span>+ datas.id,</span></span><br><span class="line"><span class="javascript">        type:<span class="string">"put"</span>,</span></span><br><span class="line"><span class="javascript">        data:<span class="built_in">JSON</span>.stringify(datas),</span></span><br><span class="line"><span class="javascript">        contentType:<span class="string">"application/json"</span>,<span class="comment">//以json字符串提交数据</span></span></span><br><span class="line"><span class="javascript">        success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line">            alert(res);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ul><li>PUT需要以json字符串提交数据<code>contentType:&quot;application/json&quot;</code></li><li>@RequestBody将接收的ajax请求的json字符串写入Account对象中</li><li>JSON.stringify()：将json对象转换为json字符串</li><li>JSON.parse()：将json字符串转换为json对象</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十七、Spring面向切面编程(AOP模块)</title>
    <link href="http://chaooo.github.io/2019/08/27/17-Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP.html"/>
    <id>http://chaooo.github.io/2019/08/27/17-Spring面向切面编程AOP.html</id>
    <published>2019-08-27T14:48:36.000Z</published>
    <updated>2019-08-27T14:55:22.336Z</updated>
    
    <content type="html"><![CDATA[<p>AOP（Aspect Oriented Programming）：面向切面编程，<br>它是面向对象基础上发展来的技术，是面向对象更高层次的应用，<br>它可以在不修改原有代码的情况给组件增强功能。</p><a id="more"></a><ol><li><a href="#id1">AOP涉及到的概念</a></li><li><a href="#id2">编写AOP程序步骤</a></li><li><a href="#id3">切点表达式</a></li><li><a href="#id4">通知的五种类型</a></li><li><a href="#id5">标注形式AOP步骤</a></li><li><a href="#id6">AOP 通知对应的标注</a></li><li><a href="#id7">@Around具体用法</a></li><li><a href="#id8">异常通知</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-AOP涉及到的概念"><a href="#1-AOP涉及到的概念" class="headerlink" title="1. AOP涉及到的概念"></a>1. AOP涉及到的概念</h3><ul><li>Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。</li><li>JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息）</li><li>Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点</li><li>Target：目标，要被切入共通业务逻辑的对象</li><li>Proxy：代理，被增强之后的目标对象就是代理</li><li>Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-编写AOP程序步骤"><a href="#2-编写AOP程序步骤" class="headerlink" title="2. 编写AOP程序步骤"></a>2. 编写AOP程序步骤</h3><ol><li>编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法</li><li>在不修改登录和注册原有代码的情况下，让两个方法调用前输出<code>******</code><ol><li>添加aop的jar包到lib</li><li>编写一个类，定义共同业务逻辑</li><li>配置aplicationContext.xml，创建切面对象</li><li>配置aop:config，切面–&gt;通知–&gt;切点</li></ol></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-切点表达式"><a href="#3-切点表达式" class="headerlink" title="3. 切点表达式"></a>3. 切点表达式</h3><ol><li>Bean限定表达式<ul><li><code>bean(&quot;容器内组件id&quot;)</code>，支持通配符<em>，如：<code>bean(&quot;*Dao&quot;)</code>，`bean(“acc</em>“)`</li></ul></li><li>类型限定表达式<ul><li><code>within(&quot;包名.类型&quot;)</code>，要求表达式最后一部分必须是类型，如：<code>com.dao.impl.类型</code>，<code>com.dao.impl.*</code>，<code>com.dao..*</code></li></ul></li><li>方法限定表达式<ul><li><code>execution(&quot;表达式&quot;)</code>，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:<code>返回值类型 方法名()</code></li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-通知的五种类型"><a href="#4-通知的五种类型" class="headerlink" title="4. 通知的五种类型"></a>4. 通知的五种类型</h3><ol><li><code>&lt;aop:before</code>：前置通知，目标方法执行之前调用</li><li><code>&lt;aop:after-returning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li><li><code>&lt;aop:after-throwing</code>：异常通知，目标方法出异常才调用</li><li><code>&lt;aop:after</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li><li><code>&lt;aop:around</code>：环绕通知，目标方法执行前后都调用</li></ol><p><span id="id5"><span></span></span></p><h3 id="5-标注形式AOP步骤"><a href="#5-标注形式AOP步骤" class="headerlink" title="5. 标注形式AOP步骤"></a>5. 标注形式AOP步骤</h3><ol><li>建项目，添加jar包(ioc,aop)，src下添加配置文件</li><li>编写一个Sevice类，里面有登录和注册两个方法</li><li>开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑</li><li>定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象</li><li>开启标注形式aop：<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true|false&quot; /&gt;</code></li><li>使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： <code>@Aspect，@Before...</code></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-AOP-通知对应的标注"><a href="#6-AOP-通知对应的标注" class="headerlink" title="6. AOP 通知对应的标注"></a>6. AOP 通知对应的标注</h3><ol><li><code>@Before</code>：前置通知，目标方法执行之前调用</li><li><code>@AfterReturning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li><li><code>@AfterThrowing</code>：异常通知，目标方法出异常才调用</li><li><code>@After</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li><li><code>@Around</code>：环绕通知，目标方法执行前后都调用</li></ol><p><span id="id7"><span></span></span></p><h3 id="7-Around具体用法"><a href="#7-Around具体用法" class="headerlink" title="7. @Around具体用法"></a>7. @Around具体用法</h3><p>@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"within(com..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">showAfterDate</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"开始时间："</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">    Object obj = pjp.proceed();</span><br><span class="line">    System.out.println(<span class="string">"结束时间："</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">    System.out.println(<span class="string">"执行时间："</span>date2.getTime() - date.getTime());</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p></blockquote><p><span id="id8"><span></span></span></p><h3 id="8-异常通知"><a href="#8-异常通知" class="headerlink" title="8. 异常通知"></a>8. 异常通知</h3><p>JoinPoint可以获取出异常的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"within(com..*)"</span>, throwing=<span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processException</span><span class="params">(JoinPoint jp, Exception e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"捕获到异常"</span> + jp.getSignature() + <span class="string">":\n【"</span> + e +<span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AOP（Aspect Oriented Programming）：面向切面编程，&lt;br&gt;它是面向对象基础上发展来的技术，是面向对象更高层次的应用，&lt;br&gt;它可以在不修改原有代码的情况给组件增强功能。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十六、Spring事务管理</title>
    <link href="http://chaooo.github.io/2019/08/27/16-Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.html"/>
    <id>http://chaooo.github.io/2019/08/27/16-Spring事务管理.html</id>
    <published>2019-08-27T14:47:30.000Z</published>
    <updated>2019-08-27T14:55:34.127Z</updated>
    
    <content type="html"><![CDATA[<p>事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。</p><a id="more"></a><ol><li><a href="#id1">事务的特性(ACID)</a></li><li><a href="#id2">Spring提供事务管理的3个接口</a></li><li><a href="#id3">TransactionDefinition接口</a></li><li><a href="#id4">TransactionStatus接口</a></li><li><a href="#id5">PlatformTransactionManager接口（事务管理器）</a></li><li><a href="#id6">基于AspectJ的xml方式的声明式事务管理</a></li><li><a href="#id7">基于注解的声明式事务管理</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-事务的特性-ACID"><a href="#1-事务的特性-ACID" class="headerlink" title="1. 事务的特性(ACID)"></a>1. 事务的特性(ACID)</h3><ul><li>事务的特性：<strong>原子性、一致性、隔离性、持久性</strong>。</li><li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。</li><li>隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。</li><li>持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-Spring提供事务管理的3个接口："><a href="#2-Spring提供事务管理的3个接口：" class="headerlink" title="2. Spring提供事务管理的3个接口："></a>2. Spring提供事务管理的3个接口：</h3><ol><li><strong>PlatformTransactionManager</strong>：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。</li><li><strong>TransactionDefinition</strong>：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。</li><li><strong>TransactionStatus</strong>：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。</li></ol><blockquote><p>Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。</p></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-TransactionDefinition接口"><a href="#3-TransactionDefinition接口" class="headerlink" title="3. TransactionDefinition接口"></a>3. TransactionDefinition接口</h3><p>TransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation)</p><ul><li>如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。</li><li>事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。</li></ul><h4 id="3-1-安全问题"><a href="#3-1-安全问题" class="headerlink" title="3.1 安全问题"></a>3.1 安全问题</h4><ol><li>脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。</li><li>不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。</li><li>幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。</li></ol><h4 id="3-2-事务的隔离级别-Isolation-："><a href="#3-2-事务的隔离级别-Isolation-：" class="headerlink" title="3.2 事务的隔离级别(Isolation)："></a>3.2 事务的隔离级别(Isolation)：</h4><ol><li><strong><code>READ_UNCOMMITED</code></strong>(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。</li><li><strong><code>READ_COMMITED</code></strong>(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。</li><li><strong><code>REPEATABLE_READ</code></strong>(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。</li><li><strong><code>SERIALIZABLE</code></strong>(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。</li><li><code>DEFAULT</code>(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别）。</li></ol><h4 id="3-3-事务的传播特性-Propagation-："><a href="#3-3-事务的传播特性-Propagation-：" class="headerlink" title="3.3 事务的传播特性(Propagation)："></a>3.3 事务的传播特性(Propagation)：</h4><ol><li>第一类：运行在同一个事务<ul><li><strong><code>REQUIRED</code></strong>：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li><li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li><li><code>MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常</li></ul></li><li>第二类：运行在不同事务<ul><li><strong><code>REQUIRES_NEW</code></strong>：新建事务，如果当前存在事务，把当前事务挂起</li><li><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li><code>NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常</li></ul></li><li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul><li><strong><code>NESTED</code></strong>：如果当前事务存在，则嵌套事务执行</li></ul></li></ol><p><span id="id4"><span></span></span></p><h3 id="4-TransactionStatus接口"><a href="#4-TransactionStatus接口" class="headerlink" title="4. TransactionStatus接口"></a>4. TransactionStatus接口</h3><p>平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。</p><p><span id="id5"><span></span></span></p><h3 id="5-PlatformTransactionManager接口（事务管理器）"><a href="#5-PlatformTransactionManager接口（事务管理器）" class="headerlink" title="5. PlatformTransactionManager接口（事务管理器）"></a>5. PlatformTransactionManager接口（事务管理器）</h3><p>该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。</p><h4 id="5-1-Spring支持两种方式事务管理："><a href="#5-1-Spring支持两种方式事务管理：" class="headerlink" title="5.1 Spring支持两种方式事务管理："></a>5.1 Spring支持两种方式事务管理：</h4><ol><li>编程式事务管理<ul><li>手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用）</li></ul></li><li>声明式事务管理<ul><li>基于TransactionProxyFactoryBean的方式（很少使用）</li><li>基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用）</li><li>基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加<code>@Transactional</code>注解（经常使用）</li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-基于AspectJ的xml方式的声明式事务管理"><a href="#6-基于AspectJ的xml方式的声明式事务管理" class="headerlink" title="6. 基于AspectJ的xml方式的声明式事务管理"></a>6. 基于AspectJ的xml方式的声明式事务管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"jdbc连接池对象id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务的通知（事务的增强） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- propagation:事务传播行为</span></span><br><span class="line"><span class="comment">            isolation:事务的隔离级别</span></span><br><span class="line"><span class="comment">            read-only:只读</span></span><br><span class="line"><span class="comment">            rollback-for:发生哪些异常回滚</span></span><br><span class="line"><span class="comment">            no-rollback-for:发生哪些异常不回滚</span></span><br><span class="line"><span class="comment">            timeout:过期信息    --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"transfer"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">rollback-for</span>=<span class="string">""</span> <span class="attr">timeout</span>=<span class="string">""</span> <span class="attr">no-rollback-for</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut1"</span> <span class="attr">expression</span>=<span class="string">"execution(*cn.muke.spring.demo3.AccountService+.*(.))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id7"><span></span></span></p><h3 id="7-基于注解的声明式事务管理"><a href="#7-基于注解的声明式事务管理" class="headerlink" title="7. 基于注解的声明式事务管理"></a>7. 基于注解的声明式事务管理</h3><ol><li><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.创建一个事务管理器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"事务管理器id"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"jdbc连接池对象id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.开启声明式事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"事务管理器id"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true|false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>transaction-manager</strong>：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource)</li><li><strong>proxy-target-class</strong>：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。</li></ul></li></ol><ol start="2"><li><p>使用，在类上或者方法上标注<code>@Transactional</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(</span><br><span class="line">        rollbackFor=&#123;Exception.class&#125;, </span><br><span class="line">        readOnly=<span class="keyword">false</span>, </span><br><span class="line">        isolation=Isolation.DEFAULT,</span><br><span class="line">        propagation=Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure><ul><li>@Transactional的属性<ul><li><strong>rollbackFor</strong>：设置检查异常也回滚</li><li><strong>noRollbackFor</strong>：指定运行时异常不回滚</li><li><strong>readOnly</strong>： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。</li><li><strong>isolation</strong>：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE)</li><li><strong>propagation</strong>：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER)</li></ul></li><li>Spring中事务管理器默认值针对<strong>运行时异常</strong>回滚，对<strong>检查异常</strong>不回滚。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十五、SpringJDBC详解</title>
    <link href="http://chaooo.github.io/2019/08/27/15-SpringJDBC%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://chaooo.github.io/2019/08/27/15-SpringJDBC详解.html</id>
    <published>2019-08-27T14:46:07.000Z</published>
    <updated>2019-08-27T14:55:39.395Z</updated>
    
    <content type="html"><![CDATA[<p>Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的<strong>声明式</strong>事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。</p><a id="more"></a><ol><li><a href="#id1">数据源配置</a></li><li><a href="#id2">JdbcTemplate的使用</a></li><li><a href="#id3">通过实现RowMapper接口把查询结果映射到Java对象</a></li><li><a href="#id4">JdbcTemplate对象的主要方法</a></li><li><a href="#id5">异常转换</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-数据源配置"><a href="#1-数据源配置" class="headerlink" title="1. 数据源配置"></a>1. 数据源配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">mysqlDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/test"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(mysqlDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用XML配置来实现配置效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义jdbcTemplate对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.jdbc"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id2"><span></span></span></p><h3 id="2-JdbcTemplate的使用"><a href="#2-JdbcTemplate的使用" class="headerlink" title="2. JdbcTemplate的使用"></a>2. JdbcTemplate的使用</h3><p>JdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。<br>JdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。</p><p>基本的查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAO实现类</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(*) from emp32"</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><span id="id3"><span></span></span></p><h3 id="3-通过实现RowMapper接口把查询结果映射到Java对象"><a href="#3-通过实现RowMapper接口把查询结果映射到Java对象" class="headerlink" title="3. 通过实现RowMapper接口把查询结果映射到Java对象"></a>3. 通过实现RowMapper接口把查询结果映射到Java对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Emp</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Emp(</span><br><span class="line">            rs.getInt(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getDouble(<span class="string">"salary"</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAO实现类</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"empDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title">EmpDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">getEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp32 where id=?"</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> EmpRowMapper(), id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-JdbcTemplate对象的主要方法"><a href="#4-JdbcTemplate对象的主要方法" class="headerlink" title="4. JdbcTemplate对象的主要方法"></a>4. JdbcTemplate对象的主要方法</h3><ol><li><p>queryForInt()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询一个整数类型</span></span><br><span class="line"><span class="keyword">int</span> count = jdbcTemplateObject.queryForInt(<span class="string">"select count(*) from emp32"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个使用绑定变量的简单查询</span></span><br><span class="line"><span class="keyword">int</span> age = jdbcTemplateObject.queryForInt(<span class="string">"select age from emp32 where id = ?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>queryForLong()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询一个 long类型</span></span><br><span class="line"><span class="keyword">long</span> count = jdbcTemplateObject.queryForLong(<span class="string">"select count(*) from emp32"</span>);</span><br></pre></td></tr></table></figure></li><li><p>queryForObject()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询字符串</span></span><br><span class="line">String SQL = <span class="string">"select name from emp32 where id = ?"</span>;</span><br><span class="line">String name = jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询并返回一个对象：</span></span><br><span class="line">String SQL = <span class="string">"select * from emp32 where id = ?"</span>;</span><br><span class="line">emp32 student = jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">10</span>&#125;, <span class="keyword">new</span> EmpRowMapper());</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询并返回多个对象：</span></span><br><span class="line">String SQL = <span class="string">"select * from emp32"</span>;</span><br><span class="line">List&lt;emp32&gt; students = jdbcTemplateObject.query(SQL, <span class="keyword">new</span> EmpRowMapper());</span><br></pre></td></tr></table></figure></li><li><p>update()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表中插入一行：</span></span><br><span class="line">String SQL = <span class="string">"insert into emp32 (name, age) values (?, ?)"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="string">"Zara"</span>, <span class="number">11</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新表中的一行：</span></span><br><span class="line">String SQL = <span class="string">"update emp32 set name = ? where id = ?"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="string">"Zara"</span>, <span class="number">10</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//从表中删除一行：</span></span><br><span class="line">String SQL = <span class="string">"delete emp32 where id = ?"</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> Object[]&#123;<span class="number">20</span>&#125; );</span><br></pre></td></tr></table></figure></li><li><p>execute()：执行DDL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">"CREATE TABLE emp32(</span></span><br><span class="line"><span class="string">idINT AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">NAMEVARCHAR(30),</span></span><br><span class="line"><span class="string">salaryDOUBLE DEFAULT 5000,</span></span><br><span class="line"><span class="string">CONSTRAINT student_id_pk PRIMARY KEY(id),</span></span><br><span class="line"><span class="string">CONSTRAINT student_name_uk UNIQUE(NAME)</span></span><br><span class="line"><span class="string">)"</span>;</span><br><span class="line">jdbcTemplateObject.execute( SQL );</span><br></pre></td></tr></table></figure></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-异常转换"><a href="#5-异常转换" class="headerlink" title="5. 异常转换"></a>5. 异常转换</h3><ul><li>Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。</li><li>所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。</li><li>这样可以使异常处理机制独立于当前使用的具体数据库。</li><li>除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。</li></ul><p>例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSQLErrorCodeTranslator</span> <span class="keyword">extends</span> <span class="title">SQLErrorCodeSQLExceptionTranslator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DataAccessException customTranslate</span><br><span class="line">      (String task, String sql, SQLException sqlException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlException.getErrorCode() == -<span class="number">104</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DuplicateKeyException(<span class="string">"完整性约束冲突"</span>, sqlException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的&lt;strong&gt;声明式&lt;/strong&gt;事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十四、Spring IoC注解实现</title>
    <link href="http://chaooo.github.io/2019/08/27/14-SpringIoC%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://chaooo.github.io/2019/08/27/14-SpringIoC注解实现.html</id>
    <published>2019-08-27T14:44:07.000Z</published>
    <updated>2019-08-27T14:55:45.009Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="#id1">回顾xml方式管理Java Bean</a></li><li><a href="#id2">注解方式管理Java Bean</a></li><li><a href="#id3">注解方式Bean的注入</a></li><li><a href="#id4">注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-回顾xml方式管理Java-Bean"><a href="#1-回顾xml方式管理Java-Bean" class="headerlink" title="1. 回顾xml方式管理Java Bean"></a>1. 回顾xml方式管理Java Bean</h3><ol><li>将一个Bean交由Spring创建并管理<ul><li><code>&lt;baen id=&quot;bean&quot; class=&quot;包名.Bean&quot;&gt;&lt;/baen&gt;</code></li></ul></li><li>获取Spring上下文<ul><li><code>ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></li></ul></li><li>获取Bean<ul><li><code>Bean bean = app.getBean(&quot;bean&quot;, Bean.class);</code></li></ul></li></ol><p><span id="id2"><span></span></span></p><h3 id="2-注解方式管理Java-Bean"><a href="#2-注解方式管理Java-Bean" class="headerlink" title="2. 注解方式管理Java Bean"></a>2. 注解方式管理Java Bean</h3><p>一、创建一个class配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="comment">//将一个Bean交由Spring创建并管理</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean <span class="title">bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean = <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、获取Spring上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = </span><br><span class="line">    <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfiguration.class);</span><br></pre></td></tr></table></figure><p>三、获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bean1 bean1 = context.getBean(<span class="string">"bean1"</span>, Bean1.class);</span><br></pre></td></tr></table></figure><h4 id="2-1-简化注解方式的步骤1"><a href="#2-1-简化注解方式的步骤1" class="headerlink" title="2.1 简化注解方式的步骤1"></a>2.1 简化注解方式的步骤1</h4><p>一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//该注解可理解当前class等同于一个xml文件</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>) <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在applicationContext.xml中开启组件扫描方式<code>&lt;context:component-scan base-package=&quot;包路径&quot;/&gt;</code>。</p></blockquote><p>二、 将交由Spring管理的类加上<code>@Component</code>注解，或（<code>@Repository</code>，<code>@Controller</code>，<code>@Service</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"bean1"</span>)<span class="comment">//通过构造方法实例化Bean1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 </p><ul><li>@Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 </li><li>@Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 </li><li>@Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 </li></ul></blockquote><h4 id="2-2-Bean别名"><a href="#2-2-Bean别名" class="headerlink" title="2.2 Bean别名"></a>2.2 Bean别名</h4><p>一、 xml形式：通过name属性或alias标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">name</span>=<span class="string">"bean2,bean3"</span> <span class="attr">class</span>=<span class="string">"com...Bean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"bean1"</span> <span class="attr">alias</span>=<span class="string">"bean4"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>二、 注解形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=&#123;<span class="string">"bean1"</span>,<span class="string">"bean2"</span>,<span class="string">"bean3"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：@Component只能指定一个名字，@Component默认值为<strong>类名首字母小写</strong>，也可以自定义，如:<code>@Component(&quot;bean1&quot;)</code>； 默认@scope为singleton单例，也可以进行指定</p></blockquote><p><span id="id3"><span></span></span></p><h3 id="3-注解方式Bean的注入"><a href="#3-注解方式Bean的注入" class="headerlink" title="3. 注解方式Bean的注入"></a>3. 注解方式Bean的注入</h3><p>一、 <strong><code>@Value(&quot;值&quot;)</code></strong>：常用于基本数据类型值注入，<code>值</code>可用EL表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、 <strong><code>@Autowired</code></strong>：常用于复杂类型值的注入<br>    + <code>@Autowired</code>：可以用在<strong>成员变量</strong>，<strong>setter方法</strong>，<strong>构造方法</strong>上；优先按照类型进行匹配，匹配不上启用名字进行匹配。<br>    + <code>@Qualifier(&quot;名字&quot;)</code> 根据名字匹配，配合@Autowired，<strong>不能用在构造方法上</strong>；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，<code>@Autowired(required=false)</code>:尽量去找，组件不存在也不报错。<br>    + @Autowired的<strong>原理</strong>：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于成员变量 */</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//@Qualifier("card1")</span></span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于构造方法 */</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于setter方法 */</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCard</span><span class="params">(Card card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、 <strong><code>@Resource</code></strong>：常用于复杂类型值的注入<br>    + @Resource：用在<strong>成员变量</strong>和<strong>setter方法</strong>上，是<strong>JDK</strong>1.6支持的注解，优先按照名字匹配，可以通过<code>@Resource(name=&quot;名&quot;)</code>指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"card"</span>)</span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合类型值注入实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"aaa"</span>);</span><br><span class="line">        list.add(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等"><a href="#4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等" class="headerlink" title="4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)"></a>4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</h3><h4 id="4-1-注解方式Bean的作用域"><a href="#4-1-注解方式Bean的作用域" class="headerlink" title="4.1 注解方式Bean的作用域"></a>4.1 注解方式Bean的作用域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-注解方式Bean的懒加载"><a href="#4-2-注解方式Bean的懒加载" class="headerlink" title="4.2 注解方式Bean的懒加载"></a>4.2 注解方式Bean的懒加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"包路径"</span>)</span><br><span class="line"><span class="meta">@Lazy</span> <span class="comment">//相当于xml中default-lazy-init="true"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"bean1"</span>)</span><br><span class="line">    <span class="meta">@Lazy</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean1 <span class="title">bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1 = <span class="keyword">new</span> Bean1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-Bean初始化和销毁"><a href="#4-3-Bean初始化和销毁" class="headerlink" title="4.3 Bean初始化和销毁"></a>4.3 Bean初始化和销毁</h4><p>一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、xml形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"example.Bean"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">init-method</span>=<span class="string">"init"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>三、注解形式1，@Bean(initMethod=”init”, destroyMethod=”cleanup”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"cleanup"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean <span class="title">bean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、注解形式2，添加@PostConstruct，@PreDestroy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#id1&quot;&gt;回顾xml方式管理Java Bean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#id2&quot;&gt;注解方式管理Java Bean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#id3&quot;&gt;注解方式Bean的注入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>十三、Spring基础和IoC控制反转</title>
    <link href="http://chaooo.github.io/2019/08/27/13-Spring%E5%9F%BA%E7%A1%80%E5%92%8CIoC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC.html"/>
    <id>http://chaooo.github.io/2019/08/27/13-Spring基础和IoC控制反转.html</id>
    <published>2019-08-27T14:38:23.000Z</published>
    <updated>2019-08-27T14:55:50.125Z</updated>
    
    <content type="html"><![CDATA[<p>Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。</p><ul><li>IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础<a id="more"></a></li><li>DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装</li><li>WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持</li><li>AOP：是在面向对象的基础上发展来的更高级的技术</li><li>ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库</li><li>JEE：Java的消息服务，远程调用，邮件服务等</li></ul><ol><li><a href="#id1">IoC（控制反转）</a></li><li><a href="#id2">Spring容器初始化</a></li><li><a href="#id3">spring容器创建对象(实例化)</a></li><li><a href="#id4">Spring DI注入的实现</a></li><li><a href="#id5">DI的参数的注入</a></li><li><a href="#id6">Bean的常用配置项(作用域,生命周期,懒加载等)</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-IoC（控制反转）"><a href="#1-IoC（控制反转）" class="headerlink" title="1. IoC（控制反转）"></a>1. IoC（控制反转）</h3><p><strong>IoC</strong>：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。</p><ol><li>控制：控制对象的创建及销毁（生命周期）</li><li>反转：将对象的控制权交给IoC容器</li></ol><p><strong>DI</strong>：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。</p><ul><li>简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入</li></ul><blockquote><p>IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。</p></blockquote><p><span id="id2"><span></span></span></p><h3 id="2-Spring容器初始化"><a href="#2-Spring容器初始化" class="headerlink" title="2. Spring容器初始化"></a>2. Spring容器初始化</h3><p>任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext</p><ul><li>BeanFactory提供配置结构和基本功能，加载并初始化Bean</li><li>ApplicationContext保存了Bean对象并在Spring中被广泛使用</li></ul><h4 id="2-1-初始化ApplicationContext的几种方式："><a href="#2-1-初始化ApplicationContext的几种方式：" class="headerlink" title="2.1 初始化ApplicationContext的几种方式："></a>2.1 初始化ApplicationContext的几种方式：</h4><ol><li><p>本地文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileSystemXmlApplicationContext app = </span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"F:/workspace/appcontext.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Classpath</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext app = </span><br><span class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classath:applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p>Web应用中依赖Servlet或Listener</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-Spring容器完成IOC的步骤"><a href="#2-2-Spring容器完成IOC的步骤" class="headerlink" title="2.2 Spring容器完成IOC的步骤"></a>2.2 Spring容器完成IOC的步骤</h4><ol><li>建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下</li><li>在spring容器配置文件中配置文件中配置一个对象的创建<ul><li><code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li></ul></li><li>写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件<ul><li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code></li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-spring容器创建对象-实例化"><a href="#3-spring容器创建对象-实例化" class="headerlink" title="3. spring容器创建对象(实例化)"></a>3. spring容器创建对象(实例化)</h3><h4 id="3-1-构造器方式实例化"><a href="#3-1-构造器方式实例化" class="headerlink" title="3.1 构造器方式实例化"></a>3.1 构造器方式实例化</h4><ul><li>配置文件：<code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li><li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code>默认调用类型对应的无参构造方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Date date = app.getBean(<span class="string">"date"</span>, Date.class);</span><br></pre></td></tr></table></figure><h4 id="3-2-静态工厂方法实例化"><a href="#3-2-静态工厂方法实例化" class="headerlink" title="3.2 静态工厂方法实例化"></a>3.2 静态工厂方法实例化</h4><ul><li>使用一个类型对应的静态方法来获取这个类型的对象</li><li><code>&lt;bean id=&quot;对象引用名&quot; class=&quot;包名.工厂类名&quot; factory-method=&quot;静态方法名&quot;&gt;&lt;/bean&gt;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cal"</span> <span class="attr">class</span>=<span class="string">"java.util.Calendar"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Calendar cal = app.getBean(<span class="string">"cal"</span>, Calendar.class);</span><br></pre></td></tr></table></figure><h4 id="3-3-实例工厂方法实例化"><a href="#3-3-实例工厂方法实例化" class="headerlink" title="3.3 实例工厂方法实例化"></a>3.3 实例工厂方法实例化</h4><ul><li>使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象</li><li><code>&lt;bean id=&quot;对象的引用名&quot; factory-bean=&quot;工厂方法的id&quot; factory-method=&quot;成员方法名&quot;&gt;&lt;/bean&gt;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cal"</span> <span class="attr">class</span>=<span class="string">"java.util.Calendar"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"time"</span> <span class="attr">factory-bean</span>=<span class="string">"cal"</span> <span class="attr">factory-method</span>=<span class="string">"getTime"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Date time = app.getBean(<span class="string">"time"</span>, Date.class);</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-Spring-DI注入的实现"><a href="#4-Spring-DI注入的实现" class="headerlink" title="4. Spring DI注入的实现"></a>4. Spring DI注入的实现</h3><p>Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。<br>Bean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。<br>DI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配)</p><ul><li>实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。</li></ul><h4 id="4-1-设值注入"><a href="#4-1-设值注入" class="headerlink" title="4.1 设值注入"></a>4.1 设值注入</h4><p>property(属性)的name参考对象set方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"黑桃"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"A"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player参考其setCard方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"玩家1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span> <span class="attr">ref</span>=<span class="string">"card"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-构造注入（Constructor-arguments）"><a href="#4-2-构造注入（Constructor-arguments）" class="headerlink" title="4.2 构造注入（Constructor arguments）"></a>4.2 构造注入（Constructor arguments）</h4><p>构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card2"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"红桃"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"K"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player参考其构造方法Player(name,card) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player2"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"玩家2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"card"</span> <span class="attr">ref</span>=<span class="string">"card2"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-自动化注入（Autowiring-mode）"><a href="#4-3-自动化注入（Autowiring-mode）" class="headerlink" title="4.3 自动化注入（Autowiring mode）"></a>4.3 自动化注入（Autowiring mode）</h4><p>一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire=”byName/byType/constructor”)指定对应的自动化的注入方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">autowire</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>自动装配autowire</strong>属性 有五种自动装配的方式：</p><ul><li><p>No：默认，需要通过<code>ref</code>属性来连接bean。</p></li><li><p><strong>byName</strong>： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card3"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应)</span></span><br><span class="line"><span class="comment">    否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player3"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>byType</strong>：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player4"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>constructor</strong>：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"card5"</span> <span class="attr">class</span>=<span class="string">"bean.Card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suit"</span> <span class="attr">value</span>=<span class="string">"方片"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"point"</span> <span class="attr">value</span>=<span class="string">"J"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"player5"</span> <span class="attr">class</span>=<span class="string">"bean.Player"</span> <span class="attr">autowire</span>=<span class="string">"constructor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>autodetect</strong>：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</p></li></ul><p><span id="id5"><span></span></span></p><h3 id="5-DI的参数的注入"><a href="#5-DI的参数的注入" class="headerlink" title="5. DI的参数的注入"></a>5. DI的参数的注入</h3><p>Bean对象 注入类型 可以是 字符串、集合、bean对象。</p><h4 id="5-1-注入字符串"><a href="#5-1-注入字符串" class="headerlink" title="5.1 注入字符串"></a>5.1 注入字符串</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"msg"</span> <span class="attr">class</span>=<span class="string">"com.xdl.bean.OracleDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"scott"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>tiger<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-注入集合"><a href="#5-2-注入集合" class="headerlink" title="5.2 注入集合"></a>5.2 注入集合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"friends"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"friends2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546454"</span> <span class="attr">value</span>=<span class="string">"值1"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546464"</span> <span class="attr">value</span>=<span class="string">"值2"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. props集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164545564"</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164546756"</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-集合参数的单独定义"><a href="#5-3-集合参数的单独定义" class="headerlink" title="5.3 集合参数的单独定义"></a>5.3 集合参数的单独定义</h4><p>注入集合–引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"ref_friends"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:set</span> <span class="attr">id</span>=<span class="string">"ref_buddys"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:set</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">"ref_phones"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"159454644"</span> <span class="attr">value</span>=<span class="string">"值1"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1594546454"</span> <span class="attr">value</span>=<span class="string">"值2"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. props集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"ref_phonePro"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"164545564"</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"16454675665564"</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"ref_db"</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones"</span> <span class="attr">ref</span>=<span class="string">"ref_phones"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"phones2"</span> <span class="attr">ref</span>=<span class="string">"ref_phonePro"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-Spring的’EL’表达式"><a href="#5-3-Spring的’EL’表达式" class="headerlink" title="5.3 Spring的’EL’表达式"></a>5.3 Spring的’EL’表达式</h4><p>它和EL在语法上很 相似，可以读取一个bean对象/集合中的数据。<br>Spring EL 采用 #{Sp Expression Language} 即 <code>#{spring表达式}</code>，可在xml配置和注解中使用。</p><ul><li>Spring EL配置连接池对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"db"</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.xdl.bean.OracleDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.name&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"#&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><span id="id6"><span></span></span></p><h3 id="6-Bean的常用配置项-作用域-生命周期-懒加载等"><a href="#6-Bean的常用配置项-作用域-生命周期-懒加载等" class="headerlink" title="6. Bean的常用配置项(作用域,生命周期,懒加载等)"></a>6. Bean的常用配置项(作用域,生命周期,懒加载等)</h3><p>Bean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization/destruction method</p><h4 id="6-1-Bean作用域（Scope）"><a href="#6-1-Bean作用域（Scope）" class="headerlink" title="6.1 Bean作用域（Scope）"></a>6.1 Bean作用域（Scope）</h4><ol><li>Singleton作用域<ul><li>单例，指一个Bean容器只存在一份</li></ul></li><li>prototype作用域<ul><li>每次请求(使用)创建新的实例，destroy方式不生效</li></ul></li><li>Web环境作用域：<ul><li>request作用域：每个request请求都会创建一个单独的实例。</li><li>session作用域：每个session都会创建一个单独的实例。</li><li>application作用域：每个servletContext都会创建一个单独的实例。</li><li>websocket作用域：每个websocket连接都会创建一个单独的实例。</li></ul></li><li>自定义作用域<ul><li>SimpleThreadScope作用域：每个线程都会创建一个单独的实例。</li></ul></li></ol><h4 id="6-2-Bean的生命周期（Initialization-destruction-method）"><a href="#6-2-Bean的生命周期（Initialization-destruction-method）" class="headerlink" title="6.2 Bean的生命周期（Initialization/destruction method）"></a>6.2 Bean的生命周期（Initialization/destruction method）</h4><p>Bean的生命周期：定义 –&gt; 初始化 –&gt; 使用 –&gt; 销毁</p><h5 id="6-2-1-Bean初始化"><a href="#6-2-1-Bean初始化" class="headerlink" title="6.2.1 Bean初始化"></a>6.2.1 Bean初始化</h5><p>如果需要在Bean实例化之后执行一些逻辑，有两种方法：</p><ul><li>实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。</li><li><strong>配置init-method</strong><ul><li>配置<strong><code>beans</code></strong>的<code>default-init-method</code>属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。</li><li>配置<strong><code>bean</code></strong>的<code>init-method</code>来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleId"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-2-2-Bean销毁"><a href="#6-2-2-Bean销毁" class="headerlink" title="6.2.2 Bean销毁"></a>6.2.2 Bean销毁</h5><p>如果需要在Bean销毁之前执行一些逻辑，有两种方法：</p><ul><li>实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。</li><li><strong>配置destroy-method</strong><ul><li>配置<strong><code>beans</code></strong>的<code>default-destroy-method</code>属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。</li><li>配置<strong><code>bean</code></strong>的<code>destroy-method</code>来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleId"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：销毁方法只针对单例模式的对象</p></blockquote><h4 id="6-3-Bean的懒加载（Lazy-initialization-mode）"><a href="#6-3-Bean的懒加载（Lazy-initialization-mode）" class="headerlink" title="6.3 Bean的懒加载（Lazy-initialization mode）"></a>6.3 Bean的懒加载（Lazy-initialization mode）</h4><p>Spring容器会在创建容器时提前初始化<code>Singleton作用域</code>的bean，可以通过bean标记<code>lazy-init=&quot;true&quot;</code>延迟实例化(对象被使用时才创建)。</p><ul><li><p><strong>配置lazy-init</strong></p><ul><li>配置<strong><code>beans</code></strong>的<code>default-lazy-init=&quot;true&quot;</code>为所有Bean设定懒加载。</li><li>配置<strong><code>bean</code></strong>的<code>lazy-init=&quot;true&quot;</code>为单独的某个Bean设定懒加载。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"example.exampleBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载</p><ul><li>优点：尽可能的节约了资源</li><li>缺点：可能导致某个操作响应时间增加</li></ul></li></ul><h4 id="6-4-Bean装配的Aware接口"><a href="#6-4-Bean装配的Aware接口" class="headerlink" title="6.4 Bean装配的Aware接口"></a>6.4 Bean装配的Aware接口</h4><p>实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。</p><ol><li>ApplicationContextAware<ul><li>接口方法：setApplicationContext</li><li>作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li><li>实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li></ul></li><li>BeanNameAware<ul><li>接口方法：setBeanName</li><li>作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li><li>实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li></ul></li></ol><h4 id="6-4-Bean装配之Resource"><a href="#6-4-Bean装配之Resource" class="headerlink" title="6.4 Bean装配之Resource"></a>6.4 Bean装配之Resource</h4><p><strong>Resources</strong>（针对于资源文件的统一接口）</p><ol><li>UrlResource：URL 对应的资源，根据一个 URL 地址即可获取</li><li>ClassPathResource：获取类路径下的资源</li><li>FileSystemResource：获取文件系统里面的资源</li><li>ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源</li><li>InputStreamResource：获取输入流封装的资源</li><li>ByteArrayResource：获取字节数组封装的资源</li></ol><p>ResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。</p><ul><li>getResource()参数：<ul><li>classPath方式：”classPath:class路径下文件”</li><li>file方式： “file:本地磁盘文件绝对地址”</li><li>url方式： “url:URL地址下文件”</li><li>没有前缀时依赖applicationContext的配置文件路径: “文件全名”</li></ul></li><li>eg:<code>applicationContext.getResource(&quot;classpath:config.txt&quot;)</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
      <category term="Spring" scheme="http://chaooo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统基础</title>
    <link href="http://chaooo.github.io/2019/07/22/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.html"/>
    <id>http://chaooo.github.io/2019/07/22/01-数据库系统基础.html</id>
    <published>2019-07-22T12:20:19.000Z</published>
    <updated>2019-08-27T14:36:49.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ol><li>数据库 是 电子化信息的集合<ul><li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li></ul></li><li>表(Table)：以按行按列形式组织及展现的数据<a id="more"></a><ul><li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li></ul></li><li>数据库系统的构成（概念层次）:<ol><li>数据库(DB):Database：相互之间有关联关系的数据的集合</li><li>数据库管理系统(DBMS):Database Management System</li><li>数据库应用(DBAP):Database Application</li><li>数据库管理员(DBA):Database Asministrator</li><li>计算机基本系统</li></ol></li></ol><h3 id="2-数据库管理系统-DBMS"><a href="#2-数据库管理系统-DBMS" class="headerlink" title="2. 数据库管理系统(DBMS)"></a>2. 数据库管理系统(DBMS)</h3><h4 id="2-1-从用户角度看DBMS-数据库管理系统"><a href="#2-1-从用户角度看DBMS-数据库管理系统" class="headerlink" title="2.1 从用户角度看DBMS(数据库管理系统)"></a>2.1 从用户角度看DBMS(数据库管理系统)</h4><ol><li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等<ul><li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li><li>用户使用DDL描述其所要建立的表的格式</li><li>DBMS依照用户的定义，创建数据库及其中的表</li></ul></li><li>数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等<ul><li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li><li>用户使用DML描述其所要进行的增、删、改、查等操作</li><li>DBMS依照用户的操作描述，实际执行这些操作</li></ul></li><li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)<ul><li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li><li>用户使用DCL描述其对数据库所要实施的控制</li><li>DBMS依照用户描述，实际ijnx控制</li></ul></li><li>数据库维护：转储/恢复/重组/性能监测/分析…<ul><li>DBMS提供了一系列程序(实用程序/例行程序)给用户</li><li>在这些程序中提供了对数据库维护的各种功能</li><li>用户使用这些程序进行各种数据库维护操作</li><li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li></ul></li></ol><h4 id="2-2-数据库语言"><a href="#2-2-数据库语言" class="headerlink" title="2.2 数据库语言"></a>2.2 数据库语言</h4><ul><li>使用者使用数据库语言，利用DBMS操纵数据库</li><li>SQL语言：结构化的数据库语言</li><li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li></ul><h4 id="2-3-从系统实现角度看DBMS的功能"><a href="#2-3-从系统实现角度看DBMS的功能" class="headerlink" title="2.3 从系统实现角度看DBMS的功能"></a>2.3 从系统实现角度看DBMS的功能</h4><ol><li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li><li>DBMS为完成DB管理，在后台运行着一系列程序…<ul><li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li><li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li><li><strong>数据存取与索引</strong>：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等</li><li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li><li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li><li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li><li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li><li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li><li><strong>数据字典管理</strong>：管理用户已经定义的信息</li><li><strong>应用程序接口(API)</strong>：提供应用程序使用DBMS特定功能的二首段</li><li><strong>数据库数据装载、重组等实用程序</strong></li><li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li></ul></li></ol><blockquote><p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p></blockquote><h3 id="3-数据库系统的标准结构"><a href="#3-数据库系统的标准结构" class="headerlink" title="3. 数据库系统的标准结构"></a>3. 数据库系统的标准结构</h3><h4 id="3-1-DBMS管理数据的三个层次"><a href="#3-1-DBMS管理数据的三个层次" class="headerlink" title="3.1 DBMS管理数据的三个层次"></a>3.1 DBMS管理数据的三个层次</h4><ol><li>External Level = User Level（外部级别 = 用户级别）<ul><li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li></ul></li><li>Conceptual Level = Logic level（概念级别 = 逻辑级别）<ul><li>从全局角度理解/管理的数据, 含相应的关联约束</li></ul></li><li>Internal Level = Physical level（内部级别 = 物理级别）<ul><li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li></ul></li></ol><h4 id="3-2-三级模式两层映像"><a href="#3-2-三级模式两层映像" class="headerlink" title="3.2 三级模式两层映像"></a>3.2 三级模式两层映像</h4><h5 id="3-2-1-数据-视图-与模式-数据的结构"><a href="#3-2-1-数据-视图-与模式-数据的结构" class="headerlink" title="3.2.1 数据(视图)与模式(数据的结构)"></a>3.2.1 数据(视图)与模式(数据的结构)</h5><ul><li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li><li>视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据</li></ul><h5 id="3-2-2-三级模式-三级视图"><a href="#3-2-2-三级模式-三级视图" class="headerlink" title="3.2.2 三级模式(三级视图)"></a>3.2.2 三级模式(三级视图)</h5><ul><li>External Schema —-(External) View<ul><li>某一用户能够看到与处理的数据的结构描述</li></ul></li><li>(Conceptual) Schema —- Conceptual View<ul><li>从全局角度理解/管理的数据的结构描述, 含相应的关联约束</li><li>体现在数据之间的内在本质联系</li></ul></li><li>Internal Schema —- Internal  View<ul><li>存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li></ul></li></ul><h5 id="3-2-3-两层映像"><a href="#3-2-3-两层映像" class="headerlink" title="3.2.3 两层映像"></a>3.2.3 两层映像</h5><ul><li>E-C Mapping：External Schema-Conceptual Schema Mapping <ul><li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li><li>便于用户观察和使用</li></ul></li><li>C-I Mapping：Conceptual Schema-Internal Schema Mapping <ul><li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li><li>便于计算机进行存储和处理</li></ul></li></ul><h4 id="3-3-标准结构的两个独立性"><a href="#3-3-标准结构的两个独立性" class="headerlink" title="3.3 标准结构的两个独立性"></a>3.3 标准结构的两个独立性</h4><ul><li>逻辑数据独立性<ul><li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li></ul></li><li>物理数据独立性<ul><li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li></ul></li></ul><h3 id="4-数据模型"><a href="#4-数据模型" class="headerlink" title="4. 数据模型"></a>4. 数据模型</h3><ul><li>数据模型：模式 与 模式的结构<ul><li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li><li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li><li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li></ul></li><li>三大经典数据模型<ul><li>关系模型：<strong>表</strong>的形式组织数据</li><li>层次模型：<strong>树</strong>的形式组织数据</li><li>网状模型：<strong>图</strong>的形式组织数据</li></ul></li></ul><h3 id="5-关系模型"><a href="#5-关系模型" class="headerlink" title="5. 关系模型"></a>5. 关系模型</h3><ul><li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：<ul><li>描述DB各种数据的基本结构形式(Table/Relation)</li><li>描述Table与Table之间所可能发生的各种操作(关系运算)</li><li>描述这些操作所应遵循的约束条件(完整性约束)</li></ul></li><li>关系模型的三个要素：<ul><li>基本结构：Relation/Table</li><li>基本操作：Relation Operator<ul><li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li><li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li></ul></li><li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li></ul></li><li>表(Table)的基本构成要素<ul><li>列/字段/属性/数据项：列名，列值</li><li>行/元组/记录</li><li>标题/模式</li></ul></li></ul><h4 id="5-1-“表”的严格定义"><a href="#5-1-“表”的严格定义" class="headerlink" title="5.1 “表”的严格定义"></a>5.1 “表”的严格定义</h4><ul><li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li><li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li><li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li></ul><h4 id="5-2-关系模式与关系"><a href="#5-2-关系模式与关系" class="headerlink" title="5.2 关系模式与关系"></a>5.2 关系模式与关系</h4><ul><li>同一关系模式下，可有很多的关系</li><li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li><li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li></ul><h4 id="5-3-关系的特性"><a href="#5-3-关系的特性" class="headerlink" title="5.3 关系的特性"></a>5.3 关系的特性</h4><ul><li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li><li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li><li>列位置互换性：区分哪一列是靠列名</li><li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)</li><li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li><li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li><li>属性不可再分特性:又被称为关系第一范式</li></ul><h4 id="5-4-关系的一些重要概念"><a href="#5-4-关系的一些重要概念" class="headerlink" title="5.4 关系的一些重要概念"></a>5.4 关系的一些重要概念</h4><ul><li>候选码(Candidate Key)/候选键<ul><li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li></ul></li><li>主码(Primary Key)/主键<ul><li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li></ul></li><li>主属性与非主属性<ul><li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li><li>最简单的，候选码只包含一个属性；</li><li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li></ul></li><li>外码(Foreign Key)/外键<ul><li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li><li>两个关系通常是靠外码连接起来的。</li></ul></li></ul><h3 id="6-关系模型中的完整性"><a href="#6-关系模型中的完整性" class="headerlink" title="6. 关系模型中的完整性"></a>6. 关系模型中的完整性</h3><h4 id="6-1-实体完整性"><a href="#6-1-实体完整性" class="headerlink" title="6.1 实体完整性"></a>6.1 实体完整性</h4><ul><li>关系的主码中的属性值不能为空值；</li><li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li></ul><h4 id="6-2-参照完整性"><a href="#6-2-参照完整性" class="headerlink" title="6.2 参照完整性"></a>6.2 参照完整性</h4><ul><li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li><li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li></ul><h4 id="6-3-用户自定义完整性"><a href="#6-3-用户自定义完整性" class="headerlink" title="6.3 用户自定义完整性"></a>6.3 用户自定义完整性</h4><ul><li>用户针对具体的应用环境定义的完整性约束条件</li></ul><h4 id="6-4-DBMS对关系完整性的支持"><a href="#6-4-DBMS对关系完整性的支持" class="headerlink" title="6.4 DBMS对关系完整性的支持"></a>6.4 DBMS对关系完整性的支持</h4><ul><li>实体完整性和参照完整性由DBMS系统自动支持</li><li>DBMS系统通常提供了如下机制：<ol><li>它使用户可以自行定义有关的完整性约束条件</li><li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li></ol></li></ul><h3 id="7-关系代数"><a href="#7-关系代数" class="headerlink" title="7. 关系代数"></a>7. 关系代数</h3><h4 id="7-1-关系代数的特点"><a href="#7-1-关系代数的特点" class="headerlink" title="7.1 关系代数的特点"></a>7.1 关系代数的特点</h4><ul><li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li><li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li><li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li><li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li><li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li></ul><h4 id="7-2-关系代数的约束"><a href="#7-2-关系代数的约束" class="headerlink" title="7.2 关系代数的约束"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p><ul><li>并相容性<ul><li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li><li>定义：关系R与关系S存在相容性，当且仅当：<ul><li>(1) 关系R和关系S的属性数目必须相同；</li><li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li></ul></li><li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li><li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li></ul></li></ul><h4 id="7-3-关系代数的基本操作"><a href="#7-3-关系代数的基本操作" class="headerlink" title="7.3 关系代数的基本操作"></a>7.3 关系代数的基本操作</h4><ol><li>集合操作<ul><li>并（UNIO）：R∪S</li><li>交（INTERSECTION）：R∩S</li><li>差（DIFFERENCE）：R-S</li><li>笛卡儿积（Cartesian PRODUCT）：R×S</li></ul></li><li>纯关系操作<ul><li>投影（PROJECT）：∏ a(R)</li><li>选择（SELECT）：σ Con(R)</li><li>连接（JOIN）：R⋈S</li><li>除（DIVISION）：R÷S</li></ul></li></ol><h5 id="7-3-1-并-Union-操作"><a href="#7-3-1-并-Union-操作" class="headerlink" title="7.3.1 并(Union) 操作"></a>7.3.1 并(Union) 操作</h5><ul><li>定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：<strong><code>R∪S</code></strong>, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li><li>数学描述：<code>R∪S = {t|t∈R ∨ t∈S}</code>，其中t是元组</li><li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li><li>汉语中的“或者…或者…”通常意义是并运算的要求。</li><li><code>R ∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li></ul><h5 id="7-3-2-差-Difference-操作"><a href="#7-3-2-差-Difference-操作" class="headerlink" title="7.3.2 差(Difference) 操作"></a>7.3.2 差(Difference) 操作</h5><ul><li>定义：假设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：<strong><code>R-S</code></strong>, 它由出现在关系R中但不出现在关系S中的元组构成。</li><li>数学描述：<code>R-S ={t|t∈R ∧ t(!∈)S }</code> ，其中t是元组</li><li>汉语中的“是…但不含…”通常意义是差运算的要求。</li><li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li></ul><h5 id="7-3-3-广义笛卡尔积-Cartesian-Product-操作"><a href="#7-3-3-广义笛卡尔积-Cartesian-Product-操作" class="headerlink" title="7.3.3 广义笛卡尔积(Cartesian Product) 操作"></a>7.3.3 广义笛卡尔积(Cartesian Product) 操作</h5><ul><li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：<strong><code>RxS</code></strong>, 它由关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。</li><li>数学描述：<code>RxS = {&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S}</code></li><li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li><li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li><li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数×,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).</li></ul><h5 id="7-3-4-选择-Select"><a href="#7-3-4-选择-Select" class="headerlink" title="7.3.4 选择(Select)"></a>7.3.4 选择(Select)</h5><ul><li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记con), 选择运算结果也是一个关系，记作<strong><code>σ con(R)</code></strong>, 它从关系R中选择出满足给定条件condition的元组构成。</li><li>数学描述：<code>con(R)={t|t(R)={t|t∈R ∧ con(t)=&#39;真&#39;}</code>，</li><li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；﹁；∧；∨</code> }</li></ul><h5 id="7-3-5-投影-Project"><a href="#7-3-5-投影-Project" class="headerlink" title="7.3.5 投影(Project)"></a>7.3.5 投影(Project)</h5><ul><li>定义：给定一个关系R, 投影运算结果也是一个关系，记作<strong><code>A(R)</code></strong>, 它从关系R中选出属性包含在A中的列构成。</li><li>数学描述：<code>∏ Ai1,Ai2,…,Aik (R) = {&lt;t[Ai1],t[Ai2],…,t[Aik]&gt; | t∈R}</code></li><li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li></ul><h4 id="7-4-关系代数的扩展操作"><a href="#7-4-关系代数的扩展操作" class="headerlink" title="7.4 关系代数的扩展操作"></a>7.4 关系代数的扩展操作</h4><h5 id="7-4-1-交-Intersection"><a href="#7-4-1-交-Intersection" class="headerlink" title="7.4.1 交(Intersection)"></a>7.4.1 交(Intersection)</h5><ul><li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：<strong><code>R∩S</code></strong>, 它由同时出现在关系R和关系S中的元组构成。</li><li>数学描述：<code>R∩S = {t|t∈R ∧ t∈S}</code>，其中t是元组</li><li>R∩S 和 S∩R 运算的结果是同一个关系</li><li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li><li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li></ul><h5 id="7-4-2-θ-连接-θ-Join-theta-Join"><a href="#7-4-2-θ-连接-θ-Join-theta-Join" class="headerlink" title="7.4.2 θ-连接(θ-Join, theta-Join)"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul><li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li><li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 <strong><code>R⋈[AθB]S</code></strong>：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li><li>数学描述：<code>R⋈[AθB]S = σ t[A] θ s[B] (R×S)</code></li><li>在实际应用中，θ-连接操作经常与投影∏、选择σ操作一起使用</li><li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li></ul><h5 id="7-4-3-等值连接-Equi-Join"><a href="#7-4-3-等值连接-Equi-Join" class="headerlink" title="7.4.3 等值连接(Equi-Join)"></a>7.4.3 等值连接(Equi-Join)</h5><ul><li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作<strong><code>R⋈[A=B]S</code></strong>：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li><li>数学描述：<code>R⋈[A=B]S = σ t[A] = s[B] (R×S)</code></li><li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li><li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接/等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li></ul><h5 id="7-4-4-自然连接-Natural-Join"><a href="#7-4-4-自然连接-Natural-Join" class="headerlink" title="7.4.4 自然连接(Natural-Join)"></a>7.4.4 自然连接(Natural-Join)</h5><ul><li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li><li>数学描述：<code>R⋈S = σ t[B]=s[B](R×S)</code></li><li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li></ul><h4 id="7-5-关系代数的基本书写思路"><a href="#7-5-关系代数的基本书写思路" class="headerlink" title="7.5 关系代数的基本书写思路"></a>7.5 关系代数的基本书写思路</h4><ol><li>选出将用到的关系/表</li><li>做”积”运算（可用连接运算替换）</li><li>做选择运算保留所需的行/元组</li><li>做投影运算保留所需的列/属性</li></ol><ul><li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li><li>如涉及多个表，则检查：<ul><li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li><li>如不能，能否使用等值或不等值连接(-连接)</li><li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li></ul></li><li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li></ul><h4 id="7-6-关系代数之复杂扩展操作"><a href="#7-6-关系代数之复杂扩展操作" class="headerlink" title="7.6 关系代数之复杂扩展操作"></a>7.6 关系代数之复杂扩展操作</h4><h5 id="7-6-1-除-Division"><a href="#7-6-1-除-Division" class="headerlink" title="7.6.1 除(Division)"></a>7.6.1 除(Division)</h5><ul><li>除法运算经常用于求解“查询… 全部的/所有的…”问题</li><li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li><li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li><li>数学描述：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R÷S = &#123;t|t∈∏[R-S](R) ∧ ▽u∈S(tu∈R) &#125;</span><br><span class="line">    = ∏[R-S](R) - ∏[R-S]((∏[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure></li></ul><h5 id="7-6-2-外连接-Outer-Join"><a href="#7-6-2-外连接-Outer-Join" class="headerlink" title="7.6.2 外连接(Outer-Join)"></a>7.6.2 外连接(Outer-Join)</h5><ul><li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li><li>外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li><li>外连接的形式：左外连接、右外连接、全外连接<ul><li>左外连接 = 自然连接(或连接) + 左侧表中失配的元组</li><li>右外连接 = 自然连接(或连接) + 右侧表中失配的元组</li><li>全外连接 = 自然连接(或连接) + 两侧表中失配的元组</li><li>左外连接(Left Outer Join)记为：⋊</li><li>右外连接(Right Outer Join)记为：⋉</li><li>全外连接(Full Outer Join)记为：×</li></ul></li></ul><h3 id="8-关系演算"><a href="#8-关系演算" class="headerlink" title="8. 关系演算"></a>8. 关系演算</h3><ul><li>关系演算是描述关系运算的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</li><li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ul><li>关系元组演算是以元组变量作为谓词变量的基本对象</li><li>关系域演算是以域变量作为谓词变量的基本对象</li></ul></li></ul><h4 id="8-1-关系元组演算"><a href="#8-1-关系元组演算" class="headerlink" title="8.1 关系元组演算"></a>8.1 关系元组演算</h4><ul><li>关系元组演算公式：{ t | P(t) }<ul><li>表示：所有使谓词 P 为真的元组 t 的集合</li><li>t 是元组变量</li><li>t ∈ r 表示元组 t 在关系 r 中</li><li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li><li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li></ul></li><li>关系元组演算公式的基本形式：{ t | P(t) }</li><li>P(t)可以是如下三种形式之一的原子公式：<ul><li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li><li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=</li><li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li></ul></li><li>P(t)可以由公式加运算符 ∧(与)、∨(或)、﹁(非)递归地构造<ul><li>如果F是一个公式，则 ﹁F 也是公式</li><li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li></ul></li><li>P(t)运算符优先次序(括弧；θ；E；▽；﹁；∧；∨)示例</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据库 是 电子化信息的集合&lt;ul&gt;
&lt;li&gt;将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;表(Table)：以按行按列形式组织及展现的数据
    
    </summary>
    
      <category term="数据库系统" scheme="http://chaooo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="数据库" scheme="http://chaooo.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>十二、JavaWeb编程基础</title>
    <link href="http://chaooo.github.io/2019/07/20/12_JavaWeb%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html"/>
    <id>http://chaooo.github.io/2019/07/20/12_JavaWeb编程基础.html</id>
    <published>2019-07-20T12:59:40.000Z</published>
    <updated>2019-07-25T11:59:55.682Z</updated>
    
    <content type="html"><![CDATA[<p>JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。</p><a id="more"></a><ol><li><a href="#id1">http协议</a></li><li><a href="#id2">Servlet</a></li><li><a href="#id3">get和post区别</a></li><li><a href="#id4">上下文对象ServletContext</a></li><li><a href="#id5">会话跟踪（状态管理）</a></li><li><a href="#id6">JSP</a></li><li><a href="#id7">内置对象(隐含对象)</a></li><li><a href="#id8">taglib指令</a></li><li><a href="#id9">JavaWeb三大组件</a></li><li><a href="#id10">JSON在Java中的使用</a></li><li><a href="#id11">AJAX</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-http协议"><a href="#1-http协议" class="headerlink" title="1. http协议"></a>1. http协议</h3><p>超文本传输协议，是一种应用层的网络传输协议</p><ul><li>http协议的特点：<ol><li>简单，快速：支持多种不同的的数据提交方式，如get/post</li><li>数据传输灵活，支持任意类型数据的传输</li><li>无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。</li><li>无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。</li></ol></li><li>http协议的组成部分：<ol><li>请求：浏览器连接服务器的过程</li><li>响应：服务器回复浏览器的过程</li></ol></li><li>http协议的请求：<ol><li>请求头：描述客户端的信息</li><li>请求体：GET没有请求体，请求体用于存储POST请求发送的数据。</li><li>请求空行：请求头与请求体之间的一行空白</li><li>请求行：描述请求方式，服务器地址，协议版本等</li></ol></li><li>http协议的响应：<ol><li>响应头：描述服务器的信息</li><li>响应体：响应的内容，文本，json数据等。</li><li>响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。</li></ol></li></ul><p><span id="id2"><span></span></span></p><h3 id="2-Servlet"><a href="#2-Servlet" class="headerlink" title="2. Servlet"></a>2. Servlet</h3><p>servlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。</p><h4 id="2-1-Servlet编写步骤："><a href="#2-1-Servlet编写步骤：" class="headerlink" title="2.1 Servlet编写步骤："></a>2.1 Servlet编写步骤：</h4><ol><li>编写一个Java类，继承HttpServlet类</li><li>重新service方法</li><li>在service方法中，对用户请求进行响应。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解：添加访问的网址</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.设置响应体的编码，以及内容类型</span></span><br><span class="line">res.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="comment">//2.得到响应体输出的打印流</span></span><br><span class="line">PrintWriter out = res.getWriter();</span><br><span class="line"><span class="comment">//3.打印文字</span></span><br><span class="line">out.println(<span class="string">"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-配置ervlet类的访问网址"><a href="#2-2-配置ervlet类的访问网址" class="headerlink" title="2.2 配置ervlet类的访问网址"></a>2.2 配置ervlet类的访问网址</h4><ul><li>web3.0版本之后使用注解的方式配置ervlet类的访问网址</li><li>web3.0版本之前配置Servlet访问网址的方式：<ul><li>将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 </li><li>配置Servlet类的别名，并给指定别名的Servlet添加映射网址。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet类别名，用于后续添加映射网址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet类全名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>day01_Servlet.demo1.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给指定别名的Servlet添加映射网址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-Servlet生命周期"><a href="#2-3-Servlet生命周期" class="headerlink" title="2.3 Servlet生命周期"></a>2.3 Servlet生命周期</h4><ul><li>实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用</li><li>创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。</li><li>销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。</li><li>tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：<ul><li>init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。</li><li>service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。</li><li>destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。</li></ul></li></ul><h4 id="2-4-get和post区别"><a href="#2-4-get和post区别" class="headerlink" title="2.4 get和post区别"></a>2.4 get和post区别</h4><ul><li>GET请求：<ul><li>没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&amp;连接键值对。</li><li>只能传输字符串类型参数</li><li>浏览器url地址最大长度4kb</li><li>数据传输时，参数在url中明文显示，不安全。</li></ul></li><li>POST请求：<ul><li>有请求体，是一个单独的数据包，用于存储请求中的多个参数</li><li>可传输任意类型的数据，进行文件上传必须POST请求</li><li>可以传递的数据大小，理论上没有上限</li><li>数据传输时在单独的数据包，较为安全。</li></ul></li></ul><h4 id="2-5-接收请求中的参数"><a href="#2-5-接收请求中的参数" class="headerlink" title="2.5 接收请求中的参数"></a>2.5 接收请求中的参数</h4><ol><li>根据参数的名称，接收参数的单个值<ul><li>String value = <strong>request.getParameter(String name)</strong>;</li></ul></li><li>根据参数的名称，接收一组参数的值<ul><li>String[] values = <strong>request.getParameterValues(String name)</strong>;</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">  request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">  response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">  <span class="comment">//1.接收</span></span><br><span class="line">  String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">  String[] password = request.getParameterValues(<span class="string">"password"</span>);</span><br><span class="line">  <span class="comment">//2.打印</span></span><br><span class="line">  System.out.println(<span class="string">"username:"</span> + username);</span><br><span class="line">  System.out.println(<span class="string">"password:"</span> + password[<span class="number">0</span>]);</span><br><span class="line">  System.out.println(<span class="string">"password2:"</span> + password[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">//3.浏览器输出</span></span><br><span class="line">  response.getWriter().append(<span class="string">"&lt;div&gt;很遗憾注册失败，点击&lt;a href=\"demo1.html\"&gt;重新注册&lt;/a&gt;&lt;/div&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-乱码处理"><a href="#2-6-乱码处理" class="headerlink" title="2.6 乱码处理"></a>2.6 乱码处理</h4><h4 id="2-6-1-乱码情况："><a href="#2-6-1-乱码情况：" class="headerlink" title="2.6.1 乱码情况："></a>2.6.1 乱码情况：</h4><ul><li>浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。</li><li>tomcat8版本之前(不包含tomcat8版本), GET请求乱码</li><li>任何版本, POST请求乱码</li></ul><h4 id="2-6-2-请求乱码处理："><a href="#2-6-2-请求乱码处理：" class="headerlink" title="2.6.2 请求乱码处理："></a>2.6.2 请求乱码处理：</h4><ul><li>适用于所有乱码问题：(Tomcat8之后get无乱码)<ol><li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li><li>将接收到的中文乱码重新编码：</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">String userName = <span class="keyword">new</span> String( name.getByte(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><ul><li>仅适用于POST请求：<ol><li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li><li>Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li></ol></li></ul><h4 id="2-6-3-响应乱码的处理："><a href="#2-6-3-响应乱码的处理：" class="headerlink" title="2.6.3 响应乱码的处理："></a>2.6.3 响应乱码的处理：</h4><ul><li>方式一：设置响应的内容类型, 以及编码格式:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>;</li><li>方式二：进设置编码格式, 不设置响应内容类型:<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code>(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);</li></ul><h4 id="2-7-Servlet的创建时机"><a href="#2-7-Servlet的创建时机" class="headerlink" title="2.7 Servlet的创建时机"></a>2.7 Servlet的创建时机</h4><ul><li>通过web.xml配置Servlet, 可以修改Servlet加载的时机。</li><li>可以给Servlet节点，添加<code>&lt;load-on-startup&gt;</code>节点来制定servlet启动顺序。</li><li>节点中的值为数字：<ul><li><code>-1</code>：默认-1，表示当用户第一次请求时，创建对象</li><li><code>&gt;=0</code>：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>demo.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id3"><span></span></span></p><h3 id="3-请求的转发与重定向"><a href="#3-请求的转发与重定向" class="headerlink" title="3. 请求的转发与重定向"></a>3. 请求的转发与重定向</h3><h4 id="3-1-请求对象request的常用操作"><a href="#3-1-请求对象request的常用操作" class="headerlink" title="3.1 请求对象request的常用操作"></a>3.1 请求对象request的常用操作</h4><ol><li>getMethod() : 得到请求的方式</li><li>getRequestURI() : 获取浏览器请求地址</li><li>getRemoteAddr() : 获取客户端ip地址</li><li>getRemoteHost() : 获取客户端名称</li><li>getServerName() : 获取服务器名称</li><li>getServerPort() : 获取服务器端口号</li><li>getQueryString() : 获取get请求参数字符串，其他请求返回null</li></ol><h4 id="3-1-请求的转发与重定向注意事项"><a href="#3-1-请求的转发与重定向注意事项" class="headerlink" title="3.1 请求的转发与重定向注意事项"></a>3.1 请求的转发与重定向注意事项</h4><ul><li>请求转发与重定向操作，必须要有出口。</li><li>当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了</li></ul><h4 id="3-2-转发"><a href="#3-2-转发" class="headerlink" title="3.2 转发*"></a>3.2 转发*</h4><ul><li>一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理</li><li>步骤：<ol><li>获取请求转发器：<code>RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;);</code></li><li>进行转发操作：<code>rd.forward(request, response);</code></li></ol></li><li>因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:<ul><li><code>request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response);</code></li></ul></li><li>特点：<ul><li>转发过程中，多个web组件之间共享一个请求对象request与响应对象response</li><li>在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变</li><li>转发不能跨项目实现</li><li>比重定向效率更高</li></ul></li></ul><h4 id="3-3-重定向"><a href="#3-3-重定向" class="headerlink" title="3.3 重定向*"></a>3.3 重定向*</h4><ul><li>一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址</li><li>格式：<code>response.sendRedirect(&quot;重定向地址&quot;)</code>；</li><li>原理：当客户端请求服务器时，发起重定向流程：<ol><li>给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.</li><li>当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.</li><li>浏览器自动发起新的请求 , 跳转到新地址.</li></ol></li><li>特点：<ol><li>重定向会产生两个请求对象，多个请求对象中数据不互通</li><li>浏览器地址发生了改变</li><li>重定向可以跨域实现</li><li>比转发效率低</li></ol></li></ul><p><span id="id4"><span></span></span></p><h3 id="4-上下文对象ServletContext"><a href="#4-上下文对象ServletContext" class="headerlink" title="4. 上下文对象ServletContext"></a>4. 上下文对象ServletContext</h3><ul><li>用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享</li><li>每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。</li></ul><p>获取ServletContext对象：<code>ServletContext context = getServletContext();</code></p><ul><li>常用方法<ul><li>context.setAttributes(String key, Objexct value); //设置替换数据</li><li>context.getAttributes(String key); //获取数据</li><li>context.removeAttributes(String key); //删除数据</li><li>context.getRealPath(“/“); //获取项目运行时所在文件路径</li></ul></li></ul><p><span id="id5"><span></span></span></p><h3 id="5-会话跟踪（状态管理）"><a href="#5-会话跟踪（状态管理）" class="headerlink" title="5. 会话跟踪（状态管理）"></a>5. 会话跟踪（状态管理）</h3><ul><li><p>存在两种实现：</p><ol><li>cookie: 将浏览器产生的状态存储在浏览器中</li><li>Session: 将浏览器产生的状态存储在服务器中</li></ol></li><li><p>cookie技术原理：</p><ul><li>服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，</li><li>浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来</li><li>当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器</li></ul></li><li><p>Session技术原理：</p><ul><li>当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，</li><li>该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器</li><li>浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。</li></ul></li></ul><h4 id="5-1-Cookie"><a href="#5-1-Cookie" class="headerlink" title="5.1 Cookie"></a>5.1 Cookie</h4><ul><li>创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对<ul><li><code>Cookie cookie = new Cookie(String key, String value);</code></li><li>注意：tomcat8.5版本之前，cookie无法出场中文</li></ul></li><li>通过响应对象，将cookie添加到响应头,可添加多个<ul><li><strong>response.addCookie(Cookie cookie)</strong>;</li></ul></li><li>通过请求头得到cookie数组，没有则返回null<ul><li><strong>Cookie[] cookies = request.getCookies()</strong>;</li><li>取键：cookie.getName();</li><li>取值：cookie.getValue()</li></ul></li><li>Cookie的存储时长：<ul><li>cookie.setMaxAge(int 秒)；<ul><li>正数：倒计时秒数</li><li>0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它</li><li>负数：默认-1，表示会话结束时自动删除（关闭浏览器）</li></ul></li></ul></li><li>Cookie的存储路径问题<ul><li>存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同</li><li>为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“/“);</li></ul></li></ul><h4 id="5-2-Cookie的优缺点"><a href="#5-2-Cookie的优缺点" class="headerlink" title="5.2 Cookie的优缺点"></a>5.2 Cookie的优缺点</h4><ul><li>缺点：<ol><li>Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。</li><li>数据存储在客户的计算机中，不安全，不建议存储安全敏感数据</li><li>保存数据量有限制，大约4kb左右</li><li>依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除</li></ol></li><li>优点：<ol><li>分散服务器的压力</li></ol></li></ul><h4 id="5-3-Session"><a href="#5-3-Session" class="headerlink" title="5.3 Session"></a>5.3 Session</h4><ul><li>获取Session<ul><li>格式1：<strong>request.getSession()</strong>;//等价参数传true</li><li>格式2：request.getSession(boolean isNew);<ul><li>true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回</li><li>false，根据浏览器的SessionId查找一个session，若没有就返回null</li></ul></li></ul></li><li>Session常用方法<ul><li><strong>session.setAttribute(String key, object value)</strong>;//设置/替换值</li><li><strong>session.getAttribute(String key)</strong>;//获取值</li><li>session.invalidate();//销毁</li></ul></li><li>设置session存活时长<ul><li>默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。</li><li>可以通过修改配置文件，修改所有的session时长<ul><li>修改<code>conf/web.xml</code>的<code>&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt;</code></li></ul></li><li>可以通过session对象，修改单个对象的session时长<ul><li>void session.setMaxInactiveInterval(int seconds)</li></ul></li></ul></li></ul><h4 id="5-4-Session的优缺点"><a href="#5-4-Session的优缺点" class="headerlink" title="5.4 Session的优缺点"></a>5.4 Session的优缺点</h4><ul><li>缺点：<ul><li>数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源</li></ul></li><li>优点：<ol><li>数据存储在服务器中，安全</li><li>数据类型为Object，在Java中表示可以存储所有类型的数据</li><li>session存储的数据大小，理论上无限的。</li></ol></li></ul><h4 id="5-5-Cookie和Session的使用"><a href="#5-5-Cookie和Session的使用" class="headerlink" title="5.5 Cookie和Session的使用"></a>5.5 Cookie和Session的使用</h4><ul><li>Cookie和Session不是互斥的，是相辅相成的</li><li>在项目开发时：<ul><li>对安全敏感的数据，存储在session中</li><li>对安全不敏感的字符串数据，可以选择存储在Cookie中</li><li>对于大的数据，应该存在数据库和文件中</li></ul></li></ul><blockquote><p>注意：cookie和session是为了管理状态而非存储数据。</p></blockquote><p><span id="id6"><span></span></span></p><h3 id="6-JSP"><a href="#6-JSP" class="headerlink" title="6.JSP"></a>6.JSP</h3><h4 id="6-1-JSP语法基础"><a href="#6-1-JSP语法基础" class="headerlink" title="6.1 JSP语法基础"></a>6.1 JSP语法基础</h4><ul><li><p>Java Server Pages：java动态网页技术</p></li><li><p>JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应</p></li><li><p>注意：</p><ol><li>JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet</li><li>执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html</li></ol></li><li><p>JSP语法结构</p><ol><li>html代码</li><li>Java代码</li><li>Jsp特有的语法结构</li></ol></li><li><p>Java代码声明区：指的是类的成员位置</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">  <span class="comment">// Java代码声明区</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><ul><li>Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  <span class="comment">// Java代码执行区</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><ul><li>JSP输出表达式<ul><li>用于快速的将Java中的数据，输出到网页中..</li><li>语法格式：<code>&lt;%=数据 %&gt;</code>，编译后被转换成out.print(数据)</li></ul></li><li>JSP注释：<ul><li>html中可以用<code>&lt;!-- --&gt;</code></li><li>java中可以用<code>//，/**/，/** */</code></li><li>jsp注释<code>&lt;%-- --%&gt;</code><ul><li>html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略</li></ul></li></ul></li></ul><h4 id="6-2-JSP三大指令"><a href="#6-2-JSP三大指令" class="headerlink" title="6.2 JSP三大指令"></a>6.2 JSP三大指令</h4><ul><li>page指令</li><li>include指令</li><li>taglib指令</li></ul><ul><li>指令使用格式：&lt;%@ 指令名称 属性1=值 属性2=值 属性n=值 %&gt;<br>*语法上，JSP允许在单个页面出现多个相同的JSP指令</li></ul><h5 id="6-2-1-page指令"><a href="#6-2-1-page指令" class="headerlink" title="6.2.1 page指令"></a>6.2.1 page指令</h5><ul><li>用于配置页面信息</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page</span><br><span class="line">  language=<span class="string">"java"</span>：语言</span><br><span class="line">  contentType=<span class="string">"text/html;charset=utf-8"</span>：响应的内容类型，以及响应的编码格式</span><br><span class="line">  pageEncoding=<span class="string">"UTF-8"</span>：文件存储的编码格式</span><br><span class="line">  extends=<span class="string">"继承的父类"</span></span><br><span class="line">  buffer=<span class="string">"数字/none"</span>：是否允许缓存，默认值<span class="number">8</span>kb</span><br><span class="line">  autoFlush=<span class="string">"true/false"</span>：是否自动清除缓存，默认<span class="keyword">true</span></span><br><span class="line">  session=<span class="string">"true/false"</span>：是否提前准备session对象，默认<span class="keyword">true</span></span><br><span class="line">  isThreadSafe=<span class="string">"true/false"</span>：是否线程安全的</span><br><span class="line">  <span class="keyword">import</span>=<span class="string">"java.util.List"</span>：用于导包，多个包使用<span class="string">","</span>隔开</span><br><span class="line">  errorPage=<span class="string">"网址"</span>：当页面发生BUG后，显示哪个页面</span><br><span class="line">  isErrorPage=<span class="string">"true/false"</span>：当前页面是否是一个错误处理页面，如果结果为<span class="keyword">true</span>，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="6-3-项目发生错误时，统一的处理方式"><a href="#6-3-项目发生错误时，统一的处理方式" class="headerlink" title="6.3 项目发生错误时，统一的处理方式"></a>6.3 项目发生错误时，统一的处理方式</h4><ol><li>打开项目的web.xml</li><li>加入子节点<code>&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt;</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>include指令：用于将jsp或html引入到另一个jsp中<ul><li>语法格式：<code>&lt;%@ include file=&quot;地址&quot; %&gt;</code></li></ul></li><li>include动作：用于将jsp或html引入到另一个jsp中<ul><li>语法格式：<code>&lt;jsp:include page=&quot;地址&quot;&gt;</code></li></ul></li></ul><blockquote><p>include指令 与 include动作区别：</p><ul><li>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp =&gt; 一个Servlet）</li><li>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp =&gt; 多个Servlet）</li></ul></blockquote><p><span id="id7"><span></span></span></p><h3 id="7-内置对象-隐含对象"><a href="#7-内置对象-隐含对象" class="headerlink" title="7.内置对象(隐含对象)"></a>7.内置对象(隐含对象)</h3><ul><li>在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。</li><li>内置对象通常是我们会主动创建的对象</li></ul><h4 id="7-1-九大内置对象"><a href="#7-1-九大内置对象" class="headerlink" title="7.1 九大内置对象"></a>7.1 九大内置对象</h4><ol><li>request<ul><li>对象类型：java.servlet.<strong>HttpServletRequest</strong></li><li>request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。</li></ul></li><li>response<ul><li>对象类型：javax.servlet.<strong>HttpServletResponse</strong></li><li>response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。</li></ul></li><li>config<ul><li>对象类型：javax.servlet.<strong>ServletConfig</strong></li><li>在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。</li></ul></li><li>out<ul><li>对象类型：javax.servlet.jsp.<strong>JspWriter</strong></li><li>在JSP开发过程中使用得最为频繁的对象</li></ul></li><li>page<ul><li>对象类型：java.lang.<strong>Object</strong></li><li>page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。</li></ul></li><li>pageContext<ul><li>对象类型：<strong>pageContext</strong></li><li>pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</li></ul></li><li>session<ul><li>对象类型：java.servlet.http.<strong>HttpSession</strong></li><li>session是与请求有关的会话期，用来表示和存储当前页面的请求信息。</li></ul></li><li>application<ul><li>对象类型：javax.servlet.<strong>ServletContext</strong></li><li>用于实现用户之间的数据共享（多使用于网络聊天系统）。</li></ul></li><li>exception<ul><li>对象类型：java.lang.<strong>Throwable</strong></li><li>作用 exception内置对象是用来处理页面出现的异常错误。</li></ul></li></ol><h4 id="7-2-JSP四大域对象"><a href="#7-2-JSP四大域对象" class="headerlink" title="7.2 JSP四大域对象"></a>7.2 JSP四大域对象</h4><ul><li>九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据</li><li>域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法：<ol><li>存储数据：setAttribute(String key, Object value);</li><li>获取数据：Object value = getAttribute(String);</li><li>删除数据： removeAttribute(String key);</li></ol></li><li>四大内置对象，分别指的是：<ol><li>pageContext: (作用域：1个页面)<ul><li>页面上下文，存储在pageContext中的数据, 作用域是最小的,  pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁.</li></ul></li><li>request: (作用域：一次请求，如果请求被转发，可能跨越多个页面)<ul><li>请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁.</li></ul></li><li>session: (作用域：一次会话，一次会话可能包含多个请求)<ul><li>会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。</li></ul></li><li>application: (域范围：一次服务，应用从启动到关闭application一直都在)<ul><li>Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用.</li></ul></li></ol></li></ul><h4 id="7-3-EL表达式"><a href="#7-3-EL表达式" class="headerlink" title="7.3 EL表达式"></a>7.3 EL表达式</h4><ul><li>用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。</li><li>格式：<code>${表达式}</code></li><li>EL表达式用于运算<ul><li>在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是:   246 </li></ul></li><li>用于取出域对象中的数据<ul><li>取出数据直接输出：<code>${域对象中存储的键}</code></li><li>如果取出的数据不存在, 则不输出 (不可能显示null)</li></ul></li><li>取出对象数据的属性值:<ul><li>格式1： ${对象存储的键.属性名}</li><li>格式2： ${对象存储的键[“属性名”]}</li><li>格式3(动态取值)： ${对象存储的键[属性存储的键]}</li></ul></li><li>取出集合中的数据<ul><li>格式: ${集合存储时的key[下标]}</li></ul></li></ul><h4 id="7-4-EL表达式取出数据的流程"><a href="#7-4-EL表达式取出数据的流程" class="headerlink" title="7.4 EL表达式取出数据的流程"></a>7.4 EL表达式取出数据的流程</h4><ul><li>四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据.</li><li>步骤:<ol><li>先从pageContext中, 寻找数据是否存在.</li><li>如果pageContext中数据不存在, 则去request中寻找数据是否存在</li><li>如果request 中数据不存在, 则去session中寻找数据是否存在</li><li>如果session中数据不存在, 则去application中寻找数据是否存在</li><li>如果application中数据不存在,则不输出任何数据.</li></ol></li></ul><p><span id="id8"><span></span></span></p><h3 id="8-taglib指令"><a href="#8-taglib指令" class="headerlink" title="8. taglib指令"></a>8. taglib指令</h3><p>用于在JSP文件中，引入标签库文件。</p><ul><li>格式： <code>&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt;</code><ul><li>prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：<code>&lt;标签库名称:标签名&gt;</code></li><li>uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性</li></ul></li><li>JSTL(JSP Standard Tag Library): JSP标准标签库<ul><li>使用时，需要引入jar文件</li><li>if 标签，格式：&lt;库名称:if text=”${ booble }”&gt;</li><li>forEach 标签，格式：&lt;库名称:forEach items=”${ List }” var=”item”&gt;</li></ul></li><li>自定义标签库:<ol><li>编写一个Java类, 继承SimpleTagSupport类.</li><li>重写父类的doTag方法.</li><li>在doTag方法中, 通过getJspContext方法,  的到JSP页面的上下文</li><li>通过上下文对象, 得到JSP中的out对象, </li><li>通过out对象,  向网页中输出内容</li><li>编写tld文件 , 描述标签库 以及 标签.</li></ol></li></ul><p>自定义标签库案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTag1</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ArrayList&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        data.add(<span class="string">"流水在碰到底处时才会释放活力。——歌德"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">        JspContext context = getJspContext();</span><br><span class="line">        JspWriter out = context.getOut();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> index = r.nextInt(data.size());</span><br><span class="line">        out.println(<span class="string">"&lt;span&gt;"</span>+data.get(index)+<span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述标签库 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是对于标签库的介绍 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>我们这个标签库, 是闲的慌 , 所以写的.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述标签库的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>xdl<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签库的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>11.88<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 建议的短命名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>xdl<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签库的表示, 用于引入时匹配标签库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://shuidianshuisg.com<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开始描述标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对于标签的介绍 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>这个标签用于随机向网页中, 输出一句名言<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>heiheihei<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签所对应的的Java类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.xdl.tag.MyTag1<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签的内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="id9"><span></span></span></p><h3 id="9-JavaWeb三大组件-Servlet-filter-Lister"><a href="#9-JavaWeb三大组件-Servlet-filter-Lister" class="headerlink" title="9. JavaWeb三大组件(Servlet,filter,Lister)"></a>9. JavaWeb三大组件(Servlet,filter,Lister)</h3><h4 id="9-1-Filter过滤器"><a href="#9-1-Filter过滤器" class="headerlink" title="9.1 Filter过滤器"></a>9.1 Filter过滤器</h4><ul><li>请求的过滤器，面向切面编程思想（AOP）</li><li>使用步骤：<ol><li>编写一个类，实现Filter接口</li><li>通过注解或web.xml配置过滤器规则</li></ol></li><li>过滤器链：<ul><li>当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求</li></ul></li><li>过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml）<ul><li>注解方式：按照类名的自然顺序先后</li><li>web.xml配置方式：按照web.xml配置顺序，先后执行</li></ul></li><li>案例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/home.jsp"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Filter即将销毁时执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有新的请求, 满足了过滤器的过滤规则,  正在过滤</span></span><br><span class="line"><span class="comment">     * 参数1.   请求对象</span></span><br><span class="line"><span class="comment">     * 参数2. 响应对象</span></span><br><span class="line"><span class="comment">     * 参数3.  过滤器链对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"过滤管理员登录的过滤器 正在执行"</span>);</span><br><span class="line">        <span class="comment">//1.    从请求中, 得到session</span></span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="comment">//2.    判断session中是否存在username</span></span><br><span class="line">        Object username = session.getAttribute(<span class="string">"username"</span>);</span><br><span class="line">        <span class="comment">//3.    如果存在, 且值为admin , 则放行 </span></span><br><span class="line">        <span class="keyword">if</span>(username !=<span class="keyword">null</span> &amp;&amp; username.equals(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4.    否则拦截, 并响应, 提示请先以管理员身份登录</span></span><br><span class="line">            response.getWriter().append(<span class="string">"&lt;script&gt;alert('请先以管理员身份登录, 再访问管理页面');window.location.href='login.jsp'&lt;/script&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Filter初始化时 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web.xml配置方式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.xdl.demo1.EnCodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/home.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-Listener监听器"><a href="#9-2-Listener监听器" class="headerlink" title="9.2 Listener监听器"></a>9.2 Listener监听器</h4><ul><li>监听服务器的一些状态事件，事件驱动机制。</li><li>分为两类状态事件：<ul><li>服务器中组件的生命周期</li><li>一些域对象中数据变化的事件</li></ul></li><li>监听服务器的启动与关闭：ServletContextListener</li><li>监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener</li><li>监听Session会话的开启与关闭：HttpSessionListener </li><li>监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener </li></ul><p><span id="id10"><span></span></span></p><h3 id="10-JSON在Java中的使用"><a href="#10-JSON在Java中的使用" class="headerlink" title="10. JSON在Java中的使用"></a>10. JSON在Java中的使用</h3><ul><li>JSON：JavaScript Object Notation</li><li>GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入jar文件</span></span><br><span class="line">Gson g = <span class="keyword">new</span> Gson();</span><br><span class="line">String str = g.toJson(Java对象);<span class="comment">//转换JSON字符串</span></span><br><span class="line">类型 对象名 = g.fromJson(Json字符串, 类型.class);<span class="comment">//转换为Java对象</span></span><br></pre></td></tr></table></figure><p><span id="id11"><span></span></span></p><h3 id="11-AJAX"><a href="#11-AJAX" class="headerlink" title="11. AJAX"></a>11. AJAX</h3><ul><li>一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作</li><li>Ajax请求的状态（readyState）<ul><li>0：正在初始化</li><li>1：请求正在发送</li><li>2：请求发送完毕</li><li>3：服务器开始响应</li><li>4：响应接收完毕，连接断开</li></ul></li><li>Ajax响应的状态（status）<ul><li>200：成功</li><li>404：找不到资源</li><li>500：服务器错误</li></ul></li></ul><h4 id="11-1-GET请求AJAX"><a href="#11-1-GET请求AJAX" class="headerlink" title="11.1 GET请求AJAX"></a>11.1 GET请求AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"地址?参数列表"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//通过xhr.responseText接收响应体</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//失败处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h4 id="11-2-POST请求AJAX"><a href="#11-2-POST请求AJAX" class="headerlink" title="11.2 POST请求AJAX"></a>11.2 POST请求AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"地址"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//通过xhr.responseText接收响应体</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//失败处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//POST请求设置请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>); </span><br><span class="line">xhr.send(参数列表); <span class="comment">//发送请求参数</span></span><br></pre></td></tr></table></figure><h4 id="11-2-Jquery中的AJAX"><a href="#11-2-Jquery中的AJAX" class="headerlink" title="11.2 Jquery中的AJAX"></a>11.2 Jquery中的AJAX</h4><ol><li><code>$.ajax({url,[settings]})</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"请求的网址"</span>,</span><br><span class="line">    type:<span class="string">"请求方式GET/POST..."</span>,</span><br><span class="line">    <span class="keyword">async</span>:<span class="string">"请求是否异步, 默认true"</span>,</span><br><span class="line">    data:<span class="string">"请求的参数列表, 格式与GET请求?后的格式一致"</span>,</span><br><span class="line">    dataType:<span class="string">"TEXT或JSON"</span>,<span class="comment">//服务器返回的数据类型</span></span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="comment">//当服务器响应状态码在200-299之间时, 这里执行</span></span><br><span class="line">        <span class="comment">//参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//当服务器响应状态码不再200-299之间时, 这里执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>$.get(url, [data], [callback], [type])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>("请求的网址", &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><code>$.post(url, [data], [callback], [type])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;, <span class="string">"json"</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li><code>$.getJSON(url, [data], [callback])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li><code>jquery对象.load(url, [data], [callback])</code></li></ol><ul><li>载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#dom"</span>).load(<span class="string">"请求的网址"</span>, &#123; 请求参数键值对 &#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//加载成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="11-3-Vue中的AJAX"><a href="#11-3-Vue中的AJAX" class="headerlink" title="11.3 Vue中的AJAX"></a>11.3 Vue中的AJAX</h4><ul><li>使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js</li><li>不创建Vue对象的情况下, 使用的ajax:<ul><li><code>Vue.http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li><li><code>Vue.http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li></ul></li><li>创建Vue实例, 使用ajax<ul><li><code>this.$http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li><li><code>this.$http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GET请求: 传递参数列表: </span></span><br><span class="line">&#123;</span><br><span class="line">    params:&#123;</span><br><span class="line">        参数名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">        参数名<span class="number">2</span>:值<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">POST请求: 传递参数列表:</span><br><span class="line">&#123;</span><br><span class="line">    参数名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">    参数名<span class="number">2</span>:值<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>success函数 与 error函数<ul><li>格式: function(res){} //res , 就是响应对象, 包含了响应的相关信息</li><li>响应对象的常用属性:<ol><li>url : 响应的网址</li><li>body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string</li><li>ok  : boolean值, 响应码在200-299之间时  为 true</li><li>status : 响应码, 例如: 200,302,404,500</li><li>statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok</li></ol></li><li>响应对象的常用函数:<ol><li>text() : 以字符串的形式, 返回响应体</li><li>json() : 以对象的形式, 返回响应体</li><li>blob() : 以二进制的形式 , 返回响应体.</li></ol></li></ul></li></ul><h4 id="11-4-AJAX缓存问题"><a href="#11-4-AJAX缓存问题" class="headerlink" title="11.4 AJAX缓存问题"></a>11.4 AJAX缓存问题</h4><ul><li>浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。</li><li>缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。</li><li>在请求地址加上随机参数可以比避免缓存，如:<code>&quot;s1.do?time=&quot;+new Date().getTime();</code></li></ul><h4 id="11-5-AJAX跨域问题"><a href="#11-5-AJAX跨域问题" class="headerlink" title="11.5 AJAX跨域问题"></a>11.5 AJAX跨域问题</h4><ul><li>默认编写的Servlet . 不允许其他网站的ajax跨域请求.</li><li>我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域:<ul><li><code>response.addHeader(&quot;Access-Control-allow-Origin&quot;,&quot;*&quot;)</code>;</li><li><code>response.addHeader(&quot;Access-Control-allow-Methods&quot;,&quot;GET,POST&quot;)</code>;</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb编程" scheme="http://chaooo.github.io/categories/JavaWeb%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaEE" scheme="http://chaooo.github.io/tags/javaEE/"/>
    
  </entry>
  
  <entry>
    <title>十一、JavaSE数据结构与算法入门</title>
    <link href="http://chaooo.github.io/2019/07/15/11_JavaSE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8.html"/>
    <id>http://chaooo.github.io/2019/07/15/11_JavaSE数据结构与算法入门.html</id>
    <published>2019-07-15T10:12:38.000Z</published>
    <updated>2019-07-20T15:08:05.419Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。</p><a id="more"></a><ol><li><a href="#id1">Java数据结构</a></li><li><a href="#id2">时间复杂度与空间复杂度</a></li><li><a href="#id3">算法的基本概念</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-Java数据结构-Data-Structure"><a href="#1-Java数据结构-Data-Structure" class="headerlink" title="1.Java数据结构(Data Structure)"></a>1.Java数据结构(Data Structure)</h3><h4 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h4><ol><li>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</li><li>而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。</li><li>而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</li></ol><h4 id="1-2-Java数据结构"><a href="#1-2-Java数据结构" class="headerlink" title="1.2 Java数据结构"></a>1.2 Java数据结构</h4><ul><li>数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。<ol><li>线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。</li><li>非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。</li></ol></li><li>按数据的存储结构分为：顺序存储结构和链式存储结构<ol><li>顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 </li><li>链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。</li></ol></li></ul><h4 id="1-2-1-线性数据结构"><a href="#1-2-1-线性数据结构" class="headerlink" title="1.2.1 线性数据结构"></a>1.2.1 线性数据结构</h4><p>常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。</p><ol><li>一维数组<ul><li>在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。</li><li>ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。</li><li>数组的插入/更新/删除效率比较低，而<strong>查询效率非常高</strong>,查询效率时间复杂度是1。</li></ul></li><li>线性表<ul><li>线性表是有序的储存结构、链式的储存结构。</li><li>链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。</li><li>常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。</li><li>线性表<strong>插入效率比较高</strong>，而查询效率就比较低（add(),get()）。</li></ul></li><li>栈Stack<ul><li>栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。</li></ul></li><li>队列<ul><li>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。</li><li>Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</li><li>使用场景也非常多，如线程池，mq，连接池等。</li></ul></li><li>串<ul><li>串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）</li></ul></li></ol><h4 id="1-2-2-非线性数据结构"><a href="#1-2-2-非线性数据结构" class="headerlink" title="1.2.2 非线性数据结构"></a>1.2.2 非线性数据结构</h4><p>常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。</p><ol><li>多维数组<ul><li>Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</li></ul></li><li>集合<ul><li>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</li></ul></li><li>树<ul><li>在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。</li><li>除了根节点，其他结点有且只有一个直接父节点</li><li>每个结点可以有任意多个直接子节点。</li><li>树的数据结构又分为：<ol><li>自由树/普通树：对子节点没有任何约束。</li><li>二叉树：每个节点最多含有两个子节点的树称为二叉树。</li><li>二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）</li><li>B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。</li><li>B+tree：又称B+。是B-树的变体，也是一种多路搜索树。</li></ol></li></ul></li><li>Hash<ul><li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）</li><li>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li><li>Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。</li><li>Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</li><li>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</li></ul></li><li>图<ul><li>图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</li></ul></li></ol><h3 id="2-时间复杂度与空间复杂度"><a href="#2-时间复杂度与空间复杂度" class="headerlink" title="2. 时间复杂度与空间复杂度"></a>2. 时间复杂度与空间复杂度</h3><h4 id="2-1-时间复杂度"><a href="#2-1-时间复杂度" class="headerlink" title="2.1 时间复杂度"></a>2.1 时间复杂度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为<strong>T(n)</strong></p><p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。</p><p>有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。</p><p>常见的算法的时间 复杂度之间的关系为：<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</code></p><h4 id="2-2-空间复杂度"><a href="#2-2-空间复杂度" class="headerlink" title="2.2 空间复杂度"></a>2.2 空间复杂度</h4><p>空间复杂度：算法所需存储空间的度量，记作：<code>S(n)=O( f(n) )</code>，其中 n 为问题的规模。</p><p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p><p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p><blockquote><ul><li>空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。</li><li>时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。</li><li>稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。</li></ul></blockquote><h3 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h3><ul><li>算法: 简单来说就是解决问题的步骤。</li><li>算法的五个特征:有穷性，确定性，可行性，有输入，有输出<ol><li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li><li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li><li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li><li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li><li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li></ol></li><li>算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求<ul><li>描述算法的速度必须要和数据项的个数联系起来。</li><li>算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；</li><li>一个算法的效率越高越好，而存储量是越低越好。</li></ul></li></ul><h3 id="4-常用的查找算法"><a href="#4-常用的查找算法" class="headerlink" title="4. 常用的查找算法"></a>4. 常用的查找算法</h3><h4 id="4-1-线性（顺序）查找算法"><a href="#4-1-线性（顺序）查找算法" class="headerlink" title="4.1 线性（顺序）查找算法"></a>4.1 线性（顺序）查找算法</h4><ol><li>使用目标元素与样本数列中第一个元素起依次进行比较</li><li>若目标元素等于样本元素，则表示查找成功</li><li>若目标元素与样本元素比较完毕也不相等，则表示查找失败</li></ol><h4 id="4-2-二分查找算法"><a href="#4-2-二分查找算法" class="headerlink" title="4.2 二分查找算法"></a>4.2 二分查找算法</h4><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。</p><ul><li>普通循环实现二分查找算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(srcArray, <span class="number">28</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找普通循环实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcArray 有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 查找元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span> srcArray[], <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = srcArray.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == srcArray[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = srcArray.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p></blockquote><ul><li>递归实现二分查找递归实现算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(srcArray, <span class="number">0</span>,<span class="number">15</span>,<span class="number">28</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcArray  有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 数组低地址下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end   数组高地址下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  查找元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 查找元素不存在返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span> srcArray[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">    <span class="keyword">if</span> (srcArray[mid] == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(srcArray, mid + <span class="number">1</span>, end, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(srcArray, start, mid - <span class="number">1</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p></blockquote><h3 id="4-常用的排序算法"><a href="#4-常用的排序算法" class="headerlink" title="4. 常用的排序算法"></a>4. 常用的排序算法</h3><ul><li>八大排序算法<ul><li>一、直接插入排序（Insertion Sort）</li><li>二、希尔排序（Shell Sort）</li><li>三、选择排序（Selection Sort）</li><li>四、堆排序（Heap Sort）</li><li>五、冒泡排序（Bubble Sort）</li><li>六、快速排序（Quick Sort）</li><li>七、归并排序（Merging Sort）</li><li>八、基数排序（Radix Sort）</li></ul></li></ul><h4 id="4-1-冒泡排序算法"><a href="#4-1-冒泡排序算法" class="headerlink" title="4.1 冒泡排序算法"></a>4.1 冒泡排序算法</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><ul><li><p>算法描述：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</li></ol></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//声明标志位</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="keyword">int</span> temp = arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j++<span class="number">1</span>] = temp;</span><br><span class="line">          flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//若此轮结束flag还是为true,则证明已经有序</span></span><br><span class="line">      <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>冒泡排序算法复杂度:</p><ul><li>平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)</li><li>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</li></ul></li></ul><blockquote><p>Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。&lt;br&gt;算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>十、JavaSE常用设计模式</title>
    <link href="http://chaooo.github.io/2019/07/15/10_JavaSE%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://chaooo.github.io/2019/07/15/10_JavaSE常用设计模式.html</id>
    <published>2019-07-15T00:34:55.000Z</published>
    <updated>2019-07-20T15:03:36.395Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><a id="more"></a><ol><li><a href="#id1">常用的设计原则</a></li><li><a href="#id2">设计模式分类</a></li><li><a href="#id3">单例模式</a></li><li><a href="#id4">模板模式</a></li><li><a href="#id5">工厂模式</a></li><li><a href="#id6">适配器模式</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-常用的设计原则"><a href="#1-常用的设计原则" class="headerlink" title="1.常用的设计原则"></a>1.常用的设计原则</h3><ul><li><strong>开闭原则</strong>：对扩展开发，对修改方便</li><li><strong>里氏代换原则</strong>：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）</li><li><strong>依赖倒转原则</strong>：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li><li><strong>接口隔离原则</strong>：尽量多依赖小接口而不是大接口</li><li><strong>迪米特法则</strong>（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。</li><li><strong>合成复用原则</strong>：尽量多使用合成/聚合的方式，而不是继承的方式。</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2.设计模式分类"></a>2.设计模式分类</h3><h4 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><ul><li>设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。</li><li>设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。</li><li>设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性</li></ul><h4 id="2-2-具体分类"><a href="#2-2-具体分类" class="headerlink" title="2.2 具体分类"></a>2.2 具体分类</h4><ol><li><strong>创建型模式</strong>：<em>用于对象创建的过程</em><ul><li><strong>单例模式</strong>、<strong>工厂方法模式</strong>、抽象工厂模式、建造者模式(生成器模式)、原型模式</li></ul></li><li><strong>结构型模式</strong>：<em>用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构</em><ul><li>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)</li></ul></li><li><strong>行为型模式</strong>：<em>用于解决类或对象之间的交互，更合理的优化类或对象之间的关系</em><ul><li>责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、<strong>模板模式</strong>、访问者模式、备忘录模式、</li></ul></li><li>JEE 设计模式<ul><li>数据访问对象模式 </li></ul></li></ol><p><span id="id3"><span></span></span></p><h3 id="3-单例模式（Singleton）"><a href="#3-单例模式（Singleton）" class="headerlink" title="3.单例模式（Singleton）"></a>3.单例模式（Singleton）</h3><h4 id="3-1-实现流程："><a href="#3-1-实现流程：" class="headerlink" title="3.1 实现流程："></a>3.1 实现流程：</h4><ol><li>私有的构造方法</li><li>私有的静态的当前类的对象作为属性</li><li>共有的静态方法返回当前对象<h4 id="3-1-实现方式："><a href="#3-1-实现方式：" class="headerlink" title="3.1 实现方式："></a>3.1 实现方式：</h4></li><li>饿汉式：立即加载，对象启动时就加载</li><li>懒汉式：延迟加载，对象什么时候用到时才会加载</li><li>生命周期托管：单例对象交给别人处理</li></ol><p><span id="id4"><span></span></span></p><h3 id="4-模板模式"><a href="#4-模板模式" class="headerlink" title="4.模板模式"></a>4.模板模式</h3><p>在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。</p><ul><li>eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">      initialize();</span><br><span class="line">      start();</span><br><span class="line">      end();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 不同子类以不同方法实现抽象类的的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span> <span class="keyword">extends</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Initialized!."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Browser Started."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> <span class="keyword">extends</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Initialized!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Editor Started!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Software s1 = <span class="keyword">new</span> Browser();</span><br><span class="line">      s1.play();</span><br><span class="line">      s1 = <span class="keyword">new</span> Editor();</span><br><span class="line">      s1.play();    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-模式模式优缺点："><a href="#4-1-模式模式优缺点：" class="headerlink" title="4.1 模式模式优缺点："></a>4.1 模式模式优缺点：</h4><ol><li>优点<ul><li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li></ul></li><li>缺点<ul><li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li></ul></li><li>适用场景<ul><li>在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。</li></ul></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5. 工厂模式"></a>5. 工厂模式</h3><ol><li>简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；</li><li>工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；</li><li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。</li></ol><h4 id="5-1-简单工厂模式的实现："><a href="#5-1-简单工厂模式的实现：" class="headerlink" title="5.1 简单工厂模式的实现："></a>5.1 简单工厂模式的实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span></span>; &#125;</span><br><span class="line">  <span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span> </span>&#123; <span class="comment">/*苹果*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pear</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatIm</span><span class="params">()</span> </span>&#123; <span class="comment">/* 梨 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"apple"</span>)) &#123;<span class="comment">//生产苹果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pear"</span>)) &#123;<span class="comment">//生产梨</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">FruitFactory mFactory = <span class="keyword">new</span> FruitFactory();</span><br><span class="line">Apple apple = (Apple) mFactory.createFruit(<span class="string">"apple"</span>);<span class="comment">//获得苹果</span></span><br><span class="line">Pear pear = (Pear) mFactory.createFruit(<span class="string">"pear"</span>);<span class="comment">//获得梨</span></span><br></pre></td></tr></table></figure><blockquote><p>简单工厂只适合于产品对象较少，且产品固定的需求</p></blockquote><h4 id="5-2-工厂方法模式实现："><a href="#5-2-工厂方法模式实现：" class="headerlink" title="5.2 工厂方法模式实现："></a>5.2 工厂方法模式实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Fruit <span class="title">createFruit</span><span class="params">()</span></span>;<span class="comment">//生产水果</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PearFactory</span> <span class="keyword">implements</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruit <span class="title">createFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">AppleFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">PearFactory pearFactory = <span class="keyword">new</span> PearFactory();</span><br><span class="line">Apple apple = (Apple) appleFactory.createFruit();<span class="comment">//获得苹果</span></span><br><span class="line">Pear pear = (Pear) pearFactory.createFruit();<span class="comment">//获得梨</span></span><br></pre></td></tr></table></figure><blockquote><p>工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂</p></blockquote><h4 id="5-3-抽象工厂模式实现："><a href="#5-3-抽象工厂模式实现：" class="headerlink" title="5.3 抽象工厂模式实现："></a>5.3 抽象工厂模式实现：</h4><ul><li>抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；</li><li>eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// cpu接口和实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cpu650</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">/* 625 也厉害 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cpu825</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* 825 处理更强劲 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 屏幕接口和实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Screen5</span> <span class="keyword">implements</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="comment">/* 5寸 */</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Screen6</span> <span class="keyword">implements</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">/* 6寸 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Cpu <span class="title">getCpu</span><span class="params">()</span></span>;<span class="comment">//使用的cpu</span></span><br><span class="line">    <span class="function">Screen <span class="title">getScreen</span><span class="params">()</span></span>;<span class="comment">//使用的屏幕</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 具体工厂实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cpu.Cpu825();<span class="comment">//高性能处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Screen <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Screen.Screen6();<span class="comment">//6寸大屏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HongMiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cpu.Cpu650();<span class="comment">//高效处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Screen <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Screen.Screen5();<span class="comment">//小屏手机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；</p></blockquote><h4 id="5-4-三种工厂方式总结："><a href="#5-4-三种工厂方式总结：" class="headerlink" title="5.4 三种工厂方式总结："></a>5.4 三种工厂方式总结：</h4><ol><li>对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；</li><li>抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；</li></ol><p><span id="id6"><span></span></span></p><h3 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6.适配器模式（Adapter）"></a>6.适配器模式（Adapter）</h3><ul><li>适配器模式Adapter是结构型模式的一种，分为<strong>类适配器模式</strong>，<strong>对象适配器模式</strong>，<strong>缺省适配器模式</strong>。<ul><li>类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；</li><li>对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。</li></ul></li></ul><blockquote><p>适配器模式的缺点<br><br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p></blockquote><h4 id="6-1-缺省适配器模式"><a href="#6-1-缺省适配器模式" class="headerlink" title="6.1 缺省适配器模式"></a>6.1 缺省适配器模式</h4><ul><li>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</li><li>缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)</li><li>适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>九、JavaSE网络编程</title>
    <link href="http://chaooo.github.io/2019/07/12/09_JavaSE%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"/>
    <id>http://chaooo.github.io/2019/07/12/09_JavaSE网络编程.html</id>
    <published>2019-07-12T03:59:46.000Z</published>
    <updated>2019-07-20T15:01:52.870Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br>java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p><a id="more"></a><ol><li><a href="#id1">网络编程常识</a></li><li><a href="#id2">基于tcp协议的编程模型</a></li><li><a href="#id3">基于udp协议的编程模型</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-网络编程常识"><a href="#1-网络编程常识" class="headerlink" title="1. 网络编程常识"></a>1. 网络编程常识</h3><h4 id="1-1-七层网络模型"><a href="#1-1-七层网络模型" class="headerlink" title="1.1 七层网络模型"></a>1.1 七层网络模型</h4><p>为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：<br><br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><ul><li>当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；</li><li>当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；</li></ul><h4 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h4><ul><li>IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。</li><li>日常生活中采用<strong>点分十进制</strong>表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1</li></ul><h4 id="1-3-端口号"><a href="#1-3-端口号" class="headerlink" title="1.3 端口号"></a>1.3 端口号</h4><ul><li>根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。</li><li>网络编程需要提供：IP地址 和 端口号</li><li>端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。</li></ul><h4 id="1-4-tcp协议与udp协议"><a href="#1-4-tcp协议与udp协议" class="headerlink" title="1.4 tcp协议与udp协议"></a>1.4 tcp协议与udp协议</h4><ul><li>TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。</li><li>UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li><li>tcp协议与udp协议比较：</li></ul><table><thead><tr><th>tcp协议</th><th>udp协议</th></tr></thead><tbody><tr><td>传输控制协议，面向连接</td><td>用户数据报协议，非面向连接</td></tr><tr><td>通信过程全程保持连接</td><td>通信过程不需要全程连接</td></tr><tr><td>保证了数据传输的可靠性和有序性</td><td>不保证数据传输的可靠性和有序性</td></tr><tr><td>全双工的字节流的通信方式</td><td>全双工的数据报的通信方式</td></tr><tr><td>服务器的资源消耗多，压力大，效率低</td><td>服务器资源消耗少，压力小，效率高</td></tr></tbody></table><p><span id="id2"><span></span></span></p><h3 id="2-基于tcp协议的编程模型"><a href="#2-基于tcp协议的编程模型" class="headerlink" title="2. 基于tcp协议的编程模型"></a>2. 基于tcp协议的编程模型</h3><h4 id="2-1-编程模型"><a href="#2-1-编程模型" class="headerlink" title="2.1 编程模型"></a>2.1 编程模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器端                         客户端</span><br><span class="line"></span><br><span class="line">创建监听服务</span><br><span class="line">等待连接    &lt;----建立连接------  连接服务器           </span><br><span class="line">进行通讯    &lt;----进行通讯-----&gt;  进行通讯</span><br><span class="line">关闭连接                        关闭连接</span><br></pre></td></tr></table></figure><ul><li>服务器：<ol><li>创建ServerSocket类型的对象并提供端口号；</li><li>等待客户端的连接请求，调用accept方法；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li><li>客户端：<ol><li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li></ul><h4 id="2-2-ServerSocket类和Socket类"><a href="#2-2-ServerSocket类和Socket类" class="headerlink" title="2.2 ServerSocket类和Socket类"></a>2.2 ServerSocket类和Socket类</h4><ul><li>java.net.ServerSocket类主要用于描述服务器套接字信息。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>根据参数指定的端口号来构造对象</td></tr><tr><td>Socket accept()</td><td>监听并接收到此套接字的连接请求</td></tr><tr><td>void close()</td><td>用于关闭套接字</td></tr></tbody></table><ul><li>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>Socket(String host, int port)</td><td>根据指定主机名和端口号来构造对象</td></tr><tr><td>InputStream getInputStream()</td><td>用于获取当前套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>用于获取当前套接字的输出流</td></tr><tr><td>void close()</td><td>用于关闭套接字</td></tr></tbody></table><p><span id="id3"><span></span></span></p><h3 id="3-客户端与服务端通信演示："><a href="#3-客户端与服务端通信演示：" class="headerlink" title="3.客户端与服务端通信演示："></a>3.客户端与服务端通信演示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Socket s;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 3.使用输入输出流进行通信</span></span><br><span class="line">      BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">          <span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">      PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 实现服务器接收到字符串内容后打印出来</span></span><br><span class="line">        <span class="comment">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class="line">        String str = br.readLine();</span><br><span class="line">        <span class="comment">//System.out.println("服务器接收到的数据是：" + str);</span></span><br><span class="line">        <span class="comment">// 当服务器接收到"bye"后，则聊天结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"bye"</span>.equalsIgnoreCase(str)) &#123;</span><br><span class="line">          System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() + <span class="string">"已下线！"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() </span><br><span class="line">          + <span class="string">"发来的消息是："</span> + str);  </span><br><span class="line">        <span class="comment">// 当服务器接收到客户端发来的消息后，向客户端回发消息"I received!"</span></span><br><span class="line">        ps.println(<span class="string">"I received!"</span>);</span><br><span class="line">        <span class="comment">//System.out.println("服务器发送数据成功！");</span></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 4.关闭Socket</span></span><br><span class="line">      ps.close();</span><br><span class="line">      br.close();</span><br><span class="line">      s.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStringTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建ServerSocket类型的对象并提供端口号</span></span><br><span class="line">      ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">      <span class="comment">// 2.等待客户端的连接请求，调用accept方法</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"等待客户端的连接请求..."</span>);</span><br><span class="line">        <span class="comment">// 当没有客户端连接时，阻塞在accept方法的调用这里</span></span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        <span class="comment">// 获取连接成功的客户端通信地址</span></span><br><span class="line">        System.out.println(<span class="string">"客户端"</span> + s.getInetAddress() + <span class="string">"连接成功！"</span>);</span><br><span class="line">        <span class="comment">// 当有客户端连接成功后，则启动一个新的线程为之服务</span></span><br><span class="line">        <span class="keyword">new</span> ServerThread(s).start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//ss.close();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientStringTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建Socket类型的对象并提供服务器的通信地址和端口号</span></span><br><span class="line">      Socket s = <span class="keyword">new</span> Socket(<span class="string">"XDL-20170621QCO"</span>, <span class="number">8888</span>);</span><br><span class="line">      System.out.println(<span class="string">"连接服务器成功！"</span>);</span><br><span class="line">      <span class="comment">// 2.使用输入输出流进行通信</span></span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">      BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">          <span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞</span></span><br><span class="line">        <span class="comment">//Thread.sleep(10000);</span></span><br><span class="line">        <span class="comment">// 练习：实现客户端向服务器发送的内容由用户从键盘输入</span></span><br><span class="line">        System.out.println(<span class="string">"请输入要发送的内容："</span>);</span><br><span class="line">        <span class="comment">//String msg = sc.next(); // 读取字符串内容时，遇到空格停止</span></span><br><span class="line">        String msg = sc.nextLine();</span><br><span class="line">        <span class="comment">// 实现客户端向服务器发送字符串内容"hello"</span></span><br><span class="line">        <span class="comment">//ps.println("hello");</span></span><br><span class="line">        ps.println(msg);</span><br><span class="line">        System.out.println(<span class="string">"客户端发送数据成功！"</span>);</span><br><span class="line">        <span class="comment">// 判断客户端发送的内容是否为"bye"，若是则聊天结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"bye"</span>.equalsIgnoreCase(msg)) &#123;</span><br><span class="line">          System.out.println(<span class="string">"聊天结束！"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现服务器回发消息的接收</span></span><br><span class="line">        <span class="comment">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class="line">        String str = br.readLine();</span><br><span class="line">        System.out.println(<span class="string">"客户端接收到的数据是："</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.关闭Socket</span></span><br><span class="line">      br.close();</span><br><span class="line">      sc.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      s.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id4"><span></span></span></p><h3 id="4-基于udp协议的编程模型"><a href="#4-基于udp协议的编程模型" class="headerlink" title="4. 基于udp协议的编程模型"></a>4. 基于udp协议的编程模型</h3><h4 id="4-1-编程模型"><a href="#4-1-编程模型" class="headerlink" title="4.1 编程模型"></a>4.1 编程模型</h4><ul><li>主机A(接收方):<ol><li>创建DatagramSocket类型的对象，并提供端口号；</li><li>创建DatagramPacket类型的对象，用于接收发来的数据；</li><li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li><li>主机B(发送方)<ol><li>创建DatagramSocket类型的对象；</li><li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li><li>通过Socket发送数据，调用<strong>send()</strong>方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li></ul><h4 id="4-2-DatagramSocket类"><a href="#4-2-DatagramSocket类" class="headerlink" title="4.2 DatagramSocket类"></a>4.2 DatagramSocket类</h4><ul><li>java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>无参的方式构造对象。</td></tr><tr><td>DatagramSocket(int port)</td><td>根据参数指定的端口号来构造对象。</td></tr><tr><td>void receive(DatagramPacket p)</td><td>用于接收数据并存放到参数指定的变量中。</td></tr><tr><td>void send(DatagramPacket p)</td><td>用于将参数指定的数据发送出去。</td></tr><tr><td>void close()</td><td></td></tr></tbody></table><h4 id="4-3-DatagramPacket类"><a href="#4-3-DatagramPacket类" class="headerlink" title="4.3 DatagramPacket类"></a>4.3 DatagramPacket类</h4><ul><li>java.net.DatagramPacket类用于描述数据报信息(信件)；</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int length)</td><td>用于接收数据包并记录到参数变量中；</td></tr><tr><td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td><td>用于将参数指定的数据发送到参数指定的位置</td></tr><tr><td>InetAddress getAddress()</td><td>用于获取发送方或接收方的通信地址信息。</td></tr><tr><td>int getPort()</td><td>用于获取发送方或接收方的端口信息。</td></tr><tr><td>int getLength()</td><td>用于获取发送或接收数据的长度。</td></tr></tbody></table><h4 id="4-4-InetAddress类"><a href="#4-4-InetAddress类" class="headerlink" title="4.4 InetAddress类"></a>4.4 InetAddress类</h4><ul><li>java.net.InetAddress类用于描述互联网协议地址。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>static InetAddress getLocalHost()</td><td>用于获取本地主机的通信地址信息。</td></tr><tr><td>static InetAddress getByName(String host)</td><td>根据参数指定的主机名来获取通信地址。</td></tr><tr><td>String getHostName()</td><td>用于获取通信地址中的主机名信息。</td></tr><tr><td>String getHostAddress()</td><td>用于获取通信地址中的IP地址信息。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。&lt;br&gt;java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谈谈开源</title>
    <link href="http://chaooo.github.io/2019/07/11/%E8%B0%88%E8%B0%88%E5%BC%80%E6%BA%90.html"/>
    <id>http://chaooo.github.io/2019/07/11/谈谈开源.html</id>
    <published>2019-07-11T12:13:15.000Z</published>
    <updated>2019-08-27T15:02:02.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是开源"><a href="#什么是开源" class="headerlink" title="什么是开源"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p><p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p><a id="more"></a><p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p><h3 id="开源是否等于免费"><a href="#开源是否等于免费" class="headerlink" title="开源是否等于免费"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p><p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p><p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p><p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p><p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p><h3 id="为什么要选择开源软件"><a href="#为什么要选择开源软件" class="headerlink" title="为什么要选择开源软件"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p><p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p><p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p><p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p><p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p><blockquote><p>参考连接：</p><ul><li><a href="https://blog.csdn.net/happmaoo/article/details/83201544" target="_blank" rel="noopener">https://blog.csdn.net/happmaoo/article/details/83201544</a></li><li><a href="https://www.oschina.net/news/58921/what-is-open-source" target="_blank" rel="noopener">https://www.oschina.net/news/58921/what-is-open-source</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是开源&quot;&gt;&lt;a href=&quot;#什么是开源&quot; class=&quot;headerlink&quot; title=&quot;什么是开源&quot;&gt;&lt;/a&gt;什么是开源&lt;/h3&gt;&lt;p&gt;所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。&lt;/p&gt;
&lt;p&gt;在IT领域来说的话，字面意思就是&lt;strong&gt;开放源代码&lt;/strong&gt;，开源软件的源代码任何人都可以审查、修改和增强。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://chaooo.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="开源" scheme="http://chaooo.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>八、JavaSE反射机制</title>
    <link href="http://chaooo.github.io/2019/07/10/08_JavaSE%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html"/>
    <id>http://chaooo.github.io/2019/07/10/08_JavaSE反射机制.html</id>
    <published>2019-07-10T07:47:15.000Z</published>
    <updated>2019-07-20T14:56:40.906Z</updated>
    
    <content type="html"><![CDATA[<p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。</p><a id="more"></a><ol><li><a href="#id1">基本概念</a></li><li><a href="#id2">Class类</a></li><li><a href="#id3">Constructor类</a></li><li><a href="#id4">Field类</a></li><li><a href="#id5">Method类</a></li><li><a href="#id6">原始方式与反射方式构造对象实例</a></li><li><a href="#id7">注解(Annotation)</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><p>反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；<br>类是用来描述一组对象，反射机制可以理解为是用来描述一组类</p><p>通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。</p><h4 id="1-1-相关类及描述"><a href="#1-1-相关类及描述" class="headerlink" title="1.1 相关类及描述"></a>1.1 相关类及描述</h4><ul><li>Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</li><li>Package：用来描述类所属的包</li><li>Field：用来描述类中的属性</li><li>Method：用来描述类中的方法</li><li>Constructor：用来描述类中的构造方法</li><li>Annotation：用来描述类中的注解</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-Class类"><a href="#2-Class类" class="headerlink" title="2. Class类"></a>2. Class类</h3><p>java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</p><h4 id="2-1-获取Class类型对象的三种方式"><a href="#2-1-获取Class类型对象的三种方式" class="headerlink" title="2.1 获取Class类型对象的三种方式"></a>2.1 获取Class类型对象的三种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"包名.类名"</span>);<span class="comment">//用的最多，但可能抛出ClassNotFoundException异常</span></span><br><span class="line">Class clazz = 类名.class;<span class="comment">//任何类都有一个隐含的静态成员变量class</span></span><br><span class="line">Class clazz = 对象.getClass();<span class="comment">//Object类中的方法</span></span><br><span class="line">Class clazz = 包装类.TYPE;<span class="comment">//获取对应基本数据类型的class对象</span></span><br></pre></td></tr></table></figure><h4 id="2-2-常用方法"><a href="#2-2-常用方法" class="headerlink" title="2.2 常用方法"></a>2.2 常用方法</h4><ul><li>static Class&lt;?&gt; forName(String className)<ul><li>用于获取参数指定对应的Class对象并返回</li></ul></li><li>T newInstance()<ul><li>默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li></ul></li><li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<ul><li>用于获取此Class对象所表示类型中参数指定的公共构造方法。</li></ul></t></li><li>Constructor&lt;?&gt;[] getConstructors()<ul><li>用于获取此Class对象所表示类型中所有的公共构造方法</li></ul></li><li>Field getDeclaredField(String name)<ul><li>用于获取此Class对象所表示类中参数指定的单个成员变量信息</li></ul></li><li>Field[] fs = getDeclaredFields()<ul><li>用于获取此Class对象所表示类中所有成员变量信息</li></ul></li><li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<ul><li>用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法</li></ul></li><li>Method[] getMethods()<ul><li>用于获取该Class对象表示类中所有公共成员方法。</li></ul></li><li>获取私有相关方法<ul><li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)</li><li>getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)</li><li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有)</li><li>getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)</li></ul></li></ul><h4 id="2-3-其他方法"><a href="#2-3-其他方法" class="headerlink" title="2.3 其他方法"></a>2.3 其他方法</h4><ol><li>int result = getModifiers(); 获取类的修饰符(权限+特征)<ul><li>每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract</li></ul></li><li>String name = getName(); 获取类的全名(包名.类名)</li><li>String name = getSimpleName(); 获取类简单名(只有类名 缺少包)</li><li>Package p = getPackage(); 获取当前类所属的包<ul><li>p.getName(); 获取包名(Package类中的方法)</li></ul></li><li>Class sclazz = getSuperClass(); 获取超类(父类)对应Class</li><li>Class[] classes = getInterface(); 获取当前类父亲接口</li><li>Class[] classes = getClasses(); 获取类中的内部类</li><li>Object obj = <strong>newInstance()</strong>; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li><li>Field f = getField(“属性名”); 获取类中的属性(公有的 自己类+父类)</li><li>Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)</li><li>getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类)</li><li>Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)</li></ol><p><span id="id3"><span></span></span></p><h3 id="3-Constructor类"><a href="#3-Constructor类" class="headerlink" title="3. Constructor类"></a>3. Constructor类</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p><h4 id="3-1-Constructor类中的常用方法"><a href="#3-1-Constructor类中的常用方法" class="headerlink" title="3.1 Constructor类中的常用方法"></a>3.1 Constructor类中的常用方法</h4><ul><li>T newInstance(Object… initargs)<ul><li>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。</li></ul></li></ul><h4 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2 其他方法"></a>3.2 其他方法</h4><ul><li>con.getModifiers();</li><li>con.getName();</li><li>con.getParameterTypes();</li><li>con.getExceptionTypes();</li><li>如何操作构造方法<ul><li>执行一次,创建对象</li><li>Object = newInstance(执行构造方法时的所有参数);</li><li>con.setAccessible(true);</li></ul></li></ul><p><span id="id4"><span></span></span></p><h3 id="4-Field类"><a href="#4-Field类" class="headerlink" title="4. Field类"></a>4. Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p><h4 id="4-1-Field类中的常用方法"><a href="#4-1-Field类中的常用方法" class="headerlink" title="4.1 Field类中的常用方法"></a>4.1 Field类中的常用方法</h4><ul><li>Object get(Object obj)<ul><li>调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。</li></ul></li><li>Object set(Object obj, Object value)<ul><li>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。</li></ul></li><li>void setAccessible(boolean flag)<ul><li>当实参传递true时，则反射的对象在使用时应该取消java语言访问检查</li></ul></li></ul><h4 id="4-2-其他方法"><a href="#4-2-其他方法" class="headerlink" title="4.2 其他方法"></a>4.2 其他方法</h4><ol><li>int = getModifiers(); 获取属性修饰符(权限+特征)</li><li>Class = getType(); 获取属性的类型对应的那个class</li><li>String = getName(); 获取属性的名字</li><li>操作属性: set(对象,值); Object = get(对象);<ul><li>如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入</li></ul></li></ol><p><span id="id5"><span></span></span></p><h3 id="5-Method类"><a href="#5-Method类" class="headerlink" title="5. Method类"></a>5. Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p><h4 id="5-1-Method类中的常用方法"><a href="#5-1-Method类中的常用方法" class="headerlink" title="5.1 Method类中的常用方法"></a>5.1 Method类中的常用方法</h4><ul><li>Object invoke(Object obj, Object… args)<ul><li>使用对象obj来调用此Method对象所表示的成员方法，实参传递args。</li></ul></li></ul><h4 id="5-2-其他方法"><a href="#5-2-其他方法" class="headerlink" title="5.2 其他方法"></a>5.2 其他方法</h4><ul><li>int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)</li><li>Class mrt = m.getReturnType(); 获取返回值数据类型</li><li>String mn = m.getName(); 获取方法的名字</li><li>Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型</li><li>Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型</li><li>如何操作方法</li><li>调用方法   让他执行一次</li><li>Object result = invoke(对象,执行方法需要传递的所有参数…);</li><li>若方法是私有的方法  不允许操作</li><li>可以设置setAccessable(true)   设置方法使用权  准入</li></ul><p><span id="id6"><span></span></span></p><h3 id="6-原始方式与反射方式构造对象实例"><a href="#6-原始方式与反射方式构造对象实例" class="headerlink" title="6. 原始方式与反射方式构造对象实例"></a>6. 原始方式与反射方式构造对象实例</h3><ol><li>使用原始方式来构造对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//1.采用无参的方式构造Person对象并打印</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p); <span class="comment">//null 0</span></span><br><span class="line">  <span class="comment">//2.使用有参方式来构造Person对象</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"zhangfei"</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(p2); <span class="comment">//zhangfei 30</span></span><br><span class="line">  <span class="comment">//3.修改与获取属性(成员变量)，调用get,set方法</span></span><br><span class="line">p2.setName(<span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + p2.getName()); <span class="comment">//guanyu</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用反射机制来构造对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//1.使用获取到的Class对象来构造Person对象并打印</span></span><br><span class="line">Class c1 = Class.forName(<span class="string">"myproject.Person"</span>);<span class="comment">//不可省略包名</span></span><br><span class="line">System.out.println(c1.newInstance());<span class="comment">//null 0</span></span><br><span class="line">    <span class="comment">//2.使用有参方式来构造对象</span></span><br><span class="line">Class c2 = Class.forName(<span class="string">"myproject.Person"</span>);</span><br><span class="line">Constructor ct2 = c2.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">Object obj = ct2.newInstance(<span class="string">"zhangfei"</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(obj);<span class="comment">//zhangfei 30</span></span><br><span class="line">    <span class="comment">//3.修改与获取属性(成员变量)</span></span><br><span class="line">Field f2 = c2.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，设置使用权</span></span><br><span class="line">f2.set(obj, <span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + f2.get(obj)); <span class="comment">//guanyu</span></span><br><span class="line">    <span class="comment">//4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来</span></span><br><span class="line">Method m1 = c2.getMethod(<span class="string">"getName"</span>);</span><br><span class="line">System.out.println(<span class="string">"获取到的姓名是："</span> + m1.invoke(obj)); <span class="comment">//zhangfei</span></span><br><span class="line">    <span class="comment">//5.成员方法setName，调用getMethod方法来修改姓名并打印出来</span></span><br><span class="line">Method m2 = c2.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">Object res = m2.invoke(obj, <span class="string">"guanyu"</span>);</span><br><span class="line">System.out.println(<span class="string">"方法调用的返回值是："</span> + res); <span class="comment">//null</span></span><br><span class="line">System.out.println(<span class="string">"修改后的姓名是："</span> + m1.invoke(obj)); <span class="comment">//guanyu</span></span><br></pre></td></tr></table></figure><p><span id="id7"><span></span></span></p><h3 id="7-注解-Annotation"><a href="#7-注解-Annotation" class="headerlink" title="7. 注解(Annotation)"></a>7. 注解(Annotation)</h3><h4 id="7-1-注解相关概念"><a href="#7-1-注解相关概念" class="headerlink" title="7.1 注解相关概念"></a>7.1 注解相关概念</h4><ul><li>注释<ul><li>单行注释：<code>//</code></li><li>多行注释：<code>/*   */</code></li><li>文档注释：<code>/**   */</code></li></ul></li><li>注解的写法<ul><li><code>@XXX [(一些信息)]</code></li></ul></li><li>注解位置<ul><li>类的上面，属性上面，方法上面，构造方法上面，参数前面</li></ul></li><li>注解的作用<ol><li>用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated</li><li>用来做代码的检测(验证)，@Override</li><li>*可以携带一些信息(内容)，文件.properties/.xml，注解</li></ol></li><li>常用的注解<ul><li>@Deprecated：用来说明方法是废弃的</li><li>@Override：用来做代码检测   检测此方法是否是一个重写</li><li>@SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{}<ul><li>unused：变量定义后未被使用</li><li>serial：类实现了序列化接口  不添加序列化ID号</li><li>rawtypes：集合没有定义泛型</li><li>deprecation：方法以废弃    </li><li>*unchecked：出现了泛型的问题  可以不检测</li><li>all：包含了以上所有(不推荐)</li></ul></li></ul></li><li>注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：<ol><li>基本数据类型</li><li>String类型</li><li>枚举类型enum</li><li>注解类型@</li><li>数组类型[]，数组的内部需要是如上的四种类型</li></ol></li><li>注解的分类<ol><li>按运行机制分：源码注解，编译时注解，运行时注解</li><li>按照来源分：来自JDK的注解，来自第三方的注解，自定义注解</li></ol></li></ul><h4 id="7-2-自定义注解类型的语法要求："><a href="#7-2-自定义注解类型的语法要求：" class="headerlink" title="7.2 自定义注解类型的语法要求："></a>7.2 自定义注解类型的语法要求：</h4><ol><li>使用@interface关键字定义注解</li><li>成员以<strong>无参无异常</strong>方式声明</li><li>可以用default为成员指定一个默认值</li><li>成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration</li><li>如果注解只有一个成员，则成员名必须取名<strong>value()</strong>,在使用时可以忽略成员名和赋值号(=)</li><li>注解类可以没有成员，没有成员的注解称为标识注解</li><li>需要元注解来描述说明<ul><li>@Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)</li><li>@Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME)</li><li>@Inherited：允许子类继承</li><li>@Document：当前注解是否能被文档(javadoc)所记录</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description&#123;</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-使用自定义注解："><a href="#7-3-使用自定义注解：" class="headerlink" title="7.3 使用自定义注解："></a>7.3 使用自定义注解：</h4><ul><li>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Description</span>(desc=<span class="string">"I am eyeColor"</span>, author=<span class="string">"Chao"</span>, age=<span class="number">18</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">eyeColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Description</span>(<span class="string">"I am class annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Description</span>(<span class="string">"I am method annotation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-解析注解"><a href="#7-4-解析注解" class="headerlink" title="7.4 解析注解"></a>7.4 解析注解</h4><p>通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。</p><ol><li>使用类加载器加载类<ul><li><code>Class c=Class.forName（&quot;com.ann.test.Child&quot;)</code></li></ul></li><li>找到类上面的注解<ul><li><code>isAnnotationPresent（类类型）</code>：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。</li></ul></li><li>拿到注解实例，需要强制类型转换。<ul><li><code>Description d=（Description）c.getAnnotation(Description.class);</code></li></ul></li><li>找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseAnn</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//1. 使用类加载器加载类</span></span><br><span class="line">      Class c=Class.forName（<span class="string">"com.ann.test.Child"</span>)</span><br><span class="line">      <span class="comment">//2. 找到类上面的注解</span></span><br><span class="line">      <span class="keyword">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class="line">      <span class="keyword">if</span>(isExist)&#123;</span><br><span class="line">        <span class="comment">//3. 拿到注解实例</span></span><br><span class="line">        Description d=（Description）c.getAnnotation(Description.class);</span><br><span class="line">        System.out.println(d.value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.找到方法上的注解</span></span><br><span class="line">      Method[] ms = c.getMethods();</span><br><span class="line">      <span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isMExist = m.isAnnotationPresent(Description.class);</span><br><span class="line">        <span class="keyword">if</span>(isMExist)&#123;</span><br><span class="line">          Description md=（Description）c.getAnnotation(Description.class);</span><br><span class="line">          System.out.println(md.value());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另一种解析方法上的注解:<ul><li>获取这个方法的所有注解，<code>Annotation [] as=m.getAnnotations();</code>然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">  Annotation [] as=m.getAnnotations();</span><br><span class="line">  <span class="keyword">for</span>(Annotation a:as)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Description)&#123;</span><br><span class="line">      Description md = (Description)a;</span><br><span class="line">      System.out.println(md.value());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。&lt;br&gt;多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>七、JavaSE多线程</title>
    <link href="http://chaooo.github.io/2019/07/09/07_JavaSE%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"/>
    <id>http://chaooo.github.io/2019/07/09/07_JavaSE多线程.html</id>
    <published>2019-07-09T10:07:41.000Z</published>
    <updated>2019-07-20T14:51:55.308Z</updated>
    
    <content type="html"><![CDATA[<p>多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>程序的执行其实都是在抢CPU的资源，CPU的执行权。<br>多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。</p><a id="more"></a><ol><li><a href="#id1">基本概念</a></li><li><a href="#id2">实现线程的过程</a></li><li><a href="#id3">线程常用方法</a></li><li><a href="#id4">线程池</a></li><li><a href="#id5">线程的主要状态</a></li><li><a href="#id6">线程的同步机制</a></li><li><a href="#id7">线程的死锁</a></li><li><a href="#id8">内存可见性</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  </li><li>进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个<strong>进程包含n个线程</strong>；(进程是系统进行资源分配和调度的一个独立单位)。</li><li>线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。</li><li>多进程是指操作系统能同时运行多个任务（程序）。</li><li>多线程是指在同一程序(一个进程)中有多个顺序流在执行。</li><li>并行与并发：<ul><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li></ul></li><li>线程和进程一样分为五个阶段：<strong>创建</strong>、<strong>就绪状态</strong>、<strong>执行状态</strong>、<strong>等待/挂起/阻塞</strong>、<strong>终止/异常/消亡</strong>。</li></ul><p><span id="id2"><span></span></span></p><h3 id="2-实现线程的过程"><a href="#2-实现线程的过程" class="headerlink" title="2. 实现线程的过程"></a>2. 实现线程的过程</h3><p>java.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。</p><ul><li>自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  </li><li>自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 </li></ul><h4 id="2-1-实现方式一：继承Thread类"><a href="#2-1-实现方式一：继承Thread类" class="headerlink" title="2.1 实现方式一：继承Thread类"></a>2.1 实现方式一：继承Thread类</h4><ol><li>自己描述一个类</li><li>继承父类Thread</li><li>重写run方法</li><li>new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="comment">//这里编写该线程的执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">mt.start();</span><br></pre></td></tr></table></figure><h4 id="2-2-实现方式二：实现Runnable接口"><a href="#2-2-实现方式二：实现Runnable接口" class="headerlink" title="2.2 实现方式二：实现Runnable接口"></a>2.2 实现方式二：实现Runnable接口</h4><ol><li>自己描述一个类</li><li>实现一个父接口Runnable</li><li>重写run方法</li><li>new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="comment">//这里编写该线程的执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread td = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">td.start();</span><br></pre></td></tr></table></figure><h4 id="2-3-两种方式优缺点："><a href="#2-3-两种方式优缺点：" class="headerlink" title="2.3 两种方式优缺点："></a>2.3 两种方式优缺点：</h4><ul><li>使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类</li><li>使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。</li></ul><p><span id="id3"><span></span></span></p><h3 id="3-线程常用方法"><a href="#3-线程常用方法" class="headerlink" title="3. 线程常用方法"></a>3. 线程常用方法</h3><p><img src="http://cdn.chaooo.top/java/thread.jpg" alt="Thread常用方法"></p><h4 id="3-1-相关方法的解析："><a href="#3-1-相关方法的解析：" class="headerlink" title="3.1 相关方法的解析："></a>3.1 相关方法的解析：</h4><ul><li>Thread()：使用无参方式构造对象  </li><li>Thread(String name)：根据参数指定的名称来构造对象。  </li><li>Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   </li><li>Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。</li><li>void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  </li><li>void <strong>start()</strong>：用于<strong>启动线程</strong>，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。</li></ul><ul><li>int getPriority()：用于获取线程的优先级，优先级1-10</li><li>void setPriority(int)：更改线程的优先级</li></ul><h4 id="3-2-多线程原理分析"><a href="#3-2-多线程原理分析" class="headerlink" title="3.2 多线程原理分析"></a>3.2 多线程原理分析</h4><ol><li>执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  </li><li>对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  </li><li>当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  </li><li>两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  </li></ol><h4 id="3-3-线程的编号和名称"><a href="#3-3-线程的编号和名称" class="headerlink" title="3.3 线程的编号和名称"></a>3.3 线程的编号和名称</h4><ul><li>long getId()：用于获取调用对象所表示线程的编号</li><li>String getName()：用于获取调用对象所表示线程的名称</li><li>void setName()：用于设置线程的名称为参数指定的数值</li><li>static Thread currentThread()：获取当前正在执行线程的引用</li></ul><p><span id="id4"><span></span></span></p><h3 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h3><ul><li>为了避免重复的创建线程，线程池的出现可以<strong>让线程进行复用</strong>。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。</li><li>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。</li><li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务<ul><li>接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService</li><li>抽象类：AbstractExecutorService</li><li>实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor</li></ul></li><li>创建线程的第三种方式是实现Callable接口，主要用于线程池</li></ul><p><span id="id5"><span></span></span></p><h3 id="5-线程的主要状态"><a href="#5-线程的主要状态" class="headerlink" title="5. 线程的主要状态"></a>5. 线程的主要状态</h3><p><img src="http://cdn.chaooo.top/java/threadLife.jpg" alt="线程的生命周期"></p><ol><li>新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行</li><li>就绪状态：调用start()进入的状态，此时线程还是没有开始执行</li><li>运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态</li><li>消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止</li><li>阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态</li></ol><h4 id="5-1-线程的休眠"><a href="#5-1-线程的休眠" class="headerlink" title="5.1 线程的休眠"></a>5.1 线程的休眠</h4><ul><li><strong>终止线程</strong>：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。</li><li>static void <strong>yield()</strong>：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。</li><li>static void <strong>sleep(times)</strong>：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。</li></ul><h4 id="5-1-线程的等待"><a href="#5-1-线程的等待" class="headerlink" title="5.1 线程的等待"></a>5.1 线程的等待</h4><ul><li>void <strong>join()</strong>：等待该线程终止，让多个线程同步执行，变成单个线程</li><li>void <strong>join(long millis)</strong>：表示等待参数指定的毫秒数</li><li><strong>对象.wait()</strong> 和 <strong>对象.notify()/notifyAll()</strong>可以让线程的状态来回切换</li><li>sleep()和wait()的区别：</li></ul><table><thead><tr><th>sleep()和wait()的区别</th><th>sleep()</th><th>wait()</th></tr></thead><tbody><tr><td>1.类</td><td>Thread类</td><td>Object类</td></tr><tr><td>2.调用</td><td>静态 类名.</td><td>对象.</td></tr><tr><td>3.理解</td><td>调用位置的线程等待</td><td>对象调用，访问对象的其他线程等待</td></tr><tr><td>4.唤醒</td><td>不需要唤醒</td><td>需要其他对象调用notify唤醒</td></tr><tr><td>5.锁</td><td>不会释放锁</td><td>等待后会释放锁</td></tr></tbody></table><h4 id="5-2-守护线程"><a href="#5-2-守护线程" class="headerlink" title="5.2 守护线程"></a>5.2 守护线程</h4><ul><li>boolean <strong>isDeamon()</strong>：用于判断是否为守护线程</li><li>void <strong>setDeamon(boolean on)</strong>：用于设置线程为守护线程</li><li>Java线程有两类：<ul><li>用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程</li><li>守护线程：运行在后台，为其他前台线程服务</li></ul></li><li>守护线程特点：<ul><li><strong>一旦所有线程都结束运行，守护线程会随JVM一起结束工作</strong></li></ul></li><li>守护线程应用：<ul><li>数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。</li></ul></li><li>设置守护线程：<ul><li>可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程</li></ul></li></ul><p><span id="id6"><span></span></span></p><h3 id="6-线程的同步机制"><a href="#6-线程的同步机制" class="headerlink" title="6. 线程的同步机制"></a>6. 线程的同步机制</h3><ul><li><p>条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。</p></li><li><p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做<strong>线程的同步机制</strong>。</p></li><li><p>Java提供了一种<strong>内置的锁机制</strong>来支持<strong>原子性</strong>，使用<strong>synchronized</strong>关键字来保证线程执行操作的原子性，叫做<strong>对象/同步锁机制</strong>。</p></li><li><p>特征修饰符synchronized：表示同步，一个时间点只有一个线程访问</p></li><li><p>线程安全锁：两种形式是（锁定的永远是对象）</p><ol><li><p>使用同步代码块的方式，将synchronized关键字放在方法体内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="comment">//需同步执行(锁定)的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用synchronized保证线程同步时应当注意：</p><ol><li>多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用</li><li>在使用同步块时应当尽量减少同步范围以提高并发的执行效率</li></ol></li></ul><blockquote><ol><li>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li><li>每个对象只有一个锁（lock）与之相关联。</li><li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li></ol></blockquote><p><span id="id7"><span></span></span></p><h3 id="7-线程的死锁"><a href="#7-线程的死锁" class="headerlink" title="7. 线程的死锁"></a>7. 线程的死锁</h3><p>Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**当两个线程或多个线程之间相互锁定时就形成了死锁**/</span></span><br><span class="line"><span class="comment">//线程一：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">synchronized</span>(a) &#123; <span class="comment">//表示:持有对象锁a,等待对象锁b</span></span><br><span class="line">        <span class="keyword">synchronized</span>(b) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程二：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">synchronized</span>(b) &#123; <span class="comment">//表示:持有对象锁b,等待对象锁a</span></span><br><span class="line">        <span class="keyword">synchronized</span>(a) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。</span></span><br></pre></td></tr></table></figure><ul><li>产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。</li><li>隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。</li><li>两种导致隐性死锁的情况：加锁次序和占有并等待。<ul><li>加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。</li><li>占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。</li></ul></li></ul><h4 id="7-1-死锁的避免"><a href="#7-1-死锁的避免" class="headerlink" title="7.1 死锁的避免"></a>7.1 死锁的避免</h4><ul><li>避免死锁的原则：顺序上锁，反向解锁，不要回头</li><li>静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。</li><li>动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：<strong>安全序列</strong>和<strong>银行家算法</strong>。</li></ul><p><span id="id8"><span></span></span></p><h3 id="8-内存可见性"><a href="#8-内存可见性" class="headerlink" title="8.内存可见性"></a>8.内存可见性</h3><h4 id="8-1-基本概念"><a href="#8-1-基本概念" class="headerlink" title="8.1 基本概念"></a>8.1 基本概念</h4><ul><li>可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到</li><li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量</li><li>Java内存模型(JMM)：<ul><li>Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。</li><li>所有的变量都存储在主内存中</li><li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li></ul></li><li>Java内存模型规定：<ul><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li></ul></li><li>要实现共享变量的可见性，必须保证两点：<ul><li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li><li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。</li></ul></li><li>Java<strong>语言层面</strong>支持的可见性实现方式：Synchronized，volatile</li></ul><h4 id="8-2-Synchronized实现可见性"><a href="#8-2-Synchronized实现可见性" class="headerlink" title="8.2 Synchronized实现可见性"></a>8.2 Synchronized实现可见性</h4><ul><li>Synchronized能够实现：原子性(同步)、可见性</li><li>JMM关于synchronized的两条规定：<ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li></ul></li><li>线程执行互斥代码的过程：<ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存</li><li>执行代码</li><li>将更改后的共享变量的值刷新到主内存</li><li>释放互斥锁</li></ol></li><li>重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化<ol><li>编译器优化重排序（编译器处理）</li><li>指令级并行重排序（处理器优化）</li><li>内存系统的重排序（处理器读写缓存的优化）</li></ol></li><li>as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致</li><li>单线程中重排序不会带来内存可见性问题</li><li>多线程中程序交错执行时，重排序可能造成内存可见性问题</li></ul><table><thead><tr><th>不可见的原因</th><th>syschronized解决方案</th></tr></thead><tbody><tr><td>1.线程的交叉执行</td><td>原子性</td></tr><tr><td>2.重排序结合线程交叉执行</td><td>原子性</td></tr><tr><td>3.共享变量未及时更新</td><td>可见性</td></tr></tbody></table><h4 id="8-3-volatile实现可见性"><a href="#8-3-volatile实现可见性" class="headerlink" title="8.3 volatile实现可见性"></a>8.3 volatile实现可见性</h4><ul><li>深入来说：通过加入内存屏障和禁止重排序优化来实现的。<ul><li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li><li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li></ul></li><li>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</li><li>线程<strong>写</strong>volatile变量的过程：<ol><li>改变线程工作内存中volatile变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ol></li><li>线程<strong>读</strong>volatile变量的过程：<ol><li>从主内存中读取volatile变量的最新值到线程的工作内存中</li><li>从工作内存中读取volatile变量的副本</li></ol></li><li>volatile不能保证volatile变量复合操作的原子性</li><li>volatile适用场景：<ol><li>对变量的写操作不依赖其当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ol></li></ul><h4 id="8-4-Synchronized和volatile比较"><a href="#8-4-Synchronized和volatile比较" class="headerlink" title="8.4 Synchronized和volatile比较"></a>8.4 Synchronized和volatile比较</h4><ul><li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li><li>从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁</li><li>synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性</li><li>volatile没有synchronized使用广泛。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。&lt;br&gt;程序的执行其实都是在抢CPU的资源，CPU的执行权。&lt;br&gt;多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>六、JavaSE输入输出(IO)</title>
    <link href="http://chaooo.github.io/2019/07/09/06_JavaSE%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-IO.html"/>
    <id>http://chaooo.github.io/2019/07/09/06_JavaSE输入输出-IO.html</id>
    <published>2019-07-09T09:31:22.000Z</published>
    <updated>2019-07-20T14:47:09.875Z</updated>
    
    <content type="html"><![CDATA[<p>输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。</p><a id="more"></a><ol><li><a href="#id1">File类</a></li><li><a href="#id2">IO流</a></li><li><a href="#id3">文件流</a></li><li><a href="#id4">字节型文件流</a></li><li><a href="#id5">字符型文件流</a></li><li><a href="#id6">*缓冲流</a></li><li><a href="#id7">转换流</a></li><li><a href="#id8">对象流</a></li><li><a href="#id9">打印流(PrintStream类)</a></li><li><a href="#id10">Properties类的使用</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h3><ul><li>File与真实硬盘中的文件或文件夹  不是一个东西<ul><li>File是在内存中的一个对象&lt;—映射—&gt;硬盘上的文件或文件夹</li></ul></li><li>java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。</li><li>File类中的常用的方法<ul><li>canRead()，canWrite()，isHidden()，isFile()，isDirectory()</li><li>length()，获取文件中字节的个数</li><li>lastModified()，获取文件最后的修改时间—&gt;毫秒值</li><li>*String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt<ul><li>绝对路径&lt;—-&gt;相对路径</li><li>绝对路径可以通过完整的字符串，定位盘符，文件夹，文件</li><li>相对路径没有盘符的写法，当前工程(项目)所在的位置找寻</li></ul></li><li>String name = getName()，获取文件的名字    Test.txt</li><li><em>boolean = *</em>createNewFile()**，创建新的文件</li><li><em>boolean = *</em>mkdir** ，创建新的文件夹  外层没有 不能创建</li><li><em>boolean = *</em>mkdirs**，创建新的文件夹  外层没有 可以自动创建</li><li>String pname = getParent()，获取当前file的父亲file名字</li><li>*File file = getParentFile()，获取当前file的父亲file对象</li><li>String[] names = list()，获取当前file的所有儿子名字</li><li>*File[] files = listFiles()，获取当前file的所有儿子对象</li><li>*boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹</li></ul></li><li>文件夹的路径(找父目录)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找当前file的所有父目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"D:\\test\\bbb\\inner\\InnerTest.txt"</span>);</span><br><span class="line">File pfile = file.getParentFile();</span><br><span class="line"><span class="keyword">while</span>(pfile!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(pfile.getAbsolutePath());</span><br><span class="line">    pfile = pfile.getParentFile();<span class="comment">//再找一遍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件夹的遍历—-需要一个递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法  用来展示(遍历)文件夹,参数--&gt;file(代表文件或文件夹)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFile</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取file的子元素</span></span><br><span class="line">    <span class="comment">//files==null是个文件</span></span><br><span class="line">    <span class="comment">//files!=null是个文件夹</span></span><br><span class="line">    <span class="comment">//files.length!=0是一个带元素的文件夹</span></span><br><span class="line">    File[] files = file.listFiles();<span class="comment">//test文件夹所有子元素</span></span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span> &amp;&amp; files.length!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">            <span class="keyword">this</span>.showFile(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做自己的显示(file是文件或file是一个空的文件夹)</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件夹的删除—-需要一个递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法 删除文件夹,参数 file</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断file不是空文件夹</span></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="keyword">null</span> &amp;&amp; files.length!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">            <span class="keyword">this</span>.deleteFile(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除file (file是个文件或file是一个空文件夹)</span></span><br><span class="line">    file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id2"><span></span></span></p><h3 id="2-IO流"><a href="#2-IO流" class="headerlink" title="2. IO流"></a>2. IO流</h3><ul><li>流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </li><li>流的分类:<ul><li>根据处理数据类型的不同分为：字符流和字节流</li><li>根据数据流向不同分为：输入流in(读取)和输出流out(写入)</li><li>操作的目标来区分:<ul><li>文件流，数组流，字符串流，数据流，对象流，网络流…</li></ul></li></ul></li><li>IO流的框架结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|——IO流</span><br><span class="line">    |————字节流</span><br><span class="line">        |————InputStream</span><br><span class="line">            |————FileInputStream</span><br><span class="line">            |————DataInputStream</span><br><span class="line">            |————ObjectInputStream</span><br><span class="line">        |————OutputStream</span><br><span class="line">            |————FileOutputStream</span><br><span class="line">            |————DataOutputStream</span><br><span class="line">            |————ObjectOutputStream</span><br><span class="line">            |————PrintStream</span><br><span class="line">    |————字符流</span><br><span class="line">        |————Reader</span><br><span class="line">            |————BufferedReader</span><br><span class="line">            |————InputStreamReader</span><br><span class="line">        |————Writer</span><br><span class="line">            |————BufferedWriter</span><br><span class="line">            |————OutputStreamWriter</span><br></pre></td></tr></table></figure><p><span id="id3"><span></span></span></p><h3 id="3-文件流"><a href="#3-文件流" class="headerlink" title="3. 文件流"></a>3. 文件流</h3><p>读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分</p><ul><li>字节型文件流(1字节)：FileInputStream/FileOutputStream</li><li>字符型文件流(2字节–1字符)：FileReader/FileWriter</li><li>字节流和字符流的区别：<ul><li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li><li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li></ul></li><li>结论：只要是处理<strong>纯文本</strong>数据，就优先考虑使用<strong>字符流</strong>。 除此之外都使用<strong>字节流</strong>。</li><li>输入流和输出流<ul><li>对输入流只能进行<strong>读</strong>操作，对输出流只能进行<strong>写</strong>操作。 </li></ul></li></ul><p><span id="id4"><span></span></span></p><h3 id="4-字节型文件流"><a href="#4-字节型文件流" class="headerlink" title="4. 字节型文件流"></a>4. 字节型文件流</h3><h4 id="4-1-字节型文件输入流FileInputStream-读"><a href="#4-1-字节型文件输入流FileInputStream-读" class="headerlink" title="4.1 字节型文件输入流FileInputStream(读)"></a>4.1 字节型文件输入流FileInputStream(读)</h4><ul><li>FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。</li><li>创建对象<ul><li>调用一个带File类型的构造方法</li><li>调用一个带String类型的构造方法</li></ul></li><li>常用方法<ul><li>int code = read();    每次从流管道中读取一个字节，返回字节的code码</li><li>*int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数</li><li>int count = available();   返回流管道中还有多少缓存的字节数</li><li>skip(long n);跳过几个字节  读取<ul><li>多线程—&gt;利用几个线程同时读取文件</li></ul></li><li>*close()    将流管道关闭—必须要做,最好放在finally里<ul><li>注意代码的健壮性，判断严谨（eg:非空判断）</li></ul></li></ul></li></ul><h4 id="4-2-字节型文件输出流FileOutputStream-写"><a href="#4-2-字节型文件输出流FileOutputStream-写" class="headerlink" title="4.2 字节型文件输出流FileOutputStream(写)"></a>4.2 字节型文件输出流FileOutputStream(写)</h4><ul><li>FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。</li><li>创建对象<ul><li>调用一个带File参数，还有File boolean重载</li><li>调用一个带String参数，还有String boolean重载</li><li>eg: new FileOutputStream(“D://test//bbb.txt”, true)//第二个参控制每次写入追加还是重载</li></ul></li><li>常用方法<ul><li>write(int code);  将给定code对应的字符写入文件   ‘=’</li><li>write(byte[]);  将数组中的全部字节写入文件   getByte()</li><li>write(byte[] b, int off, int len);</li><li>flush();    将管道内的字节推入(刷新)文件</li><li>close();    注意在finally中关闭</li></ul></li></ul><blockquote><ul><li>创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException</li><li>创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件</li></ul></blockquote><ul><li>设计一个文件复制的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File file, String path)</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建输入流读取信息</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">//创建一个新的File对象</span></span><br><span class="line">        File newFile = <span class="keyword">new</span> File(path +<span class="string">"\\"</span>+ file.getName());<span class="comment">//"E:\\test\\test.txt"</span></span><br><span class="line">        <span class="comment">//创建一个输出流</span></span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(newFile);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//通常1kb-8kb之间</span></span><br><span class="line">        <span class="keyword">int</span> count = fis.read(b);</span><br><span class="line">        <span class="keyword">while</span>(count != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(b, <span class="number">0</span>, count);<span class="comment">//将读取到的有效字节写入</span></span><br><span class="line">            fos.flush();</span><br><span class="line">            count = fis.read(b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"复制完毕！"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fis!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; fis.close(); &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fos!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;fos.close();&#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id5"><span></span></span></p><h3 id="5-字符型文件流"><a href="#5-字符型文件流" class="headerlink" title="5. 字符型文件流"></a>5. 字符型文件流</h3><p>FileReader/FileWriter：只能操作纯文本的文件 .txt / .properties</p><h4 id="5-1-字符型文件输入流FileReader-读"><a href="#5-1-字符型文件输入流FileReader-读" class="headerlink" title="5.1 字符型文件输入流FileReader(读)"></a>5.1 字符型文件输入流FileReader(读)</h4><ul><li>FileReader类在java.io包，继承自InputStreamReader，Reader</li><li>创建对象<ul><li>调用一个带File类型的构造方法</li><li>调用一个带String类型的构造方法</li></ul></li><li>常用方法<ul><li>read()</li><li>read(char[])</li><li>close()</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"F://test//Test.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="comment">// int code = fr.read();</span></span><br><span class="line">    <span class="comment">// System.out.println(code);</span></span><br><span class="line">    <span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> count = fr.read(c);</span><br><span class="line">    <span class="keyword">while</span>(count!=-<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(c, <span class="number">0</span>, count));</span><br><span class="line">        count = fr.read(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-字符型文件输出流FileWriter-写"><a href="#5-2-字符型文件输出流FileWriter-写" class="headerlink" title="5.2 字符型文件输出流FileWriter(写)"></a>5.2 字符型文件输出流FileWriter(写)</h4><ul><li>FileWriter类在java.io包，继承自OutputStreamWriter，Writer</li><li>构造方法<ul><li>带file参数，带file,boolean参数</li><li>带String参数，带String,boolean参数</li></ul></li><li>常用方法<ul><li>write(int)</li><li>write(char[])</li><li>write(string)</li><li>flush()，close()</li></ul></li></ul><p><span id="id6"><span></span></span></p><h3 id="6-缓冲流"><a href="#6-缓冲流" class="headerlink" title="6. *缓冲流"></a>6. *缓冲流</h3><ul><li>缓冲流,也叫高效流，是对4个基本的File…流的增强，所以也是4个流，按照数据类型分类：<ul><li>字节缓冲流：BufferedInputStream，BufferedOutputStream </li><li>字符缓冲流：BufferedReader，BufferedWriter</li></ul></li><li>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li><li>缓冲流读写方法与基本的流是一致</li></ul><h4 id="6-1-字节缓冲流"><a href="#6-1-字节缓冲流" class="headerlink" title="6.1 字节缓冲流"></a>6.1 字节缓冲流</h4><ul><li>BufferedInputStream，BufferedOutputStream</li><li>构造方法<ul><li>public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 </li><li>public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"bis.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"bos.txt"</span>));</span><br></pre></td></tr></table></figure><h4 id="6-2-字符缓冲流"><a href="#6-2-字符缓冲流" class="headerlink" title="6.2 字符缓冲流"></a>6.2 字符缓冲流</h4><ul><li>BufferedReader，BufferedWriter</li><li>构造方法<ul><li>public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 </li><li>public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"br.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw.txt"</span>));</span><br></pre></td></tr></table></figure><ul><li>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</li><li>特有方法: <ul><li>BufferedReader：public String readLine(): 读一行文字。 </li><li>BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法，用来用户登录认证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://test//User.txt"</span>));</span><br><span class="line">        <span class="comment">//User.txt每行存储格式：张三-123</span></span><br><span class="line">        String user = br.readLine();<span class="comment">//user表示一行记录，记录账号密码</span></span><br><span class="line">        <span class="keyword">while</span>(user!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将user信息拆分，分别与参数比较</span></span><br><span class="line">            String[] value = user.split(<span class="string">"-"</span>);<span class="comment">//value[0]账号，value[1]密码</span></span><br><span class="line">            System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(value[<span class="number">0</span>].equals(username)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(value[<span class="number">1</span>].equals(password)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"登录成功"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            user = br.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"账号或密码错误！"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readLine方法演示:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;F://test//User.txt&quot;, true));</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.write(&quot;java-888&quot;);</span><br><span class="line">    bw.flush();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id7"><span></span></span></p><h3 id="7-转换流"><a href="#7-转换流" class="headerlink" title="7. 转换流"></a>7. 转换流</h3><h4 id="7-1-字符编码"><a href="#7-1-字符编码" class="headerlink" title="7.1 字符编码"></a>7.1 字符编码</h4><ul><li>字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。</li><li>字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li><li>常见字符集:<ul><li>ASCII字符集 ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）</li></ul></li><li>ISO-8859-1字符集：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li>GBxxx字符集：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li>GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）</li></ul></li><li>Unicode字符集 ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。</li></ul></li></ul></li><li>编码引出的问题<ul><li>在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</li></ul></li></ul><h4 id="7-2-InputStreamReader类"><a href="#7-2-InputStreamReader类" class="headerlink" title="7.2 InputStreamReader类"></a>7.2 InputStreamReader类</h4><p>转换流java.io.InputStreamReader，是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><ul><li>构造方法<ul><li>InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </li><li>InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure><ul><li>指定编码读取:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">       String FileName = <span class="string">"E:\\file_gbk.txt"</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">       InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">    <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">       InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">"GBK"</span>);</span><br><span class="line"><span class="comment">// 定义变量,保存字符</span></span><br><span class="line">       <span class="keyword">int</span> read;</span><br><span class="line">    <span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">       <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.print((<span class="keyword">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">      &#125;</span><br><span class="line">       isr.close();</span><br><span class="line">    <span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">       <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">      &#125;</span><br><span class="line">       isr2.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-OutputStreamWriter类"><a href="#7-3-OutputStreamWriter类" class="headerlink" title="7.3 OutputStreamWriter类"></a>7.3 OutputStreamWriter类</h4><p>转换流java.io.OutputStreamWriter ，是Writer的子类，是从<strong>字符流到字节流</strong>的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><ul><li>构造方法<ul><li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </li><li>OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure><ul><li>指定编码写出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 定义文件路径</span></span><br><span class="line">       String FileName = <span class="string">"E:\\out.txt"</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">       OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">       <span class="comment">// 写出数据</span></span><br><span class="line">    osw.write(<span class="string">"你好"</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">       osw.close();</span><br><span class="line"><span class="comment">// 定义文件路径</span></span><br><span class="line">String FileName2 = <span class="string">"E:\\out2.txt"</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">       OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">"GBK"</span>);</span><br><span class="line">       <span class="comment">// 写出数据</span></span><br><span class="line">    osw2.write(<span class="string">"你好"</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">       osw2.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id8"><span></span></span></p><h3 id="8-对象流"><a href="#8-对象流" class="headerlink" title="8. 对象流"></a>8. 对象流</h3><ul><li>对象序列化和反序列化<ul><li>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 </li><li>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象</li><li>简单来讲<ul><li>对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中</li><li>对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象</li><li>如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口；<br>如果想要将对象反序列化：需要给对象提供一个序列化的版本号，<code>private long serialVersionUID = 任意L</code>;</li></ul></li></ul></li></ul><h3 id="8-1-ObjectOutputStream类"><a href="#8-1-ObjectOutputStream类" class="headerlink" title="8.1 ObjectOutputStream类"></a>8.1 ObjectOutputStream类</h3><ul><li>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</li><li>构造方法<ul><li>public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure><ul><li>序列化操作<ol><li>一个对象要想序列化，必须满足两个条件:<ul><li>该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</li></ul></li><li>写出对象方法<ul><li>public final void writeObject (Object obj) : 将指定的对象写出。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//满足两个条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> String address;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Address check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写出对象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">  Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">  e.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">  e.address = <span class="string">"beiqinglu"</span>;</span><br><span class="line">  e.age = <span class="number">20</span>; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建序列化流对象</span></span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>));</span><br><span class="line">      <span class="comment">// 写出对象</span></span><br><span class="line">      out.writeObject(e);</span><br><span class="line">      <span class="comment">// 释放资源</span></span><br><span class="line">      out.close();</span><br><span class="line">      fileOut.close();</span><br><span class="line">      System.out.println(<span class="string">"Serialized data is saved"</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">           i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//Serialized data is saved</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h4 id="8-1-ObjectInputStream类"><a href="#8-1-ObjectInputStream类" class="headerlink" title="8.1 ObjectInputStream类"></a>8.1 ObjectInputStream类</h4><ul><li>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </li><li>构造方法<ul><li>public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。</li></ul></li><li>反序列化操作1<ul><li>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。</li><li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。</li><li>public final Object readObject () : 读取一个对象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">       Employee e = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建反序列化流</span></span><br><span class="line">            FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">            <span class="comment">// 读取一个对象</span></span><br><span class="line">            e = (Employee) in.readObject();</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">            <span class="comment">// 捕获其他异常</span></span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassNotFoundException c) &#123;</span><br><span class="line">      <span class="comment">// 捕获类找不到异常</span></span><br><span class="line">            System.out.println(<span class="string">"Employee class not found"</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">       System.out.println(<span class="string">"Name: "</span> + e.name);<span class="comment">// zhangsan</span></span><br><span class="line">       System.out.println(<span class="string">"Address: "</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">       System.out.println(<span class="string">"age: "</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反序列化操作2<ul><li>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：<ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul></li><li>Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Address check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id9"><span></span></span></p><h3 id="9-打印流-PrintStream类"><a href="#9-打印流-PrintStream类" class="headerlink" title="9. 打印流(PrintStream类)"></a>9. 打印流(PrintStream类)</h3><ul><li>平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</li><li>构造方法<ul><li><code>public PrintStream(String fileName);</code>  使用指定的文件名创建一个新的打印流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>)；</span><br></pre></td></tr></table></figure><ul><li>改变打印流向<ul><li>System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">        <span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line">        <span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        <span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id10"><span></span></span></p><h3 id="10-Properties类的使用"><a href="#10-Properties类的使用" class="headerlink" title="10. Properties类的使用"></a>10. Properties类的使用</h3><ul><li>Java.util.Properties，主要用于读取Java的配置文件。</li><li>Properties类继承自Hashtable</li><li>配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用”#”来注释。</li><li>Properties类的主要方法：<ol><li>getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</li><li>load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</li><li>setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</li><li>store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</li><li>clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>五、JavaSE异常处理机制</title>
    <link href="http://chaooo.github.io/2019/07/09/05_JavaSE%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html"/>
    <id>http://chaooo.github.io/2019/07/09/05_JavaSE异常处理机制.html</id>
    <published>2019-07-09T00:34:31.000Z</published>
    <updated>2019-07-20T14:46:51.992Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。</p><a id="more"></a><ol><li><a href="#id1">基本概念</a></li><li><a href="#id2">异常的分支结构</a></li><li><a href="#id3">添加处理异常的手段</a></li><li><a href="#id4">异常的捕获</a></li><li><a href="#id5">异常的抛出</a></li><li><a href="#id6">自定义异常</a></li><li><a href="#id7">总结</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>异常用于在Java语言中描述运行阶段发生的错误。</li><li>在Java中有一个定义好的规则Throwable（可以抛出的）</li><li>java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。<ul><li>Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。</li><li>Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。</li></ul></li><li>java.lang.Exception类是所有异常的超类，主要分为两大类：<ul><li>RuntimeException - 运行时异常，也叫非检测性异常</li><li>IOException和其他异常 - 其他异常也叫做检测性异常</li></ul></li></ul><blockquote><p>注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Throwable类</span><br><span class="line">    |————Exception类</span><br><span class="line">        |————RuntimeException异常</span><br><span class="line">            |————ArithmeticException类</span><br><span class="line">            |————ArrayIndexOutOfBoundsException类</span><br><span class="line">            |————NullPointerException类</span><br><span class="line">            |————ClassCastException类</span><br><span class="line">            |————NumberFormatException类</span><br><span class="line">        |————IOException和其他异常</span><br><span class="line">    |————Error类</span><br></pre></td></tr></table></figure><p><span id="id2"><span></span></span></p><h3 id="2-异常的分支结构"><a href="#2-异常的分支结构" class="headerlink" title="2. 异常的分支结构"></a>2. 异常的分支结构</h3><h4 id="2-1-运行时异常（非检查异常）"><a href="#2-1-运行时异常（非检查异常）" class="headerlink" title="2.1 运行时异常（非检查异常）"></a>2.1 运行时异常（非检查异常）</h4><ol><li>Error和RuntimeException都算作运行时异常</li><li>javac编译的时候，不会提示和发现的，</li><li>在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)</li><li>要求大家出现这样异常的时候 知道怎么产生及如何修改<ul><li>InputMisMatchException 输入不匹配<ul><li>int value = input.nextInt();//   abc</li></ul></li><li>*NumberFormatException 数字格式化<ul><li>int value = Integer.parseInt(“123.45”);</li></ul></li><li>NegativeArraySizeException 数组长度负数<ul><li>int[] array = new int[-2];</li></ul></li><li>*ArrayIndexOutOfBoundsException 数组索引越界<ul><li>int[] array = {1,2,3};</li><li>array[5];</li></ul></li><li>*5NullPointerException 空指针异常<ul><li>int[][] array = new int[3][];</li><li>array[0][0] =10;</li><li>Person p = null;</li><li>p.getName();</li></ul></li><li>ArithmeticException 数字异常<ul><li>10/0    整数不允许除以0    Infinity小数除以0会产生无穷</li></ul></li><li>*ClassCastException 造型异常<ul><li>Person p = new Teacher();</li><li>Student s = (Student)p;</li></ul></li><li>*StringIndexOutOfBoundsException 字符串越界<ul><li>String str = “abc”;</li><li>str.charAt(5);</li></ul></li><li>*IndexOutOfBoundsException 集合越界<ul><li>List家族</li><li>ArrayList  list = new ArrayList();</li><li>list.add(); list.add(); list.add();</li><li>list.get(5);</li></ul></li><li>IllegalArgumentException 非法参数异常<ul><li>ArrayList  list = new ArrayList(-1);</li></ul></li></ul></li></ol><h4 id="2-2-编译时异常-检查异常"><a href="#2-2-编译时异常-检查异常" class="headerlink" title="2.2 编译时异常(检查异常)"></a>2.2 编译时异常(检查异常)</h4><ul><li>除了Error和RuntimeException以外其他的异常</li><li>javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)</li><li>因为这样的异常在程序运行过程中极有可能产生问题的</li><li>异常产生后后续的所有执行就停止</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg: InterruptException</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id3"><span></span></span></p><h3 id="3-添加处理异常的手段"><a href="#3-添加处理异常的手段" class="headerlink" title="3. 添加处理异常的手段"></a>3. 添加处理异常的手段</h3><ul><li>处理异常不是 异常消失了</li><li>处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行</li><li>两种手段：<ul><li>异常的捕获：try{}catch(){}[ finally{} ]</li><li>throws抛出</li></ul></li><li>final，finally，finalize区别<ul><li>final：特征修饰符，修饰变量，属性，方法，类<ul><li>修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)</li><li>修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)</li><li>修饰方法：不能被子类重写</li><li>修饰类：不能被其他的子类继承</li></ul></li><li>finally：处理异常手段的一部分<ul><li>try{}catch(){}后面的一个部分</li><li>这个部分可有可无，如果有只能含有一份，且必须执行</li></ul></li><li>finalize：是Object类中的一个protected方法<ul><li>对象没有任何引用指向的时候 – 会被GC回收</li><li>当对象回收的时候 默认调用finalize方法</li><li>若想要看到对象回收的效果，可以重写 public void finalize(){}</li></ul></li></ul></li></ul><p><span id="id4"><span></span></span></p><h3 id="4-异常的捕获"><a href="#4-异常的捕获" class="headerlink" title="4. 异常的捕获"></a>4. 异常的捕获</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 引用变量)&#123;</span><br><span class="line">    针对该异常的处理代码;</span><br><span class="line">&#125;<span class="keyword">catch</span> ...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论是否发生异常都要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理异常放在方法内部 可能会出现的小问题<ul><li>如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String test() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //...可能产生异常的的代码</span><br><span class="line">        return &quot;值1&quot;;//事先约定好 返回值</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();//打印输出异常的名字</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        System.out.println(&quot;finally块执行啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;值2&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述执行结果：若try中代码块产生异常return返回 <strong>值2</strong>，若try中无异常则return返回 <strong>值1</strong>，无论return在哪finally都会执行。</li></ul><blockquote><p>异常捕获的注意事项：</p><ul><li>当需要多分catch分子时，切记小类型应该放在大类型的前面；</li><li>懒人写法：catch(Exception e){…}</li><li>finally通常用于善后处理，如：关闭已经打开的文件等。</li></ul></blockquote><p><span id="id5"><span></span></span></p><h3 id="5-异常的抛出"><a href="#5-异常的抛出" class="headerlink" title="5. 异常的抛出"></a>5. 异常的抛出</h3><ul><li>当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。</li><li>语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{} ，<br><br>如：<code>public void show() throw Exception {}</code></li><li>重写方法的抛出规则：<ul><li>不抛出异常</li><li>抛出父类异常中的子类异常</li><li>抛出和父类一样的异常</li><li>不能抛出同级不一样的异常</li><li>不能抛出更大的异常</li></ul></li></ul><p><span id="id6"><span></span></span></p><h3 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="6. 自定义异常"></a>6. 自定义异常</h3><ul><li>可以根据需要自定义异常类。</li><li>自定义异常的方式：<ul><li>继承Exception或者异常的子类。</li><li>提供两个构造，无参构造和String做参数的构造。 </li></ul></li><li>异常的手段<ul><li>如果继承是RuntimeException—-&gt;运行时异常(不需要必须添加处理手段)</li><li>如果继承是Exception—–&gt;编译时异常(必须添加处理手段)</li></ul></li><li>类中可以写带String参数的构造方法，可以做细致的说明</li><li>通过throw关键字，new一个异常的对象</li><li>主动产生异常：<code>throw new 异常类型();</code></li></ul><p><span id="id7"><span></span></span></p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul><li>1.在开发中尽量使用条件判断避免异常的发生;</li><li>2.若实在避免不了，则进行异常捕获；</li><li>3.若实在捕获不了，则进行异常抛出；</li><li>4.若需要使用针对性异常，则自定义异常。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>四、JavaSE集合框架</title>
    <link href="http://chaooo.github.io/2019/07/08/04_JavaSE%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html"/>
    <id>http://chaooo.github.io/2019/07/08/04_JavaSE集合框架.html</id>
    <published>2019-07-08T14:10:57.000Z</published>
    <updated>2019-07-20T14:46:43.086Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。</p><a id="more"></a><ol><li><a href="#id1">Collection集合</a></li><li><a href="#id2">List集合</a></li><li><a href="#id3">泛型机制</a></li><li><a href="#id4">Queue集合</a></li><li><a href="#id5">*ArrayList类</a></li><li><a href="#id6">Vector类</a></li><li><a href="#id7">Stack类</a></li><li><a href="#id8">*LinkedList类</a></li><li><a href="#id9">Set集合</a></li><li><a href="#id10">HashSet类</a></li><li><a href="#id11">TreeSet类</a></li><li><a href="#id12">Map集合</a></li><li><a href="#id13">HashMap类</a></li><li><a href="#id14">TreeMap类</a></li><li><a href="#id15">Lambda表达式</a></li><li><a href="#id16">Stream API</a></li></ol><p><span id="id1"><span></span></span></p><h3 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1. Collection集合"></a>1. Collection集合</h3><ul><li>Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。</li></ul><blockquote><p>数组与集合的比较</p><ul><li>数组的特点：<ol><li>数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；</li><li>支持下标访问，实现随机访问非常方便；</li><li>增删操作不方便，可能会移动大量元素；</li><li>数组一旦声明长度固定无法更改；</li><li>数组支持基本数据类型，也支持引用数据类型；</li></ol></li><li>集合的特点：<ol><li>集合的存储单元可以不连续，数据类容可以不相同；</li><li>集合部分支持下标访问，部分不支持；</li><li>集合中增删元素可以不移动大量元素；</li><li>集合大小可以随时动态调整；</li><li>集合中的元素必须是引用数据类型（基本数据类型可用包装类）；</li></ol></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-Collection接口</span><br><span class="line">    |————List接口</span><br><span class="line">        |————ArrayList类</span><br><span class="line">        |————LinkedList类</span><br><span class="line">        |————Stack类</span><br><span class="line">        |————Vector类</span><br><span class="line">    |————Queue接口</span><br><span class="line">        |————LinkedList类</span><br><span class="line">    |————Set接口</span><br><span class="line">        |————HashSet类</span><br><span class="line">        |————TreeSet类</span><br><span class="line">-Map接口</span><br><span class="line">    |————HashMap类</span><br><span class="line">    |————TreeMap类</span><br></pre></td></tr></table></figure><blockquote><ul><li>Collection存储的都是value,其中List有序可重复，Set无序无重复</li><li>Map存储的是以key-value形式,key无序无重复 value无序可重复</li><li>序 : 顺序–添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序</li></ul></blockquote><table><thead><tr><th>Collection集合的常用方法</th><th></th></tr></thead><tbody><tr><td>boolean add(E e);</td><td>向集合中添加对象</td></tr><tr><td>boolean contains(Object o);</td><td>判断是否包含指定对象</td></tr><tr><td>boolean remove(Object o);</td><td>从集合中删除对象</td></tr><tr><td>void clear();</td><td>清空集合</td></tr><tr><td>int size();</td><td>返回包含对象的个数</td></tr><tr><td>boolean isEmpty();</td><td>判断是否为空</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection c2 = <span class="keyword">new</span> ArrayList(); <span class="comment">//多态</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = c2.add(<span class="keyword">new</span> String(<span class="string">"one"</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = c2.add(<span class="keyword">new</span> Integer(<span class="number">2</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">"c2 = "</span> + c2); <span class="comment">//[one, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = c2.contains(<span class="keyword">new</span> Integer(<span class="number">2</span>));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//contains方法工作原理：(o==null ? e==null : o.equals(e));</span></span><br></pre></td></tr></table></figure><p><span id="id2"><span></span></span></p><h3 id="2-List集合"><a href="#2-List集合" class="headerlink" title="2. List集合"></a>2. List集合</h3><ul><li>java.util.List集合是Collection集合的子集合。</li><li>List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。<ul><li>ArrayList类的底层使用<strong>数组</strong>进行数据管理，访问元素方便，增删不方便。</li><li>LinkedList类的底层使用<strong>链表</strong>进行数据管理，访问不方便，增删方便。</li><li>Stark类的底层使用数组进行数据管理，该类主要描述具有<strong>后进先出</strong>的特征的数据结构，叫做<strong>栈</strong>。</li><li>Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。</li></ul></li><li>List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。</li></ul><table><thead><tr><th>List类常用方法</th><th></th></tr></thead><tbody><tr><td>void add(int index, E element)</td><td>向集合指定位置添加元素</td></tr><tr><td>boolean addAll(int index, Collection&lt;?extends E&gt; c)</td><td>向集合中添加所有元素</td></tr><tr><td>E get(int index)</td><td>从集合中获取指定位置的元素</td></tr><tr><td>E set(int index, E element)</td><td>修改指定位置的元素</td></tr><tr><td>E remove(int index)</td><td>删除指定位置的元素</td></tr><tr><td>int indexOf(Object o)</td><td>在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))</td></tr><tr><td><t> T[] toArray(T[] a)</t></td><td>将集合中的对象序列化以对象数组的形式返回。</td></tr><tr><td>List<e> subList(int fromIndex, int toIndex)</e></td><td>获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图</td></tr></tbody></table><p><span id="id3"><span></span></span></p><h3 id="3-泛型机制"><a href="#3-泛型机制" class="headerlink" title="3. 泛型机制"></a>3. 泛型机制</h3><ul><li>集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。</li><li>从jdk1.5开始推出泛型机制，在集合名称后面使用&lt;数据类型&gt;的方式明确要求该集合中可以存放的数据类型。如：<code>List&lt;String&gt; lt = new LinkedList&lt;String&gt;();</code>。</li><li>从jdk1.7开始可省略后面&lt;&gt;的数据类型，叫做<code>菱形特性</code>，如：<code>List&lt;String&gt; lt = new ArrayList&lt;&gt;();</code>。</li><li>泛型本质就是参数化类型，让数据类型作为参数传递，<code>public interface List&lt;E&gt;{}</code>其中<code>E</code>是占位形参，由于实参可以支持各种广泛的类型，因此得名<code>泛型</code>。</li><li>泛型可以用在哪里：<ol><li>泛型类：类定义的时候描述某种数据类型，集合的使用就是这样</li><li>泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型</li><li>泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中</li><li>方法参数泛型限制，高级泛型，规范边界，extends，super</li></ol></li></ul><p><span id="id4"><span></span></span></p><h3 id="4-Queue集合"><a href="#4-Queue集合" class="headerlink" title="4. Queue集合"></a>4. Queue集合</h3><ul><li>java.util.Queue集合是Collection集合的子集合。</li><li>Queue集合主要描述具有<strong>先进先出</strong>特性的数据结构，叫做<strong>队列</strong>(FIFO:First Input First Output)。</li><li>Queue集合主要实现类是<code>LinkedList类</code>，因为该类在增删方面有一定优势。</li></ul><table><thead><tr><th>Queue接口中主要方法</th><th></th></tr></thead><tbody><tr><td>boolean offer(E e)</td><td>将一个对象添加至队尾，若添加成功则返回true</td></tr><tr><td>E poll()</td><td>从队首删除并返回一个元素</td></tr><tr><td>E peek()</td><td>返回队首的元素（但并不删除）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//将数据11、22、33、44、55依次入队</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    q1.offer(i*<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id5"><span></span></span></p><h3 id="5-ArrayList类"><a href="#5-ArrayList类" class="headerlink" title="5. *ArrayList类"></a>5. *ArrayList类</h3><ol><li>底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util</li><li>ArrayList特点适合遍历轮询，不适合插入删除</li><li>如何构建一个ArrayList对象<ul><li>无参数构造方法，带默认容量构造方法，带collection参数的构造方法</li></ul></li><li>ArrayList中常用的方法<ul><li>增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()</li></ul></li><li>类中其他常用的方法<ul><li>addAll并集，removeAll差集，ratainAll交集;</li><li>indexOf()，lastIndexOf()，contains()，List=subList();</li><li>isEmpty()，clear()，ensureCapacity()，iterator();迭代器</li><li>toArray(T[] x)，trimToSize();</li></ul></li></ol><p><span id="id6"><span></span></span></p><h3 id="6-Vector类"><a href="#6-Vector类" class="headerlink" title="6. Vector类"></a>6. Vector类</h3><ol><li>是ArrayList集合的早期版本，所属的包 java.util<ul><li>Vector底层也是利用(动态)数组的形式存储</li><li>Vector是线程同步的(synchronized)，安全性高，效率较低</li></ul></li><li>扩容方式与ArrayList不同<ul><li>默认是扩容2倍，可以通过构造方法创建对象时修改这一机制</li></ul></li><li>构造方法和常用方法与ArrayList类似</li></ol><p><span id="id7"><span></span></span></p><h3 id="7-Stack类"><a href="#7-Stack类" class="headerlink" title="7. Stack类"></a>7. Stack类</h3><ol><li>Stack类，栈，java.util包</li><li>构造方法只有一个无参数</li><li>除了继承自Vacton类的方法外还有特殊的方法<ul><li>push(E e)将某一个元素压入栈顶(add())</li><li>E = pop()将某一个元素从栈顶取出并删掉(E = remove())</li><li>E = peek()查看栈顶的一个元素 不删除(get())</li><li>boolean = empty()判断栈内元素是否为空(isEmpty())</li><li>int = search()查找给定的元素在占中的位置(indexOf())</li></ul></li><li>应用场景<ul><li>中国象棋，悔棋</li><li>栈中存储每一次操作的步骤</li><li>撤销功能</li></ul></li></ol><p><span id="id8"><span></span></span></p><h3 id="8-LinkedList类"><a href="#8-LinkedList类" class="headerlink" title="8. *LinkedList类"></a>8. *LinkedList类</h3><ol><li>LinkedList类，java.util包</li><li>底层使用<strong>双向链表</strong>的数据结构形式来存储<ul><li>适合于插入或删除  不适合遍历轮询</li></ul></li><li>构建对象<ul><li>无参数构造方法，带参数的构造方法(collection)</li></ul></li><li>常用的方法<ul><li>增删改查：add()，remove()，set()，get()，size()，offer，poll，peek</li><li>手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()</li></ul></li><li>插入删除的特性是否像想的那样<ul><li>对比ArrayList  Linked</li></ul></li></ol><p><span id="id9"><span></span></span></p><h3 id="9-Set集合"><a href="#9-Set集合" class="headerlink" title="9. Set集合"></a>9. Set集合</h3><ul><li>java.util.Set集合是Collection集合的子集合。</li><li>Set集合没有先后放入次序，并且不允许有重复关系，实现类有<code>HashSet类</code>和<code>TreeSet</code>类。</li><li>其中<code>HashSet类</code>底层是采用哈希表进行数据管理的。</li><li>其中<code>TreeSet类</code>的底层是采用二叉树进行数据管理的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法和Collection集合基本一样</span></span><br><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">set1.add(<span class="string">"one"</span>);</span><br><span class="line">System.out.println(<span class="string">"s1="</span>+s1);</span><br></pre></td></tr></table></figure><ul><li>set集合的无重复特性<ul><li>HashSet，无重复原则有两个方法同时起作用<ul><li>equals    hashCode</li><li>默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入</li><li>如果想要改变其比较的规则  可以重写上述两个方法</li></ul></li><li>TreeSet，无重复原则有一个方法起作用<ul><li>compareTo</li><li>上述这个方法不是每一个对象都有的</li><li>若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable</li><li>实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后</li></ul></li></ul></li></ul><h4 id="9-1-Set集合的遍历"><a href="#9-1-Set集合的遍历" class="headerlink" title="9.1 Set集合的遍历"></a>9.1 Set集合的遍历</h4><ul><li>所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。</li></ul><table><thead><tr><th>迭代器<code>Iterator&lt;E&gt; iterator()</code>，主要方法有</th><th></th></tr></thead><tbody><tr><td>boolean hasNext()</td><td>判断集合中是否有可以迭代/访问的元素</td></tr><tr><td>E next()</td><td>用于取出一个元素并指向下一个元素</td></tr><tr><td>void remove()</td><td>用于删除访问到的最后一个元素</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = set1.iterator();<span class="comment">//获取当前集合的迭代器对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;<span class="comment">//判断是否有可以访问的元素</span></span><br><span class="line">    String temp = it.next();<span class="comment">//取出一个并指向下一个</span></span><br><span class="line">    System.out.println( temp );</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"two"</span>.equals(temp))&#123;</span><br><span class="line">        it.remove();<span class="comment">//删除set1中该元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>增强for循环(for each结构)</li><li>语法格式：<code>for(元素类型 变量名:集合/数组){ 循环体; }</code>。</li><li>执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(String ts : s1) &#123;</span><br><span class="line">    System.out.println(ts);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ti : arr) &#123;</span><br><span class="line">    System.out.println(ti);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="id10"><span></span></span></p><h3 id="10-HashSet类"><a href="#10-HashSet类" class="headerlink" title="10. HashSet类"></a>10. HashSet类</h3><ol><li>HashSet集合底层采用HashMap（数组+链表–&gt;散列表），java.util包。</li><li>它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 </li><li>创建对象：无参数，有参数</li><li>集合容器的基本使用<ul><li>增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)</li><li>没有修改方法</li><li>iterator()  获取一个迭代器对象</li><li>size()</li></ul></li><li>无重复的原则<ul><li>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li></ul></li></ol><p><span id="id11"><span></span></span></p><h3 id="11-TreeSet类"><a href="#11-TreeSet类" class="headerlink" title="11. TreeSet类"></a>11. TreeSet类</h3><ol><li><p>TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))</p></li><li><p>创建对象： 无参数构造方法 ，带Collection构造方法</p></li><li><p>基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()</p></li><li><p>二叉树主要指每个节点最多只有两个子节点的树形结构。</p></li><li><p>满足以下三个特征的二叉树叫做<strong>有序二叉树</strong>：</p><ul><li>左子树中的任意节点元素都小于根节点元素；</li><li>右子树中的任意节点元素都大于根节点元素；</li><li>左子树和右子树内部也遵守上述规则；</li></ul></li><li><p>无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。</p></li><li><p>元素放入TreeSet集合过程：<br>由于TreeSet集合底层采用<strong>有序二叉树</strong>进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：</p><ol><li>使用元素的<strong>自然排序</strong>规则进行比较并排序，让元素类型实现java.lang.Comparable接口；</li><li>使用<strong>比较器规则</strong>进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；</li></ol></li></ol><blockquote><p>注意：<br>    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；<br>    2. 可以使用Collections工具类对集合中的元素进行操作；</p></blockquote><p><span id="id12"><span></span></span></p><h3 id="12-Map集合"><a href="#12-Map集合" class="headerlink" title="12. Map集合"></a>12. Map集合</h3><ul><li>java.util.Map&lt;K, V&gt;集合存取元素的基本单位是：单对元素（键值对key-value）。</li><li>Map：映射，通过某一个key可以直接定位到一个value值</li><li>key无序无重复   value无序可重复<ul><li>key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致</li></ul></li><li>主要有两个实现类：<code>HashMap类</code>和<code>TreeMap类</code>。</li><li>Map基本使用：HashMap，TreeMap，Properties</li><li>Map集合常用方法：<ul><li>增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)</li></ul></li><li>Map集合的遍历方式：a.迭代Key，b.迭代Entry</li><li>Map集合的性能调优：<ul><li>加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）</li></ul></li></ul><p><span id="id13"><span></span></span></p><h3 id="13-HashMap类"><a href="#13-HashMap类" class="headerlink" title="13. HashMap类"></a>13. HashMap类</h3><ol><li>包:java.util，底层散列表的形式（数组+链表）</li><li>构造方法创建对象   无参数  带默认容量的  带map参数的构造方法</li><li>特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复<ul><li>找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry</li></ul></li><li>基本方法：<ul><li>增 put(key,value)，存放一组映射关系key-value<ol><li>key存储的顺序与取得顺序不同</li><li>不同的key可以存储相同的value</li><li>key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)</li></ol></li><li>删 E = remove(key);</li><li>改 replace(key,newValue)，put(key,value2)</li><li>查 E = get(key)；</li><li>Set<key> = keySet()获取全部的key</key></li><li>Set<entry> = entrySet();</entry></li><li>size();</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();<span class="comment">//获取集合中全部的entry对象</span></span><br><span class="line">Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = entrys.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Entry&lt;Integer,String&gt; entry = it.next();<span class="comment">//entry  key value</span></span><br><span class="line">    Integer key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">"--"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>除了上述几个常用的方法外  其他API中提供的方法<ul><li>clear，containsKey(key)，containsValue(value)</li><li>getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值</li><li>isEmpty()</li><li>putAll(map)</li><li>putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦</li></ul></li><li>map集合在什么情形下用?<ol><li>想要存储一组元素<ul><li>数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合</li></ul></li><li>如果发现长度以后不确定—&gt;集合</li></ol></li></ol><table><thead><tr><th align="center">list</th><th align="center">Set</th><th align="center">Map</th></tr></thead><tbody><tr><td align="center">List家族有序的</td><td align="center">Set家族无重复</td><td align="center">Map家族k-v</td></tr><tr><td align="center">存储有顺序用这个</td><td align="center">存储元素希望自动去掉重复元素用这个</td><td align="center">通过唯一的k快速找寻v用这个</td></tr><tr><td align="center">ArrayList:更适合遍历轮询</td><td align="center">HashSet:性能更高</td><td align="center">HashMap:性能更高</td></tr><tr><td align="center">LinkedList:更适合插入和删除</td><td align="center">TreeSet:希望存进去的元素自动去重复,同时还能自动排序</td><td align="center">Tree:希望存进去的元素key自动排序</td></tr><tr><td align="center">Stack:LIFO</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p><span id="id14"><span></span></span></p><h3 id="14-TreeMap类"><a href="#14-TreeMap类" class="headerlink" title="14. TreeMap类"></a>14. TreeMap类</h3><ol><li>java.util包</li><li>构造方法：无参数，带map参数</li><li>常用方法：put， get，remove，replace，size</li><li>底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）</li><li>自然有序，按照Unicode编码自然有序<ul><li>ap集合中的key需要可比较的   key的对象需要实现Comparable接口</li></ul></li></ol><p><span id="id15"><span></span></span></p><h3 id="15-Lambda表达式"><a href="#15-Lambda表达式" class="headerlink" title="15. Lambda表达式"></a>15. Lambda表达式</h3><ul><li>java8支持的新的语法格式，Lambda允许<code>把函数作为一个方法的参数</code>(函数作为参数传递进方法中)，使用lambda表达式可以<code>使代码变得更加简洁紧凑</code>。</li><li>函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。</li><li>lambda表达式语法由<strong>参数列表</strong>、<strong>箭头函数<code>-&gt;</code></strong>和<strong>函数体</strong>组成，函数体即可以是一个表达式，也可以是一个语句块。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int a, int b) -&gt; a+b</span><br><span class="line">() -&gt; 42</span><br><span class="line">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure><ul><li>函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。</li><li>jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。</li></ul><h4 id="15-1-Lambda表达式-方法引用"><a href="#15-1-Lambda表达式-方法引用" class="headerlink" title="15.1 Lambda表达式-方法引用"></a>15.1 Lambda表达式-方法引用</h4><ul><li>方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</li><li>方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。</li></ul><p><span id="id16"><span></span></span></p><h3 id="16-Stream-API"><a href="#16-Stream-API" class="headerlink" title="16. Stream API"></a>16. Stream API</h3><ul><li><p>Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。</p></li><li><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p><ul><li><strong>无存储</strong>。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li><li><strong>为函数式编程而生</strong>。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li><li><strong>惰式执行</strong>。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li><strong>可消费性</strong>。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul></li><li><p>对stream的操作分为为两类，中间操作和结束操作，二者特点是：</p><ul><li><strong>中间操作</strong>总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li><li><strong>结束操作</strong>会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li></ul></li></ul><h4 id="16-1-stream方法使用"><a href="#16-1-stream方法使用" class="headerlink" title="16.1 stream方法使用"></a>16.1 stream方法使用</h4><ul><li>stream跟<strong>函数接口</strong>关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。&lt;/p&gt;
    
    </summary>
    
      <category term="javaSE知识梳理" scheme="http://chaooo.github.io/categories/javaSE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="javaSE" scheme="http://chaooo.github.io/tags/javaSE/"/>
    
      <category term="后端开发" scheme="http://chaooo.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
